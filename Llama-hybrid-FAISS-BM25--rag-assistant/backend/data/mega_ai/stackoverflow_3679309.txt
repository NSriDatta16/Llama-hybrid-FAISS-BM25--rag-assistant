[site]: stackoverflow
[post_id]: 3679309
[parent_id]: 3608703
[tags]: 
OK guys, here is what I came up with... It's not that elegant but I think is a bit better than having various catches. First, we have an abstract class called ExceptionHandler . package my.api.pack; import java.lang.reflect.ParameterizedType; import java.util.LinkedHashSet; import java.util.Set; public abstract class ExceptionHandler { Set > exceptionClasses = new LinkedHashSet >(); protected abstract void handler(Throwable t) throws E; public ExceptionHandler catches(Class clazz) { exceptionClasses.add(clazz); return this; } @SuppressWarnings("unchecked") private Class getGenericsClass() { ParameterizedType parameterizedType = (ParameterizedType) getClass().getGenericSuperclass(); return (Class ) parameterizedType.getActualTypeArguments()[0]; } @SuppressWarnings("unchecked") public final void handle(Throwable t) throws E, UnhandledException { if (getGenericsClass().isInstance(t)) { throw (E) t; } for (Class clazz : exceptionClasses) { if (clazz.isInstance(t)) { handler(t); return; } } throw new UnhandledException("Unhandled exception", t); } } Along with it, we have this simple runtime exception called UnhandledException package my.api.pack; public class UnhandledException extends RuntimeException { private static final long serialVersionUID = -3187734714363068446L; public UnhandledException(String message, Throwable cause) { super(message, cause); } } With it we can use these to handle exceptions like this... try { /* some code that throws these exceptions */ } catch (Exception e) { new ExceptionHandler () { @Override protected void handler(Throwable t) throws MyAPIException { throw new MyAPIException("Something went wrong", t); } }. catches(MismatchedDimensionException.class). catches(NoSuchAuthorityCodeException.class). catches(FactoryException.class). catches(TransformException.class). handle(e); return null; } What you guys think?
