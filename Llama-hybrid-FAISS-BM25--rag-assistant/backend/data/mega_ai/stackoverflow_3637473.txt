[site]: stackoverflow
[post_id]: 3637473
[parent_id]: 
[tags]: 
How to define a global variable of type NSUserDefaults and initialize a value?

which is the cleanest way to use something like a global variable? Normally, using a global variable is forbidden, but I don't know a better solution for accessing NSUserDefaults from different classes. I read a bit and come up with this. I define a Contants.h and a Constants.m file and include them everywhere I need to. //Constants.h #import @interface Constants : NSObject { extern NSUserDefaults *settings; } @end . //Constants.m @implementation Constants NSString *filePath = [[NSBundle mainBundle] pathForResource:@"Settings" ofType:@"plist"]; NSDictionary *settingsDict = [NSDictionary dictionaryWithContentsOfFile:filePath]; [[NSUserDefaults standardUserDefaults] registerDefaults:settingsDict]; NSUserDefaults *settings = [NSUserDefaults standardUserDefaults]; @end The problem here is that I want to initialize a value to my constant. I have no method in Constants.m. So my helper variables would also be globals? One thing to mention: I think the global variable also has to be released? Thanks for your help! Edit: @hotpaw2: AppBundleSingleton.h: #import @interface AppBundleSingleton : NSObject { } + (AppBundleSingleton *)sharedAppBundleSingleton; @end AppBundleSingleton.m: #import "AppBundleSingleton.h" static AppBundleSingleton *sharedAppBundleSingleton = nil; @implementation AppBundleSingleton #pragma mark - #pragma mark Singleton methods + (AppBundleSingleton *)sharedAppBundleSingleton { @synchronized(self) { if (sharedAppBundleSingleton == nil) { sharedAppBundleSingleton = [[self alloc] init]; } } return sharedAppBundleSingleton; } + (id)allocWithZone:(NSZone *)zone { @synchronized(self) { if (sharedAppBundleSingleton == nil) { sharedAppBundleSingleton = [super allocWithZone:zone]; return sharedAppBundleSingleton; // assignment and return on first allocation } } return nil; // on subsequent allocation attempts return nil } - (id)copyWithZone:(NSZone *)zone { return self; } - (id)retain { return self; } - (NSUInteger)retainCount { return NSUIntegerMax; //denotes an object that cannot be released } - (void)release { //do nothing } - (id)autorelease { return self; } -(id)init { self = [super init]; sharedAppBundleSingleton = self; // Initialization code here NSString *filePath = [[NSBundle mainBundle] pathForResource:@"Settings" ofType:@"plist"]; NSDictionary *settingsDict = [NSDictionary dictionaryWithContentsOfFile:filePath]; [[NSUserDefaults standardUserDefaults] registerDefaults:settingsDict]; return self; } @end In my AppDelegate.m I have the following: // ... #include "AppBundleSingleton.h" @implementation MyAppDelegate // ... - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { // Override point for customization after application launch. // Add the navigation controller's view to the window and display. [window addSubview:navigationController.view]; [window makeKeyAndVisible]; [AppBundleSingleton sharedAppBundleSingleton]; return YES; } // ... @end In my ViewController I query the values: NSString *myString = [[NSUserDefaults standardUserDefaults] stringForKey:@"myKeyforString"]; Would that be a solution?
