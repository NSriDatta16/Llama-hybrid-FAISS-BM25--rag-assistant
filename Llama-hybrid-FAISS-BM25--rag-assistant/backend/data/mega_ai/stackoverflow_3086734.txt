[site]: stackoverflow
[post_id]: 3086734
[parent_id]: 3086561
[tags]: 
There are two parts to doing this, at least in my solution, however you will need this function (thanks to the guys at cl-prevalence for this ( warn LLGPL ) (defun get-slots (object) ;; thanks to cl-prevalence #+openmcl (mapcar #'ccl:slot-definition-name (#-openmcl-native-threads ccl:class-instance-slots #+openmcl-native-threads ccl:class-slots (class-of object))) #+cmu (mapcar #'pcl:slot-definition-name (pcl:class-slots (class-of object))) #+sbcl (mapcar #'sb-pcl:slot-definition-name (sb-pcl:class-slots (class-of object))) #+lispworks (mapcar #'hcl:slot-definition-name (hcl:class-slots (class-of object))) #+allegro (mapcar #'mop:slot-definition-name (mop:class-slots (class-of object))) #+sbcl (mapcar #'sb-mop:slot-definition-name (sb-mop:class-slots (class-of object))) #+clisp (mapcar #'clos:slot-definition-name (clos:class-slots (class-of object))) #-(or openmcl cmu lispworks allegro sbcl clisp) (error "not yet implemented")) Then, for reading you will need to run this piece of code, which sets up 1/2 of the syntax which is { type-of-object ((slot-name . slot-value) (slot-name . slot-value) ...) (set-macro-character #\{ #'(lambda (str char) (declare (ignore char)) (let ((list (read-delimited-list #\} str t))) (let ((type (first list)) (list (second list))) (let ((class (allocate-instance (find-class type)))) (loop for i in list do (setf (slot-value class (car i)) (cdr i))) class))))) For printing, use (defmethod print-object ((object standard-object) stream) (format stream "{ ~s ~s}" (type-of object) (loop for i in (get-slots object) collect (cons i (slot-value object i))))) A *print-readably* is highly recommended when using all these methods. Also, note that circular relationships are untested
