[site]: stackoverflow
[post_id]: 2342798
[parent_id]: 2342772
[tags]: 
It is very unclear what your question means. Can you carefully define what "garbage collected" means? Does it mean "are inputs to the GC algorithm", or "are deallocated by compacting the GC heap", or what? Values stored on the stack -- whether values of value types or reference types -- are the roots of the collection algorithm. They are not collected because they are the things that are alive that keep almost everything else alive. And obviously they are not deallocated by compacting the GC heap; they're deallocated by popping the stack. Does that answer your question? UPDATE: What I mean by "garbage collected" is that, if a value type variable is found not to be used by the application then it will be removed from the stack OK, we're getting closer to an answerable question here I think. Now we need to understand what exactly you mean by "removed from the stack". The stack is a block of pre-allocated memory one million bytes in size . Sometimes we use portions of that block of memory to store local variables of value type. What precisely do you mean by "removed from the stack"? The stack never changes in size; it's a one-million-byte block of pre-allocated memory. The stack is divided into two contiguous regions, which we'll call the "valid" and "invalid" sections of the stack. On x86 architectures the ESP register points to the boundary between those regions. Are you asking "under what conditions does the memory associated with a particular local variable of value type on the stack become a part of the invalid section based on a change in value of the ESP register on x86 architectures?" This might seem like a very, very "implementation detail" version of your question. The stack is an implementation detail of a specific version of the runtime , so if you're going to ask questions about it, you're going to have to accept the fact that you're asking about a specific value in a specific register on a specific chip architecture. Further reading: References are not addresses The Stack Is An Implementation Detail, Part One The Stack Is An Implementation Detail, Part Two “Out Of Memory” Does Not Refer to Physical Memory I am a bit confused now to read what you have mentioned about "values" and "value types". I am finding it hard to understand the difference. It is tricky! We use the words "value" and "reference" to mean too many things. Let me sum up. A variable is a storage location . Every variable has a type . A type can be a value type or a reference type . A storage location contains a value . The value of a variable of value type is a value of the value type. For example, int is a value type. The value of a variable of type int is an int, say, 12. The value of a variable of reference type is a reference to an object of that type, or null. For example, string is a reference type. The value of a variable of type string is a reference to a string, or null. That's why they're called "value types" and "reference types". The value of a value type is an instance of the type. The value of a reference type is a reference to an instance of the type. Does that make sense now?
