[site]: stackoverflow
[post_id]: 915858
[parent_id]: 915849
[tags]: 
Whenever you have a resource that needs deterministic cleanup, i.e. you want it to have a chance to be ``destroyed'' as soon as you're done with it. In more detail, the IDisposible interface mainly tries to solve the lack of a ``delete'' keyword in .net languages. Because the CLR is garbage collected, you never know when the finalizer (destructor) for an object will be run. The GC is at liberty to wait for as long as you it likes before getting around to releasing the managed resource. However, many managed resources wrap underlying finite resources - memory is not the only thing that must be allocated and deallocated. As mentioned, file handles are one; database handles another - there are myriad examples. To avoid an inconsistent mess of cleanup idioms, the IDisposible pattern is used to say "Please release your finite resources, I'm done with them". Because it's built into the framework, it gets special language support via "using", to help ensure you never forget to call the Dispose methods, and hence "leak" unmanaged resource. This does not mean all IDisposible implementers should be wrapped in a using - if you're retaining a reference, and need them in the future, you should certainly not wrap them, as you'd cause premature release of the underlying resource. Call Dispose only when you're finished with the object and thus wrap in "using" only if you know you're done with it after the using scope ends. So as we'd expect, languages which have deterministic destruction, such as C++/CLI, don't need "using". Non-heap C++/CLI objects have their Dispose method called automatically when they fall out of scope, mimicking the destructor behaviour the pattern tries to capture.
