[site]: stackoverflow
[post_id]: 5202850
[parent_id]: 
[tags]: 
NHibernate - returning complex object from sql function

I've got an application witch uses NHibernate as an ORM. I have one persistent class: public class Match : IEntity { public virtual int ID { get; set; } public virtual string Word { get; set; } public virtual int WordIntervalBeginning { get; set; } public virtual int WordIntervalEnding { get; set; } } and I have an SQL function on the server side: CREATE FUNCTION ftMatchTest ( ) RETURNS TABLE AS RETURN ( SELECT mt1.*, mt2.*, CASE WHEN mt1.Word = mt2.Word THEN 1 ELSE 0 END AS sc FROM dbo.tMatchesTest mt1, dbo.tMatchesTest mt2 ) I want to be able to call this function and map the result from it into the following class public class FResult { public Match Match1 { get; set; } public Match Match2 { get; set; } public int sc { get; set; } } Is it possible to do it with NHibernate 3.0? Is it possible to do it with FluentNHibernate? Thanks in advance! UPDATED I map Match class into tMatchesTest table. Structure of tMatchesTest table is: CREATE TABLE [dbo].[tMatchesTest]( [ID] [int] IDENTITY(1,1) NOT NULL, [Word] [varchar](50) NOT NULL, [WordIntervalBeginning] [int] NOT NULL, [WordIntervalEnding] [int] NOT NULL, CONSTRAINT [PK_tMatchesTest] PRIMARY KEY CLUSTERED ( [ID] ASC )WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] ) ON [PRIMARY] UPDATED2 The solution I found on my own: 1. Create named query like this SELECT {Match1.*}, {Match2.*}, CASE WHEN Match1.Word = Match2.Word THEN 1 ELSE 0 END sc FROM dbo.tMatchesTest Match1, dbo.tMatchesTest Match2 and execute the query like this: Session.GetNamedQuery("getfresult") .SetResultTransformer(new AliasToBeanResultTransformer(typeof(FResult))) .List (); This is the shortest and simples way I found so far to perform the task.
