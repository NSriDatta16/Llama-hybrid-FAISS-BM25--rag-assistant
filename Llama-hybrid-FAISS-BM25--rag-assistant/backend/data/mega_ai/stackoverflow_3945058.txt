[site]: stackoverflow
[post_id]: 3945058
[parent_id]: 
[tags]: 
Timer Efficiency

I am planning to develop a system with tens of thousands of objects in it, which will each have up to 42(but more likely down around 4 or 5) separate actions they will potentially be performing at regular intervals. I also plan to write code that will deactivate the timers until the object comes into use. When idle, the objects will only need 1 timer each, but when active, the other timers will all start at once. At first the number of objects will be small, maybe a few hundred, but I expect it to grow exponentially, and within a few months, start to reach up in the tens of thousands. So, I am very worried about efficiency of the code I will be writing for the timers and for these objects. There are three levels in which I could write this application on that would all successfully perform the tasks required. Also, I plan to run this system on a Quad Core server, so I would like to make use of multi-threading wherever possible. To this end, I've decided to use the System.Timers.Timer class which fires a new thread for each elapse event. These are the 3 levels I am considering: One single timer operates the entire application, it iterates through each object, checks to see if any other actions need to be fired, and if so, runs them, then moves on to the next. Multi-tier timer where each object has a master timer that checks all of the functions the object could need to perform, runs any that are ready, and then sets the next timer interval to the next required action time. Recursive-tier timer where each action in each object has it's own timer that will be triggered, and then set to run the next time it will be available. The problem with option 1 is that with so many objects and actions, one singular timer elapse in this manner could run for maybe 20+ seconds (while it executed a few million lines of looped code), where this should probably be ticking every 1 second. If the objects aren't kept in synch, the system would likely not work well. The problem with option 2 is that it would be a little harder to write than option 3, but not by much, it would also mean perhaps 10,000+ maybe timers running on the system (one for each object), creating and destroying threads with each elapse like its nobody's business (which I'm not sure if this is a problem or not). Each timer would have to fire at least once per second in this situation, with perhaps a few hundred lines of code running (up to perhaps a thousand in an extreme case). The problem with option 3 is the sheer amount of timers that could potentially be introduced into the system. I'm talking about an average of 10,000+ timers with the potential for near 100,000+ timers to be run at the same time. Each elapse event may only have to run 50 or less lines of code though, making them very short. The elapse events would have delays between a hundredth of a second on one extreme, and five minutes on the other, with the average likely being around 1 second. I am proficient in Visual Basic .NET, and was planning to write it in that, but I could also revert to my high-school days and try to write this in C++ for efficiency if it would make that much of a difference (please let me know if you have any sources on code efficiency between languages). Also toying with the notion of running this on a clustered Linux server instead of my Quad Core Windows server, but I'm not sure if I could get any of my .NET apps to run on a linux cluster like that (would love any info on that as well). The main question to answer for this topic is: Do I use option 1, 2, or 3, and why? ~Edit after considering comments~ So the 4th option involving the timer wheel with a spinlock. Here is a job class: Public Class Job Private dFireTime As DateTime Private objF As CrossAppDomainDelegate Private objParams() As Object Public Sub New(ByVal Func As CrossAppDomainDelegate, ByVal Params() As Object, ByVal FireTime As DateTime) objF = Func dFireTime = FireTime objParams = Params End Sub Public ReadOnly Property FireTime() Get Return dFireTime End Get End Property Public ReadOnly Property Func() As CrossAppDomainDelegate Get Return objF End Get End Property Public ReadOnly Property Params() As Object() Get Return objParams End Get End Property End Class And then the main loop implementation: Private Tasks As LinkedList(Of Job) Private Sub RunTasks() While True Dim CurrentTime as DateTime = Datetime.Now If Not Tasks.Count = 0 AndAlso Tasks(0).FireTime > CurrentTime Then Dim T As Job = Tasks(0) Tasks.RemoveFirst() T.Func.Invoke() Else Dim MillisecondDif As Double MillisecondDif = Tasks(0).FireTime.Subtract(CurrentTime).Milliseconds If MillisecondDif > 30 Then Threading.Thread.Sleep(MillisecondDif) End If End If End While End Sub Do I have it right? EpicClanWars.com ~Edit 2~ Switched the word "Task" out for "Job" so ppl could stop complaining about it ;) ~Edit 3~ Added variables for tracking time & ensuring spinloops happen when needed
