[site]: stackoverflow
[post_id]: 3916370
[parent_id]: 3916204
[tags]: 
There is no reason why you can't do that. You just have to pay some extra attention to your memory. Because what happens when you later assign to the property again? Using your example: @property (nonatomic, assign) NSArray *myArray; @synthesize myArray; ... self.myArray = [[NSArray alloc] initWithObjects: @"foo", nil]; self.myArray = [[NSArray alloc] initWithObjects: @"bar", nil]; // MEMORY LEAK! In this case you would have to manually release your ivar by calling release on it. If you do not, you will have leaked the memory. Another smart thing about having it retained (or copied, less bug prone ) it that you can say: self.myArray = nil; This will release the variable AND set the reference to nil, so you avoid getting yourself into trouble. I absolutely see your point though. It is alot more verbose to have to write 3 lines instead of one. You can as @willcodejavaforfood suggests use autorelease when you are assigning to retained properties , as he seems to have missed ). But Apple suggests that on the iPhone you do as little autoreleasing as you can, and we always listen to apple like good little children. Update: When you specify a property as (nonatomic, assign) an synthesize it the setter code that is generated looks something like this: - (void)setMyArray:(NSArray *)newValue { myArray = newValue; } If you on the other hand define it as (nonatomic, retain) you get: - (void)setMyArray:(NSArray *)newValue { if (myArray != newValue) { [myArray release]; myArray = [newValue retain]; } } Hope it clears things up.
