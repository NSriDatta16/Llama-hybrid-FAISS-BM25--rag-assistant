[site]: stackoverflow
[post_id]: 846304
[parent_id]: 846201
[tags]: 
Unfortunately, the pure SQL methods to do it are quite slow. The NESTED SETS proposed by @Marc W are quite elegant but they may require updating the whole tree if your tree branches hit the ranges, which can be quite slow. See this article in my blog on how to do it fast in MySQL : Hierarchical queries in MySQL - emulating Oracle 's CONNECT BY You'll need to create a function: CREATE FUNCTION hierarchy_connect_by_parent_eq_prior_id(value INT) RETURNS INT NOT DETERMINISTIC READS SQL DATA BEGIN DECLARE _id INT; DECLARE _parent INT; DECLARE _next INT; DECLARE CONTINUE HANDLER FOR NOT FOUND SET @id = NULL; SET _parent = @id; SET _id = -1; IF @id IS NULL THEN RETURN NULL; END IF; LOOP SELECT MIN(id) INTO @id FROM t_hierarchy WHERE parent = _parent AND id > _id; IF @id IS NOT NULL OR _parent = @start_with THEN SET @level = @level + 1; RETURN @id; END IF; SET @level := @level - 1; SELECT id, parent INTO _id, _parent FROM t_hierarchy WHERE id = _parent; END LOOP; END and use it in a query like this: SELECT hi.* FROM ( SELECT hierarchy_connect_by_parent_eq_prior_id(id) AS id, @level AS level FROM ( SELECT @start_with := 0, @id := @start_with, @level := 0 ) vars, t_hierarchy WHERE @id IS NOT NULL ) ho JOIN t_hierarchy hi ON hi.id = ho.id This is of course MySQL specific but it's real fast. If you want this to be portable betwen PostgreSQL and MySQL , you can use PostgreSQL 's contrib for CONNECT BY and wrap the query into a stored procedure with same name for both systems.
