[site]: stackoverflow
[post_id]: 3239414
[parent_id]: 3239157
[tags]: 
The gang of four seem to think so. Transactions, history tracking, and un-doing are all part of a command pattern contract. You can implement history with a stack. Here's a snippet of relevant code including the contract, note that not all methods are or have to be implemented: public interface ICommand { void execute(); void undo(); void store(); void load(); } public class ManagerMacro : ICommand { List Commands; Stack commandStack; /// /// Use in combination with AddSteps /// //public ManagerMacro() //{ //} public ManagerMacro(List commands) { this.Commands = commands; this.commandStack = new Stack(); } #region ICommand Members public void execute() { for (int i = 0; i 0) { ICommand Command = (ICommand)commandStack.Pop(); Command.undo(); } } } public void store() { throw new NotImplementedException(); } public void load() { throw new NotImplementedException(); } #endregion public void AddSteps(Steps[] steps) { foreach (Steps step in steps) { ICommand thisStep = null; switch (step) { case Steps.Manager1: thisStep = new Step1(); break; case Steps.Manager2: thisStep = new Step2(); break; case Steps.Manager3: thisStep = new Step3(); break; case Steps.Manager4: thisStep = new Step4(); break; } this.Commands.Add(thisStep); } } } Note that I also use a factory pattern.
