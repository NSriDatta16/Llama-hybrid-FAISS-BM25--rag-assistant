[site]: stackoverflow
[post_id]: 3990122
[parent_id]: 3990079
[tags]: 
The technique you are looking for is called locking. The simplest way to do this is to create a temporary file, and remove it when the operation has completed. Other processes will look for that temporary file, see that it already exists and go away. However, you also need to take care of the possibility of the lock's owner process crashing, and failing to remove the lock. This is where this simple task seems to become complicated. File based locking solutions PHP has a built-in flock() function that promises a OS-independent file-based locking feature. This question has some practical hints on how to use it. However, the manual page warns that under some circumstances, flock() has problems with multiple instances of PHP scripts trying to get a lock simultaneously. This question seems to have more advanced answers on the issue, but they are all not trivial to implement. Database based locking The author of this question - probably scared away by the complications surrounding flock() - asks for other, not file-based locking techniques and comes up with MySQL's GET_LOCK() . I have never worked with it, but it looks pretty straightforward - if you use mySQL anyway, it may be worth a shot. Damn, this issue is complicated if you want to do it right! Interested to see whether anything more elegant comes up.
