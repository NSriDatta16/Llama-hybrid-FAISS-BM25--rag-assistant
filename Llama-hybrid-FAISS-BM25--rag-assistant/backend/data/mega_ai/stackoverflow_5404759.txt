[site]: stackoverflow
[post_id]: 5404759
[parent_id]: 5404603
[tags]: 
I assume you are taking about nano-seconds rather than milli-seconds. (That is one million times smaller!) OR the use of ConcurrentHashMap is a trivial portion of your delay. EDIT: Have edited the example to be multi-threaded using 100 tasks. /* Average operation time for a map of 10,000,000 was 48 ns Average operation time for a map of 5,000,000 was 51 ns Average operation time for a map of 2,500,000 was 48 ns Average operation time for a map of 1,250,000 was 46 ns Average operation time for a map of 625,000 was 45 ns Average operation time for a map of 312,500 was 44 ns Average operation time for a map of 156,200 was 38 ns Average operation time for a map of 78,100 was 34 ns Average operation time for a map of 39,000 was 35 ns Average operation time for a map of 19,500 was 37 ns */ public static void main(String... args) { ExecutorService es = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); try { for (int size = 100000; size >= 100; size /= 2) test(es, size); } finally { es.shutdown(); } } private static void test(ExecutorService es, final int size) { int tasks = 100; final ConcurrentHashMap map = new ConcurrentHashMap (tasks*size); List futures = new ArrayList (); long start = System.nanoTime(); for (int j = 0; j
