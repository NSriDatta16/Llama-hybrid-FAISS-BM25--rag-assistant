[site]: stackoverflow
[post_id]: 3117567
[parent_id]: 3077718
[tags]: 
I don't know if I got the corner cases correctly, but anyway, here is some code: function floatToIntBits(f) { var NAN_BITS = 0|0x7FC00000; var INF_BITS = 0|0x7F800000; var ZERO_BITS = 0|0x00000000; var SIGN_BIT = 0|0x80000000; var EXP_MASK = 0|0x7F800000; var MANT_MASK = 0|0x007FFFFF; if (f != f) return NAN_BITS; var signBit = (f > 0.0 || (f == 0.0 && Math.pow(f, -1) > 0)) ? 0 : SIGN_BIT; var fabs = Math.abs(f); if (fabs == Number.POSITIVE_INFINITY) return signBit | INF_BITS; if (fabs == 0.0) return signBit | ZERO_BITS; var e = 0, x = f; while (x != 0.0) { e++; x /= 2.0; } var exp = e - (1023 + 52); if (exp >= 127) // XXX: maybe incorrect return signBit | INF_BITS; if (exp The funny-looking 0|0x... expressions are necessary because JavaScript treats these literal numbers as being large positive integers, but applying a bitwise operator apparently converts them to signed 32-bit ints. (Compare the ECMAScript specification, section 8.5, last paragraph.) Update: The following code is based on the above code, but it is more aligned to the actual wording of the specification. Additionally, it is independent of the particular floating point type that is used to implement JavaScript's Number . The code first moves the value to the interval [1.0; 2.0), since this is the representation that is mentioned in IEEE 754-1985 for normalized numbers. This code also handles denormalized numbers correctly and all the operations it uses are defined in IEEE 754-1985 and are exact, that is they don't lose precision. function assert(cond, msg, arg0) { if (!cond) console.log("error", msg, arg0); } function floatToIntBits(f) { var NAN_BITS = 0|0x7FC00000; var INF_BITS = 0|0x7F800000; var ZERO_BITS = 0|0x00000000; var SIGN_MASK = 0|0x80000000; var EXP_MASK = 0|0x7F800000; var MANT_MASK = 0|0x007FFFFF; var MANT_MAX = Math.pow(2.0, 23) - 1.0; if (f != f) return NAN_BITS; var hasSign = f = 2.0 && exp = -126) { exp--; x *= 2.0; } assert(x * Math.pow(2.0, exp) == fabs, "fabs"); var biasedExp = exp + 127; assert(0
