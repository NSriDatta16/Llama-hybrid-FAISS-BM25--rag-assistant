[site]: stackoverflow
[post_id]: 1337739
[parent_id]: 1337722
[tags]: 
Yours is the canonical solution. I'm not sure how you might like to do it in a way that would be better. To expand on this, if you have n members in your class you will find that you have to compare some number of these fields in order to establish a strict ordering. There is no real way around this, although you might find that it is possible to make the comparison function perform better (in terms of the average complexity) if you order the comparisons so that the ones that are more likely to contribute to the success of the comparison will come first. This helps it to drop out of the comparison faster. A possibility that can help in some circumstances (if you find that performance is dominated by comparisons) is to establish a "sort key" - comparing strings can be expensive. A sort key is a integer that can be used to do a fast comparison of the objects. If the sort key compares less than, then the string would do also. In your case, a simplistic sort key might involve treating the binary representation of the strings as integers - this has many bugs by the way - and then comparing the integers instead of the strings. In Windows, the LCMapString function can be used to produce a sort key for strings in this way. I think that you can then use a fast function like memcmp to compare the strings instead of a slower string comparison. This is more useful if you would be doing case insensitive comparisons or using the full range of unicode characters and wanted correct comparisons according to their rules.
