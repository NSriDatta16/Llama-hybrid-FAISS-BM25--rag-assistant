[site]: stackoverflow
[post_id]: 3202547
[parent_id]: 3201742
[tags]: 
Warning: this is rather ugly. I'm very curious about more elegant approaches. There is no (seq*seq) type. You'll have to test each parameter individually. Something like match (a,b) with | (:? seq as seqa), (:? seq as seqb) -> ... But this gives a compiler error, because the types of a and b need more type annotation. But this would constrain the parameters in such a way that you cant do something like eq 2 2. The snippet below would fix this: let eq a b = match (box a, box b) with | (:? seq as seqa), (:? seq as seqb) -> printfn "comparing sequences..." Seq.map2 (fun xA xB -> xA = xB) seqa seqb |> Seq.forall id | _ -> printfn "comparing default..." a=b But the result of comparing two sequences is not what's expected: > eq {1..10} {1..10};; comparing default... val it : bool = false It jumps to the second match clause. This is because the compiler restricted the types seq to seq and it's fed two seq. In order to compare two sequences, they need to be converted to Seq's like this: > eq1 (Seq.map box {1..10}) (Seq.map box {1..10});; comparing sequences... val it : bool = true > eq1 (Seq.map box {1..10}) (Seq.map box {1L..10L});; comparing sequences... val it : bool = false This said, I think it's a rather ugly hack. I'd suggest writing a sequence comparison function that only tests sequences.
