[site]: stackoverflow
[post_id]: 4341919
[parent_id]: 4341570
[tags]: 
To understand why variably-sized arrays are more complicated to implement, you need to know a little about how automatic storage duration ("local") variables are usually implemented. Local variables tend to be stored on the runtime stack. The stack is basically a large array of memory, which is sequentially allocated to local variables and with a single index pointing to the current "high water mark". This index is the stack pointer . When a function is entered, the stack pointer is moved in one direction to allocate memory on the stack for local variables; when the function exits, the stack pointer is moved back in the other direction, to deallocate them. This means that the actual location of local variables in memory is defined only with reference to the value of the stack pointer at function entry 1 . The code in a function must access local variables via an offset from the stack pointer. The exact offsets to be used depend upon the size of the local variables. Now, when all the local variables have a size that is fixed at compile-time, these offsets from the stack pointer are also fixed - so they can be coded directly into the instructions that the compiler emits. For example, in this function: void foo(void) { int a; char b[10]; int c; a might be accessed as STACK_POINTER + 0 , b might be accessed as STACK_POINTER + 4 , and c might be accessed as STACK_POINTER + 14 . However, when you introduce a variably-sized array, these offsets can no longer be computed at compile-time; some of them will vary depending upon the size that the array has on this invocation of the function. This makes things significantly more complicated for compiler writers, because they must now write code that accesses STACK_POINTER + N - and since N itself varies, it must also be stored somewhere. Often this means doing two accesses - one to STACK_POINTER + to load N , then another to load or store the actual local variable of interest. 1. In fact, "the value of the stack pointer at function entry" is such a useful value to have around, that it has a name of its own - the frame pointer - and many CPUs provide a separate register dedicated to storing the frame pointer. In practice, it is usually the frame pointer from which the location of local variables is calculated, rather than the stack pointer itself.
