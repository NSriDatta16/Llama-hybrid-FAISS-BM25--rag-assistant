[site]: stackoverflow
[post_id]: 3635900
[parent_id]: 3629458
[tags]: 
Right. So I decided that I would have to hold a double at least to calculate any given dimension's mean. The issue was that i was approaching this problem by going: for each sample, get the array it is to update for each dimension in that array, calculate it's running mean given the new sample The issue with that is that a double[][] would have to be held holding the current running mean for each dimension of each element to update. Therefore, i have now rearranged my loop to look more like this: for each array to be updated for each sample that will update this array for each dimension in the array to be updated calculate the running mean This way round requires some pre-processing, i need to loop through all the samples to find which samples will update which arrays (a single indecies array) but my overall saving is that i can now hold a SINGLE double which is updated for each sample which updates a given array for a given dimension of that sample. This double can then be cast to the appropriate low precision type, in my case, a byte. The overall saving in terms of storage space i was initially going for was: replace Integers (costing 4*128*numberOfSamples) with Bytes (costing 1*128*numberOfSamples) that didn't work, but i have now formulated a solution that costs something like: (128*numberOfSamples + numberOfSamples). A saving of 127*numberOfSamples. Which in my worst case is something approaching 15Gb of RAM :-) So yeah, there we go, a nights sleep and i answered my own question. Thanks for the help fellows!
