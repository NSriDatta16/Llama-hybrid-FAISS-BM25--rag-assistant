[site]: stackoverflow
[post_id]: 4648702
[parent_id]: 4648607
[tags]: 
Your team needs to learn about the reasons for avoiding repeated string concatenation . There certainly are times when it makes sense to use StringBuffer - in particular when you're creating a string in a loop, especially if you aren't sure that there will be few iterations in the loop. Note that it's not just a matter of creating new objects - it's a matter of copying all the text data you've appended already. Also bear in mind that object allocation is only "essentially free" if you don't consider garbage collection. Yes, if there's enough room in the current generation, it's basically a matter of incrementing a pointer... but: That memory must have been cleared at some point. That's not free. You're shortening the time until the next GC is required. GC isn't free. If your object lives into the next generation, it may take longer to be cleaned up - again, not free. All of these things are reasonably cheap in that it's "usually" not worth bending a design away from elegance to avoid creating objects... but you shouldn't regard them as free . On the other hand, there is no point in using StringBuffer in cases where you won't need the intermediate strings. For example: String x = a + b + c + d; is at least as efficient as: StringBuffer buffer = new StringBuffer(); buffer.append(a); buffer.append(b); buffer.append(c); buffer.append(d); String x = buffer.toString();
