[site]: stackoverflow
[post_id]: 1821337
[parent_id]: 1821142
[tags]: 
Your table of jobs is a queue. Writing user tables backed up queues is a notoriously error prone as it leads to deadlocks and concurency issues. The simplest thing would be to drop the user table and use a true queue instead. This will give you deadlock free concurency free queue on system tested and validated code base. The problem is that the whole paradigm around queues changes from INSERT and DELETE/UPDATE to SEND / RECEIVE . On the other hand with built-in queue you get some very powerfull free goodies, namely Activation and correlated items locking . If you want to continue down the path of user table backed queues then the second most important trick in writing user tables queues is to use UPDATE ... OUTPUT: WITH cte AS ( SELECT TOP(20) status, id, ... FROM table WITH (ROWLOCK, READPAST, UPDLOCK) WHERE status = 'new' ORDER BY enqueue_time) UPDATE cte SET status = 'processing' OUTPUT INSERTED.id, ... The CTE syntax is just for convenience of placing the TOP and ORDER BY properly, the query can be written using derived tables just as esily. You cannot use straight UPDATE ... TOP because UPDATE does not support an ORDER BY and you require this to satisfy the 'oldest' part of your requirement. The lock hints are needed to facilitate high concurency between parallel processing threads. I said this is the second most important trick. The most important is how you organize the table. For a queue it must be clustered by (status, enqueue_time) . If you don't organize the table properly you'll end up with deadlocks. Pre-emptive comment: fragmentation is irelevant in this scenario.
