[site]: stackoverflow
[post_id]: 1144565
[parent_id]: 1144322
[tags]: 
You have the indicies of the highlighted words.. I think the below is a good, fast approach as it doesn't require "finding" every word (to do the circular loop). To do this it uses a "chunk size" derived from a number of characters rather than words. You could then "round up" or "round down" to the nearest word ending and there you have your chunk. The method to get how many highlighted indicies are within a "chunk size" ahead in your sample could be better done I think. Pseudo string GetHighestDensityChunk(){ // {chunk size} = 400 * average word length // {possible start positions} = 0, highlighted indicies, and (sample - {chunk size}) int position int bestPositionSoFar = 0 int maxHighLightedCountSoFar = 0 for each position in {possible start position} { highlightedCount = GetNumberOfHighlightedWithinChunkSize(position) if(highlightedCount > maxHighLightedCountSoFar) { maxHighLightedCountSoFar = highlightedCount bestPositionSoFar = position } } // "round up" to nearest word end // gives index of next space after end of chunk starting from current best position {revised chunk size} = sample.indexOf(' ', startingAt = bestPositionSoFar + {chunk size}) - bestPositionSoFar return sample.substring(bestPositionSoFar, {revised chunk size}) } int GetNumberOfHighlightedWithinChunkSize(position) { numberOfHighlightedInRange = 0 // starts from current position and scans forward counting highlighted indicies that are in range for(int i= {possible start position}.indexOf(position); i
