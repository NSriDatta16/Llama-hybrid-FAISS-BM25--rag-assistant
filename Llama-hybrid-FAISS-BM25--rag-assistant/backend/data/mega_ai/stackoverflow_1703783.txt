[site]: stackoverflow
[post_id]: 1703783
[parent_id]: 1703528
[tags]: 
Not sure about the efficiency, but this is straightforward with Linq to XML - the follwing was a bit rough - but having remembered that the very wonderful LinqPAD will let you run programs... herewith a complete lump of code that would do the job: void Main() { XDocument settingsXML = XDocument.Load(@"c:\temp\settings.xml"); XDocument updateXML = XDocument.Load(@"c:\temp\updates.xml"); Console.WriteLine("Processing"); // Loop through the updates foreach(XElement update in updateXML.Element("preset").Elements("var")) { // Find the element to update XElement settingsElement = (from s in settingsXML.Element("preset").Elements("var") where s.Attribute("id").Value == update.Attribute("id").Value && s.Attribute("opt").Value == update.Attribute("opt").Value select s).FirstOrDefault(); if (settingsElement != null) { settingsElement.Attribute("val").Value = update.Attribute("val").Value; // Handling for additional attributes here } else { // not found handling Console.WriteLine("Not found {0},{1}", update.Attribute("id").Value, update.Attribute("opt").Value); } } Console.WriteLine("Saving"); settingsXML.Save(@"c:\temp\updatedSettings.xml"); Console.WriteLine("Finis!"); } Addition of using clauses is left as an exercise :) There's another example here but its in VB which has more capabilities in terms of XML. I also think that it might be possible to do something seriously elegant by way of a query with a join of the two sets of XML data generating a list of dynamic types containing an XElement and the value (or values) that it needs to be updated with. But I've had enough fun (spent enough time) with this one already for one evening
