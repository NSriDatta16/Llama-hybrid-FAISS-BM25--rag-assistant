[site]: stackoverflow
[post_id]: 2999058
[parent_id]: 2974210
[tags]: 
I agree with the other posts that lookaround is regular (meaning that it does not add any fundamental capability to regular expressions), but I have an argument for it that is simpler IMO than the other ones I have seen. I will show that lookaround is regular by providing a DFA construction. A language is regular if and only if it has a DFA that recognizes it. Note that Perl doesn't actually use DFAs internally (see this paper for details: http://swtch.com/~rsc/regexp/regexp1.html ) but we construct a DFA for purposes of the proof. The traditional way of constructing a DFA for a regular expression is to first build an NFA using Thompson's Algorithm. Given two regular expressions fragments r1 and r2 , Thompson's Algorithm provides constructions for concatenation ( r1r2 ), alternation ( r1|r2 ), and repetition ( r1* ) of regular expressions. This allows you to build a NFA bit by bit that recognizes the original regular expression. See the paper above for more details. To show that positive and negative lookahead are regular, I will provide a construction for concatenation of a regular expression u with positive or negative lookahead: (?=v) or (?!v) . Only concatenation requires special treatment; the usual alternation and repetition constructions work fine. The construction is for both u(?=v) and u(?!v) is: In other words, connect every final state of the existing NFA for u to both an accept state and to an NFA for v , but modified as follows. The function f(v) is defined as: Let aa(v) be a function on an NFA v that changes every accept state into an "anti-accept state". An anti-accept state is defined to be a state that causes the match to fail if any path through the NFA ends in this state for a given string s , even if a different path through v for s ends in an accept state. Let loop(v) be a function on an NFA v that adds a self-transition on any accept state. In other words, once a path leads to an accept state, that path can stay in the accept state forever no matter what input follows. For negative lookahead, f(v) = aa(loop(v)) . For positive lookahead, f(v) = aa(neg(v)) . To provide an intuitive example for why this works, I will use the regex (b|a(?:.b))+ , which is a slightly simplified version of the regex I proposed in the comments of Francis's proof. If we use my construction along with the traditional Thompson constructions, we end up with: The e s are epsilon transitions (transitions that can be taken without consuming any input) and the anti-accept states are labeled with an X . In the left half of the graph you see the representation of (a|b)+ : any a or b puts the graph in an accept state, but also allows a transition back to the begin state so we can do it again. But note that every time we match an a we also enter the right half of the graph, where we are in anti-accept states until we match "any" followed by a b . This is not a traditional NFA because traditional NFAs don't have anti-accept states. However we can use the traditional NFA->DFA algorithm to convert this into a traditional DFA. The algorithm works like usual, where we simulate multiple runs of the NFA by making our DFA states correspond to subsets of the NFA states we could possibly be in. The one twist is that we slightly augment the rule for deciding if a DFA state is an accept (final) state or not. In the traditional algorithm a DFA state is an accept state if any of the NFA states was an accept state. We modify this to say that a DFA state is an accept state if and only if: = 1 NFA states is an accept state, and 0 NFA states are anti-accept states. This algorithm will give us a DFA that recognizes the regular expression with lookahead. Ergo, lookahead is regular. Note that lookbehind requires a separate proof.
