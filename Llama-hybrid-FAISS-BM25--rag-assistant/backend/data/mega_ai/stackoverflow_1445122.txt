[site]: stackoverflow
[post_id]: 1445122
[parent_id]: 
[tags]: 
What do you do to test methods that produce complicated object graphs?

I'm a controls developer and a relative newbie to unit testing. Almost daily, I fight the attitude that you cannot test controls because of the UI interaction. I'm producing a demonstration control to show that it's possible to dramatically reduce manual testing if the control is designed to be testable. Currently I've got 50% logic coverage, but I think I could bump that up to 75% or higher if I could find a way to test some of the more complicated parts. For example, I have a class with properties that describe the control's state and a method that generates a WPF PathGeometry object made of several segments. The implementation looks something like this: internal PathGeometry CreateOuterGeometry() { double arcRadius = OuterCoordinates.Radius; double sweepAngle = OuterCoordinates.SweepAngle; ArcSegment outerArc = new ArcSegment(...); LineSegment arcEndToCenter = new LineSegment(...); PathFigure fig = new PathFigure(); // configure figure and add segments... PathGeometry outerGeometry = new PathGeometry(); outerGeometry.Figures.Add(fig); return outerGeometry; } I've got a few other methods like this that account for a few hundred blocks of uncovered code, an extra 25% coverage. I originally planned to test these methods, but rejected the notion. I'm still a unit testing newbie, and the only way I could think of to test the code would be several methods like this: void CreateOuterGeometry_AngleIsSmall_ArcSegmentIsCorrect() { ClassUnderTest classUnderTest = new ClassUnderTest(); // configure the class under test... ArcSegment expectedArc = // generate expected Arc... PathGeometry geometry = classUnderTest.CreateOuterGeometry() ArcSegment arc = geometry.Figures.Segments[0]; Assert.AreEqual(expectedArc, arc) } The test itself looks fine; I'd write one for each expected segment. But I had some problems: Do I need tests to verify "Is the first segment an ArcSegment ?" In theory the test tests this, but shouldn't each test only test one thing? This sounds like two things. The control has at least six cases for calculation and four edge cases; this means for each method I need at least ten tests. During development I changed how the various geometries were generated several times. This would cause me to have to rewrite all of the tests. The first problem gave me pause because it seemed like it might inflate the number of tests. I thought I might have to test things like "Were there x segments?" and "Is segment n the right type?", but now that I've thought more I see that there's no branching logic in the method so I only need to do those tests once. The second problem made me more confident that there would be much effort associated with the test. It seems unavoidable. The third problem compounds the first two. Every time I changed the way the geometry was calculated, I'd have to edit an estimated 40 tests to make them respect the new logic. This would also include adding or removing tests if segments were added or removed. Because of these three problems, I opted to write an application and manual test plan that puts the control in all of the interesting states and asks the user to verify it looks a particular way. Was this wrong? Am I overestimating the effort involved with writing the unit tests? Is there an alternative way to test this that might be easier? (I'm currently studying mocks and stubs; it seems like it'd require some refactoring of the design and end up being approximately as much effort.)
