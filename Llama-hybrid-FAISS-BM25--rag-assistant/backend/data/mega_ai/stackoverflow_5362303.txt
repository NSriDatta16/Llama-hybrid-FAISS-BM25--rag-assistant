[site]: stackoverflow
[post_id]: 5362303
[parent_id]: 5359258
[tags]: 
Indeed, the kind of gradient you want relies on 4 colors at each pixel, where OpenGL typically only interpolates input over triangles (so 3 inputs). Getting the perfect gradient is not possible just with the standard interpolants. Now, as you mentioned, a 2x2 texture can do it. If you did see precision issues, I suggest switching the format of the texture to something that typically requires more precision (like a float texture). Last, and as you mentioned also in your question, you can solve this with a shader. Say you pass an extra attribute per-vertex that corresponds to (u,v) = (0,0) (0,1) (1,0) (1,0) all the way to the pixel shader (with the vertex shader just doing a pass-through). You can do the following in the pixel shader (note, the idea here is sound, but I did not test the code): Vertex shader snippet: varying vec2 uv; attribute vec2 uvIn; uv = uvIn; Fragment shader: uniform vec3 color0; uniform vec3 color1; varying vec2 uv; // from wikipedia on bilinear interpolation on unit square: // f(x,y) = f(0,0)(1-x)(1-y) + f(1,0)x(1-y) + f(0,1)(1-x)y + f(1,1) xy. // applied here: // gl_FragColor = color0 * ((1-x)*(1-y) + x*y) + color1*(x*(1-y) + (1-x)*y) // gl_FragColor = color0 * (1 - x - y + 2 * x * y) + color1 * (x + y - 2 * x * y) // after simplification: // float temp = (x + y - 2 * x * y); // gl_FragColor = color0 * (1-temp) + color1 * temp; gl_FragColor = mix(color0, color1, uv.u + uv.v - 2 * uv.u * uv.v);
