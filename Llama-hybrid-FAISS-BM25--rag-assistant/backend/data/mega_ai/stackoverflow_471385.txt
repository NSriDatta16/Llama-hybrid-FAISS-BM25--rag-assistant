[site]: stackoverflow
[post_id]: 471385
[parent_id]: 464456
[tags]: 
To answer the original question better: Background Every single page request spins up a new Session object and then inflates it from your session store. To do this, it uses the cookie provided by the client or a special path construct (for cookieless sessions). With this session identifier, it consults the session store and deserializes (this is why all providers but InProc need to be Serializable) the new session object. In the case of the InProc provider, merely hands you the reference it stored in the HttpCache keyed by the session identifier. This is why the InProc provider drops session state when the AppDomain is recycled (and also why multiple web servers cannot share InProc session state . This newly created and inflated object is stuck in the Context.Items collection so that it's available for the duration of the request. Any changes you make to the Session object are then persisted at the end of the request to the session store by serializing (or the case of InProc, the HttpCache entry is updated). Since Session_End fires without a current request in-fly, the Session object is spun up ex-nilo, with no information available. If using InProc session state, the expiration of the HttpCache triggers a callback event into your Session_End event, so the session entry is available, but is still a copy of what was last stored in the HttpContext.Cache . This value is stored against the HttpApplication.Session property by an internal method (called ProcessSpecialRequest ) where it is then available. Under all other cases, it internally comes from the HttpContext.Current.Session value. Your answer Since the Session_End always fires against a null Context, you should ALWAYS use this.Session in that event and pass the HttpSessionState object down to your tracing code. In all other contexts, it's perfectly fine to fetch from HttpContext.Current.Session and then pass into the tracing code. Do NOT , however, let the tracing code reach up for the session context. My answer Don't use Session_End unless you know that the session store you are using supports Session_End , which it does if it returns true from SetItemExpireCallback . The only in-the-box store which does is the InProcSessionState store. It is possible to write a session store that does but the question of who will process the Session_End is kind of ambiguous if there are multiple servers.
