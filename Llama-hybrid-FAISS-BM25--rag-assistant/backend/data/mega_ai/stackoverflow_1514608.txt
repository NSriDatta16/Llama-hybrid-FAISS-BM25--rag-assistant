[site]: stackoverflow
[post_id]: 1514608
[parent_id]: 1514548
[tags]: 
In the first construct, you are specifying that you are returning a List of the interface of the item that was passed in. You specify the relationship between the passed in Object and the return Object type in the U extends T direction. In this case, the compiler can associate A and B with T and U respectively. In the second, there is no such differentiation, so the compiler assumes that T refers to B and will type the return value as List . You then fall into the trap where, although B is an instance of A , List is not an instance of List . The compiler will complain: Type mismatch: cannot convert from List to List You will find that, with the first construct, you have the liberty of specifying a List of any interface the B implements or any superclass in the B hierarchy ( List , for example), and the compiler will not complain.
