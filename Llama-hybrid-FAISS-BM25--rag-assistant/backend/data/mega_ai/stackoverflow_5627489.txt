[site]: stackoverflow
[post_id]: 5627489
[parent_id]: 4443526
[tags]: 
The work simshaun did on this is fantastic. I messed with his version and got a bit smoother animation with the jquery.easing plugin. Try it out on jsfiddle . $(document).ready(function() { $('#dragme').draggable({ start: function(e, ui) { dragMomentum.start(this.id, e.clientX, e.clientY, e.timeStamp); }, stop: function(e, ui) { dragMomentum.end(this.id, e.clientX, e.clientY, e.timeStamp); } }); }); var dragMomentum = new function () { var howMuch = 30; // change this for greater or lesser momentum var minDrift = 6; // minimum drift after a drag move var easeType = 'easeOutBack'; // This easing type requires the plugin: // jquery.easing.1.3.js http://gsgd.co.uk/sandbox/jquery/easing/ var dXa =[0]; var dYa =[0]; var dTa =[0]; this.start = function (elemId, Xa, Ya, Ta) { dXa[elemId] = Xa; dYa[elemId] = Ya; dTa[elemId] = Ta; }; // END dragmomentum.start() this.end = function (elemId, Xb, Yb, Tb) { var Xa = dXa[elemId]; var Ya = dYa[elemId]; var Ta = dTa[elemId]; var Xc = 0; var Yc = 0; var dDist = Math.sqrt(Math.pow(Xa-Xb, 2) + Math.pow(Ya-Yb, 2)); var dTime = Tb - Ta; var dSpeed = dDist / dTime; dSpeed=Math.round(dSpeed*100)/100; var distX = Math.abs(Xa - Xb); var distY = Math.abs(Ya - Yb); var dVelX = (minDrift+(Math.round(distX*dSpeed*howMuch / (distX+distY)))); var dVelY = (minDrift+(Math.round(distY*dSpeed*howMuch / (distX+distY)))); var position = $('#'+elemId).position(); var locX = position.left; var locY = position.top; if ( Xa > Xb ){ // we are moving left Xc = locX - dVelX; } else { // we are moving right Xc = locX + dVelX; } if ( Ya > Yb ){ // we are moving up Yc = (locY - dVelY); } else { // we are moving down Yc = (locY + dVelY); } var newLocX = Xc + 'px'; var newLocY = Yc + 'px'; $('#'+elemId).animate({ left:newLocX, top:newLocY }, 700, easeType ); }; // END dragmomentum.end() }; // END dragMomentum()
