[site]: stackoverflow
[post_id]: 4112389
[parent_id]: 
[tags]: 
What is one of the more efficient ways to search for a string in an array and get its index?

Given an enum similar to this: Friend Enum TestValue As Int32 tstNotSet = -1 tstA = 0 tstB = 1 tstC = 2 tstD = 3 tstE = 4 tstF = 5 tstG = 6 tstH = 7 tstI = 8 tstJ = 9 tstK = 10 tstL = 11 tstM = 12 End Enum And an Array similar to this: Dim TestValues() As String = {"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M"} And a string is fed in as input in some form similar to (assume it is already stored to a variable): Dim tmpInput As String = "ADFGHJLM" And a Sub/Method in another arbitrary class that takes in as input an array of one of more of the Enums from TestValue , based on the input string tmpInput . Basically, I want to walk the tmpInput variable, and for each character, map out its equivalent member in the Enum, so that I can pass it to this Sub in the other object. The string array TestValues and the Enum TestValue (yes, the names could be done better, but don't let that bother you too much) are laid out to match each other explicitly. So I basically want to search the array for the matching letter, and use its index offset to know which Enum I want to map to that letter. My current code uses a large Select Case statement, but that's just ugly (although, performance tests show it to be rather speedy, even in the debug build). The purpose of this test case is to provide an example of a mechanism I use in a project I'm working on. In this project, objects have a ReadOnly property that returns a string of letters composed from TestValues . It also has a Sub that accepts an array of one or more Enums from TestValue that sets a private member in the object that is used by the aforementioned ReadOnly property. The purpose was to store an array of smaller integer values (the Enums) rather than an array of strings for the object's internal functionality. So I had to create a way to map back and forth between the string array and the enum. Yes, it's easily doable with the many different collections available in .NET, but I feel those are too heavyweight for my needs, as many of my objects have enums as small as two values, hence, arrays. I borrowed the trick from a similar example used in C to be able to select a string from a const array based on an index offset. Anyways, as I've discovered, searching arrays in VB.NET is not trivial. There is apparently no simple command like TestValues.GetIndex(tmp(i)) , where tmp(i) is a variable holding a single character (String, not Char), that would return say, '8' if tmp(i) was set to 'I'. Instead, methods like Array.FindIndex require using delegates/predicates, something I haven't fully wrapped my head around just yet (they seem like function pointers from C). So what's the best way, other than constantly looping over the array for every input character, to locate the index offset based on the stored value? Is the method I highlight sane or insane (hint: it's a hold-over from VBA code)? Is there a more efficient way? Oh, and yes, the ReadOnly property does check that the internal members are NOT set to tstNotSet before attempting to read from the TestValues array. That's why that Enum member exists. Thanks! EDIT: Hopefully this doesn't muddle the explanation up too much, but here's an example, as simplified as I can get it, of how the look up currently operates using the array, enum, and input string as defined above: Dim n As Int32 = 0 Dim Foobar(0 to 12) As TestValue For Each s As String In tmpInput Select Case Char.ToUpper(CChar(s)) Case CChar(TestValues(tstA)) Foobar(n) = tstA n += 1 Case CChar(TestValues(tstB)) Foobar(n) = tstB n += 1 Case CChar(TestValues(tstC)) Foobar(n) = tstC n += 1 Case CChar(TestValues(tstD)) Foobar(n) = tstD n += 1 Case CChar(TestValues(tstE)) Foobar(n) = tstE n += 1 Case CChar(TestValues(tstF)) Foobar(n) = tstF n += 1 Case CChar(TestValues(tstG)) Foobar(n) = tstG n += 1 Case CChar(TestValues(tstH)) Foobar(n) = tstH n += 1 Case CChar(TestValues(tstI)) Foobar(n) = tstI n += 1 Case CChar(TestValues(tstJ)) Foobar(n) = tstJ n += 1 Case CChar(TestValues(tstK)) Foobar(n) = tstK n += 1 Case CChar(TestValues(tstL)) Foobar(n) = tstL n += 1 Case CChar(TestValues(tstM)) Foobar(n) = tstM n += 1 End Select Next As noted in my comment to Jon Skeet, this construct, along with the rest of the Object's components, executes 100,000 times in a profiling loop in ~570ms (rough average of 3-5 runs). Exchanging the above construct out with a smaller Array.IndexOf construct loops 100,000 times in ~630ms (again, 3-5 runs, rough average, the whole Object). The new construct looks like this: Dim p As Int32 p = Array.IndexOf(TestValues, s) If p <> tstNotSet Then Foobar(n) = DirectCast(p, TestValue) n += 1 End If
