[site]: stackoverflow
[post_id]: 839424
[parent_id]: 839119
[tags]: 
I've found the problem. It was the squishy organic component that operates my computer. ThreadPool.QueueUserWorkItem() will start work on a threadpool thread. Which means a background thread . The code was running in a test console application, and of course I'd forgotten to put anything in Main() to stop the program exiting after it called ThreadPool.QueueUserWorkItem() . This meant that by the time I got to pressing F10 to step to the next line, the program had actually already stopped, so the debugger closed itself. All I did to fix it was add a call to Console.ReadKey() at the end of Program.Main() and now it all works beautifully. Note that the problem had nothing to do with System.Transactions.TransactionScope or threadpool threads. It would've happened no matter what line I put my breakpoint on. Note : If you're thinking I should've seen a ThreadAbortException , then reading the article linked above will point out why that didn't happen. Here's a direct quote: When the runtime stops a background thread because the process is shutting down, no exception is thrown in the thread. However, when threads are stopped because the AppDomain.Unload method unloads the application domain, a ThreadAbortException is thrown in both foreground and background threads.
