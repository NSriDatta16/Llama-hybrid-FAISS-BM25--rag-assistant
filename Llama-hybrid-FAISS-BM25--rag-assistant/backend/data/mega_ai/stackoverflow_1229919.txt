[site]: stackoverflow
[post_id]: 1229919
[parent_id]: 1229751
[tags]: 
reinterpret_casts are used for low-level implementation defined casts. According to the standard, reinterpret_casts can be used for the following conversions (C++03 5.2.10): Pointer to an integral type Integral type to Pointer A pointer to a function can be converted to a pointer to a function of a different type A pointer to an object can be converted to a pointer to an object of different type Pointer to member functions or pointer to data members can be converted to functions or objects of a different type. The result of such a pointer conversion is unspecified, except the pointer a converted back to its original type. An expression of type A can be converted to a reference to type B if a pointer to type A can be explicitly converted to type B using a reinterpret_cast . That said, using the reinterpret_cast is not a good solution in your case, since casting to different types are unspecified by the standard, though casting from char * to unsigned char * and back should work on most machines. In your case I would think about using a static_cast or not casting at all by defining stg as type char * : template char *copy_binary( unsigned char length, const ITER_T& begin) { // alloc_storage() returns a char* char* stg = alloc_storage(length); std::copy(begin, begin + length, stg); return stg; }
