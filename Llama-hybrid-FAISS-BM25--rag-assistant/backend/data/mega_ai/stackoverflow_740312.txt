[site]: stackoverflow
[post_id]: 740312
[parent_id]: 739311
[tags]: 
what would be the best way to reorganize the project and refactor the code so that it retains its current ability to access everything else? I think you're actually quite close already, and probably better than many Python projects where they just assume that there is only one instance of the application, and store application-specific values in a module global or singleton. (This is OK for many simple applications, but really it's nicest to be able to bundle everything up into one Application object that owns all inner classes and methods that need to know the application's state.) The first thing I would do from the looks of the code above would be to factor out any of those modules and classes that aren't a core competency of your application, things that don't necessarily need access to the application's state. Names like “Utils” and “Misc” sound suspiciously like much of their contents aren't really specific to your app; they could perhaps be refactored out into separate standalone modules, or submodules of your package that only have static functions, stuff not relying on application state. Next, I would put the main owner Application class in the package's __init__.py rather than a ‘master script’. Then from your run-script or just the interpreter, you can get a complete instance of the application as simply as: import myapplication a= myapplication.Application() You could also consider moving any basic deployment settings from the Settings class into the initialiser: a= myapplication.Application(basedir= '/opt/myapp', site= 'www.example.com', debug= False) (If you only have one possible set of settings and every time you instantiate Application() you get the same one, there's little use in having all this ability to encapsulate your whole application; you might as well simply be using module globals.) What I'm doing with some of my apps is making the owned classes monkey-patch themselves into actual members of the owner application object: # myapplication/__init__.py class Application(object): def __init__(self, dbfactory, debug): # ... self.mailer= self.Mailer(self) self.webservice= self.Webservice(self) # ... import myapplication.mailer, myapplication.webservice # myapplication/mailer.py import myapplication class Mailer(object): def __init__(self, owner): self.owner= owner def send(self, message, recipients): # ... myapplication.Application.Mailer= Mailer Then it's possible to extend, change or configure the Application from outside it by replacing/subclassing the inner classes: import myapplication class MockApplication(myapplication.Application): class Mailer(myapplication.Application.Mailer): def send(self, message, recipients): self.owner.log('Mail send called (not actually sent)') return True I'm not that worried about internal data integrity Well no, this is Python not Java: we don't worry too much about Evil Programmers using properties and methods they shouldn't, we just put ‘_’ at the start of the name and let that be a suitable warning to all. And those long chains slow the code down as well. Not really noticeably. Readability is the important factor; anything else is premature optimisation.
