[site]: stackoverflow
[post_id]: 5446078
[parent_id]: 
[tags]: 
Frequency weighting in R, comparing results with Stata

I'm trying to analyze data from the University of Minnesota IPUMS dataset for the 1990 US census in R . I'm using the survey package because the data is weighted . Just taking the household data (and ignoring the person variables to keep things simple), I am attempting to calculate the mean of hhincome ( household income ). To do this I created a survey design object using the svydesign() function with the following code: > require(foreign) > ipums.household ipums.household[ipums.household$hhincome==9999999, "hhincome"] ipums.hh.design svymean(ipums.household$hhincome, ipums.hh.design, na.rm=TRUE) mean SE [1,] 37029 17.365 So far so good. However, I get a different standard error if I attempt the same calculation in Stata (using code meant for a different portion of the same dataset ): use "C:\I\Hate\Backslashes\stata_export.dta" replace hhincome = . if hhincome == 9999999 (933734 real changes made, 933734 to missing) mean hhincome [fweight = hhwt] # The code from the link above. Mean estimation Number of obs = 91746420 -------------------------------------------------------------- | Mean Std. Err. [95% Conf. Interval] -------------+------------------------------------------------ hhincome | 37028.99 3.542749 37022.05 37035.94 -------------------------------------------------------------- And, looking at another way to skin this cat, the author of survey , has this suggestion for frequency weighting: expanded.data However, I can't seem to get this code to work: > hh.dataframe expanded.hh.dataframe Which I can't seem to fix. This may be related to this issue . So in sum: Why don't I get the same answers in Stata and R ? Which one is right (or am I doing something wrong in both cases)? Assuming I got the rep() solution working, would that replicate Stata 's results? What's the right way to do it? Kudos if the answer allows me to use the plyr package for doing arbitrary calculations, rather than being limited to the functions implemented in survey ( svymean() , svyglm() etc.) Update So after the excellent help I've received here and from IPUMS via email, I'm using the following code to properly handle survey weighting. I describe here in case someone else has this problem in future. Initial Stata Preparation Since IPUMS don't currently publish scripts for importing their data into R , you'll need to start from Stata , SAS , or SPSS . I'll stick with Stata for now. Begin by running the import script from IPUMS. Then before continuing add the following variable: generate strata = statefip*100000 + puma This creates a unique integer for each PUMA of the form 240001, with first two digits as the state fip code (24 in the case of Maryland) and the last four a PUMA id which is unique on a per state basis. If you're going to use R you might also find it helpful to run this as well generate statefip_num = statefip * 1 This will create an additional variable without labels, since importing .dta files into R apply the labels and lose the underlying integers. Stata and svyset As Keith explained, survey sampling is handled by Stata by invoking svyset . For an individual level analysis I now use: svyset serial [pweight=perwt], strata(strata) This sets the weighting to perwt , the stratification to the variable we created above, and uses the household serial number to account for clustering. If we were using multiple years, we might want to try generate double yearserial = year*100000000 + serial to account for longitudinal clustering as well. For household level analysis (without years): svyset serial [pweight=hhwt], strata(strata) Should be self-explanatory (though I think in this case serial is actually superfluous). Replacing serial with yearserial will take into account a time series. Doing it in R Assuming you're importing a .dta file with the additional strata variable explained above and analysing at the individual letter: require(foreign) ipums Or at the household level: ipums.hh.design Hope someone finds this helpful, and thanks so much to Dwin, Keith and Brandon from IPUMS.
