[site]: stackoverflow
[post_id]: 2511026
[parent_id]: 2510218
[tags]: 
I think the ZODB is the tool to use. It will store lots of arbitrary items, it handles memory issues. Here is a working example, and in this case I included objects that reference each other as well as being stored in a BTree by number. import random from collections import deque import ZODB from ZODB.FileStorage import FileStorage from ZODB.DB import DB import transaction import persistent import BTrees def random_string(n=100): return ''.join([chr(random.randint(0,95)+32) for i in xrange(n)]) class Node(persistent.Persistent): def __init__(self, value=None): if not value: self.value = random_string() def setNeighbors(self, refs): self.p1 = refs[0] self.p2 = refs[1] self.p3 = refs[2] self.p4 = refs[3] def getTree(): storage = FileStorage('c:\\test.zdb') db = DB(storage) connection = db.open() root = connection.root() if root.has_key('tree'): tree = root['tree'] else: tree = BTrees.OOBTree.OOBTree() root['tree'] = tree transaction.commit() return tree def fillDB(): tree = getTree() # start with some initial objects. nodes = deque([Node(), Node(), Node(), Node()]) node = Node() for n in xrange(20000): tree[n] = node # store the node based on a numeric ID node.setNeighbors(nodes) # Make the node refer to more nodes. node = nodes.popleft() # maintain out list of 4 upcoming nodes. nodes.append(Node()) if n % 1000 == 0: transaction.commit() # Must commit for data to make it to disk. print n transaction.commit() return tree At this point the tree variable basically works like a dictionary and can be accessed by the key. You can also get the keys in a range by using tree.keys(min, max) as described by the ZODB BTrees API documentation . You can store your 10 lists by putting each one under a different key in the root object returned by the ZODB. The root object serves as the "gateway" to the ZODB object storage. Thanks to the ZODB, you can also use the inter-object references as well as the Btree index. For example: tree = getTree() node1 = tree[1] print node1.p1.p1.p1.p1.p1.p1.p1.p1.p1.value
