[site]: stackoverflow
[post_id]: 5642487
[parent_id]: 5639548
[tags]: 
You've got too many things going on. You need to isolate and test individual portions to convince yourself that doesn't contain the problem. It seems to me the first thing to verify is the serialization of TransferObject. You can use code this like to simply test the serialization/deserialization of your object import java.io.*; public static Object testSerialization(Object inObj) throws IOException, ClassNotFoundException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(inObj); // Ensure everything is written to the stream. oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bais); return ois.readObject(); } Use this method and some unit tests to prove it is okay. I suspect the problem is in TransferObject. You are passing in a reference to an array in the constructor, and just hanging on to it. It is mutable, and if someone is messing with that array while you are serializing the TransferObject, bad things will happen. It seems to me that TransferObject should really be immutable: import java.io.Serializable; import java.util.Arrays; public class TransferObject implements Serializable { /** You should really have this for efficiency */ private static final long serialVersionUID = 1L; private final int playerId; //to be sent in forst data send to tell client which player they are private final int turnNow; // ID of who's go it is now private final int command; //0 = initialise, 1=game update, 2=roll, 3=end game private final int[] playerLoc; public TransferObject(int playerId, int command, int[] playerLoc) { this.playerId = playerId; this.command = command; this.playerLoc = Arrays.copyOf(playerLoc, playerLoc.length); }
