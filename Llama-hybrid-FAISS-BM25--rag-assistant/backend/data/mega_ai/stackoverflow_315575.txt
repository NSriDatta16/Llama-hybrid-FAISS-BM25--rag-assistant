[site]: stackoverflow
[post_id]: 315575
[parent_id]: 315496
[tags]: 
One way to get this to work is to define your own iterator in a separate class, and then tell your main class to use that new iterator instead of the default one. class MyIterator implements Iterator { public function key() { // } public function rewind() { // } // etc. } class MyMainClass implements IteratorAggregate { private $_data = array(); // getIterator is required for the IteratorAggregate interface. public function getIterator() { return new MyIterator($this->_data); } // etc. } Then you should have as much control as you need. (And you can reuse your own MyIterator across a number of classes). No testing done on the above, but the principle is correct, I believe. Hope this helps!
