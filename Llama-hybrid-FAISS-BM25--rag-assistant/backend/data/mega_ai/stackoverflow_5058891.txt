[site]: stackoverflow
[post_id]: 5058891
[parent_id]: 5057755
[tags]: 
This is possible, but it takes some work. I'll assume C++, and omit the struct keyword in struct node . You will need to do some bookkeeping to keep track of the "ref" pointers. Here, I'm converting them to numerical indices into the original list and then back to pointers into the new list. node *copy_list(node const *head) { // maps "ref" pointers in old list to indices std::map ptr_index; // maps indices into new list to pointers std::map index_ptr; size_t length = 0; node *curn; // ptr into new list node const *curo; // ptr into old list node *copy = NULL; for (curo = head; curo != NULL; curo = curo->next) { ptr_index[curo] = length; length++; // construct copy, disregarding ref for now curn = new node; curn->next = copy; copy = curn; } curn = copy; for (size_t i=0; i next) index_ptr[i] = curn; // set ref pointers in copy for (curo = head, curn = copy; curo != NULL; ) { curn->ref = index_ptr[ptr_index[curo->ref]]; curo = curo->next; curn = curn->next; } return copy; } This algorithm runs in O( n lg n ) because it stores all n list elements in an std::map , which has O(lg n ) insert and retrieval complexity. It can be made linear by using a hash table instead. NOTE: not tested, may contain bugs.
