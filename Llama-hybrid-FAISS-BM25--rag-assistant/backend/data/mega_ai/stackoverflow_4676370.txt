[site]: stackoverflow
[post_id]: 4676370
[parent_id]: 3768278
[tags]: 
I think you will have to loop over the "inserted" table, which contains all rows that were updated. You can use a WHERE loop, or a WITH statement if your primary key is a GUID. This is the simpler (for me) to write, so here is my example. We use this approach, so I know for a fact it works fine. ALTER TRIGGER [dbo].[RA2Newsletter] ON [dbo].[Reiseagent] AFTER INSERT AS -- This is your primary key. I assume INT, but initialize -- to minimum value for the type you are using. DECLARE @rAgent_ID INT = 0 -- Looping variable. DECLARE @i INT = 0 -- Count of rows affected for looping over DECLARE @count INT -- These are your old variables. DECLARE @rAgent_Name NVARCHAR(50) DECLARE @rAgent_Email NVARCHAR(50) DECLARE @rAgent_IP NVARCHAR(50) DECLARE @hotelID INT DECLARE @retval INT BEGIN SET NOCOUNT ON ; -- Get count of affected rows SELECT @Count = Count(rAgent_ID) FROM inserted -- Loop over rows affected WHILE @i @rAgent_ID ORDER BY rAgent_ID ASC -- Populate values for the current row SELECT @rAgent_Name = rAgent_Name, @rAgent_Email = rAgent_Email, @rAgent_IP = rAgent_IP, @hotelID = hotelID FROM Inserted WHERE rAgent_ID = @rAgent_ID -- Run your stored procedure EXEC insert2Newsletter '', '', @rAgent_Name, @rAgent_Email, @rAgent_IP, @hotelID, 'RA', @retval -- Set up next iteration SET @i = @i + 1 END END GO I sure hope this helps you out. Cheers!
