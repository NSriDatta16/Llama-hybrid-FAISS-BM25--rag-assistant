[site]: crossvalidated
[post_id]: 162058
[parent_id]: 
[tags]: 
How to organise an iterative manual rotation of n component pairs?

I am currently building a q.rotate() function for the qmethod R package for Q Methodology . As is desirable for Q, I'd like users to be able to iteratively rotate any given component pair loadings from a principal components analysis (PCA). Like so (early draft): Crucially, users should be able to go back to already rotated pairs, and continue rotating them. This is giving me some headaches, because rotations don't commute , so the order in which rotations are done matters. This is not a technical question on how to implement this in R. I am wondering how to organise this from a statistical procedure. I don't know whether what I'm planning makes any sense. Let's say I have three retained components: f1 , f2 , f3 , and this is their (unrotated) loadings matrix: # suppose I have some ORIGINAL loadings matrix, from a principal components analysis, with three retained components loa.orig Here's a draft order of things for the iteration: User chooses a component pair from the combinations of factors one of columns from combs User enters an angle in degrees to rotate the given factor pair , say f1 vs f2 , say 5° clockwise. f1 and f2 are rotated 5° clockwise all plots involving either f1 or f2 are updated, because they all change. ( correct ?) User enters another angle to try out, say 10° , still on f1 and f2 repeat steps 3 , 4 , 5 as long as the user wants user indicates that she is done with f1 and f2 . the rotated loadings matrix is saved to, say loa.rot return to step 1 , now all rotations, say between f2 and f3 are done on the rotated loa.rot from the past loop. repeat steps 1-9 . once user indicates that she is done with all factor pairs, last loa.rot is returned. Does that make sense? PS : There is an additional problem. Obviously, I'd like for this procedure to be reproducible , preferably without saving all the steps the user took. (They may be redundant). Instead, to create a reproducible "recipe" for this by-hand rotation, I would take the final loa.rot and compute the simplest step of rotations required to arrive at the final loa.rot from the initial loa.orig . No idea yet how to do that, that's a different question .
