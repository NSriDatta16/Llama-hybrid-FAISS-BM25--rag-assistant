[site]: stackoverflow
[post_id]: 3345521
[parent_id]: 3344731
[tags]: 
Aside from the fact that a comparison is typically about as fast as an addition (so you'd have more operations, on the average), and the fact that on many architectures branching is expensive if the CPU can't guess which way it'll go, there's also locality of code. Modern processors keep as much as possible on cache in the processor, or perhaps on the motherboard. Hitting the main memory is relatively slow, and reading in a memory page is comparatively very slow. There's a hierarchy from fast and small to slow and big. One important thing for performance is to try to stay on the "fast and small" side of that hierarchy. Your code will be in a loop. If that loop fits in one or two cache lines, you're in great shape, since the CPU can execute the loop with absolutely minimal time to fetch instructions, and without kicking other pieces of memory out of the cache. Therefore, when micro-optimizing, you should try to have inner loops contain small code, which typically means simple and short. In your case, you've got three comparisons and several adds when you could have no comparisons and two adds. This code is much more likely to cause a cache miss than the simpler tempAnswer = work1 + work2 + toCarry; .
