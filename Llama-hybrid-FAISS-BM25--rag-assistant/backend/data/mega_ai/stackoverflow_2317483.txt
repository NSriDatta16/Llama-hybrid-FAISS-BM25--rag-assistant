[site]: stackoverflow
[post_id]: 2317483
[parent_id]: 2316762
[tags]: 
If the C++ application talks directly to the database, you can use fragment caching in combination with the cache_key . It's easy and built-in in Rails. All you have to do, is to make sure your C++ application updates the updated_at field of the record when the main record content is updated. Then, you can scope your fragment to the record object and the cache will automatically expire when the record is changed. here the content to be cached for example the . :metadata is simply a name for this fragment. Assuming the @article record was saved on 2010-02-10 18:00:00, the fragment will be cached at /path/to/cache/.../24-20100210180000 . When your C++ updates the record and changes the updated_at column, the cache will be invalidated and the next request will automatically hit the content again. For more information about caching, check out http://railslab.newrelic.com/scaling-rails
