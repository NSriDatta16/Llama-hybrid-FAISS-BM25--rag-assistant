[site]: stackoverflow
[post_id]: 1238460
[parent_id]: 1235195
[tags]: 
the point is, that weak references are expensive ... they are both slower and consume more space ... here is some benchmark code: package { //{ region imports import flash.display.Sprite; import flash.events.Event; import flash.events.EventDispatcher; import flash.system.System; import flash.utils.*; //} endregion public class Main extends Sprite { public function Main():void { switch (0) { case 0: this.benchmarkDispatchers(false); break; case 1: this.benchmarkDispatchers(true); break; case 2: this.benchmarkDictionaries(false); break; case 3: this.benchmarkDictionaries(true); break; } } private function benchmarkDictionaries(weakKeys:Boolean, size:uint = 1000000):void { var a:Array = []; for (var i:int = 0; i this is, what i get on my machine: adding 100000 event handlers took 679 msecs and 6922240 B of memory with weakKeys == false adding 100000 event handlers took 1348 msecs and 13606912 B of memory with weakKeys == true adding 1000000 keys took 283 msecs and 16781312 B of memory with weakKeys == false adding 1000000 keys took 906 msecs and 42164224 B of memory with weakKeys == true results are a little more drastic for dictionaries, most probably because there are no ActionScript calls involved, concerning time, and since some storage overhead in event handler registering lessens the difference between memory needed (as you can see, it's 69 Byte/handler and 16 Byte/key, when comparing weak references) ... so yeah, it is about performance ... using weak references is not about the cool fact, that you don't have to remove the listener in order for an object to die ... if you want to have a scalable app, you need to do these kind of things yourself, and if you want it to be 100% reliable, you can't hope for the GC to do your job, but you need tomake cleanups yourself ... and also, if you have a good hierarchy in your app, you will probably not run into this problem much to often ... in a sense, it is a luxury, if you don't wanna spend you time doing proper object cleanups, because problems that cannot be solved without weak references are rare ... it should be used when it offers a real advantage, not just out of laziness ... i think that is why it is false by default ... hope that helps ... ;) greetz back2dos
