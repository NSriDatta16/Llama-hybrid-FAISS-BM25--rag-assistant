[site]: stackoverflow
[post_id]: 3494178
[parent_id]: 
[tags]: 
Fatal error from incrementing loop

Currently, I'm trying to make a function that sorts a vector full of fighters in the function sortFighters in the Fighter.cpp file. It all seems to compile correctly; However, when it does run, I get a fatal error in one of the lines of the aformentioned .cpp file. I know exactly what the problem is, and put a comment there accordingly. So, what I'm asking here, is what I might do to fix this problem without adding any other functions and such. Here's my Fighter.h file: #ifndef FIGHTER_H #define FIGHTER_H #include #include #include #include #include #include class Fighter { protected: std::string name; int health, level; //int damage; public: int getHealth(int); void getEnemies(std::vector &); void printFighter(std::vector &); void sortFighters(std::vector &); //friend std::istream & operator >> (std::istream & strm, Fighter & x); //friend std::ostream & operator My Fighter.cpp file: //dynamically locate an array that holds the number of fighters, and for each fighter in the array, assign from the .txt //file the name and level from the fighter. #include "Fighter.h" #pragma region getEnemies void Fighter::getEnemies(std::vector &baddie) { Fighter x; std::ifstream inputFile; inputFile.open("EnemyFighters.txt"); if(!inputFile) { std::cout > line; if (line == " ") { do { inputFile >> line; x.name = line; inputFile >> line; x.level = atoi(line.c_str()); inputFile >> line; x.health = getHealth(this->level); baddie.push_back(x); inputFile >> line; }while(line != " "); } } inputFile.close(); } } #pragma endregion #pragma region getHealth int Fighter::getHealth(int lv) { if(lv >= 6) { std::cout health = lv * 2; } /*else if (lv > 1) for (int i = 1; i health += 2;}*/ return health; } #pragma endregion #pragma region attack //void Fighter::attack() //{ // int randomAttack = rand() % 4 + 1; // // switch (randomAttack) // case 1: // { // std::cout &baddie) { //std::cout &x) { Fighter * temp = new Fighter; bool swap; do { swap = false; std::cout x[i+1].level)//I get a fatal error here when it tries to compare //the iterator with 1 that's outside its range { //assign the stats from the first to temp temp->name = x[i].name; temp->health = x[i].health; temp->level = x[i].level; //assign the stats from the next to the first x[i].name = x[i+1].name; x[i].health = x[i+1].health; x[i].level = x[i+1].level; //assign the ones in temp(the first) to the next x[i+1].name = temp->name; x[i+1].health = temp->health; x[i+1].level = temp->level; swap = true; } else if(x[i].level >= x[i+1].level) { temp->name = x[i].name; temp->health = x[i].health; temp->level = x[i].level; x[i].name = x[i+1].name; x[i].health = x[i+1].health; x[i].level = x[i+1].level; x[i+1].name = temp->name; x[i+1].health = temp->health; x[i+1].level = temp->level; swap = true; } else if (x[i].level name = x[i].name; //temp->health = x[i].health; //temp->level = x[i].level; //x[i].name = x[i+1].name; //x[i].health = x[i+1].health; //x[i].level = x[i+1].level; //x[i+1].name = temp->name; //x[i+1].health = temp->health; //x[i+1].level = temp->level; swap = false; } else if(x[i].level name = x[i].name; temp->health = x[i].health; temp->level = x[i].level; x[i].name = x[i+1].name; x[i].health = x[i+1].health; x[i].level = x[i+1].level; x[i+1].name = temp->name; x[i+1].health = temp->health; x[i+1].level = temp->level;*/ swap = false; } } }while (swap); delete temp; } //std::istream & operator >>(std::istream & strm, Fighter x) //{ // //x.name += strm.c_str(); // //x.level += atoi(strm.c_str()); // strm >> x.name; // strm >> x.level; // return strm; //} //std::ostream & operator () //{ //} // //void operator =() //{ //} // // // int Player::getHealth(int lv) { if(lv >= 6) { std::cout health = lv * 2; } /*else if (lv > 1) for (int i = 1; i health += 2;}*/ return health; } void Player::printFighter() { //std::cout level health experience = (level * 10)) { std::cout And here's main.cpp: #include "Fighter.h" int main() { unsigned seed = time(0); srand(seed); std::vector baddie; Fighter * enemy = new Fighter; Player * me = new Player; enemy->getEnemies(baddie); enemy->sortFighters(baddie); enemy->printFighter(baddie); me->printFighter(); delete enemy; delete me; return 0; }
