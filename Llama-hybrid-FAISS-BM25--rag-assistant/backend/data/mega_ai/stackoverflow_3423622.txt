[site]: stackoverflow
[post_id]: 3423622
[parent_id]: 3420622
[tags]: 
I get the feeling that you are thinking that variables can be only instance or static, and forgetting that local variables are different to either. Consider: public class MyClass { public int InstanceInt; public static int StaticInt; public int InstanceMethod() { int i = new Random().Next(1, 50); return i; } public static int StaticMethod() { int j = new Random().Next(1, 50); return j; } } Here InstanceInt is an instance variable, and StaticInt a static variable. Both of these require locking if they are going to be accessed by different threads, however, InstanceInt is only going to be accessed by different threads if an instance of MyClass is accessed by different threads. This could happen with static MyClass AllThreadsSeeMe = new MyClass() , storage in a static collection, explicitly passing it to another thread, or so on, but otherwise will not. StaticInt meanwhile is inherently accessible to all threads running in the application, even if you take care to make sure that no instance of MyClass is shared between threads. Meanwhile, i and j are both local to their functions. Each thread calling the function will be given their own copy of i or j , irregardless to how many threads could call them. Hence they are inherently thread-safe. It is only if either of these methods alter a static or instance variable, or read a mutable static or instance variable that could be altered by a different method, that they are not thread-safe (immutable - readonly - variables are also threadsafe because there's no way another thread can change their value, given that no thread at all can change it).
