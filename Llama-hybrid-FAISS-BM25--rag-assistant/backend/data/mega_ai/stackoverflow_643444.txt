[site]: stackoverflow
[post_id]: 643444
[parent_id]: 643410
[tags]: 
Unit tests can't tell you when a method suddenly has a smaller set of possible results. That's what code coverage is for: It will tell you that code isn't executed anymore. This in turn will lead to the discovery of the dead code in the application layer. [EDIT] Based on a comment: A mock must not do anything but allowing to instantiate the class under test and allow to collect additional information. Especially, it must never influences the result of what you want to test. [EDIT2] Mocking a database means that you don't care whether the DB driver works. What you want to know is whether your code can interpret the data returned by the DB correctly. Also, this is the only way to test whether your error handling works correctly because you can't tell the real DB driver "when you see this SQL, throw this error." This is only possible with a mock. I agree, it takes some time to get used to. Here is what I do: I have tests which check whether the SQL works. Each SQL gets executed once against a static test DB and I verify that the data returned is what I expect. All other tests run with a mock DB connector that returns predefined results. I like to get these results by running the code against the database, logging the primary keys somewhere. I then write a tool which takes these primary keys and dumps Java code with the mock to System.out. This way, I can create new test cases very quickly and the test cases will reflect the "truth". Even better, I can recreate old tests (when the DB changes) by running the old IDs and my tool again
