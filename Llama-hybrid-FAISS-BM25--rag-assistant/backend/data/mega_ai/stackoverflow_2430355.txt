[site]: stackoverflow
[post_id]: 2430355
[parent_id]: 2428725
[tags]: 
It is most likely thread safe, from your description of the framework. There must have been a memory barrier somewhere between calling myobj.startup() and making myobj available to other threads. That guarantees that the writes in startup() will be visible to other threads. Therefore you don't have to worry about thread safety because the framework does it. There is no free lunch though; everytime another thread obtains access to myobj through the framework, it must involve sync or volatile read. If you look into the framework and list the code in the path, you'll see sync/volatile in proper places that make your code thread safe. That is, if the framework is correctly implemented. Let's examine a typical swing example, where a worker threads does some calculation, saves the results in a global variable x , then sends a repaint event. The GUI thread upon receiving the repaint event, reads the results from the global variable x , and repaints accordingly. Neither the worker thread nor the repaint code does any synchronization or volatile read/write on anything. There must be tens of thousands of implementations like this. Luckily they are all thread safe even though the programmers paid no special attention. Why? Because the event queue is synchronized; we have a nice happends-before chain: write x - insert event - read event - read x Therefore write x and read x are properly synchronized, implicitly via event framework.
