[site]: stackoverflow
[post_id]: 3983089
[parent_id]: 3982348
[tags]: 
GMan started this attempt, to code this in combination of an inline function and a macro. This solution supposes that you have modern C compiler that supports C99, since it uses a compound literal : inline void swap_detail(void* p1, void* p2, void* tmp, size_t pSize) { memcpy(tmp, p1, pSize); memcpy(p1, p2, pSize); memcpy(p2 , tmp, pSize); } #define SWAP(a, b) swap_detail(&(a), &(b), (char[(sizeof(a) == sizeof(b)) ? (ptrdiff_t)sizeof(a) : -1]){0}, sizeof(a)) This has the following properties: It evaluates each of a and b only once. It has a compile time check for the correct sizes. It has no naming issue with a hidden variable. The size of the temporary variable is computed at compile time, so the compound literal is not a dynamic array. The cast (ptrdiff_t) is needed such that the -1 is not silently promoted to SIZE_MAX . This solution still suffers from two drawbacks: It is not type safe. It only checks for the sizes of the types, not their semantics. If the types differ, say a double of size 8 and a uint64_t , you are in trouble. The expressions must allow the & operator to be applicable. Thus it will not work on variables that are declared with the register storage class.
