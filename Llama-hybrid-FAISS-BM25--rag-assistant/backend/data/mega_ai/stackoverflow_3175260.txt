[site]: stackoverflow
[post_id]: 3175260
[parent_id]: 3169051
[tags]: 
Common LISP, 670 characters I'm a LISP newbie, and this is an attempt using an hash table for counting (so probably not the most compact method). (flet((r()(let((x(read-char t nil)))(and x(char-downcase x)))))(do((c( make-hash-table :test 'equal))(w NIL)(x(r)(r))y)((not x)(maphash(lambda (k v)(if(not(find k '("""the""and""of""to""a""i""it""in""or""is"):test 'equal))(push(cons k v)y)))c)(setf y(sort y #'> :key #'cdr))(setf y (subseq y 0(min(length y)22)))(let((f(apply #'min(mapcar(lambda(x)(/(- 76.0(length(car x)))(cdr x)))y))))(flet((o(n)(dotimes(i(floor(* n f))) (write-char #\_))))(write-char #\Space)(o(cdar y))(write-char #\Newline) (dolist(x y)(write-char #\|)(o(cdr x))(format t "| ~a~%"(car x)))))) (cond((char can be run on for example with cat alice.txt | clisp -C golf.lisp . In readable form is (flet ((r () (let ((x (read-char t nil))) (and x (char-downcase x))))) (do ((c (make-hash-table :test 'equal)) ; the word count map w y ; current word and final word list (x (r) (r))) ; iteration over all chars ((not x) ; make a list with (word . count) pairs removing stopwords (maphash (lambda (k v) (if (not (find k '("" "the" "and" "of" "to" "a" "i" "it" "in" "or" "is") :test 'equal)) (push (cons k v) y))) c) ; sort and truncate the list (setf y (sort y #'> :key #'cdr)) (setf y (subseq y 0 (min (length y) 22))) ; find the scaling factor (let ((f (apply #'min (mapcar (lambda (x) (/ (- 76.0 (length (car x))) (cdr x))) y)))) ; output (flet ((outx (n) (dotimes (i (floor (* n f))) (write-char #\_)))) (write-char #\Space) (outx (cdar y)) (write-char #\Newline) (dolist (x y) (write-char #\|) (outx (cdr x)) (format t "| ~a~%" (car x)))))) ; add alphabetic to current word, and bump word counter ; on non-alphabetic (cond ((char
