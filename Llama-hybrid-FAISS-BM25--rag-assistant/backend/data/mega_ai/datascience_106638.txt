[site]: datascience
[post_id]: 106638
[parent_id]: 106626
[tags]: 
This can be solved by simply changing the method that is called within transform to the transform method of the vectorizer. In addition you would also have to add a call to fit within the fit method to make sure that the vectorizer is actually fitted before being used to transform any data: class Vectorizer(BaseEstimator, TransformerMixin): def __init__(self, vectorizer:Callable=CountVectorizer(), ngram_range:tuple=(1,1)) -> None: super().__init__() self.vectorizer = vectorizer self.ngram_range = ngram_range def fit(self, X, y=None): print(f">>> Vectorizer.fit() called with vectorizer={self.vectorizer} and ngram_range={self.ngram_range}.") self.vectorizer.fit(X) return self def transform(self, X, y=None): print(f">>> Vectorizer.transform() called with vectorizer={self.vectorizer} and ngram_range={self.ngram_range}.") X_ = X.copy() X_vect_ = self.vectorizer.transform(X_) X_vect_ = X_vect_.toarray() return X_vect_
