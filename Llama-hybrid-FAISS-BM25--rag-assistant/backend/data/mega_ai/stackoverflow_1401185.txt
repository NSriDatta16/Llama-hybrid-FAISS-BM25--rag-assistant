[site]: stackoverflow
[post_id]: 1401185
[parent_id]: 1401081
[tags]: 
Based on your code-example, it seems you're only detouring your own process. Therefore detouring DrawText doesn't output anything. Perhaps, you need to inject your code to desired target's process memory and detour the API call from there. For example, you can create system wide CBT hook which works kind of a.. launch point to your detouring needs. Something like this, to point you out a direction: LRESULT CALLBACK CBTProcedure(int nCode, WPARAM wParam, LPARAM lParam) { if (nCode IsRegisteredWindow(hWnd)) if (g_pClient->RegisterWindow(hWnd)) { } break; case HCBT_DESTROYWND: if (g_pClient->IsRegisteredWindow(hWnd)) g_pClient->UnregisterWindow(hWnd); break; } return 0; } bool __0XYOUROWN_API InstallHook() { // Call this one from your main process; set's up the system-wide hook. g_hHook = SetWindowsHookEx(WH_CBT, (HOOKPROC)CBTProcedure, g_hInstance, 0); /** #pragma data_seg("Shared") * HHOOK g_hHook = NULL; * #pragma data_seg() */ return g_hHook != NULL; } /** The actual DLL... * * */ BOOL APIENTRY DllMain(HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: g_hInstance = (HINSTANCE)hModule; if (::GetModuleHandle(_T("THEDESIREDMODULE.EXE")) != NULL) { g_pClient = new Client(); if (g_pClient) { InitializeCriticalSection(&g_CriticalSection); // You can setup a critic. sec. for later synchronization... DetourTransactionBegin(); DetourUpdateThread(GetCurrentThread()); DetourAttach(&(PVOID&)Real_DrawTextW, Mine_DrawTextW); DetourTransactionCommit(); } } break; case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: if (::GetModuleHandle(_T("THEDESIREDMODULE.EXE")) != NULL) { if (g_pClient) { DetourTransactionBegin(); DetourUpdateThread(GetCurrentThread()); DetourDetach(&(PVOID&)Real_DrawTextW, Mine_DrawTextW); DetourTransactionCommit(); delete g_pClient; g_pClient = NULL; } } break; } }
