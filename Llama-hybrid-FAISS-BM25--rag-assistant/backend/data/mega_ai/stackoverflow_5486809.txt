[site]: stackoverflow
[post_id]: 5486809
[parent_id]: 5485659
[tags]: 
I would probably go for a binding approach, code behind is ugly. Create a property with an error enum and create a DataTemplate or Style in which you bind the background to said property. Edit: Example... In your class: public enum ParsingStatus { None, Completed, XmlError, HtmlError } private ParsingStatus _status = ParsingStatus.None; public ParsingStatus Status { get { return _status; } set { if (_status != value) { _status = value; NotifyPropertyChanged("Status"); } } } Then you can either bind to the background property using a converter like this: public class ErrorToBrushConverter : IValueConverter { public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture) { Employee.ParsingStatus input = (Employee.ParsingStatus)value; switch (input) { case Employee.ParsingStatus.None: return null; case Employee.ParsingStatus.Completed: return Brushes.LightGreen; case Employee.ParsingStatus.XmlError: return Brushes.Pink; case Employee.ParsingStatus.HtmlError: return Brushes.Yellow; default: return null; } } public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture) { throw new NotSupportedException(); } } And the respective XAML: ... ... ... Or you only specify a Style and do the switch on the status using triggers: ( Using triggers was suggested by Robert Rossney, as you can see it is quite short and requires no code behind at all, i cannot really think of any downsides to this and i have no idea why i did not do it like this in the first place... ) Which looks like this with the converter (the yellow of the trigger-method is more suitable):
