[site]: stackoverflow
[post_id]: 3122798
[parent_id]: 3122772
[tags]: 
Looks like a typical many-to-many relationship -- I don't see any restrictions on what you desire that would allow space savings wrt the typical relational DB idiom for those, i.e., a table with two columns (both foreign keys, one into users and one into tweets)... since the current followers can and do change all the time, posting a tweet to all the followers that are current at the instant of posting (I assume that's what you mean?) does mean adding that many (extremely short) rows to that relationship table (the alternative of keeping a timestamped history of follower sets so you can reconstruct who was a follower at any given tweet-posting time appears definitely worse in time and not substantially better in space). If, on the other hand, you want to check followers at the time of viewing (rather than at the time of posting), then you could make a special userid artificially meaning "all followers of the current user" (just like you'll have one meaning "all users on Twitter"); the needed SQL to make the lookup fast, in that case, looks hairy but feasible (a UNION or OR with "all tweets for which I'm a follower of the author and the tweet is readable by [the artificial userid representing] all followers"). I'm not getting deep into that maze of SQL until and unless you confirm that it is this peculiar meaning that you have in mind (rather than the simple one which seems more natural to me but doesn't allow any space savings on the relationship table for the action of "post tweet to all followers"). Edit : the OP has clarified they mean the approach I mention in the second paragraph. Then, assume userid is the primary key of the Users table, the Tweets table has a primary key tweetid and a foreign key author for the userid of each tweet's author, the Followers table is a typical many-to-many relationship table with the two columns (both foreign keys into Users ) follower and followee , and the Canread table a not-so-typical many-to-many relationship table, still with two column -- foreign key into Users is column reader , foreign key into Tweets is column tweet (phew;-). Two special users @everybody and @allfollowers are defined with the above meanings (so that posting to everybody, all followers, or "just myself", all add only one row to Canread -- only selective posting to a specific list of N people adds N rows). So the SQL for the set of tweet IDs a user @me can read is, I think, something like: SELECT Tweets.tweetid FROM Tweets JOIN Canread ON(Tweets.tweetid=Canread.tweet) WHERE Canread.reader IN (@me, @everybody) UNION SELECT Tweets.tweetid FROM Tweets JOIN Canread ON(Tweets.tweetid=Canread.tweet) JOIN Followers ON(Tweets.author=Followers.followee) WHERE Canread.reader=@allfollowers AND Followers.follower=@me
