[site]: stackoverflow
[post_id]: 4850555
[parent_id]: 
[tags]: 
iostreams slow. Is there a way to speed them up?

I've been hacking at a problem on and off for several days now that lists filenames that exceed the Windows MAX_PATH limit. I'm using Visual Studio 2008 with all the patches I can find. The timing is done with QueryPerformanceCounter and company. The latest issue occurs in the following code: start = getTime(); for( vector ::iterator it = files.begin(); it != files.end(); ++it ) { #if USE_COUT wcout length() length(), x.c_str() ); // 2 #endif } stop = getTime(); The above loop runs over a vector with 6755 entries with an average string length of 256 characters. The code that prints via wcout takes roughly 52 seconds to display the vector using the loop above. The code that uses wprintf prints in about 1.2 seconds. If I minimize the console window the printf code runs in about 500 milliseconds while the wcout code still takes about 40 seconds. I've really tried to like iostreams over the years, but... I keep butting my head on this speed issue. In 1993/1994 when using the Borland OS/2 compiler, we had a similar issue with a runtime that took 4 to 6 hours to complete using an strstream that ran in about 200 milliseconds with sprintf. Any suggestions to get me to change my mind about iostreams? Edit: All this talk of flushing has me curious. Isn't \n in a printf string functionally the same as std::endl in the sense that both cause a newline and flush to be emitted to the output? IIRC, printf without a \n does not print on some OS's until a buffer is filled or the stream is flushed, including Windows in the past. So, if wprintf( "%6.6d: %s\n", length, string ) is flushed by the \n , why isn't wprintf as slow as wcout ? Thanks for your feedback/opinions. I wish I had had SO 18 years ago when I started hacking at this stuff.
