[site]: stackoverflow
[post_id]: 1328635
[parent_id]: 1328238
[tags]: 
All C++ objects, including pointers to member functions, are represented in memory as an array of chars. So you could try: bool (Class::*fn_ptr)() = &Class::whatever; const char *ptrptr = static_cast (static_cast (&fn_ptr)); Now treat ptrptr as pointing to an array of (sizeof(bool (Class::*)())) bytes, and hash or compare those bytes. You can use unsigned char instead of char if you prefer. This guarantees no false positives - in C++03, pointers to member functions are POD, which means among other things that they can be copied using memcpy. This implies that if have the same byte-for-byte values, then they are the same. The problem is that the storage representation of member function pointers could include bits which do not participate in the value - so they will not necessarily be the same for different pointers to the same member function. Or the compiler might, for some obscure reason, have more than one way of pointing to the same function of the same class, which are not byte-wise equal. Either way you can get false negatives. You'll have to look into how member function pointers actually work on your implementation. It must implement operator== for member function pointers somehow, and if you can find out how then you can probably figure out an order and a hash function. That's potentially hard: member function pointers are awkward, and the storage is likely to include different amounts of non-participating "slack space" according to what kind of function is pointed to (virtual, inherited). So you'll probably have to interact quite significantly with your compiler's implementation details. This article might help get you started: http://www.codeproject.com/KB/cpp/FastDelegate.aspx A cleaner alternative might be to do a linear search through an array in order to "canonicalise" all your function pointers, then compare and hash based on the position of the "canonical" instance of that function pointer in your array. Depends what your performance requirements are. And even if there are requirements, does the class (and its derived classes) have so many functions that the linear search will take that long? typedef bool (Class::*func)(); vector canon; size_t getIndexOf(func fn_ptr) { vector ::iterator it = find(canon.begin(), canon.end(), fn_ptr); if (it != canon.end()) return it - canon.begin(); canon.push_back(func); return canon.size() - 1; }
