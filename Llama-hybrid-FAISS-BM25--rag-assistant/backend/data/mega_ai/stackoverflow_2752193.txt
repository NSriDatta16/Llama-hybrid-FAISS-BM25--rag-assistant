[site]: stackoverflow
[post_id]: 2752193
[parent_id]: 2752084
[tags]: 
Another difference between these two form is the time when storage for those objects are allocated. The form BTree bTree; names static allocation whose allocation accomplishes at compile time -- i.e. the compiler will arrange memory space for this object in memory when running. While, the allocation for BTree *pbTree = new BTree , the alleged dynamic allocation -- performs at runtime -- i.e. the momory will be allocated only when the running program reach this point. In this situation, the difference between static and dynamic allocation is not apparent. Consider the following circumstance where you need to allocate memory space for an integer array, but number of elements can be determined only at runtime, i.e. we can only know the exact memory space consumed by the array after the program begin to execute. // in this function, we want to return a copy of the parameter array int *array_cpy( int *arr, int num ){ int *copy = new int[ num ]; int i; for( i = 0; i Here the definition int copy[ num ]; is not appropriate, one reason is for what I have stated above, the other is the lifetime of copy outlive the function. However, given VLA is permitted in recent language specification, the second reason is key to this problem.
