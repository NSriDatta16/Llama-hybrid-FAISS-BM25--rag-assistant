[site]: stackoverflow
[post_id]: 3050382
[parent_id]: 3045004
[tags]: 
I don't believe there is any way in a FlowDocument to make a LineBreak not really break except to take it out. Your choices are to switch to using WPF layout or to use an attached property to switch between a LineBreak and an empty Run. Using WPF layout You may consider using WPF layout instead. Something like this: Now you can easily switch between layouts just by switching DataTemplates. Automatically removing LineBreaks using bindings If you want to "hide" the LineBreak via a binding you can do it with an attached "BecomeLineBreak" property that, when applied to an empty Run and set true, removes it and replaces it with a LineBreak. Like magic you now have the ability to write: And your Run will turn into a LineBreak any time the SomeCondition property is true. Here is the code: public class LineBreakSwitcher : DependencyObject { public static bool GetBecomeLineBreak(DependencyObject obj) { return (bool)obj.GetValue(BecomeLineBreakProperty); } public static void SetBecomeLineBreak(DependencyObject obj, bool value) { obj.SetValue(BecomeLineBreakProperty, value); } public static readonly DependencyProperty BecomeLineBreakProperty = DependencyProperty.RegisterAttached("BecomeLineBreak", typeof(bool), typeof(LineBreakSwitcher), new PropertyMetadata { PropertyChangedCallback = (obj, e) => { var oldElement = (Inline)obj; var newElement = (bool)e.NewValue ? (Inline)new LineBreak() : new Run(); newElement.SetBinding(BecomeLineBreakProperty, oldElement.GetBindingExpression(BecomeLineBreakProperty).ParentBindingBase); var parent = (Paragraph)oldElement.Parent; parent.Inlines.InsertBefore(oldElement, newElement); parent.Inlines.Remove(oldElement); } }); How it works: When BecomeLineBreak becomes true on a Run, a new LineBreak is created, the BecomeLineBreak binding is copied across, the LineBreak is inserted before the Run, then the Run is removed. When BecomeLineBreak become false, a new Run is created and the whole process happens in reverse.
