[site]: stackoverflow
[post_id]: 1952879
[parent_id]: 1952818
[tags]: 
You don't mention the server-side code you're using. I had some issues with jQuery AJAX calls in IE when using ASP.NET on the server side (a ashx handler). They went away when I read the request fully before starting to write the response (even though in my case I was using POST, not GET request, so the body of the request contained some data). I wrote the following simple ASP.NET project to test your issue in IE6. However I'm unable to reproduce (IE6 SP2 running in virtual machine hitting IIS 7.5 shows the alert box from success handler properly). Could you try running it in your environment and reporting whether it works from IE6 for you? Note : Sometimes when I cleared IE6 cache and commented out the "SetCacheability" line in ashx.cs, the first click on "Send" button would not show the success alert box, although subsequent clicks did show it. Maybe all you need is adding "no-cache" headers to the call response in your implementation? file index.html AJAX GET test $("#test").click(function () { $.ajax({ url: "Api.ashx?param=one", cache: true, type: "GET", dataType: "json", success: function (data) { alert("Success, result = " + data.result); }, error: function (request, status, err) { alert("Error"); } }); }); file Api.ashx file Api.ashx.cs using System.Diagnostics; using System.Text; using System.Web; namespace AjaxTest { public class Api : IHttpHandler { public bool IsReusable { get { return true; } } public void ProcessRequest(HttpContext context) { var param = context.Request["param"]; // this flushes the request Trace.WriteLine("Request: \"" + context.Request.RawUrl + "\", param: \"" + param + "\"", "** Debug"); context.Response.StatusCode = 200; context.Response.ContentType = "application/json"; context.Response.ContentEncoding = Encoding.UTF8; context.Response.Cache.SetCacheability(HttpCacheability.NoCache); context.Response.Write("{\"result\":\"" + param + "\"}"); } } }
