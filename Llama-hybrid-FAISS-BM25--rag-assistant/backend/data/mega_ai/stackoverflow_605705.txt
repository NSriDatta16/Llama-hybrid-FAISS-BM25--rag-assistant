[site]: stackoverflow
[post_id]: 605705
[parent_id]: 
[tags]: 
Odd SQL 2000 query performance problem

In some SQL query performance tuning, I noticed that the following query was running slowly but it wasn't thrashing the CPU and there appeared to be no other system bottlenecks to cause it to run slowly. In fact the CPU average was 15% whilst it ran: UPDATE: The query in question runs in a cursor loop which contains 800 records: cursor = SELCT DISTINCT param1,param2, param3, param4 FROM t_Table GROUP BY param1,param2, param3, param4 ORDER BY param1,param2, param3, param4 DESC cursor loop: SELECT @maxval1 = max(iField1), @maxval2 = max(iField2), @dtDateMin = Min(dtDate), @dtDateMax = Max(dtDate) FROM t_Table WHERE iSomeField1 = @param1 AND iSomeField2 = @param2 AND iSomeField3 = @param3 AND iSomeField4 = @param4 next (Note: there are indices setup for iSomeField1-4) I then broke out the individual min/max parts into four queries to see how the server responded and got full throughput with the CPU peaking at 100% and the block ran in 2 seconds as opposed to > 5mins for the above. Whilst I am indeed happy with the performance increases, I would like some clever DBA to explain why this is and what other tips they would could give on these types of queries? SELECT TOP 1 @maxval1 = iField1 FROM t_Table WHERE iSomeField1 = @param1 AND iSomeField2 = @param2 AND iSomeField3 = @param3 AND iSomeField4 = @param4 ORDER BY field1 DESC SELECT TOP 1 @maxval2 = iField2 FROM t_Table WHERE iSomeField1 = @param1 AND iSomeField2 = @param2 AND iSomeField3 = @param3 AND iSomeField4 = @param4 ORDER BY field2 DESC SELECT TOP 1 @dtDateMin = dtDate FROM t_Table WHERE iSomeField1 = @param1 AND iSomeField2 = @param2 AND iSomeField3 = @param3 AND iSomeField4 = @param4 ORDER BY dtDate ASC SELECT TOP 1 @dtDateMax = dtDate FROM t_Table WHERE iSomeField1 = @param1 AND iSomeField2 = @param2 AND iSomeField3 = @param3 AND iSomeField4 = @param4 ORDER BY dtDate DESC Please note I'm a developer and not a DBA but would like to understand alittle more about how SQL Server works behind the scene on queries like the above. To add to some of the answers below, I am aware and did use the query execution planner to analyse the performance issue and what puzzles me is that despite indexes on the table, why the first query performs badly on the SQL server. UPDATE: Screenshots of CPU usage of query 1 against query 2+ run in a cursor loop: CPU usage for query 1 and query 2 http://img22.imageshack.us/img22/3262/sqlperfodd.png Query 1 EP http://img513.imageshack.us/img513/5681/query1.png Query 2 EP http://img365.imageshack.us/img365/9715/query2.png The schema is shown below (this is a cut down version of our real table but the structure and indexs are what we use). CREATE TABLE [dbo].[t_Table] ( [ID] [int] IDENTITY (1, 1) NOT NULL , [dtDate] [datetime] NULL , [iField1] [int] NULL ,[iField2] [int] NULL , [iSomeField1] [int] NULL ,[iSomeField2] [int] NULL , [iSomeField3] [int] NULL ,[iSomeField4] [int] NULL) ON [PRIMARY] CREATE CLUSTERED INDEX [IX_dtDate] ON [dbo].[t_Table]([dtDate], [iField1], [iSomeField1]) WITH FILLFACTOR = 90 ON [PRIMARY] ALTER TABLE [dbo].[t_Table] ADD CONSTRAINT [PK_t_Table] PRIMARY KEY NONCLUSTERED ([ID]) ON [PRIMARY] CREATE INDEX [idx_field1234] ON [dbo].[t_Table]([iSomeField1], [iSomeField2], [iSomeField3], [iSomeField4]) ON [PRIMARY] CREATE INDEX [idx_field1] ON [dbo].[t_Table]([iSomeField1]) [PRIMARY]
