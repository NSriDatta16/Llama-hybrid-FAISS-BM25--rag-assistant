[site]: stackoverflow
[post_id]: 5479013
[parent_id]: 
[tags]: 
Optimizating my code simulating a database (2)

Some days ago I made you a question and I got some really useful answers. I will make a summary to those of you who didn't read and I will explain my new doubts and where I have problems now. Explanation I have been working on a program, simulating a small database, that first of all read information from txt files and store them in the computer memory and then, I can make queries taking normal tables and/or transposed tables. The problem is that the performance is not good enough yet. It works slower than what I expect. I have improved it but I think I should improve it more. I have specific points where my program doesn't have a good performance. Current problem The first problem that I have now (where my program is slower) is that I spend more time to, for example table with 100,000 columns & 100 rows (0.325 min, I've improved this thanks to your help) than 100,000 rows & 100 columns (1.61198 min, the same than before). But on the other hand, access time to some data is better in the second case (in a determined example, 47 seconds vs. 6079 seconds in the first case) any idea why?? Explanation Now let me remind you how my code works (with an atached summary of my code) First of all I have a .txt file simulating a database table with random strings separated with "|". Here you have an example of table (with 7 rows and 5 columns). I also have the transposed table NormalTable.txt 42sKuG^uM|24465\lHXP|2996fQo\kN|293cvByiV|14772cjZ`SN| 28704HxDYjzC|6869xXj\nIe|27530EymcTU|9041ByZM]I|24371fZKbNk| 24085cLKeIW|16945TuuU\Nc|16542M[Uz\|13978qMdbyF|6271ait^h| 13291_rBZS|4032aFqa|13967r^\\`T|27754k]dOTdh|24947]v_uzg| 1656nn_FQf|4042OAegZq|24022nIGz|4735Syi]\|18128klBfynQ| 6618t\SjC|20601S\EEp|11009FqZN|20486rYVPR|7449SqGC| 14799yNvcl|23623MTetGw|6192n]YU\Qe|20329QzNZO_|23845byiP| TransposedTable.txt (This is new from the previous post) 42sKuG^uM|28704HxDYjzC|24085cLKeIW|13291_rBZS|1656nn_FQf|6618t\SjC|14799yNvcl| 24465\lHXP|6869xXj\nIe|16945TuuU\Nc|4032aFqa|4042OAegZq|20601S\EEp|23623MTetGw| 2996fQo\kN|27530EymcTU|16542M[Uz\|13967r^\\`T|24022nIGz|11009FqZN|6192n]YU\Qe| 293cvByiV|9041ByZM]I|13978qMdbyF|27754k]dOTdh|4735Syi]\|20486rYVPR|20329QzNZO_| 14772cjZ`SN|24371fZKbNk|6271ait^h|24947]v_uzg|18128klBfynQ|7449SqGC|23845byiP| Explanation This information in a .txt file is read by my program and stored in the computer memory. Then, when making queries, I will access to this information stored in the computer memory. Loading the data in the computer memory can be a slow process, but accessing to the data later will be faster, what really matters me. Here you have the part of the code that read this information from a file and store in the computer. Code that reads data from the Table.txt file and store it in the computer memory int h; do { cout >h; }while(h!=1 && h!=2); string ruta_base("C:\\Users\\Raul Velez\\Desktop\\Tables\\"); if(h==1) { ruta_base +="NormalTable.txt"; // Folder where my "Table.txt" is found } if(h==2) { ruta_base +="TransposedTable.txt"; } string temp; // Variable where every row from the Table.txt file will be firstly stored vector buffer; // Variable where every different row will be stored after separating the different elements by tokens. vector RowsCols; // Variable with a class that I have created, that simulated a vector and every vector element is a row of my table ifstream ifs(ruta_base.c_str()); while(getline( ifs, temp )) // We will read and store line per line until the end of the ".txt" file. { size_t tokenPosition = temp.find("|"); // When we find the simbol "|" we will identify different element. So we separate the string temp into tokens that will be stored in vector buffer // --- NEW PART ------------------------------------ const char* p = temp.c_str(); char* p1 = strdup(p); char* pch = strtok(p1, "|"); while(pch) { buffer.push_back(string(pch)); pch = strtok(NULL,"|"); } free(p1); ElementSet sss(0,buffer); buffer.clear(); RowsCols.push_back(sss); // We store all the elements of every row (stores as vector buffer) in a different position in "RowsCols" // --- NEW PART END ------------------------------------ } Table TablesStorage(RowsCols); // After every loop we will store the information about every .txt file in the vector TablesDescriptor vector TablesDescriptor; TablesDescriptor.push_back(TablesStorage); // In the vector TablesDescriptor will be stores all the different tables with all its information DataBase database(1, TablesDescriptor); Information already given in the previous post After this, comes the access to the information part. Let's suppose that I want to make a query, and I ask for input. Let's say that my query is row "n", and also the consecutive tuples "numTuples", and the columns "y". (We must say that the number of columns is defined by a decimal number "y", that will be transformed into binary and will show us the columns to be queried, for example, if I ask for columns 54 (00110110 in binary) I will ask for columns 2, 3, 5 and 6). Then I access to the computer memory to the required information and store it in a vector shownVector. Here I show you the part of this code. Problem In the loop if(h == 2) where data from the transposed tables are accessed, performance is poorer Â¿why? Code that access to the required information upon my input int n, numTuples; unsigned long long int y; cout >n; // We get the row to be represented -> "n" cout >numTuples; // We get the number of followed tuples to be queried-> "numTuples" cout >y; // We get the "columns" to be represented ' "y" unsigned int r; // Auxiliar variable for the columns path int t=0; // Auxiliar variable for the tuples path int idTable; vector columnsToBeQueried; // Here we will store the columns to be queried get from the bitset binarynumber, after comparing with a mask vector shownVector; // Vector to store the final information from the query bitset mask; mask=0x1; clock_t t1, t2; t1=clock(); // Start of the query time bitset binaryNumber = Utilities().getDecToBin(y); // We get the columns -> change number from decimal to binary. Max number of columns: 5000 // We see which columns will be queried for(r=0;r Class definitions Here I attached some of the class definitions so that you can compile the code, and understand better how it works: class ElementSet { private: int id; vector elements; public: ElementSet(); ElementSet(int, vector &); const int& getId(); void setId(int); const vector & getElements(); void setElements(vector ); }; class Table { private: vector RowsCols; public: Table(); Table(vector &); const vector & getRowsCols(); void setRowsCols(vector ); }; class DataBase { private: int id; vector pointer; public: DataBase(); DataBase(int, vector &); const int& getId(); void setId(int); const vector & getPointer(); void setPointer(vector ); }; class Utilities { public: Utilities(); static bitset getDecToBin(unsigned long long int); }; Summary of my problems Why the load of the data is different depending on the table format??? Why the access to the information also depends on the table (and the performance is in the opposite way than the table data load? Thank you very much for all your help!!! :)
