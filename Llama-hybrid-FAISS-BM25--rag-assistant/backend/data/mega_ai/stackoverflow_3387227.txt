[site]: stackoverflow
[post_id]: 3387227
[parent_id]: 3387021
[tags]: 
It's not 100% portable for the following reasons: Edit: You'd best use int a[1]; and then a+1 becomes definitively valid. &a invokes undefined behaviour on objects of register storage class. In case of alignment restrictions that are larger or equal than the size of int type, size_of_int will not contain the correct answer. Disclaimer: I am uncertain if the above hold for C++.
