[site]: stackoverflow
[post_id]: 565440
[parent_id]: 565262
[tags]: 
It would be better if the disposable object returned from cb.Function(name) was the object on which the statements should be added. That internally this function builder passed through the calls to private/internal functions on the CodeBuilder is fine, just that to public consumers the sequence is clear. So long as the Dispose implementation would make the following code cause a runtime error. CodeBuilder cb = new CodeBuilder(); var f = cb.Function("foo") using(function) { // Generate some function code f.Add(someStatement); } function.Add(something); // this should throw Then the behaviour is intuitive and relatively reasonable and correct usage (below) encourages and prevents this happening CodeBuilder cb = new CodeBuilder(); using(var function = cb.Function("foo")) { // Generate some function code function.Add(someStatement); } I have to ask why you are using your own classes rather than the provided CodeDomProvider implementations though. (There are good reasons for this, notably that the current implementation lacks many of the c# 3.0 features) but since you don't mention it yourself... Edit: I would second Anoton's suggest to use lamdas. The readability is much improved (and you have the option of allowing Expression Trees
