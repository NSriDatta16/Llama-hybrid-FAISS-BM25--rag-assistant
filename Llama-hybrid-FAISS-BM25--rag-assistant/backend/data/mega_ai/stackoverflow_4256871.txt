[site]: stackoverflow
[post_id]: 4256871
[parent_id]: 4195492
[tags]: 
Common functionality is a call for a new class, not necessarily common ancestor. The question formulation is missing responsibility statement for it. Needless to say, it's a single responsibility that we create a new class for. I take further decisions basing on class responsibility. I prefer a hybrid of robbbert 's and Jared 's answers: I construct extra classes, passing them necessary controller internals as parameters. Sometimes the classes develop from method objects . Like: def action = { def doer = SomeResponsibilityDoer(this.request, this.response) render doer.action() } Not so brief, but lets you get code under tests and keep coupling low. As SomeResponsibilityDoer is only going to have couple of fields - request an response - it's not a big deal constructing it with every request. It's also not a big deal having SomeResponsibilityDoer not reloaded on controller change in dev, because: Initially, you can declare it in some of Controller files - it will be reloaded. After you complete it, hopefully it won't change often, so move it to src/groovy . Even more important, it's faster and better for design to develop under unit tests than under application running and reloading a Contoller.
