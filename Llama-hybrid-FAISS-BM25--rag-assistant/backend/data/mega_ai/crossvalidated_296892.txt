[site]: crossvalidated
[post_id]: 296892
[parent_id]: 296873
[tags]: 
What about computing standard deviations on spatially-lagged values ? Assuming that your space is $1$-dimensional, and that coordinates, $c_i$, are those charted, i.e. $i$ ranging from $1$ to $25$. A first thing one can do is computing the $25\times 25$ distance matrix, $\boldsymbol{D}$, whose closed form expression is $\boldsymbol{D} = [d_{ij}] = [|c_i - c_j|]$ where $\{(i,j)|i \in [1,25]$ and $j \in [1,25]\}$ With $\boldsymbol{D}$ in hand, one creates a (so-called) spatial weight matrix, commonly denoted by $\boldsymbol{W}$, defined as $\boldsymbol{W} = [w_{ij}] =\begin{cases} [d_{ij}^{-1}] & \text{if $i\neq j$}, \\ 0 & \text{otherwise} \end{cases}$ And one then makes it be right stochastic matrix (real square matrix with each row summing to $1$), i.e. $\boldsymbol{W}^{*} = [w_{ij}/\sum_{k=1}^{25}w_{ik}]$ Actually, what one is going to do is working with spatially lagged vectors instead of the original ones, i.e. working with transformed versions of a , b and c instead of working with those directly. Those transformed vectors will be formed over components that consist of neighbors (distance weighted) average. The variance of these averages will be low for spatially-clustered heights. In R you would do > x = seq(1,25) > x > x [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Then, since the space is a line, one would compute the second dimension, y , (required by the package I have in mind), as $0$s, as follows > y = rep(0, each=25) > y [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 One loads the library distances > library(distances) creates the distance matrix as > D one takes its elementwise inverse > Di one replaces (in place) Di 's diagonal Inf elements with $0$ > diag(Di) defines W as the right stochastic version of Di > W sum(W) [1] 25 One can now get your 3 hypothetical transects > a b c one spatially lags these three vectors > Wa Wb Wc recalling that your sample standard deviations of a , b and c respectively are > sd(a) [1] 2.01825 > sd(b) [1] 3.569314 > sd(c) [1] 3.569314 notice that those of Wa , Wb and Wc are > sd(Wa) [1] 0.3961341 > sd(Wb) [1] 0.4542065 > sd(Wc) [1] 0.866519 which provides you with a way to differentiate between the variability in transects b and c . In this case, the std of Wc is higher than the one of Wb . As mentioned previously, when one does, say, Wc , with W being row-stochastic, one creates a vector whose components consist of neighbors (distance weighted) average. Since heights are less spatially clustered in c , these distance weighted averages exhibit a higher variance that those in b . Finally, so as to create a synthetic indicator of the two types of variance, i.e. the spatial and the non-spatial ones, you could summarize them in one object by computing an euclidean norm . > ( sd(Wa)^2 + sd(a)^2 )^.5 [1] 2.056758 > ( sd(Wb)^2 + sd(b)^2 )^.5 [1] 3.598097 > ( sd(Wc)^2 + sd(c)^2 )^.5 [1] 3.67299 You probably already know that, but recall that norms, be them euclidean or not, are often used to measure how "1-dimension big" are multidimensional objects. In our case, the first dimension is the one of non-spatial variance, and the second dimension is the one of spatial-variance .
