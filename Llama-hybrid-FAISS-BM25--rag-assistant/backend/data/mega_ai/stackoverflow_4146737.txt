[site]: stackoverflow
[post_id]: 4146737
[parent_id]: 4145873
[tags]: 
This problem can be solved in Python easily and elegantly, because there is a module called "itertools". Lets say we have objects of type HypotheticalBranch, which have attributes r, p and c. Just as you described it in your post: class HypotheticalBranch(object): def __init__(self, r, p, c): self.r=r self.p=p self.c=c def __repr__(self): return "HypotheticalBranch(%d,%d,%d)" % (self.r,self.p,self.c) Your set of hypothetical branches is thus b=[ HypotheticalBranch(0,0,0), HypotheticalBranch(0,1,1), HypotheticalBranch(1,2,1), HypotheticalBranch(1,3,2), HypotheticalBranch(1,4,2) ] The magical function that returns a list of all possible branch combos could be written like so: import collections, itertools def get_combos(branches): rc=collections.defaultdict(list) for b in branches: rc[b.r,b.c].append(b) return itertools.product(*rc.values()) To be precise, this function returns an iterator. Get the list by iterating over it. These four lines of code will print out all possible combos: for combo in get_combos(b): print "Combo:" for branch in combo: print " %r" % (branch,) The output of this programme is: Combo: HypotheticalBranch(0,1,1) HypotheticalBranch(1,3,2) HypotheticalBranch(0,0,0) HypotheticalBranch(1,2,1) Combo: HypotheticalBranch(0,1,1) HypotheticalBranch(1,4,2) HypotheticalBranch(0,0,0) HypotheticalBranch(1,2,1) ...which is just what you wanted. So what does the script do? It creates a list of all hypothetical branches for each combination (root node, child node). And then it yields the product of these lists, i.e. all possible combinations of one item from each of the lists. I hope I got what you actually wanted.
