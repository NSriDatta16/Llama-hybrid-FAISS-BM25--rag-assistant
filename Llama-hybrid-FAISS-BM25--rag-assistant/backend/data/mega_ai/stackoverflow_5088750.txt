[site]: stackoverflow
[post_id]: 5088750
[parent_id]: 5078726
[tags]: 
I've thought of what I think is a cleaner solution for implementing a pure read-only attribute, if that's all you want. It's a variant of the solution tangentstorm gave, but dispenses with the need for a __getattr__ method altogether. class Foo(object): def __init__(self): self.readonly = set() def set_readonly(self, attr, value): setattr(self, attr, value) self.readonly.add(attr) def __setattr__(self, attr, value): if hasattr(self, "readonly") and attr in self.readonly: raise AttributeError("Read only attribute: %s" % (attr,)) object.__setattr__(self, attr, value) It works like this: >>> f = Foo() >>> f.x = 5 >>> f.set_readonly("y", 9) >>> f.x, f.y (5, 9) >>> f.x = 7 >>> f.y = 1 Traceback (most recent call last): File " ", line 1, in File "ro.py", line 13, in __setattr__ raise AttributeError("Read only attribute: %s" % (name,)) AttributeError: Read only attribute: y Making a read-only attribute read-write again is easy: def unset_readonly(self, attr): self.readonly.remove(attr) In my first attempt at writing this idea I used self.__readonly instead of self.readonly , but that leads to a problem with actually setting the __readonly attribute, since I'd need to do un-munge the "private" attribute to check for its presence ( hasattr(self, "_Foo__readonly") ), and this is discouraged.
