[site]: stackoverflow
[post_id]: 1527304
[parent_id]: 1527063
[tags]: 
There are two ways to do transactions with the Entity Framework, depending upon the depth of transactional support you need. The "right" way to do it is with a TransactionScope instance. The Entity Framework supports this. The downside of this method is that you are now in a distributed transaction, which has security implications for the connection between your machine and your database server. The "lite" way to do it is with the SaveOptions argument to SaveChanges. This allows you to keep change tracking information around after the call to SaveChanges, and "accept" the changes (save to the DB and dispose change tracking information) later. Regarding your speculation in the last paragraph of the question: In EF 1, change tracking information was typically stored in the ObjectContext. In EF 4, you will have the option to use so-called "self-tracking" entities or proxies, which behave more in the manner you are expecting. But the default, I think, will still be to behave like EF 1. If you look at the generated C# code for your EDMX file, you will see how the property change notification works.
