[site]: stackoverflow
[post_id]: 1735475
[parent_id]: 1734695
[tags]: 
I don't see anything inelegant about the -performSelector:withObject:afterDelay: method that you highlight. This method simply enqueues a task to be performed after the completion of the current cycle of the run loop. From the documentation in the section you linked to : Performs the specified selector on the current thread during the next run loop cycle and after an optional delay period. Because it waits until the next run loop cycle to perform the selector, these methods provide an automatic mini delay from the currently executing code. Multiple queued selectors are performed one after another in the order they were queued. An NSTimer object is not created to manage this, the selector is simply enqueued to be run after a certain delay (a small delay means immediately after the completion of the run loop cycle). For actions that you wish to happen after updates to the UI take place, this is the simplest technique. For more explicit, threaded queueing, you could look at NSOperations and NSOperationQueues . An NSOperationQueue with a maxConcurrentOperationCount of 1 can run operations in order, one after the other.
