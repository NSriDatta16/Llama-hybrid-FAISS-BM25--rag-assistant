[site]: stackoverflow
[post_id]: 3607504
[parent_id]: 
[tags]: 
Servlets A Servlet is a Java application programming interface (API) running on the server machine which can intercept requests made by the client and can generate/send a response accordingly. A well-known example is the HttpServlet which provides methods to hook on HTTP requests using the popular HTTP methods such as GET and POST . You can configure HttpServlet s to listen on a certain HTTP URL pattern, which is configurable in web.xml , or more recently with Java EE 6 , with @WebServlet annotation. Many Java EE web frameworks are built on top of servlets, such as JSF, JAX-RS, Spring MVC, Struts, Wicket, etcetera. See also What is the difference between JSF, Servlet and JSP? Lifecycle When a Servlet is requested for the first time or when the web app starts up, the servlet container will create an instance of it and keep it in memory during the web app's lifetime. The same instance will be reused for every incoming request whose URL matches the servlet's URL pattern. You can access the requested data by HttpServletRequest and handle the response by HttpServletResponse . Both objects are available as method arguments inside of any of the overridden methods of HttpServlet , such as doGet() to preprocess a request and doPost() to post-process a request. See also How do servlets work? Instantiation, sessions, shared variables and multithreading . Installation In order to run Servlets, you need: JDK (JRE is only sufficient if the server has its own compiler). A servlet container. Optionally, a Java EE aware IDE (Integrated Development Editor). There are several servlet containers. Apache Tomcat Eclipse Jetty JBoss Undertow There are also Java EE application servers which in turn also contain a servlet container besides other Java EE APIs such as JSF, JPA, EJB, etc. See also What exactly is Java EE? JBoss WildFly Apache TomEE IBM WebSphere Liberty Payara Eclipse GlassFish Installing a servlet container is generally just a matter of downloading the zip/gz file and extracting it at the location of your choice. Generally, you'd also like to use an IDE such as Eclipse , IntelliJ or Netbeans so you don't need to manually compile and build the source files with javac over and over. Decent IDEs have plugins to seamlessly integrate the servlet container and import the necessary Java EE APIs into the build path of the project. See also How do I import the javax.servlet API in my Eclipse project? Hello World #1 (post-process a request) Post-processing a request such as submitting and validating a POST form is the most commonly known use case for a servlet. The action attribute of an HTML can point to a servlet URL and the method="post" would trigger the servlet's doPost() method where you have all the freedom to control the HTTP request and response. Assuming that there's a JSP in /WEB-INF/hello.jsp which looks like this... Servlet Hello World .error { color: red; } .success { color: green; } Hello What's your name? ${messages.name} What's your age? ${messages.age} ${messages.success} (the fn:escapeXml() is to protect your page against XSS while redisplaying user-controlled input; if JSTL doesn't work in general, then probably your servlet container doesn't support it out of the box (like Tomcat); you can install it by just dropping jstl-1.2.jar in /WEB-INF/lib , see also JSTL info page ) ...here's how the com.example.controller.HelloServlet class should look: package com.example.controller; import java.io.IOException; import java.util.HashMap; import java.util.Map; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; @WebServlet("/hello") public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // Preprocess request: we actually don't need to do any business stuff, so just display JSP. request.getRequestDispatcher("/WEB-INF/hello.jsp").forward(request, response); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // Postprocess request: gather and validate submitted data and display the result in the same JSP. // Prepare messages. Map messages = new HashMap (); request.setAttribute("messages", messages); // Get and validate name. String name = request.getParameter("name"); if (name == null || name.trim().isEmpty()) { messages.put("name", "Please enter name"); } else if (!name.matches("\\p{Alnum}+")) { messages.put("name", "Please enter alphanumeric characters only"); } // Get and validate age. String age = request.getParameter("age"); if (age == null || age.trim().isEmpty()) { messages.put("age", "Please enter age"); } else if (!age.matches("\\d+")) { messages.put("age", "Please enter digits only"); } // No validation errors? Do the business job! if (messages.isEmpty()) { messages.put("success", String.format("Hello, your name is %s and your age is %s!", name, age)); } request.getRequestDispatcher("/WEB-INF/hello.jsp").forward(request, response); } } Compile the code and put it in the /WEB-INF/classes folder. In this particular case, the class file should end up in /WEB-INF/classes/com/example/controller/HelloServlet.class . An IDE like Eclipse, Netbeans or IntelliJ will do it all automatically when you've created a dynamic web project. Note that the @WebServlet annotation only works on Java EE 6 / Servlet 3.0 capable containers (Tomcat 7, Glassfish 3, JBoss AS 6, etc) and if a /WEB-INF/web.xml file is present, then its root declaration should comply Servlet 3.0 version as well. If you're using/targeting an older Servlet version, such as Servlet 2.5, then you should remove the annotation and map the servlet in /WEB-INF/web.xml file as follows, which does effectively the same thing: helloServlet com.example.controller.HelloServlet helloServlet /hello Either way, it basically tells to the servlet container that it should do the following under the covers: HelloServlet helloServlet = new HelloServlet(); // Construct servlet. helloServlet.init(servletConfig); // Initialize servlet with config. helloServlet.init(); // Initialize servlet without config. servlets.put("/hello", helloServlet); // Add to servlet mapping. Deploy the webapp and go to http://localhost:8080/contextname/hello (without .jsp extension!) to open the Hello World page. When you're opening the page like this, by entering URL in address bar or following a link or bookmark, then an HTTP GET request will be fired and the servlet's doGet() method will be called. When a form with method="post" is been submitted on the URL of the servlet, then an HTTP POST request will be fired and the servlet's doPost() method will be called. Note that the JSP is been placed in /WEB-INF folder to prevent direct access to the JSP when a user enters its URL in the browser address bar. This is mandatory when it is required to invoke the servlet's doGet() method before the JSP is been displayed, for example when some data has to be preloaded. Hello World #2 (preprocess a request) Preprocessing a request such as preloading a list which is to be presented immediately on a "plain vanilla" GET request (which is used when you follow a link/bookmark or enter the URL in browser address yourself) is a less commonly known use case for a servlet. While it's used widely in the real world as well, the average basic Servlet tutorial found on the Internet does not explain this at all. However, it is pretty easy: you just have to implement the business job in the doGet() method instead of in doPost() . Here's a basic kickoff example where we're getting a list of products from the database so that it can be presented immediately when the end user opens the product page of a webshop. Only the ProductService class in the below example is another custom class and not described in this wiki since it's beyond the scope, but its list() method should be straightforward enough. The below example assumes it to be an EJB, but it can be anything, see also for example this post . package com.example.controller; import java.io.IOException; import java.util.List; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import com.example.business.ProductService; import com.example.model.Product; @WebServlet("/products") public class ProductServlet extends HttpServlet { @EJB private ProductService productService; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // Preprocess request: load list of products for display in JSP. List products = productService.list(); request.setAttribute("products", products); request.getRequestDispatcher("/WEB-INF/products.jsp").forward(request, response); } } Here's how the /WEB-INF/products.jsp should look: Our Products Products ID Name Description Price ${product.id} (the is to protect your page against XSS while redisplaying user-controlled input, it does effectively the same thing as fn:escapeXml() ) Deploy the webapp and go to http://localhost:8080/contextname/products (without the .jsp extension!). It'll call the doGet() method of the servlet which loads the products from the DB, stores it in the request scope and forwards the request/response to present the results. To get a step further, you could filter the products based on a request parameter which is obtained from a GET search form as follows: or a hyperlink (or bookmark) as follows: Search for products with keyword "java" with String query = request.getParameter("query"); List products = productService.find(query); // ... This is also how search engines like Google work! Coding style and recommendations Do NOT call a doGet() method from a doPost() method or the other way around, or have them both call some other common method like processRequest() . This is wrong. Each of those two HTTP methods has its own clear responsibility: preprocessing or post-processing an HTTP request. If you intend to hook on all HTTP methods, you should be overriding the service() method. See also the Front Controller Pattern . Do NOT output HTML in a servlet by using out.print() statements. It only makes it harder to maintain. HTML code belongs in JSP where you have the freedom to write HTML the way you want without fiddling with Java methods and quoted strings. From the other side on, do NOT use scriptlets (embedded raw Java code) inside JSP files. It only makes it harder to maintain. Java code belongs in Java classes where you have the freedom to write Java the way you want without fiddling with ugly things. See also How can I avoid Java code in JSP files, using JSP 2? Do NOT use if you're already using a servlet to process the model. It will only lead to confusion and maintenance trouble because the follows a different level of MVC approach than when you're using servlets. It's either servlets or , not both. Specifications Jakarta EE 9: Jakarta Servlet 5.0 Specification Jakarta EE 8: Jakarta Servlet 4.0 Specification Java EE 8: Java Servlet 4.0 Specification (JSR 369) Java EE 7: Java Servlet 3.1 Specification (JSR 340) Java EE 6: Java Servlet 3.0 Specification (JSR 315) Java EE 5: Java Servlet 2.5 Specification (JSR 154) Online Resources and tutorials The official Java EE Documentation Wikipedia: Java Servlets ZEEF: Servlets Eclipse Jakarta EE tutorials Jakarta EE 8 tutorial - Servlets (Servlet 4.0) Oracle Java EE tutorials Java EE 8 tutorial - Servlets (Servlet 4.0) Java EE 7 tutorial - Servlets (Servlet 3.1) Java EE 6 tutorial - Servlets (Servlet 3.0) Java EE 5 tutorial - Servlets (Servlet 2.5) Coreservlets.com tutorials Setup Eclipse and Tomcat 7 (Servlet 3.0) Setup Eclipse and Tomcat 6 (Servlet 2.5) Beginning & Intermediate Servlet & JSP tutorials Advanced Servlet and JSP tutorials Core Servlets and JavaServer Pages eBook Frequently Asked Questions Check the " frequent " tab of servlets tag Related tags jsp jsf servlet-filters
