[site]: stackoverflow
[post_id]: 5091622
[parent_id]: 5091345
[tags]: 
The $processes[$in-1].Start() will not work. You need to capture the processinfo you are killing and start the same app again. You can get the process binary and commandline information using Win32_Process WMI class. For example, Clear-host $processes = Get-Process notepad $processes.Count if($processes.Count -gt 1) { $i = 0 Write-host "There are multiple processes for notepad." foreach($process in $processes) { $i++ $i.ToString() + '. ' + $process.MainWindowTitle } $in = Read-host "Give a number of the process to kill: " write-host write-host "killing and restarting: " + $processes[$in-1].MainWindowTitle #Get the process details $procID = $processes[$in-1].Id $cmdline = (Get-WMIObject Win32_Process -Filter "Handle=$procID").CommandLine $processes[$in-1].Kill() $processes[$in-1].WaitForExit() } In the above example, I am using WMI to get the commandline information for a process selected. If that were a notepad process with some open text file, the commandline for that process would look like "C:\WINDOWS\system32\NOTEPAD.EXE" C:\Users\ravikanth_chaganti\Desktop\debug.log Now, all you need to do is: Invoke that commandline somehow (this part is not there in example I wrote). A very blunt way to do that is: Start-Process -FilePath $cmdline.Split(' ')[0] -ArgumentList $cmdline.Split(' ')[1] But, in your case, there may not be any argument list. Hope this gives you an idea. Other PowerShell experts may have a different & efficient approach. This is just a quick hack.
