[site]: stackoverflow
[post_id]: 3458183
[parent_id]: 3457967
[tags]: 
Very interesting! Other things I can think of it might be useful to check for: do function pointers and data pointers exist in the same address space? (Breaks in Harvard architecture machines like DOS small mode. Don't know how you'd test for it, though.) if you take a NULL data pointer and cast it to the appropriate integer type, does it have the numeric value 0? (Breaks on some really ancient machines --- see http://c-faq.com/null/machexamp.html .) Ditto with function pointer. Also, they may be different values. does incrementing a pointer past the end of its corresponding storage object, and then back again, cause sensible results? (I don't know of any machines this actually breaks on, but I believe the C spec does not allow you to even think about pointers that don't point to either (a) the contents of an array or (b) the element immediately after the array or (c) NULL. See http://c-faq.com/aryptr/non0based.html .) does comparing two pointers to different storage objects with produce consistent results? (I can imagine this breaking on exotic segment-based machines; the spec forbids such comparisons, so the compiler would be entitled to compare the offset part of the pointer only, and not the segment part.) Hmm. I'll try and think of some more. Edit: Added some clarifying links to the excellent C FAQ.
