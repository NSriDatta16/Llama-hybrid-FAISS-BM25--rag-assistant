[site]: stackoverflow
[post_id]: 1573824
[parent_id]: 
[tags]: 
How do you build a Single Page Interface in ASP.NET MVC?

I want to build a webapplication with a "Single Page Interface", using ASP.NET MVC. I have searched if this was at least possible and I think the answer is: not by simple means (reading http://msdn.microsoft.com/en-us/magazine/cc507641.aspx#S2 second-last paragraph; that article is from May 2008, though). I found other examples which implemented this by coding/hacking with jQuery. However, I'm looking for a clean solution, using standard .NET approaches, if possible. What I want is precisely the same functionality when you create a new "MVC Web Application". However, instead of links to "/Home/About" which reloads the entire page, I want links to " # Home/About" which loads only the new part via AJAX. The standard approach of calling templates (partial views) with Html.RenderPartial is exactly what I want, only then loading them in through AJAX-requests. Of course, it might be that I can't use these templates that are rendered by the Master-page for some reason (maybe it's expecting to always be called in a certain context from a certain place or so). But maybe there's another clean solution for how to build your template-pages and fetching them from the Master-page. Who has a nice solution for implementing such thing, a Single Page Interface? PS: I'm developing in Visual Web Developer 2008 Express Edition with MVC 1.0 installed, in C# [edit] Below I read that working with the templates is possible and that jQuery looks indeed like inevitable, so I tested it. The following code transforms regular links created by Html.ActionLink into anchor-links (with #) to contain history, and then fetch the page via AJAX and only injecting the html-part I'm interested in (i.e. the partial page inside div#partialView): $("a").each(function() { $(this).click(function() { $("div#partialView").load($(this).attr("href") + " div#partialView"); location.hash = $(this).attr("href"); return false; }); }); These links also allow for graceful degredation. But what I have left now, is still fetching the whole page instead of only the partial page. Altering the controller didn't help; it still provided me html of the whole page, with all of these statements: public ActionResult About() { return View(); return View("About"); return PartialView(); return PartialView("About"); } How could I only return the content of the part I'm interested in (i.e. the contents of Home/About.aspx)? What I'd like is POSTing a value with AJAX (e.g. "requesttype=ajax") so that my controller knows the page is fetched via AJAX and only returns the partial page; otherwise it will return the whole page (i.e. when you visit /Home/About instead of #Home/About). Is a good practice to alter Global.asax.cs maybe, to create a new routing schema for AJAX-calls, which will only return partial pages? (I haven't looked into this much, yet.) [edit2] Robert Koritnik was right: I also needed an About.ascx page (UserControl) with only the small HTML-content of that page. The first line of About.aspx was linked with the Master-page via MasterPageFile="~/..../Site.master" which caused that all HTML was printed. But to be able to execute the following in my controller: public ActionResult About() { return Request.IsAjaxRequest() ? (ActionResult)PartialView() : View(); } I needed to alter the way a PartialView (.ascx file) and a View (.aspx) file was found, otherwise both methods would return the same page ( About.aspx , ultimately resulting in an infinite loop). After putting the following in Global.asax.cs , the correct pages will be returned with PartialView() and View() : protected void Application_Start() { foreach (WebFormViewEngine engine in ViewEngines.Engines.Where(c => c is WebFormViewEngine)) { /* Normal search order: new string[] { "~/Views/{1}/{0}.aspx", "~/Views/{1}/{0}.ascx", "~/Views/Shared/{0}.aspx" "~/Views/Shared/{0}.ascx" }; */ // PartialViews match with .ascx files engine.PartialViewLocationFormats = new string[] { "~/Views/{1}/{0}.ascx", "~/Views/Shared/{0}.ascx" }; // Views match with .aspx files engine.ViewLocationFormats = new string[] { "~/Views/{1}/{0}.aspx", "~/Views/Shared/{0}.aspx" }; } RegisterRoutes(RouteTable.Routes); }
