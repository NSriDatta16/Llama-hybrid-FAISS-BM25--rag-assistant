[site]: stackoverflow
[post_id]: 4871886
[parent_id]: 4867965
[tags]: 
Regarding Google's style: There is no ambiguity, at all. The first header included should be the header related to this source file, thus in position 1. This way you make sure that it includes anything it needs and that there is no "hidden" dependency: if there is, it'll be exposed right away and prevent compilation. The other headers are ordered from those you are the least likely to be able to change if an issue occurs to those you are the more likely to. An issue could be either an identifier clash, a macro leaking, etc... By definition the C and C++ systems headers are very rarely altered, simply because there's so many people using them, thus they come second. 3rd party code can be changed, but it's generally cumbersome and takes time, thus they come third. The "project includes" refer to project-wide includes, generally home-brawn libraries (middle-ware) that are used by several projects. They can be changed, but this would impact the other projects as well, they come fourth. And finally the "local includes", that is those files who are specific to this project and can be changed without affecting anyone else. In case of issue, those are prime candidates, they come last. Note that you can in fact have many more layers (especially in a software shop), the key idea is to order the dependencies starting from the bottom layer (system libs) to the top layer. Within a given layer, I tend to organize them by alphabetical order, because it's easier to check them.
