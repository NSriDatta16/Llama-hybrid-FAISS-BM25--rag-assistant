[site]: stackoverflow
[post_id]: 1786634
[parent_id]: 1734926
[tags]: 
The following .pbk should pretty much do it. You can take a look at the comments to see how you would deepen the blur effect. kernel NewFilter { input image4 src1; input image4 src2; output pixel4 dst; void evaluatePixel() { float2 pos = outCoord(); // based on the current whiteness of pixel in src2 blur by a percentage. float4 val = sampleNearest(src2,pos); float percent = val[0]; // this takes into account only the closest level of pixels to make the blur more in depth // you can add the next 16 or even the 24 after that. float4 pix = sampleNearest(src1,pos); float4 pixNE = sampleNearest(src1,float2(pos.x+1.0, pos.y+1.0)); float4 pixE = sampleNearest(src1,float2(pos.x+1.0, pos.y)); float4 pixSE = sampleNearest(src1,float2(pos.x+1.0, pos.y-1.0)); float4 pixS = sampleNearest(src1,float2(pos.x, pos.y-1.0)); float4 pixSW = sampleNearest(src1,float2(pos.x-1.0, pos.y-1.0)); float4 pixW = sampleNearest(src1,float2(pos.x-1.0, pos.y)); float4 pixNW = sampleNearest(src1,float2(pos.x-1.0, pos.y+1.0)); float4 pixN = sampleNearest(src1,float2(pos.x, pos.y+1.0)); float4 result; // the result is the whiteness percentage of the original pixel averaged with the surrounding pixels. // if you added more of the surrounding pixels you can consider them in the weighted average also and get a deeper blur. result[0] = percent*pix[0]+(1.0-percent)*(pixNE[0]+pixE[0]+pixSE[0]+pixS[0]+pixSW[0]+pixW[0]+pixNW[0]+pixN[0])/8.0; result[1] = percent*pix[1]+(1.0-percent)*(pixNE[1]+pixE[1]+pixSE[1]+pixS[1]+pixSW[1]+pixW[1]+pixNW[1]+pixN[1])/8.0; result[2] = percent*pix[2]+(1.0-percent)*(pixNE[2]+pixE[2]+pixSE[2]+pixS[2]+pixSW[2]+pixW[2]+pixNW[2]+pixN[2])/8.0; result[3] = pix[3]; dst = result; } }
