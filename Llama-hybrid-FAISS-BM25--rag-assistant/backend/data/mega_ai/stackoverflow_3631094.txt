[site]: stackoverflow
[post_id]: 3631094
[parent_id]: 3630976
[tags]: 
The linux /proc filesystem is actually kernel variables pretending to be a filesystem. There is nothing to save thus nothing to backup. If the system let you, you could rm -rf /proc and it would magically reappear upon the next reboot. The /dev file system has real i-nodes and they can be backed up. Except they have no contents, just a major and minor number, permissions, and a name. Tools that do backup special device files only record those parameters and never try to open(2) the device. However, since the device major and minor numbers are only meaningful on the precise system they are built for, there is little cause for backing them up. The reason that trying to tar the /proc pseudo-filesystem causes tar to segfault is because /proc has funny file behavior: things like a write-only pseudo-file may appear to have read permissions, but return an error indication if a program tries to open(2) it for backup. That's sure to drive a na√Øve tar to get persnickety. Added in response to comment It doesn't surprise me that tar had problems reading /proc/kmsg because it has some funny properties: # strace cat /proc/kmsg execve("/bin/cat", ["cat", "kmsg"], open("kmsg", O_RDONLY|O_LARGEFILE) = 3 // ok, no problem opening the file for reading fstat64(3, { st_mode=S_IFREG|0400, st_size=0, // looks like a normal file of zero length // but cat does not pay attention to st_size so it just // does a blocking read read(3, " [103128.156051] ata2.00: qc t"..., 32768) = 461 write(1, " [103128.156051] ata2.00: qc t"..., 461) = 461 // ...forever... read(3, " [103158.228444] ata2.00: conf"..., 32768) = 48 write(1, " [103158.228444] ata2.00: conf"..., 48) = 48 +++ killed by SIGINT +++ Since /proc/kmsg is a running list of kernel messages as they happen, it never returns 0 (EOF) it just keeps going until I get bored and press ^C. Interestingly, my tar has no trouble with /proc/kmsg: $ tar --version tar (GNU tar) 1.22 # tar cf /tmp/junk.tar /proc/kmsg $ tar tvf /tmp/junk.tar -r-------- root/root 0 2010-09-01 14:41 proc/kmsg and if you look at the strace output, GNU tar 1.22 saw that st_length == 0 and didn't even bother opening the file for reading, since there wasn't anything there. I can imagine that your tar saw the length was 0, allocated that much (none) space using malloc(3) which dutifully handed back a pointer to a zero length buffer. Your tar read from /proc/kmsg, got a non-zero length read, and tried to store it in the zero length buffer and got a segmentation violation. That is but one rat-hole that awaits tar in /proc. How many more are there? Dunno. Will they behave identically? Probably not. Which of the ~1000 or so files which aren't /proc/ psuedo-files are going to have weird semantics? Dunno. But perhaps the most telling question: What sense would you make of /proc/sys/vm/lowmem_reserve_ratio, will it be different next week, and will you be able to learn anything from that difference?
