[site]: stackoverflow
[post_id]: 4792081
[parent_id]: 4791695
[tags]: 
I tend to agree with Marc; but there's a couple of other things you might consider: What constitutes as "Business Logic" vs "Data Access" code vs simple data structures which you app "knows" about? At first glance DataImportFieldMappingInfo looks like it might be Data Access related but I think they are actually just common structures (and are more business orientated) so putting them in a common assembly would make sense - assuming you use them to exchange data between different layers / assembilies. The other view to take is that all data repositories (which includes databases specific to your application as well as all external data sources like external databases, files or systems) are treated equally and accessed through an interface - not through a single concrete implementation. In this case all data is specified in a Business Logic / Domain centered way and not a Data Access / Repository specific way. In this case you'd also define all the common data structures used by your app in a common assembly. Edit: In short, interfaces allow you to abstract out complexity and dependencies associated with nasty stuff which you'd rather not be closely (and permanently) associated with. The principle behind using interfaces is Dependency Inversion (DI). (There's no shortage of information about this - in fact you might find there's too much). DI goes along way to helping build systems that play nice with the Stable Dependencies Principle . The idea is that rather than having your Business Logic (assembly/s) depend on the Data Access, you have them both depend on the interface; you can then swap out implementations anytime you want. You might have a "real" Data Access component that works against SQL and a "dummy" one that returns dummy test data straight from your code. When you design the interface the idea is to design it from a Business Logic / Domain perspective - not a technical one; although there are cases where that's appropriate. The job of the implementation (i.e: the Data Access class that implements the interface) is to translate between the Business orientated interface and whatever strange data source it's dealing with. For example, your average SQL based data provider might suck out data via a DataReader and convert in into a MyBusiness.Common.Info.OutstandingAccountsCollection . Code Structure Common Assembly (MyBusiness.Common) - contains any data structures that are used to exchange data between your layers (e.g: the MyBusiness.Common.Info.OutstandingAccount and MyBusiness.Common.Info.OutstandingAccountCollection classes). Interface Assemblies: you might have several of these. If all your data access is via the one system (say SQL) then you'd probably have just the one (MyBusiness.Interfaces.DataAccessProvider), but if you have various system to interface with you'd want to keep them seperate. MyBusiness.Interfaces.DataAccessProvider references the Common assembly because it will include the 'info' types in it's contracts. Concrete Data Access assembly(s): (MyBusiness.DataAccess.SQLDataAccessProvider). this references the Common and Interface assemblies. Your Business Logic (MyBusiness.BusinessLogic) references the Common and Interface assemblies. For more info (and diagrams) check out this piece (self promotion alert): 5-Layer Architecture
