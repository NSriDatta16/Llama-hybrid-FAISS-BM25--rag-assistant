[site]: stackoverflow
[post_id]: 582932
[parent_id]: 582919
[tags]: 
inline does two things: gives you an exemption from the "one definition rule" (see below). This always applies. Gives the compiler a hint to avoid a function call. The compiler is free to ignore this. #1 Can be very useful (e.g. put definition in header if short) even if #2 is disabled. In practice compilers often do a better job of working out what to inline themselves (especially if profile guided optimisation is available). [EDIT: Full References and relevant text] The two points above both follow from the ISO/ANSI standard (ISO/IEC 9899:1999(E), commonly known as "C99"). In §6.9 "External Definition", paragraph 5: An external definition is an external declaration that is also a definition of a function (other than an inline definition) or an object. If an identifier declared with external linkage is used in an expression (other than as part of the operand of a sizeof operator whose result is an integer constant), somewhere in the entire program there shall be exactly one external definition for the identifier; otherwise, there shall be no more than one. While the equalivalent definition in C++ is explictly named the One Definition Rule (ODR) it serves the same purpose. Externals (i.e. not "static", and thus local to a single Translation Unit -- typically a single source file) can only be defined once only unless it is a function and inline. In §6.7.4, "Function Specifiers", the inline keyword is defined: Making a function an inline function suggests that calls to the function be as fast as possible. [118] The extent to which such suggestions are effective is implementation-defined. And footnote (non-normative), but provides clarification: By using, for example, an alternative to the usual function call mechanism, such as ‘‘inline substitution’’. Inline substitution is not textual substitution, nor does it create a new function. Therefore, for example, the expansion of a macro used within the body of the function uses the definition it had at the point the function body appears, and not where the function is called; and identifiers refer to the declarations in scope where the body occurs. Likewise, the function has a single address, regardless of the number of inline definitions that occur in addition to the external definition. Summary: what most users of C and C++ expect from inline is not what they get. Its apparent primary purpose, to avoid functional call overhead, is completely optional. But to allow separate compilation, a relaxation of single definition is required. (All emphasis in the quotes from the standard.) EDIT 2: A few notes: There are various restrictions on external inline functions. You cannot have a static variable in the function, and you cannot reference static TU scope objects/functions. Just seen this on VC++'s " whole program optimisation ", which is an example of a compiler doing its own inline thing, rather than the author.
