[site]: stackoverflow
[post_id]: 5162252
[parent_id]: 5162099
[tags]: 
This is untested, but should be close. CREATE TABLE user_actions ( auto_id INT NOT NULL AUTO_INCREMENT, type INT NOT NULL, user_id INT NOT NULL, insert_datetime DATE NOT NULL, action_id INT NOT NULL) PARTITION BY RANGE(TO_DAYS(insert_datetime)) ( PARTITION p0 VALUES LESS THAN (to_days('2011-06-01')), PARTITION p1 VALUES LESS THAN (to_days('2012-01-01')) , PARTITION p11 VALUES LESS THAN MAXVALUE ); You can manage this in the following way: You can have the MAXVALUE partition always represent your "active" (in your case current 6 month period) partition. When the period is up, you can split/reorg that MAXVALUE partition where the period that past goes into a new partition with the MAXVALUE partition representing again the current/active partition. For example, Jan 1st of 2011 you would have one partition, let's call it pM and it would store everything as it would have the LESS THAN MAXVALUE clause. Then after 6 months have passed, you would reorg/split that single partition creating a new partition that holds all the data for the previous 6 months and the MAXVALUE partition again representing the current/active period. -- Untested, but again should be close ALTER TABLE t1 REORGANIZE PARTITION (pM) INTO (PARTITION p20110101 VALUES LESS THAN (to_days('2011-07-01'), PARTITION pM VALUES LESS THAN MAXVALUE); You may also consider sub-partitioning. You could sub-partition your user_id by HASH and therefore further reduce I/O and cost on queries for data based on the user_id. Check out the following links for more information on partitioning. MySQL Partitioning Partition Managment
