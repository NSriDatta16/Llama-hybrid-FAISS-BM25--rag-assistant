[site]: stackoverflow
[post_id]: 2159002
[parent_id]: 
[tags]: 
.NET: Is creating new EventArgs every time the event fires a good practice?

For example, I have a base event publishing method: protected virtual OnSomeEvent(EventArgs e) { var handler = SomeEvent; if (handler != null) { handler(this, e); // handler(this, new EventArgs());// EDIT: Yes it should be // handler(this, e), // ignore this one :D } } For a derived class that overrides OnSomeEvent and raises an additional event when it fires: protected override OnSomeEvent(EventArgs e) { base.OnSomeEvent(e); if (ExtendedEvent != null) { OnExtendedEvent(e); } } protected void OnExtendedEvent(EventArgs e) { // some stuff done // new information the ExtendedEventArgs object needs // is not available until this point ExtendedEvent(this, new ExtendedEventArgs(someStuff, someOtherStuff)); } And if derivation goes on like this, it will create a new derived EventArgs for each generation of derived class that requires it. However it seems various derivations of EventArgs on the .NET framework are not designed to be mutable (no setters), this discourages an object from keeping a single instance of EventArgs and modify it as it goes. So every time an event like this fires, it will re-allocate memory for all involved EventArgs objects. In a graphic intense application where an event can be triggered dozens of times per second (such as OnPaint event on a control), is this really a good practice? Should I make some changes to OnExtendedEvent() and make ExtendedEventArgs mutable so the following is possible? protected ExtendedEventArgs extendedArgs = ExtendedEventArgs.Empty; protected void OnExtendedEvent(EventArgs e) { // some stuff done // new information the ExtendedEventArgs object needs // is not available until this point extendedArgs.someProperty1 = someStuff; extendedArgs.someProperty2 = someOtherStuff; ExtendedEvent(this, extendedArgs); } EDIT: Fixed the example code, should be clearer now.
