[site]: crossvalidated
[post_id]: 135296
[parent_id]: 135262
[tags]: 
I don't know much about signal processing and even less about the problem, but to me it looks like a classification problem. I would try to extract some features from the data, and then apply usual models like logistic regression that would allow to get some statistics and their p-values. Although it's quite hard to do it with just 4 training examples, I'll try. I hope my findings should generalize to more data. First of all, I would extract the direction of the tail and then rotate the image. The simplest way I could think of is to use PCA. For 2-dimensional data PCA will output a 2-dimensional rotation matrix $\begin{bmatrix} \cos \theta & - \sin \theta \\ \sin \theta & \cos \theta \end{bmatrix}$, so once we learn $\theta$ we can rotate the image. Once the data is rotated, since the image is symmetric we can sum $y$ out. We also can subtract the first no-signal image from the rest and then fourier-transform each: We see that amplitudes of 1st and 3rd frequency components may be helpful in distinguishing signal from no signal. Eventually we can use all of them, but since we have only 4 training examples, it should be sufficient. Indeed, it looks quite possible to separate these two classes: Here I don't include the first training example, because it's 0 everywhere and FFT of 0-vector is NaN . So on these features it should be possible to use logistic regression or some other classification model. An IPython notebook with all the code is available here . But if something happens with the link, here's a method that extracts the features: import numpy as np from scipy import ndimage import pandas as pd def extract_features(img, th, base): df = pd.DataFrame(img) stacked = pd.DataFrame(df.stack()) stacked.reset_index(inplace=True) stacked.columns = ('y', 'x', 'v') filtered = stacked[stacked.v >= th] X = filtered[['x', 'y']].values X_cent = X - X.mean(axis=0) _, _, V = np.linalg.svd(X_cent) v = V[0, :] deg = 180 * np.arccos(v[0]) / np.pi if abs(deg) > 1e-6: X_rot = ndimage.rotate(img, deg, reshape=False) else: X_rot = img s = X_rot.sum(axis=0) - base f = np.fft.fft(s) fabs = np.abs(np.fft.fftshift(f)) fabs = fabs / fabs.max() return fabs[[6, 8]] base = X1.sum(axis=0) # X1 is the "no-signal" image f2 = extract_features(X2, 0.25, base) For comments, please refer to the notebook. References: PCA for rotating images http://staff.ustc.edu.cn/~zwp/teach/MVA/pcaimg.pdf
