[site]: stackoverflow
[post_id]: 5690779
[parent_id]: 5688215
[tags]: 
A thread alternative to a timer. Tests a 'carriage return' in the file for a paragraph: const UM_MEMOCHAR = WM_USER + 22; type TForm1 = class(TForm) Memo1: TMemo; Button1: TButton; procedure Button1Click(Sender: TObject); private procedure UMMemoChar(var Msg: TMessage); message UM_MEMOCHAR; public end; var Form1: TForm1; implementation {$R *.dfm} type TCharSender = class(TThread) private FCharWait, FParWait: Integer; FFormHandle: HWND; FFS: TFileStream; protected procedure Execute; override; public constructor Create(FileName: string; CharWait, ParagraphWait: Integer; FormHandle: HWND); destructor Destroy; override; end; constructor TCharSender.Create(FileName: string; CharWait, ParagraphWait: Integer; FormHandle: HWND); begin FCharWait := CharWait; FParWait := ParagraphWait; FFormHandle := FormHandle; FFS := TFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite); FreeOnTerminate := True; inherited Create(False); end; destructor TCharSender.Destroy; begin FFS.Free; inherited; end; procedure TCharSender.Execute; var C: Char; begin while (FFS.Position #10) then PostMessage(FFormHandle, UM_MEMOCHAR, Ord(C), 0); if C = #13 then Sleep(FParWait) else Sleep(FCharWait); end; end; {TForm1} procedure TForm1.Button1Click(Sender: TObject); begin Memo1.Clear; TCharSender.Create( ExtractFilePath(Application.ExeName) + 'text.txt', 20, 1000, Handle); end; procedure TForm1.UMMemoChar(var Msg: TMessage); begin Memo1.SelStart := Memo1.Perform(WM_GETTEXTLENGTH, 0, 0); Memo1.Perform(WM_CHAR, Msg.WParam, 0); end;
