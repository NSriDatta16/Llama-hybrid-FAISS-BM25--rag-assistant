[site]: stackoverflow
[post_id]: 1270141
[parent_id]: 767439
[tags]: 
I like to draw a distinction between "specs" and "tests." If I am covering a method called GetAverage(IEnumerable numbers) , I am going to write a more or less standard unit test. If I am covering a method called CalculateSalesTax(decimal amount, State state, Municipality municipality) , I am still going to write the unit test, but I'll call it a specification because I'm going to change it up (1) to verify the behaviour of the routine, and (2) because the test itself will document both the routine and its acceptance criteria. Consider: [TestFixture] public class When_told_to_calculate_sales_tax_for_a_given_state_and_municipality() // the name defines the context { // set up mocks and expected behaviour StateSalesTaxWebService stateService = the_dependency ; MunicipalSurchargesWebService municipalService = the_dependency ; stateService.Stub(x => x.GetTaxRate(State.Florida)) .Return(0.6); municipalService.Stub(x => x.GetSurchargeRate(Municipality.OrangeCounty)) .Return(0.05); // run what's being tested decimal result = new SalesTaxCalculator().CalculateSalesTax (10m, State.Florida, Municipality.OrangeCounty); // verify the expected behaviour (these are the specifications) [Test] public void should_check_the_state_sales_tax_rate() { stateService.was_told_to(x => x.GetTaxRate(State.Florida)); // extension methods wrap assertions } [Test] public void should_check_the_municipal_surcharge_rate() { municipalService.was_told_to(x => x.GetSurchargeRate(Municipality.OrangeCounty)); } [Test] public void should_return_the_correct_sales_tax_amount() { result.should_be_equal_to(10.65m); } }
