[site]: stackoverflow
[post_id]: 2058599
[parent_id]: 
[tags]: 
JTree rendering with JCheckBox nodes

I am attempting to modify the standard Swing JTree to intermingle nodes with and without checkboxes. This is an example: When I attempt to check/uncheck one of the checkboxes (the 'User 01' node in this example), the tree loses nodes: I my code is an adaptation of this example: http://forums.sun.com/thread.jspa?threadID=5321084&start=13 . Instead of embedding a JCheckBox in a DefaultMutableTreeNode like this: new DefaultMutableTreeNode(new CheckBoxNode("Accessibility", true)); I thought it made more sense to create a model node that derived from the DefaultMutableTreeNode, which I call JTreeNode. This class automatically sets the DefaultMutableTreeNode's UserObject to a JCheckBox. The class' ShowCheckBox property is used by the TreeCellRenderer to determine if the JCheckBox or DefaultTreeCellRenderer is used. The JTreeNode is used like this: JTreeNode user01 = new JTreeNode("User 01"); user01.setShowCheckBox(true); user01.setSelected(true); I believe the problem is with the class that implements the TreeCellEditor, specifically in the getCellEditorValue() or getTreeCellEditorComponent() methods. I suspect the issue has something to with the getCellEditorValue() returning a derivative of the DefaultMutableTreeNode, rather than a simpler model instance. public Object getCellEditorValue() { JCheckBox checkBox = renderer.getCheckBoxRenderer(); JTreeNode node = new JTreeNode(checkBox.getText()); node.setShowCheckBox(true); node.setSelected(checkBox.isSelected()); return node; } public Component getTreeCellEditorComponent(JTree tree, Object value, boolean isSelected, boolean expanded, boolean leaf, int row) { Component editor = renderer.getTreeCellRendererComponent(tree, value, true, expanded, leaf, row, true); // editor always selected / focused ItemListener itemListener = new ItemListener() { public void itemStateChanged(ItemEvent itemEvent) { if (stopCellEditing()) { fireEditingStopped(); } } }; if (editor instanceof JCheckBox) { ((JCheckBox) editor).addItemListener(itemListener); } return editor; } Here is the TreeCellRender's getTreeCellRendererComponent() method: public Component getTreeCellRendererComponent(JTree tree, Object value, boolean selected, boolean expanded, boolean leaf, int row, boolean hasFocus) { Component component; //if object being passed for rendering is a JTreeNode that should show a JCheckBox, attempt to render it so if (((JTreeNode) value).getShowCheckBox()) { String stringValue = tree.convertValueToText(value, selected, expanded, leaf, row, false); //set default JCheckBox rendering checkBoxRenderer.setText(stringValue); checkBoxRenderer.setSelected(false); //not checked checkBoxRenderer.setEnabled(tree.isEnabled()); if (selected) { //removed colorization //checkBoxRenderer.setForeground(selectionForeground); //checkBoxRenderer.setBackground(selectionBackground); } else { checkBoxRenderer.setForeground(textForeground); checkBoxRenderer.setBackground(textBackground); } //DefaultMutableTreeNode if ((value != null) && (value instanceof JTreeNode)) { //userObject should be a JTreeNode instance //DefaultMutableTreeNode //Object userObject = ((JTreeNode) value).getUserObject(); //if it is //if (userObject instanceof JTreeNode) { //cast as a JTreeNode //JTreeNode node = (JTreeNode) userObject; JTreeNode node = (JTreeNode) value; //set JCheckBox settings to match JTreeNode's settings checkBoxRenderer.setText(node.getText()); checkBoxRenderer.setSelected(node.isSelected()); //} } component = checkBoxRenderer; } //if not, render the default else { component = defaultRenderer.getTreeCellRendererComponent(tree, value, selected, expanded, leaf, row, hasFocus); } return component; } Any thoughts are greatly appreciated.
