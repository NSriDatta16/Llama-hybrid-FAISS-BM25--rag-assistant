[site]: stackoverflow
[post_id]: 5644487
[parent_id]: 5644421
[tags]: 
What you're looking for is run-time polymorphism, which means to have the object take "many forms" (i.e. a or b), and act accordingly, as the program runs. In C++, you do this by making the function virtual in the base class a : virtual void print() {cout Then, you need to store the elements by pointer or reference, and - as in general the derived classes can introduce new data members and need more storage - it's normal to create the objects on the heap with new : a* blah[10]; blah[5] = new b(); Then you can call: blah[5]->print(); And it will call the b implementation of print() . You should later delete blah[5] (and any other's you've pointed at memory returned by new ). In practice, it's a good idea to use a container that can delete the objects it contains when it is itself destructed, whether due to leaving scope or being deleted. std::vector<> is one such container. You can also use smart-pointers to automate the deletion of the a and b objects. This helps make the code correct if exceptions are thrown before your delete statements execute, and you want your program to keep running without leaking memory. The boost library is the easiest/best place to get a smart pointer implementation from. Together: #include #include std::vector > blah(10); blah[5] = new b(); (It's more normal to use vectors with push_back() , as it automatically grows the vector to fit in all the elements you've added, with the new total available by calling vector::size() .)
