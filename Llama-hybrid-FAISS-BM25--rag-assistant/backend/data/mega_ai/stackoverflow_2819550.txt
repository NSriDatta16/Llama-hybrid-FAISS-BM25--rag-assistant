[site]: stackoverflow
[post_id]: 2819550
[parent_id]: 2819347
[tags]: 
I'm not very sure Dijkstra's algorithm can be easily adapted to do that; of course is not as simple as removing the visited edges, because the n shortest might share some of them. So an almost brute force, but heuristically oriented solution, is to try this: for every edge E in the shortest path: remove E and run the modified Dijkstra again over the new graph if the shortest path is longer than the first one obtained, stop else, repeat recursively removing one edge at a time from the new sub-graph My intuition tells me that it should work, with an increase in complexity proportional to the length ( n in number of edges) of the first solution... If there are no more shortest path, it should end in the first round, if it founds another, it goes on with n-1 tries. The worst case complexity increase estimation over the original algorithm is very bad ( n! I guess?), but that also means that there are lots of paths, so that is a work that needs to be done with any algorithm... edit: Thinking a little bit more, the complexity increase might be even larger than the factorial of the number of nodes of the first found path, as the second might have even more nodes! So I think it's very difficult to estimate the complexity of this method, but it should be something like the number of valid solutions times the average number of nodes in the paths times the number of nodes squared (this last term being the original complexity of the unmodified algorithm). edit 2: I've found a research paper about this subject, it requires subscription to get the full text but maybe you can find it somewhere else: http://ieeexplore.ieee.org/Xplore/login.jsp?reload=true&url=http%3A%2F%2Fieeexplore.ieee.org%2Fiel5%2F7719%2F21161%2F00982778.pdf%3Farnumber%3D982778&authDecision=-201
