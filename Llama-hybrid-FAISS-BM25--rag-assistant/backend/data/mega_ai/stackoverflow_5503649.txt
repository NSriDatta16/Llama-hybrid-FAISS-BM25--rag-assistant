[site]: stackoverflow
[post_id]: 5503649
[parent_id]: 
[tags]: 
Trouble using Gdiplus::Graphics::DrawText to draw white text on a black background

I'm trying to find a way to use the Gdiplus::Graphics.DrawString method to create a bitmap having white text on a black background. (Why? Because I need to be able to rotate the text, and the Gdiplus::Graphics object has RotateTransform available for that.) I've written a sample console app that demonstrates what I see when trying to draw white text on a black rectangle. (The code is pasted below.) Anyone have ideas what I'm doing wrong? Thanks in advance for any help. //////////////////////// // DrawTextTest.cpp : Defines the entry point for the console application. // #include "stdafx.h" #pragma comment (lib,"Gdiplus.lib") #include #include #include #include #include #include using namespace Gdiplus; using namespace std; bool RunTheTest(string); bool SaveBitmapToFile(HDC, HBITMAP, BITMAPINFO&, string); bool WriteBitmapFile(BYTE*, BITMAPINFOHEADER&, LPCTSTR); void ShowError(); #define BUFFER_SIZE 1024 int _tmain(int argc, _TCHAR* argv[]) { bool bRet(false); char szBuff[BUFFER_SIZE]; size_t retVal; string sFileName, sUserInput; ULONG_PTR gdiplusToken; GdiplusStartupInput gdiplusStartupInput; if (argc > 1) { for (int nArg = 1; nArg 1) sFileName += " "; sFileName += szBuff; } } else { cout > sUserInput; sFileName += sUserInput; } Status s = GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL); bRet = RunTheTest(sFileName); GdiplusShutdown(gdiplusToken); if (bRet) return 0; return 1; } bool RunTheTest(string sfileName) { BITMAPINFO bitmapInfo; bool bRet(false); Brush* pBlackBrush = new SolidBrush(Gdiplus::Color::Black); Brush* pWhiteBrush = new SolidBrush(Gdiplus::Color::White); double inchesPerMeter(39.3700787); float fontSize(30); Font* pFont(NULL); FontFamily* pFontFamily(NULL); FontStyle fs(FontStyleRegular); HBITMAP hMemoryBitmap(NULL); HDC hMemoryDC(NULL); HGDIOBJ hDefaultBitmap(NULL); int pelsPerMeter(0), resolution(240); int oldBkMode(0); LPTSTR pFileName(NULL); PointF origin(0, 0); SIZE sizeRect; Status s; // Initialize a memory device context compatible with the screen hMemoryDC = CreateCompatibleDC(NULL); // Prepare some values for creating a memory bitmap pelsPerMeter = (int)(resolution * inchesPerMeter); sizeRect.cx = sizeRect.cy = 400; // Create the memory bitmap bitmapInfo.bmiHeader.biBitCount = 24; bitmapInfo.bmiHeader.biCompression = BI_RGB; bitmapInfo.bmiHeader.biPlanes = 1; bitmapInfo.bmiHeader.biXPelsPerMeter = pelsPerMeter; bitmapInfo.bmiHeader.biYPelsPerMeter = pelsPerMeter; bitmapInfo.bmiHeader.biSize = sizeof(bitmapInfo.bmiHeader); bitmapInfo.bmiHeader.biWidth = sizeRect.cx; bitmapInfo.bmiHeader.biHeight = sizeRect.cy; hMemoryBitmap = CreateCompatibleBitmap(hMemoryDC, sizeRect.cx, sizeRect.cy); hDefaultBitmap = SelectObject(hMemoryDC, hMemoryBitmap); // Draw a white rectangle on the bitmap SelectObject(hMemoryDC, GetStockObject(WHITE_BRUSH)); Rectangle(hMemoryDC, 0, 0, sizeRect.cx, sizeRect.cy); SelectObject(hMemoryDC, GetStockObject(NULL_BRUSH)); // Set bitmap background mode to transparent mode oldBkMode = SetBkMode(hMemoryDC, TRANSPARENT); // Get a Graphics object from the memory device context Graphics graphics(hMemoryDC); // draw a black rectangle on the bitmap s = graphics.FillRectangle(pBlackBrush, 0, 0, 400, 400); if (s != Ok) { cout
