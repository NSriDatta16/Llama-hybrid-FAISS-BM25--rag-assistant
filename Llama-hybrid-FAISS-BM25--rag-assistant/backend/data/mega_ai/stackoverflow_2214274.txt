[site]: stackoverflow
[post_id]: 2214274
[parent_id]: 
[tags]: 
F# pattern matching on types of tuples

I have a curried function that I'd like it to support different types of parameters, that are not on a inheritance relationship: type MyType1 = A | B of float type MyType2 = C | D of int What I tried to do is: let func x y = match (x, y) with | :? Tuple -> "1, 1" | _ -> "..." However this is not possible. F# complains: The type ''a * 'b' does not have any proper subtypes and cannot be used as the source of a type test or runtime coercion. What is an elegant way to do this? EDIT : Let me try to clarify this. I have two similar, but distinct, types. I can very easily convert one type to another. I want to define a binary operation that will act on entities of those types, but I'd like to expose a single operation to the client. That is, instead of providing: let op11 (x : MyType1) (y : MyType1) = // do something useful let op12 (x : MyType1) (y : MyType2) = // convert y to MyType1 let y' = // ... // dispatch to op11 op11 x y' let op21 (x : MyType2) (y : MyType1) = // similar let op22 (x : MyType2) (y : MyType2) = // similar what I would like is to expose a single function to client code: let op (x : obj) (y : obj) = // ... This is like simulating the behavior of method overloading, but with curried functions.
