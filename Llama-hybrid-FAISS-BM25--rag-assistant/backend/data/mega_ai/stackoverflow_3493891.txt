[site]: stackoverflow
[post_id]: 3493891
[parent_id]: 3493566
[tags]: 
Here is one way to make this situation a little more generic. Rince and repeat for the other CRUD opperations. For some sitiations the performance may be unacceptable. In those cases I would restructure that part of the program to call a non generic version. public T GetSingleItem(Func idSelector ) where T : ??? // forgot what type it needs to be off the top of my head { try { using (DataContext context = new DataContext(ConnectionStringManager.getLiveConnStr())) { context.DeferredLoadingEnabled = false; return context.GetTable ().Single( item => idSelector( item ); } } catch (Exception e) { Logger.Log("Can't get requested item.", e); throw; } } This would be how you woudl have to get the item. Not quite as elegant becase you have to tell the generic function which column you are going to be using. GenericDC.GetSingleItem ( dvd => dvd.ID == 1231 ) To make this even more generic that limiting it to a single item with an ID... public IEnumerable GetItems(Func selectFunction ) where T : ??? // forgot what type it needs to be off the top of my head { try { using (DataContext context = new DataContext(ConnectionStringManager.getLiveConnStr())) { context.DeferredLoadingEnabled = false; return context.GetTable ().Select( item => selectFunction( item ); } } catch (Exception e) { Logger.Log("Can't get requested item.", e); throw; } } Then you can call it like: GenericDC.GetItems ( dvd => dvd.Title == "Title" && dvd.Cast.Contains( "Actor" ) ); Another possible solution would be to create a custom code generator that could you could modify in one place and create the similar routines for all other types. This would probably be a good solution if you are running into performace problems. You would want to limit the changes to the template piece of code that you use.
