[site]: stackoverflow
[post_id]: 2315865
[parent_id]: 2315760
[tags]: 
Let's think for a moment. We have two fundamental storage disciplines. Contiguous and Fragmented. Contiguous. Stack is constrained by order. Last in First Out. The nesting contexts of function calls demand this. We can easily invert this pattern to define a Queue . First in First Out. We can add a bound to the queue to make a Circular Queue . Input-output processing demands this. We can combine both constraints into a Dequeue . We can add a key and ordering to a queue to create a Priority Queue . The OS Scheduler demands this. So. That's a bunch of variations on contiguous structures constrained by entry order. And there are multiple implementations of these. You can have contiguous storage unconstrained by entry order: Array and Hash . An array is indexed by "position", a hash is indexed by a hash function of a Key. Fragmented: The bare "heap" is fragmented storage with no relationships. This is the usual approach. You can have heap storage using handles to allow relocation. The old Mac OS used to do this. You can have fragmented storage with relationships -- lists and trees and the like. Linked Lists . Single-linked and doubly-linked lists are implementation choices. Binary Trees have 0, 1 or 2 children. Higher-order trees. Tries and the like. What are we up to? A dozen? You can also look at this as "collections" which exist irrespective of the storage. In this case you mix storage discipline (heapish or array-ish) Bags: unordered collections with duplicates allowed. You can have a bag built on a number of storage disciplines: LinkedBag, TreeBag, ArrayBag, HashBag. The link and tree use fragmented storage, the array and hash use contiguous storage. Sets: unordered collections with no duplicates. No indexing. Again: LinkedSet, TreeSet, ArraySet, HashSet. Lists: ordered collections. Indexed by position. Again: LinkedList, TreeList, ArrayList, HashList. Mapping: key-value association collections. Indexed by key. LinkedMap, TreeMap, ArrayMap, HashMap.
