[site]: stackoverflow
[post_id]: 466258
[parent_id]: 466180
[tags]: 
The ThreadPool does not have a way to determine how many threads are currently idle. That is, created but not actually doing anything. My experience with the ThreadPool shows that it's pretty good about keeping threads around. I don't know if they've put logic in there to keep track of the average number of threads in use, but I've never noticed my programs waiting on thread creation. Except at startup, of course. One of my programs is often creating and running dozens of concurrent threads, and I don't see any delay in starting them up, even if the workload has been low for a period of time. I would suggest that you instrument your application, keeping track of when you make the call to ThreadPool.QueueUserWorkItem, and when the work item actually starts. Something like this: DateTime queueTime = DateTime.Now; ThreadPool.QueueUserWorkItem(WorkItemProc, queueTime); void WorkItemProc(object state) { DateTime startTime = DateTime.Now; DateTime queueTime = (DateTime)state; TimeSpan elapsed = startTime - queueTime; // At this point, elapsed.TotalMilliseconds will tell you how long it took // between queuing the item and it actually being started. ... } If you find that it's taking too long to start your pool threads, then you should create your own managed thread, and use events or some other messaging mechanism to give it work.
