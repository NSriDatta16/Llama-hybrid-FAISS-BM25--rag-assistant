[site]: stackoverflow
[post_id]: 2397238
[parent_id]: 2360938
[tags]: 
I'm not sure which part you are having trouble with (based on the comments)... but here is my suggestion. The displayOrder is just a simple attribute on a NSManagedObject class. If you can save a managed object, then you will be able finish this feature. Lets first take a simple NSManagedObject: @interface RowObj : NSManagedObject { } @property (nonatomic, retain) NSString *rowDescription; @property (nonatomic, retain) NSNumber *displayOrder; Next, we need to have local copy of the data being displayed in the tableview. I have read through the comments you have made and I'm not really sure if you are using the FetchedResultsController or not. My suggestion would be to start simple and just use a normal tableviewcontroller where you update the row data whenever a user changes the display order... then save the order when the user is done editing. The interface for this tableviewcontoller would look like this: @interface MyTableViewController : UITableViewController { NSMutableArray *myTableViewData; } @property(nonatomic,retain) NSMutableArray *myTableViewData; @end Next, we need to load the the table view data in the viewWillAppear method: - (void)viewWillAppear:(BOOL)animated { myTableViewData = [helper getRowObjects]; // insert method call here to get the data self.navigationItem.leftBarButtonItem = [self editButtonItem]; } There are 2 things going on here... (I'll explain the editButtonItem later) the first is that we need to get our data from CoreData. When I have to do this I have some sort of helper(call it what you want) object do the work. A typical find method would look like this: - (NSMutableArray*) getRowObjects{ NSFetchRequest *request = [[NSFetchRequest alloc] init]; NSEntityDescription *entity = [NSEntityDescription entityForName:@"RowObj" inManagedObjectContext:[self managedObjectContext]]; [request setEntity:entity]; NSSortDescriptor *sortDescriptor = [[NSSortDescriptor alloc] initWithKey:@"displayOrder" ascending:YES]; NSArray *sortDescriptors = [[NSArray alloc] initWithObjects:sortDescriptor, nil]; [request setSortDescriptors:sortDescriptors]; [sortDescriptors release]; [sortDescriptor release]; NSError *error; NSMutableArray *mutableFetchResults = [[managedObjectContext executeFetchRequest:request error:&error] mutableCopy]; if (mutableFetchResults == nil) { // Handle the error. } [request release]; return mutableFetchResults; } Now that you have your data, you can now wait for the user to edit the table. That is where the [self editButtonItem] comes into play. This is a built in feature that returns a bar button item that toggles its title and associated state between Edit and Done. When the user hits that button, it will invoke the setEditing:animated: method: To update the display order you need to override the setEditing method on the UITableViewController class. It should look something like this: - (void)setEditing:(BOOL)editing animated:(BOOL)animated { [super setEditing:editing animated:animated]; [myTableView setEditing:editing animated:animated]; if(!editing) { int i = 0; for(RowObj *row in myTableViewData) { row.displayOrder = [NSNumber numberWithInt:i++]; } [helper saveManagedObjectContext]; // basically calls [managedObjectContext save:&error]; } } We don't have to do anything when the user is in edit mode... we only want to save once they have pressed the "Done" button. When a user drags a row in your table you can update your display order by overriding the canMoveRowAtIndexPath and moveRowAtIndexPath methods: - (BOOL)tableView:(UITableView *)tableView canMoveRowAtIndexPath:(NSIndexPath *)indexPath { return true; } (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath { RowObj *row = [myTableViewData objectAtIndex:sourceIndexPath.row]; [myTableViewData removeObjectAtIndex:sourceIndexPath.row]; [myTableViewData insertObject:row atIndex:destinationIndexPath.row]; } Again, the reason I don't update the displayOrder value here is because the user is still in edit mode... we don't know if the user is done editing AND they could even cancel what they've done by not hitting the "Done" button. EDIT If you want to delete a row you need to override tableView:commitEditingStyle:forRowAtIndexPath and do something like this: - (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath { if (editingStyle == UITableViewCellEditingStyleDelete) { // Delete the managed object at the given index path. RowObj *row = [myTableViewData objectAtIndex:indexPath.row]; [helper deleteRow:row]; // Update the array and table view. [myTableViewData removeObjectAtIndex:indexPath.row]; [myTableView deleteRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:YES]; } }
