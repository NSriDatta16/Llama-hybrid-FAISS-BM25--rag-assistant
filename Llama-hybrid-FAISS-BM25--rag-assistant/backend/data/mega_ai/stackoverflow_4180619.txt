[site]: stackoverflow
[post_id]: 4180619
[parent_id]: 4161708
[tags]: 
The initWithFrame is incorrect. You want to generate a framebuffer and a renderbuffer and link the two. Instead you generate two framebuffers and completely ignore one. You should also keep the references to them (the variables 'renderbuffer' and 'framebuffer') in your class, as you'll need to delete them later unless you want to leak memory. Without fixing the second issue, I recommend: - (id)initWithFrame:(CGRect)frame { if ((self = [super initWithFrame:frame])) { CAEAGLLayer* eaglLayer = (CAEAGLLayer*) super.layer; eaglLayer.opaque = YES; m_context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES1]; if (!m_context || ![EAGLContext setCurrentContext:m_context]) { [self release]; return nil; } // these should be in the class so that we can release them later, // this will leak resources GLuint framebuffer, renderbuffer; // generate and bind a framebuffer glGenFramebuffersOES(1, &framebuffer); glBindFramebufferOES(GL_FRAMEBUFFER_OES, framebuffer); // generate a colour renderbuffer; this example doesn't seem to want // e.g. a depth buffer, but if it did then you'd generate and add one // of those here also // generate and bind glGenRenderbuffersOES(1, &renderbuffer); glBindRenderbufferOES(GL_RENDERBUFFER_OES, renderbuffer); // get storage from the layer [m_context renderbufferStorage:GL_RENDERBUFFER_OES fromDrawable: eaglLayer]; // link to the framebuffer glFramebufferRenderbufferOES( GL_FRAMEBUFFER_OES, GL_COLOR_ATTACHMENT0_OES, GL_RENDERBUFFER_OES, renderbuffer); glViewport(0, 0, CGRectGetWidth(frame), CGRectGetHeight(frame)); [self drawView]; } return self; } Put framebuffer and renderbuffer somewhere you can get to them again at the relevant moment and you should also: - (void)dealloc { if(renderbuffer) glDeleteRenderbuffersOES(1, &renderbuffer); if(framebuffer) glDeleteFramebuffersOES(1, &framebuffer); if ([EAGLContext currentContext] == m_context) { [EAGLContext setCurrentContext:nil]; } [m_context release]; [super dealloc]; } I've tested this against the code you provide. I get the grey screen. Changing the call to glClearColor changes the colour of the screen, so clearly the GL context is working.
