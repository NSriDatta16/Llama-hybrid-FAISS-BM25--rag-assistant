[site]: stackoverflow
[post_id]: 4470377
[parent_id]: 4469847
[tags]: 
If I understand correctly you've got some kind of time-stepping going on, where you create the values in new_potential by calculations on old_potential . Then make old equal to new and carry on. You could replace your existing convergence tests with the single statement converged = all(abs(new_potential - old_potential) which might be faster. If the speed of the test is a major concern you could test only every other (or every third or fourth ...) iteration A few comments: 1) If you used a potential array with 2 planes, instead of an old_ and new_potential, you could transfer new_ into old_ by swapping indices at the end of each iteration. As your code stands there's a lot of data movement going on. 2) While semantically you are right to have a while loop, I'd always use a do loop with a maximum number of iterations, just in case the convergence criterion is never met. 3) In your declaration REAL(KIND=DP) :: TOL = 0.001_DP the specification of DP on the numerical value of TOL is redundant, REAL(KIND=DP) :: TOL = 0.001 is adequate. I'd also make this a parameter, the compiler may be able to optimise its use if it knows that it is immutable. 4) You don't really need to execute CONVERGED = .TRUE. inside the outermost loop, set it before the first iteration -- this will save you a nanosecond or two. Finally, if your convergence criterion is that every element in the potential array has converged to 3dp then that is what you should test for. It would be relatively easy to construct counterexamples for your suggested averages. However, my concern would be that your system will never converge on every element and that you should be using some matrix norm computation to determine convergence. SO is not the place for a lesson in that topic.
