[site]: stackoverflow
[post_id]: 2641671
[parent_id]: 2594440
[tags]: 
IÂ´m not so sure this is a good idea, you would probably have a better solution if you could manage to speed up communication with your database. Hopefully I understood your requirements. It fast became a lot of code, here you have it... This is just a sample but it might be some thing to build on. I have not taken into consideration your need to remove rows after a certain amount of time. I separated the cache into segments with groups where the groups contains rows. I designed the sample to only lock a row when the first set property is called, when only get operations are called you should be safe. The lock will be released when the row object is disposed. So you have to use using() or call Dispose() to make it work. Here is a cache(group) class and a row class. Add database read after the comment // Add code to read from database... public class GroupCache : SimpleCache { private static readonly object GroupCacheObjectLock = new object(); public GroupCache(int groupId) { GroupId = groupId; } public int GroupId { get; private set; } public static GroupCache GetGroupCache(int groupId) { lock (GroupCacheObjectLock) { if (HttpContext.Current.Cache["Group-" + groupId] == null) { HttpContext.Current.Cache["Group-" + groupId] = new GroupCache(groupId); } } return HttpContext.Current.Cache["Group-" + groupId]; } public override RowObject CreateItem(int id, SimpleCache cache) { return new RowObject(id, GroupId, this); } } public class RowObject : SimpleCacheItem { private string _property1; public RowObject(int rowId, int groupId, SimpleCache cache) : base(rowId, cache) { // Add code to read from database... } public string Property1 { get { return _property1; } set { if (!AcquireLock(-1)) return; _property1 = value; #if DEBUG Trace.WriteLine(string.Format("Thread id: {0}, value = {1}", Thread.CurrentThread.ManagedThreadId, value)); #endif } } } This is a unit test mostly to show how to use the classes. [TestFixture] public class GroupCacheTest { private int _threadFinishedCount; private void MultiThreadTestWorker(object obj) { for (int n = 0; n Here are the base classes. public abstract class SimpleCacheItem : IDisposable where T : class { private readonly SimpleCache _cache; protected SimpleCacheItem(TKey id, SimpleCache cache) { Id = id; _cache = cache; } protected TKey Id { get; private set; } #region IDisposable Members public virtual void Dispose() { if (_cache == null) return; _cache.ReleaseLock(Id); } #endregion protected bool AcquireLock(int timeout) { return _cache.AcquireLock(Id, -1); } } public abstract class SimpleCache where T : class { private static readonly object CacheItemLockSyncLock = new object(); private static readonly object CacheItemStoreSyncLock = new object(); private readonly Dictionary _cacheItemLock; private readonly Dictionary _cacheItemStore; public abstract T CreateItem(TKey id, SimpleCache cache); public T GetCachedItem(TKey id) { T item; lock (CacheItemStoreSyncLock) { if (!_cacheItemStore.TryGetValue(id, out item)) { item = CreateItem(id, this); _cacheItemStore.Add(id, item); } } return item; } public void ReleaseLock(TKey id) { lock (CacheItemLockSyncLock) { if (_cacheItemLock.ContainsKey(id)) { _cacheItemLock.Remove(id); } } #if DEBUG Trace.WriteLine(string.Format("Thread id: {0} lock released", Thread.CurrentThread.ManagedThreadId)); #endif } public bool AcquireLock(TKey id, int timeOut) { var timer = new Stopwatch(); timer.Start(); while (timeOut
