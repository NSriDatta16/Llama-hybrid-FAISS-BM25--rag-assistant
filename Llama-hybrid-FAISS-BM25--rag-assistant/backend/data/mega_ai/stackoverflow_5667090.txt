[site]: stackoverflow
[post_id]: 5667090
[parent_id]: 5666048
[tags]: 
EDIT: I wrote much of this before I realized Mapadd only planned to use this in a lab. WSGI probably is not required for his use case. If you are willing to run this as a wsgi app (which I would recommend over vanilla CGI for any real scalability), you can use the script I have included below. I took the liberty of modifying your source... this works with the assumptions above.. btw, you should spend some time checking that your html is reasonably compliant... this will help ensure that you get better cross-browser compatibility... the original didn't have or tags... mine (below) is strictly prototype html, and could be improved. To run this, you just run the python executable in your shell and surf to the ipaddress of the machine on 8080. If you were doing this for a production website, we should be using lighttpd or apache for serving files, but since this is simply for lab use, the embedded wsgi reference server should be fine. Substitute the WSGIServer line at the bottom of the file if you want to run in apache or lighttpd. Save as mp3.py from webob import Request import re import os import sys #### #### Run with: #### twistd -n web --port 8080 --wsgi mp3.mp3_app _MP3DIV = """ """ _MP3EMBED = """ """ _HTML = ''' Hello %s %s ''' % (_MP3DIV, _MP3EMBED) def mp3_html(environ, start_response): """This function will be mounted on "/" and refer the browser to the mp3 serving URL.""" start_response('200 OK', [('Content-Type', 'text/html')]) return [_HTML] def mp3_serve(environ, start_response): """Serve the MP3, one chunk at a time with a generator""" file_path = "/file/path/to/test.mp3" mimetype = "application/x-mplayer2" size = os.path.getsize(file_path) headers = [ ("Content-type", mimetype), ("Content-length", str(size)), ] start_response("200 OK", headers) return send_file(file_path, size) def send_file(file_path, size): BLOCK_SIZE = 4096 fh = open(file_path, 'r') while True: block = fh.read(BLOCK_SIZE) if not block: fh.close() break yield block def _not_found(environ,start_response): """Called if no URL matches.""" start_response('404 NOT FOUND', [('Content-Type', 'text/plain')]) return ['Not Found'] def mp3_app(environ,start_response): """ The main WSGI application. Dispatch the current request to the functions andd store the regular expression captures in the WSGI environment as `mp3app.url_args` so that the functions from above can access the url placeholders. If nothing matches call the `not_found` function. """ # map urls to functions urls = [ (r'^$', mp3_html), (r'mp3/?$', mp3_serve), ] path = environ.get('PATH_INFO', '').lstrip('/') for regex, callback in urls: match = re.search(regex, path) if match is not None: # assign http environment variables... environ['mp3app.url_args'] = match.groups() return callback(environ, start_response) return _not_found(environ, start_response) Run from the bash shell with: twistd -n web --port 8080 --wsgi mp3.mp3_app from the directory where you saved mp3.py (or just put mp3.py somewhere in $PYTHONPATH ). Now surf to the external ip (i.e. http://some.ip.local:8080/ ) and it will serve the mp3 directly. I tried running your original app as it was posted, and could not get it to source the mp3, it barked at me with an error in linux...
