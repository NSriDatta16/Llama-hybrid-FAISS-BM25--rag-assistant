[site]: stackoverflow
[post_id]: 5372835
[parent_id]: 5369800
[tags]: 
create_string_buffer can be initialized with a string or a length. If initialized with a string s , it allocates space for len(s)+1 chars, so that the terminating null can be appended. But if initialized with an integer value, create_string_buffer assumes that since you are the human, you must know what you are doing, and allocates just that much space. Unfortunately, your C code is writing into the full 16 characters of space, so there is no room for a null terminator. When this works for you, it is purely by accident that the byte after the allocated storage happens to be 0 (null), terminating the string. Later on, that memory gets used for something else, and then you get the garbage. Try using create_string_buffer(16+1) instead, and see if things improve for you. The docs also suggest using the .string() method of the returned string buffer object, so that you explicitly apply null-terminated semantics - the alternative is .raw() which will read past nulls up to the defined buffer size. Ironically, if you specify key = key.raw() + "000000" , this may give you exactly the 16-character sized buffer you originally specified, and bypass the junk characters that way. So here are two things you can try: In One, do: key = key.raw() + "00000000" Or in Two, change to: buffer = create_string_buffer(16+1) But please don't do both.
