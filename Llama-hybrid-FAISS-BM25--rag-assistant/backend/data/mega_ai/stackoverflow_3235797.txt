[site]: stackoverflow
[post_id]: 3235797
[parent_id]: 3235742
[tags]: 
Update : You should probably subclass UITableViewCell rather than UITableView. Then in your table view controller's cellForRowAtIndexPath: method, return an instance of this subclass rather than an instance of UITableViewCell. You will also need to pass a DetailedViewController pointer on to the cell, so that you can invoke its moveToNextItem method in the touchesBegan , etc. methods. Adapt this example to your needs: MyTableViewCell.h @class DetailedViewController; @interface MyTableViewCell : UITableViewCell { DetailedViewController *dvc; } @property (nonatomic, retain) DetailedViewController *dvc; @end MyTableViewCell.m #import "MyTableViewCell.h" #import "DetailedViewController.h" @implementation MyTableViewCell @synthesize dvc; - (void)someMethod { // This would be your touchesBegan, etc. methods [dvc moveToNextItem]; } - (void)dealloc { [dvc release]; // We retained dvc so we have to release it when we're done with it [super dealloc]; } @end DetailedViewController.h @interface DetailedViewController : UITableViewController { // iVars here } // Methods and properties here - (void)moveToNextItem; @end DetailedViewController.m #import "DetailedViewController.h" #import "MyTableViewCell.h" @implementation DetailedViewController - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { MyTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"MyTableViewCell"]; if(cell == nil) { cell = [[[MyTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@"MyTableViewCell"] autorelease]; cell.dvc = self; // This gives the cell a reference to the detailed view controller } return cell; } - (void)moveToNextItem { // ... } @end There are probably far better ways to achieve what you want, but this is the best I can do without more information.
