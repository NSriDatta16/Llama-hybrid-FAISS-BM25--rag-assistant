[site]: stackoverflow
[post_id]: 1376839
[parent_id]: 1376692
[tags]: 
There seem to be many things to choose from to explain why your stored procedure is slow. Here are some thoughts. Execution plan cache. The proc is one big procedural process. The first time it runs it will store the execution plan based on the initial parameters. Depending on your table sizes and indexes the plan first cached might not be good for other scenarios Table variables. You chose to use table variables (start with @ and exist in memory) over temp tables (start with # and exist on disk). This may be good or bad. It depends on your conditions but can hurt if the wrong one is chosen Order By. You use them frequently and sorting has a cost. WHILE loop. A very procedural approach. You're using SQL so you should be thinking in a set-based environment Correlated sub-queries. For each row in the outer set the correlated sub-query has to run. That will add up. You do a data type conversion in the WHERE clause ([value] >= convert(real,@threshold)). This is a performance hit. The @universe table variable has no primary key, index, or cluster You have a 4 level nested correlated sub-query under a case statement that ultimately gets converted to XML 3 times Overall...your stored procedure does too much. Offload this work in advance somehow. Pre-calculate things. Add indexes. You're concerned about the reporting performance so design your schema around reporting and the fastest response times possible. You need to review the Execution plan and look for the high costs. Make small changes to the procedure and compare the execution plans of the before and after to see how your changes impact performance. Make benchmarks. Know where you start and you'll be able to measure how far you've gone. Run this statement and then run the procedure. SET STATISTICS IO ON GO Look at the results and for every table that is touched look at the "logical reads". The ones with the highest logical reads need your attention. They can be loosely translated into the need for indexes on that object.
