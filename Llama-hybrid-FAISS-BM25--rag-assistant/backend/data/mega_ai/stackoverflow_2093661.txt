[site]: stackoverflow
[post_id]: 2093661
[parent_id]: 2082739
[tags]: 
Ok most were mentioned already, but here is my list anyway: Learn what your compiler can do. Read compiler documentation, experiment with code examples. Check settings. Check generated code at target optimization level. Sometimes results are surprising and often it turns out optimization actually slows things down (or just take too much space). choose suitable memory model . If you target really small tight system, large or huge memory model might not be the best choice (but usually easisest to program for...) Prefer static allocation . Use dynamic allocation only on startup or over statically allocated buffer (pool or maximum instance sized static buffer). Use C99 style data types . Use smallest sufficient data type, for storage types. Local variables like loop variables are sometimes more efficient with "fast" data types. Select inline candidates. Some parameter heavy function with relatively simple bodies are better off when inlined. Or consider passing structure of parameters. Globals are also option, but be careful - tests and maintenance can become difficult if anyone in them isn't disciplned enough. Use const keyword well , be aware of array initialization implications. Map file , ideally also with module sizes. Check also what is included from crt (is it really neccessary?). Recursion just say no (limited stack space) Floating point numbers - prefer fixed point math. Tends to include and call a lot of code (even for simple addition or multiplication). C++ you should know C++ VERY WELL. If you don't, program constrainted embedded systems in C, please. Those who dare must be careful with all advanced C++ constructs (inheritance, templates, exceptions, overloading, etc.). Consider close to HW code to be rather Super-C and C++ is used where it counts: in high level logic, GUI, etc. Disable whatever you don't need in compiler settings (be it parts of libraries, language constructs, etc.) Last but not least - while hunting for smallest possible code size - don't overdo it. Watch out also for performance and maintainability. Over-optimized code tends to decay very quickly.
