[site]: stackoverflow
[post_id]: 4461357
[parent_id]: 4459466
[tags]: 
In general you should always get the schema formally correct before you worry about performance! That way you can make informed decisions about adapting the schema to resolve specific performance problems, rather than guessing. You definitely should go down the 2 table route. This will significantly reduce the amount of storage, code complexity, and the effort to changing the system to add new attributes. Assuming that each attribute can be represented by an Ordinal number , and that you're only looking for symmetrical matches (i.e. you're trying to match people based on similar attributes, rather than an expression of intention).... At a simple level, the query to find suitable matches may be very expensive. Effectively you are looking for nodes within the same proximity in a N-dimensional space, unfortunately most relational databases aren't really setup for this kind of operation (I believe PostgreSQL has support for this). So most people would probably start with something like: SELECT candidate.id, COUNT(*) FROM users candidate, attributes candidate_attrs, attributes current_user_attrs WHERE current_user_attrs.user_id=$current_user AND candidate.user_id<>$current_user AND candidate.id=candidate_attrs.user_id AND candidate_attrs.attr_type=current_user.attr_type AND candidate_attrs.attr_value=current_user.attr_value GROUP BY candidate.id ORDER BY COUNT(*) DESC; However this forces the system to compare every available candidate to find the best match. Applying a little heurisitics and you could get a very effective query: SELECT candidate.id, COUNT(*) FROM users candidate, attributes candidate_attrs, attributes current_user_attrs WHERE current_user_attrs.user_id=$current_user AND candidate.user_id<>$current_user AND candidate.id=candidate_attrs.user_id AND candidate_attrs.attr_type=current_user.attr_type AND candidate_attrs.attr_value BETWEEN current_user.attr_value+$tolerance AND current_user.attr_value-$tolerance GROUP BY candidate.id ORDER BY COUNT(*) DESC; (the value of $tolerance will affect the number of rows returned and query performance - if you've got an index on attr_type, attr_value). This can be further refined into a points scoring system: SELECT candidate.id, SUM(1/1+ ((candidate_attrs.attr_value - current_user.attr_value) *(candidate_attrs.attr_value - current_user.attr_value)) ) as match_score FROM users candidate, attributes candidate_attrs, attributes current_user_attrs WHERE current_user_attrs.user_id=$current_user AND candidate.user_id<>$current_user AND candidate.id=candidate_attrs.user_id AND candidate_attrs.attr_type=current_user.attr_type AND candidate_attrs.attr_value BETWEEN current_user.attr_value+$tolerance AND current_user.attr_value-$tolerance GROUP BY candidate.id ORDER BY COUNT(*) DESC; This approach lets you do lots of different things - including searching by a subset of attributes, e.g. SELECT candidate.id, SUM(1/1+ ((candidate_attrs.attr_value - current_user.attr_value) *(candidate_attrs.attr_value - current_user.attr_value)) ) as match_score FROM users candidate, attributes candidate_attrs, attributes current_user_attrs, attribute_subsets s WHERE current_user_attrs.user_id=$current_user AND candidate.user_id<>$current_user AND candidate.id=candidate_attrs.user_id AND candidate_attrs.attr_type=current_user.attr_type AND candidate_attrs.attr_value AND s.subset_name=$required_subset AND s.attr_type=current_user.attr_type BETWEEN current_user.attr_value+$tolerance AND current_user.attr_value-$tolerance GROUP BY candidate.id ORDER BY COUNT(*) DESC; Obviously this does not accomodate non-ordinal data (e.g. birth sign, favourite pop-band). Without knowing a lot more about te structure of the existing data, its rather hard to say exactly how effective this will be. If you want to add more attributes, then you don't need to make any changes to your PHP code nor the database schema - it can be completely data-driven. Another approach would be to identify sterotypes - i.e. reference points within the N-dimensional space, then work out which of these a particular user is closest to. You collapse all the attributes down to a single composite identifier - then you just need to apply the same approach to find the best match within the subset of candidates whom also have been matched to the stereotype.
