[site]: stackoverflow
[post_id]: 2801948
[parent_id]: 2801097
[tags]: 
AFAIK, you can add the overload to any namespace (except std, because you are not allowed to add new functions to it), and you'd make it visible with a using declaration. This is how, for example, boost's assign library works (pay attention to the introductory snippets; for a precedent in the standard library, check out rel_ops ). Also note that you can restrict the scope of using declarations, so as to avoid global pollution. Example, using boost::array because of an old compiler: #include #include #include using boost::array; namespace bitarray_operators { template array operator& (const array & a, const array & b) { array result; std::transform(a.begin(), a.end(), b.begin(), result.begin(), std::logical_and ()); return result; } } int main() { using namespace bitarray_operators; // a, b, c; c = a & b; } I concur that overloading this operator might be somewhat questionable. It's also unclear to me why you don't use std::bitset which overloads this operator with potentially better performance possible because of a more compact internal representation (each bool taking one bit, instead of at least the size of a char).
