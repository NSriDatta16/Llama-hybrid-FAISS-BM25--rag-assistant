[site]: stackoverflow
[post_id]: 2003781
[parent_id]: 2003201
[tags]: 
This seems to be a classic problem. In my case I wanted to intercept some events over a UIWebView which can't be subclassed, etc etc. I've found that the best way to do it is to intercept the events using the UIWindow: EventInterceptWindow.h @protocol EventInterceptWindowDelegate - (BOOL)interceptEvent:(UIEvent *)event; // return YES if event handled @end @interface EventInterceptWindow : UIWindow { // It would appear that using the variable name 'delegate' in any UI Kit // subclass is a really bad idea because it can occlude the same name in a // superclass and silently break things like autorotation. id eventInterceptDelegate; } @property(nonatomic, assign) id eventInterceptDelegate; @end EventInterceptWindow.m: #import "EventInterceptWindow.h" @implementation EventInterceptWindow @synthesize eventInterceptDelegate; - (void)sendEvent:(UIEvent *)event { if ([eventInterceptDelegate interceptEvent:event] == NO) [super sendEvent:event]; } @end Create that class, change the class of your UIWindow in your MainWindow.xib to EventInterceptWindow, then somewhere set the eventInterceptDelegate to a view controller that you want to intercept events. Example that intercepts a double-tap: - (BOOL)interceptEvent:(UIEvent *)event { NSSet *touches = [event allTouches]; UITouch *oneTouch = [touches anyObject]; UIView *touchView = [oneTouch view]; // NSLog(@"tap count = %d", [oneTouch tapCount]); // check for taps on the web view which really end up being dispatched to // a scroll view if (touchView && [touchView isDescendantOfView:webView] && touches && oneTouch.phase == UITouchPhaseBegan) { if ([oneTouch tapCount] == 2) { [self toggleScreenDecorations]; return YES; } } return NO; } Related info here: http://iphoneincubator.com/blog/windows-views/360idev-iphone-developers-conference-presentation
