[site]: stackoverflow
[post_id]: 1268862
[parent_id]: 1268299
[tags]: 
AFAIK, it's not possible to use in-memory collections in LINQ to SQL queries. I can think of two possible work-arounds: Option 1: Perform a query for each ID: var someSetOfIDs = new List () {1, 2, 3, 4, 5}; // queryPerID will have type IEnumerable > var queryPerID = from id in someSetOfIDs select ( from dataEvent in DataEvent.GetByQueryExpression(context) join attribute in DataEventAttribute.GetByQueryExpression(context) on dataEvent.DataEventID equals attribute.DataEventID where attribute.DataEventKeyID == 1 && (int)attribute.ValueDecimal == id // Changed from Contains select new { ID = dataEvent.DataEventID, PluginID = dataEvent.DataOwnerID, TimeStamp = dataEvent.DataTimeStamp, DataEventKeyID = attribute.DataEventKeyID, ValueString = attribute.ValueString, ValueDecimal = attribute.ValueDecimal }); // For each of those queries, we an equivalent final queryable var res = from initialQuery in queryPerID select ( from dataEvent in DataEvent.GetByQueryExpression(context) where initialQuery.GroupBy(x => x).Select(x => x.Key.ID).Contains(dataEvent.DataEventID) select new { BasicData = attributeBaseQuery.Where( attrValue => attrValue.DataEventID == dataEvent.DataEventID && attrValue.DataEventKeyID == (short) DataEventTypesEnum.BasicData).FirstOrDefault(). ValueString }) into finalQuery from x in finalQuery select x; var finalResult = finalQuery.Take(100).ToList(); I'm not sure if that even compiles, but it should be pretty close. Option 2: Build a predicate expression from someSetOfIDs to pass on to SQL. var someSetOfIDs = new List () { 1, 2, 3, 4, 5 }; Expression > seed = x => false; var predicate = someSetOfIDs.Aggregate(seed, (e, i) => Expression.Lambda >( Expression.OrElse( Expression.Equal( Expression.Property( e.Parameters[0], "ValueDecimal"), Expression.Constant(i)), e.Body), e.Parameters)); Essentially we've built a where clause: x => ((x.ValueDecimal = 5) || ((x.ValueDecimal = 4) || ((x.ValueDecimal = 3) || ((x.ValueDecimal = 2) || ((x.ValueDecimal = 1) || False))))) It's important to note that this approach won't work with anonymous types, so you would have to use the predicate on a queryable with a named type. This isn't an issue if you reorganize a bit (and might produce a better query plan, actually): var attributes = DataEventAttribute.GetByQueryExpression(context) .Where(a => a.DataEventKeyID ==1) .Where(predicate); var initialQuery = from dataEvent in DataEvent.GetByQueryExpression(context) join attribute in attributes select new { ID = dataEvent.DataEventID, PluginID = dataEvent.DataOwnerID, TimeStamp = dataEvent.DataTimeStamp, DataEventKeyID = attribute.DataEventKeyID, ValueString = attribute.ValueString, ValueDecimal = attribute.ValueDecimal };
