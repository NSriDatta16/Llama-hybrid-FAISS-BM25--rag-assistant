[site]: stackoverflow
[post_id]: 3979503
[parent_id]: 3973080
[tags]: 
Thanks a lot for your answer. It seems to work for a very simple scenario, but I have no success for slightly more complex scenarios. I have tried to mimic you code in my own domain, only am I ummarshalling data rather than marshalling. Adapter class: public class DeleteStringAdapter extends XmlAdapter { @Override public DeletableString marshal(String value) throws Exception { System.out.println("MARSHALL: " + value); return new DeletableString(value); } @Override public String unmarshal(DeletableString v) throws Exception { System.out.println("UNMARSHALL: " + v); if(v.isDelete() != null && v.isDelete()){ return null; } return v.getValue(); } } Adapter type: public class DeletableString { public DeletableString() { } public DeletableString(String value) { this.value = value; } private Boolean delete; private String value; @XmlAttribute public Boolean isDelete() { return delete; } public void setDelete(Boolean delete) { this.delete = delete; } @XmlValue public String getValue() { return value; } public void setValue(String value) { this.value = value; } @Override public String toString() { return DeletableString.class.getSimpleName() + "[delete=" + isDelete() + ", value=" + value + "]"; } } Working domain class with annotations: @XmlAccessorType(XmlAccessType.PROPERTY) @XmlRootElement(name = "xml-fragment") public class SimpleNavne implements Serializable{ private String forNavn = ""; private String fornavneMrkKode = ""; @XmlElement(name="PersonGivenName") @XmlJavaTypeAdapter(value = DeleteStringAdapter.class) public String getForNavn() { return forNavn; } public void setForNavn(String forNavn) { this.forNavn = forNavn; } @Override public String toString() { StringBuilder builder = new StringBuilder(); builder.append(SimpleNavne.class.getSimpleName() + "["); builder.append("forNavn="); builder.append(forNavn); builder.append("]"); return builder.toString(); } } Demo public class AppTest { @Test public void testApp() throws Exception { System.setProperty("jaxb.debug", "true"); try{ JAXBContext jaxbContext = JAXBContext.newInstance(SimpleNavne.class); Unmarshaller unmarshaller = jaxbContext.createUnmarshaller(); Object ps = unmarshaller.unmarshal(new File("./personname-test4.xml")); System.out.println(ps); }catch(Exception e){ e.printStackTrace(); } } } File: 010 The above seems to work fine if concluded from the output SimpleNavne[forNavn=010] I however get problems when introducing fields annotated with @XMLPath in the SimpleName domain class. Modified domain class @XmlAccessorType(XmlAccessType.PROPERTY) @XmlRootElement(name = "xml-fragment") public class SimpleNavne implements Serializable{ private String forNavn = ""; private String fornavneMrkKode = ""; @XmlElement(name="PersonGivenName") @XmlJavaTypeAdapter(value = DeleteStringAdapter.class) public String getForNavn() { return forNavn; } public void setForNavn(String forNavn) { this.forNavn = forNavn; } @XmlPath("/PersonGivenNameMarkingStructure/MarkingCode/text()") public String getFornavneMrkKode() { return fornavneMrkKode; } public void setFornavneMrkKode(String forNavnMrk) { this.fornavneMrkKode = forNavnMrk; } @Override public String toString() { StringBuilder builder = new StringBuilder(); builder.append(SimpleNavne.class.getSimpleName() + "["); builder.append(", forNavn="); builder.append(forNavn); builder.append(", fornavneMrkKode="); builder.append(fornavneMrkKode); builder.append("]"); return builder.toString(); } } Modified file: 010 011 The output is: SimpleNavne[forNavn=010, fornavneMrkKode=] But should have been: SimpleNavne[forNavn=010, fornavneMrkKode=011] Am I doing something completely wrong or is MOXy not supporting this scenario? PS. I have tried using MOXy 2.1.1 and 2.2.0-M3 with same result
