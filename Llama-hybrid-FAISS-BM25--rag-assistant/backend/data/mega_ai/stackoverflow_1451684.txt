[site]: stackoverflow
[post_id]: 1451684
[parent_id]: 1451153
[tags]: 
The reason for your problem lies with file organisation in C++. About headers and sources Sources are files that are compiled into binary "object files", and then linked together to produce the final binary (either a library or an executable). But for one source to use the code defined in another source, they must share the "declarations" of the code. Thus, the declaration must be put in shared files we will call header files. Usually, the code in headers is not "true code", only declaration of the existence of this true code. This is what you did with your custom vector: Put the declaration on the header, and the implementation on the source, and include the header in the main. About inlining Now, some "true code" can be put inside the headers, usually by prefixing it with the keyword "inline". Again, this is not really true code: The compiler and the linker will figure what to do with it, but it can either: Move the function code into an "object file" and have all the other "object files" link with it there Inline the code where the inlined function is used The two solution above at the same time But the inlined function could well disappear from the binary if it is not used. About templates Templates are somewhat like declaration: They are not "true code", but "potential code". It's even more "potential" than inline code because the template code will need to be instanciated for the right template parameters. Like for any other code, to use a template code, your source file must have access to the declaration. But in this case, the declaration of a template is both the "potential declaration" and the "potential implementation" , which will be instanciated by the compiler for the right types you're using. There are other ways to work with templates, but this is the way that will always work. One last advice When working with templates (or inlined code) it can be very very convenient to break down the header into multiple files (for example, when dealing with circulary dependancies of declaration). Example: file: MyObject.hpp #include #include file: MyObject_header.hpp class MyObject { // Etc. } ; file: MyObject_source.hpp #include MyObject::MyObject() { // etc. } // etc.
