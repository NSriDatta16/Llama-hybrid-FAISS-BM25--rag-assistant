[site]: stackoverflow
[post_id]: 693953
[parent_id]: 693596
[tags]: 
One can often find examples of beautiful XSLT code, especially when XSLT is used as a functional programming language . For examples see this article on FXSL 2.0 -- the Functional Programming library for XSLT 2.0. As an FP language XSLT is also a declarative language . This, among other things means that one declares, specifies existing relationships. Such a definition often does not need any additional code to produce a result -- it itself is its own implementation, or an executable definition or executable specification . Here is a small example . This XPath 2.0 expression defines the " Maximum Prime Factor of a natural number ": if(f:isPrime($pNum)) then $pNum else for $vEnd in xs:integer(floor(f:sqrt($pNum, 0.1E0))), $vDiv1 in (2 to $vEnd)[$pNum mod . = 0][1], $vDiv2 in $pNum idiv $vDiv1 return max((f:maxPrimeFactor($vDiv1),f:maxPrimeFactor($vDiv2))) To pronounce it in English , the maximum prime factor of a number pNum is the number itself, if pNum is prime, otherwise if vDiv1 and vDiv2 are two factors of pNum , then the maximum prime factor of pNum is the bigger of the maximum prime factors of vDiv1 and vDiv2 . How do we use this to actually calculate the Maximum Prime Factor in XSLT? We simply wrap up the definition above in an and ... get the result! We can, then, calculate the MPF for any natural number , for example: f:maxPrimeFactor(600851475143) = 6857 As for efficiency, well, this transformation takes just 0.109 sec . Other examples of both ellegant and efficient XSLT code : Tim Bray 's Wide Finder , as solved here . Cascade deletions Transitive closure Finding all anagrams of a word Concordance of a text corpus (the Old Testament) Spelling checking (Shakespear's Othello) Sudoku solver A general compiler-compiler system -- the LR-Parsing Framework of FXSL , used successfully for a parser of JSON and XPath2.0.
