[site]: stackoverflow
[post_id]: 250204
[parent_id]: 250157
[tags]: 
Yes, there are rules of thumb. Code analysis tools are a good start for this. Some rules of thumb about your code in question: Its bad practice to allow setters on collection properties. This is because its simple to treat empty collections just like full ones in code. Forcing people to do null checks on collections will get you beaten. Consider the following code snippet: public bool IsValid(object input){ foreach(var validator in this.Validators) if(!validator.IsValid(input) return false; return true; } This code works whether or not the collection of validators is empty or not. If you wish validation, add validators to the collection. If not, leave the collection empty. Simple. Allowing the collection property to be null results in this smelly code version of the above: public bool IsValid(object input){ if(this.Validators == null) return false; foreach(var validator in this.Validators) if(!validator.IsValid(input) return false; return true; } More lines of code, less elegant. Secondly, for reference types OTHER than collections, you must consider how the object behaves when determining if you want to set property values. Is there a single, obvious, default value for the property? Or does a null value for the property have a valid meaning? In your example, you may wish to always check,in the setter, the Name value and set it to a default "(No name given)" when assigned a null. This may make it easier when binding this object against UI. Or, the name may be null because you REQUIRE a valid name, and you will be checking it and throwing an InvalidOperationException when the caller tries to perform an action on the object without first setting the name. Like most things in programming, there are a bunch of different ways to do something, half of which are bad, and each way in the other half are good only in certain circumstances.
