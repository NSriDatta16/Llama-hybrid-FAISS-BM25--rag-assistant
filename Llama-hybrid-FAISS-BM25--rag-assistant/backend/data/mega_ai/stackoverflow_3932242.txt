[site]: stackoverflow
[post_id]: 3932242
[parent_id]: 3931510
[tags]: 
--EDIT-- I see your code has now been tagged in Java; my code is more of a c#/pseudo, so you might need to convert it into Java. --EDIT-- Though this may not help. But I'd suggest a more entity orient approach; something like: Agents, Agent List: Shall list the available agents Customers, Customer Queue: Shall maintain a queue of customers wanting help CustomerSupport Manager: Shall see if an agent is available(not busy) Dequeue the customer Assign it to one of the available agents Above the top of my head, see following: Customer: public class Customer { string _strName; public Customer(string strName) { _strName = strName; } } Agent: public class Agent { string _strName; bool _bIsBusy = false;// public bool IsBusy { get { return _bIsBusy; } } Customer _Customer; public Agent(string strName) { _strName = strName; } public void HandleCustomer(Customer theCustomer) { _Customer = theCustomer; _bIsBusy = true;//Busy as long as the window is open. //You might need something that doesnt block; Thread.Sleep(5 * 1000); //Wait for time to simulate that agent is talking to customer RemoveCustomer();//Done with the customer. } private void RemoveCustomer() { _Customer = null; _bIsBusy = false; } } Manager: A class that manages the customers and agents, according to availability public class CustomerServiceBench { Queue queCustomers = new Queue (); List lstAgents = new List (); Thread thdService; public CustomerServiceBench() { //Something along these lines. thdService = new Thread(delegate() { WaitAndAddCustomerIfAgentIsAvailable(); }); } private void AddCustomer() { //Add a dummy customer. Random r = new Random(1231); queCustomers.Enqueue(new Customer("Customer" + r.Next().ToString())); Thread.Sleep(5 * 1000); //SpinWait.Once()... } private void WaitAndAddCustomerIfAgentIsAvailable() { //Thread1 to manage the } }
