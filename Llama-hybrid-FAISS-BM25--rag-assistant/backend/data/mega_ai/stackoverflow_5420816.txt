[site]: stackoverflow
[post_id]: 5420816
[parent_id]: 5419992
[tags]: 
While you're correct that .NET code gets JIT-compiled to machine code, you have to realize that you have very little control over that process. You don't get to choose the target instruction set, and while the managed code advocates claim JIT compilation is superior because it can use the fastest instruction set available on a per-machine basis, the fact is that this hasn't been implemented yet. Bottom line: You can write C++ code using SSE instructions that will be run 4 times faster than JIT-generated code on the same CPU. Some other things worth mentioning: SIMD parallelism is a lot easier to write, and a lot easier for the compiler to optimize, than multithreading. There is no overhead with SIMD, but thread synchronization isn't free. And there are fewer hidden gotchas with SIMD, so it's much easier to get linear speedup. It's SO easy for multiple threads to fall into cache line sharing and contention. And managed languages give you absolutely no control over false sharing. Yes, C# makes it easier to do multithreading. Poorly. C++ makes it much more feasible to do multithreading right, and you may get enough speed out of tuning single-threaded code that you don't even need to deal with the extra complexity of threads. If you're determined to optimize yourself, here are some techniques: (stop at any point along the line once you've reached the desired performance, since the more you apply the more complex your code will be) Work on the raw data, don't use some API that adds indirection and abstraction over a bunch of pixels. Not only can this slow you down, it interferes with the next bunch of improvements. ( Kris alluded to LockBits vs SetPixel , the native routine for raw image access is GetDIBits ) Cache tuning. A simple approach is to unroll your innermost loop by a factor of 16 or so. Then invert the loop nesting order. This will result in processing rectangular chunks of the data, which generally are interdependent, so you access each piece of data many times for each cache fill. It's a waste to use a cache profiler at this stage, though. Use SIMD. Process 4 or more times as many pixels in each loop iteration. Easy win. Especially since you've already unrolled the loop somewhat, those identical instructions are just sitting there begging to be combined. But it can't be done until you break free of the abstractions. Now use a cache profiler. SIMD fetches have significantly different characteristics than scalar instructions, so you should do this after the SIMD conversion. Maybe multithreading. If the problem's really big. Pay careful attention to cache line sizes. And try to never write to data that other threads also use. Definitely don't write the same data from multiple threads.
