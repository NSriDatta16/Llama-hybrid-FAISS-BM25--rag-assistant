[site]: stackoverflow
[post_id]: 1360783
[parent_id]: 1359095
[tags]: 
As others have remarked it is hard for us to give a definitive answer without understanding more about your domain. You have attempted to distill a lot of business rules into a couple of paragraphs but some important information has been lost. Specifically, it is not possible to be sure whether two entities are genuinely distinct without knowing their attributes. Having said all which, let's have a go. A TEST is a single procedure. Despite containing the word "test" a LAT is not a TEST in its own right but is rather a pre-defined set of such procedures. I would model this scenario as an entity TEST with an optional parent entity, which I would prefer to call TEST_GROUP (as that is what it is) but it is best to use the domain name, SUB_TEST . A TRIAL appears to be distinct from a TEST , so model it as a separate entity. Therefore you have a choice when it comes to MEASUREMENT : you can have one entity with two optional foreign keys or you can have TEST_MEASUREMENT and TRIAL_MEASUREMENT . Choosing which road to go depends on the characteristics and usage profile. The following is an initial stab at the entity relationships. This would be the point in the project when the user goes, "Oh no, that is not what I meant at all." create table sample ( sample_id number not null , constraint samp_pk primary key (sample_id) ) / create table sub_test ( sub_test_id number not null , sample_id number not null , constraint subt_pk primary key (sub_test_id) , constraint subt_samp_fk foreign key (sample_id) references sample (sample_id) ) / create table test ( test_id number not null , sample_id number not null , sub_test_id number , constraint tst_pk primary key (test_id) , constraint tst_samp_fk foreign key (sample_id) references sample (sample_id) , constraint tst_subt_fk foreign key (sub_test_id) references sub_test (sub_test_id) ) / create table trial ( trial_id number not null , test_id number not null , constraint trl_pk primary key (trial_id) , constraint trl_tst_fk foreign key (test_id) references test (test_id) ) / create table measurement ( measurement_id number not null , trial_id number , test_id number , constraint meas_pk primary key (measurement_id) , constraint meas_tst_fk foreign key (test_id) references test (test_id) , constraint meas_trl_fk foreign key (trial_id) references trial (trial_id) , constraint measurement_ck check ( (test_id is not null and trial_id is null) or (test_id is null and trial_id is not null) ) / Edit Addressing your more generic question. Option 1 (Dummy) Never use a dummy record. It's is like using a magic value instead of a null. The solution is worse than the problem it solves. Option 2 (Rollup) This can work when the parent and the child have the same attributes. But it is not a viable solution if they have different columns, or if they are different dependencies. Even if they have identical data structures but different business uses it may still be a problem. Option 3 (Pick-a-Parent) This would be my preferred solution. The snag is the need for a check constraint to ensure that one (and only one) of the eligible foreign keys has been populated. You also need to guard against allowing too many parents/grandparents/great-grandparents into the mix.
