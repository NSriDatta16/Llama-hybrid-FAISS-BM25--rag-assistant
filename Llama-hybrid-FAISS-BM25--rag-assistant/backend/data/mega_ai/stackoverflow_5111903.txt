[site]: stackoverflow
[post_id]: 5111903
[parent_id]: 
[tags]: 
LINQ to SQL Conversion Overflows

I'm really stuck on this one. I have an extensive background in SQL, but I just started a new job and they prefer to use LINQ for simple queries. So in the spirit of learning, I tried to re-write this simple SQL query: SELECT AVG([Weight] / [Count]) AS [Average], COUNT(*) AS [Count] FROM [dbo].[Average Weight] WHERE [ID] = 187 For the sake of clarity, here's the table schema: CREATE TABLE [dbo].[Average Weight] ( [ID] INT NOT NULL, [Weight] DECIMAL(8, 4) NOT NULL, [Count] INT NOT NULL, [Date] DATETIME NOT NULL, PRIMARY KEY([ID], [Date]) ) Here's what I came up with: var averageWeight = Data.Context.AverageWeight .Where(i => i.ID == 187) .GroupBy(w => w.ID) .Select(i => new { Average = i.Average(a => a.Weight / a.Count), Count = i.Count() }); Data.Context.AverageWeight is a Linq To SQL object generated by SQLMetal. If I try to averageWeight.First() I get an OverflowException. I used the SQL Profiler to see what the parametrized query generated by LINQ looks like. Re-indented that looks like this: EXEC sp_executesql N' SELECT TOP(1) [t2].[value] AS [Average], [t2].[value2] AS [Count] FROM ( SELECT AVG([t1].[value]) AS [value], COUNT(*) AS [value2] FROM ( SELECT [t0].[Weight] / (CONVERT(DECIMAL(29, 4), [t0].[Count])) AS [value], [t0].[ID] FROM [dbo].[Average Weight] AS [t0] ) AS [t1] WHERE ([t1].[ID] = @p0) GROUP BY [t1].[ID] ) AS [t2]', N'@p0 int', @p0 = 187 Excessive nesting aside, I only see one problem: DECIMAL(29, 4). (The query runs and gives the expected result.) It's my understanding that anything above 28 will overflow the C# decimal data type. [Count] is an INT so it does need to be CONVERTed, but [Weight] is a DECIMAL(8, 4). I don't have any idea why LINQ would use such a large data type. Why would LINQ CONVERT to a data type that causes and overflow? Is there anyway to change this behavior? Or am I even on the right track? Also, Data.Context.AverageWeight was generated by SqlMetal and I verified Weight is a decimal and Column Attribute is correct (Decimal(8,4)). Thanks in advance. Update: So it looks like LINQ to SQL may be the culprit. I changed my LINQ like this: var averageWeight = Data.Context.AverageWeight .Where(i => i.ID == 187) .GroupBy(w => w.ID) .Select(i => new { Average = i.Average(a => a.Weight) / (decimal)i.Average(a => a.Count), Count = i.Count() }); Now the SQL generated looks like this: SELECT TOP(1) [t2].[value] AS [Average], [t2].[value2] AS [Count] FROM ( SELECT AVG([t1].[value]) AS [value], COUNT(*) AS [value2] FROM ( SELECT [t0].[Weight] / (CONVERT(DECIMAL(16, 4), [t0].[Count])) AS [value], [t0].[ID] FROM [dbo].[Average Weight] AS [t0] ) AS [t1] WHERE ([t1].[ID] = 187) GROUP BY [t1].[ID] ) AS [t2] The result of this is: Average Count 0.000518750000000 16 The previous approach gave: Average Count 0.000518750000000000000 16 There is no longer an overflow, but the query is less efficient. I don't know why LINQ to SQL would CONVERT TO such a high precision. Not of the other variables are so precise. And as far as I can tell, there is nothing I can do in LINQ to force the data type. Any ideas?
