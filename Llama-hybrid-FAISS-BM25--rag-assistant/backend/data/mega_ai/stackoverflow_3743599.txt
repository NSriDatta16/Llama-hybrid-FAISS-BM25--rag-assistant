[site]: stackoverflow
[post_id]: 3743599
[parent_id]: 3669107
[tags]: 
Your question is very interesting, but a bit vague, because without knowing what to test it is not easy to give you some clues. You can test performance from many different angles, then, depending on the use or target of the library you should try one approach or another; I will try to enumerate some of the things you may have to consider for measurement: Multithreading: if the library uses it or your software will use the library in a multithreaded context then you may have to test it with many different processor and multiprocessor configurations to see how it reacts. Startup time: its importance depends on how intensively will you use the library and what’s the nature of the product being built with it (client, server …). Response time: for this do not take the first execution, try to execute the same call many times after the first one and do an average. Using System.Diagnostics.StopWatch could be very useful for that. Memory consumption: analyze the growth, beware of exponential ones ;). Go a step further and measure quantity of objects being created and disposed. Responsiveness: you should not only measure raw performance, how the user feels the speed of the product it is very important too. Network: if the library uses resources on the network you may have to test it with different bandwidth and latency configurations, there is software to simulate these situations. Data: try to create many different testing data packages, trying to cover, for example: a big bunch of raw data, then a large set made of many smaller chunks, a long iteration with small pieces of data, … Tools: System.Diagnostics.Stopwatch : essential for benchmarking method calls Performance counters : whenever available they are very useful to know what’s happening inside, allowing you to monitor the software without affecting its performance. Profilers: there are some good memory and performance profilers in the market, but as you said, they always affect the measurements. They are good for finding bottlenecks in your software, but I don’t think you can use them for a comparison test.
