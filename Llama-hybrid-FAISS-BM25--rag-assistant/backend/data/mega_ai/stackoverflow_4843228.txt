[site]: stackoverflow
[post_id]: 4843228
[parent_id]: 4842921
[tags]: 
If numbers are random, any worst-case O(n^2) algorithm (including yours) will run very fast. In fact, the practical complexity will be O(n*logn) (the complexity of sorting). It's much like quicksort, where we have O(n*logn) average and a tiny chance of hitting O(n^2) . 10^6 random numbers give us ~ 10^6*10^6 'nearly random' sums in range ~ 0..10^9 . What's the chance that one of those 10^12 random sums will be equal to a given random value in integer range? Pretty good. Now, what's the chance that one of those 10^12 random sums will be equal to a one of 10^6 given random values? 100%, speaking poetically. I've implemented your proposed solution, for n = 10^6 it performs on average 5000-10000 operations in the innermost loop. So much for O(n^2) . Sorting is the costliest operation in there. PS. You may reduce complexity farther and make it even O(1) , if you update the solution to use hash instead of sorting. PS 2. The test program in java, for the reference. Run it and see for yourself. int n = 1000000; int[] a = new int[n]; // generate random array Random r = new Random(); for (int i = 0; i a[k] - a[j]) { ++k; } else if (a[i]
