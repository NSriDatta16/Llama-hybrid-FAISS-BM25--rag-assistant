[site]: stackoverflow
[post_id]: 3939570
[parent_id]: 3939032
[tags]: 
First of all , you need to arrange the code. You must have one and only one display function, that clears the buffer,calls the other draw-functions and flushes them to the screen ( or swaps the buffer if you are using a double buffer). On resizing the window,GLUT will call the Display Function which is renderPoint() as you know : glutDisplayFunc (renderPoint); renderPoint clears the buffer before redrawing the "points" , for example : void renderPoint(void) /*REVISAR ESTO*/ { glClear (GL_COLOR_BUFFER_BIT); glBegin (GL_POINTS); glVertex2f (-0.98, 0.98); glEnd (); glFlush (); } Since the buffer has been cleared , all the points that are drawn outside the function renderPoint ( the points of circles, the points of lines .. ) has no meaning , because you did not call them from the "main display function which is renderPoint. How to keep the points on the screen ? You must store the points ( any point you want to draw ) in a buffer such as an array , a dynamic array, std::vector or anything else. in the display function , write a loop statement to visit each point and extract the x and y .. then draw them. for example , instead of the above function , replace it with : class MyPoint { public: float x; float y; MyPoint(float x, float y) { this->x = x; this->y = y; } }; #include std::vector testPoints; void renderPoint(void) /*REVISAR ESTO*/ { testPoints.push_back(MyPoint(-0.58,0.58)); testPoints.push_back(MyPoint(0.58,0.58)); testPoints.push_back(MyPoint(0.58,-0.58)); glClear (GL_COLOR_BUFFER_BIT); glPointSize(2); glBegin (GL_POINTS); for(int i=0;i as you can see , by using a dynamic array such as (std::vector) to store the points and by using a for loop statement , we able to keep the three points visible. what else ? do the same method with other shapes , so that for each " mouse click " event , you may add or push_back two points represents a line end points in an array or std::vector called lineArray . in the display function , make a for loop statement to draw each line after extracting the two line points. you should use glutReshapeFunc and glViewport to make sure that the viewport has the same dimenstions as the window after the resizing event. and I think that gluOrtho2d is more elegant than trying to mapping from Windows coordinates space to OpenGL coordinates space arrange your code , so that you just use one display function. Your program could be Something like this: void drawTestPoints() { for(int i=0;i ==
