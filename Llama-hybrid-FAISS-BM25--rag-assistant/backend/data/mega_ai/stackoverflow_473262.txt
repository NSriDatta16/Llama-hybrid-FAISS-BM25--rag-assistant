[site]: stackoverflow
[post_id]: 473262
[parent_id]: 473236
[tags]: 
As the other answers says, C++ doesn't have this concept. You can easily work around it though. Either you can have an undefined value which you initialize bar to in the constructor, typically -1.0 or something similar. If you know that calculate_bar never returns negative values you can implement the undefined function as a check for A more general solution is having a bool saying whether bar is defined yet that you initialized to false in the constructor and when you first set it you change it to true. boost::optional does this in an elegant templated way. This is what the code example you have would look like. class Foo { public: double get_bar(); Foo() : barDefined(false) {} private: double bar; bool barDefined; void calculate_bar() { bar = something(); } }; double Foo::get_bar() { if ( barDefined == false ) { calculate_bar(); barDefined = true; } return bar; }
