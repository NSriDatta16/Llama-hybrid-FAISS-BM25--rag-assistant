[site]: stackoverflow
[post_id]: 2979113
[parent_id]: 
[tags]: 
QCoreApplication QApplication with WMI

I found some WMI C++ Application Examples in MSDN website. I have tried the code form the below link http://msdn.microsoft.com/en-us/library/aa390423%28v=VS.85%29.aspx when I copied and run the application as win32 console application it worked well. the same code I put into the Qt application , When I use QApplication anApplication ( argc, argv ); in my code it is not working But if I use QCoreApplication anApplication ( argc, argv ); it is working shows me error like "when i change QCoreApplication to QApplication The below source code not works and gives me error like " Failed to initialize COM library. Error code = 0x80010106 " Any suggestions or help #define _WIN32_DCOM #include using namespace std; #include #include # pragma comment(lib, "wbemuuid.lib") // Qt Includes #include #include //---------------------------------------------------------------------------- // Main Function int main( int a_argc, char *a_argv[] ) //************************************ { // initialize the application QApplication anapplication( a_argc, a_argv ); HRESULT hres; // Step 1: -------------------------------------------------- // Initialize COM. ------------------------------------------ hres = CoInitializeEx(0, COINIT_MULTITHREADED); if (FAILED(hres)) { cout ConnectServer( _bstr_t(L"ROOT\\CIMV2"), // Object path of WMI namespace NULL, // User name. NULL = current user NULL, // User password. NULL = current 0, // Locale. NULL indicates current NULL, // Security flags. 0, // Authority (e.g. Kerberos) 0, // Context object &pSvc // pointer to IWbemServices proxy ); if (FAILED(hres)) { cout Release(); CoUninitialize(); return 1; // Program has failed. } cout Release(); pLoc->Release(); CoUninitialize(); return 1; // Program has failed. } // Step 6: -------------------------------------------------- // Use the IWbemServices pointer to make requests of WMI ---- // For example, get the name of the operating system IEnumWbemClassObject* pEnumerator = NULL; hres = pSvc->ExecQuery( bstr_t("WQL"), bstr_t("SELECT * FROM Win32_USBControllerDevice"), WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnumerator); //ExecQuery(L"WQL", L"SELECT * FROM Win32_LogicalDisk", WBEM_FLAG_FORWARD_ONLY, NULL, &iter); if (FAILED(hres)) { cout Release(); pLoc->Release(); CoUninitialize(); return 1; // Program has failed. } // Step 7: ------------------------------------------------- // Get the data from the query in step 6 ------------------- IWbemClassObject *pclsObj; ULONG uReturn = 0; while (pEnumerator) { HRESULT hr = pEnumerator->Next(WBEM_INFINITE, 1, &pclsObj, &uReturn); if(FAILED(hr)||0 == uReturn) { break; } VARIANT vtProp; // Get the value of the Name property /*hr = pclsObj->Get(L"VolumeName", 0, &vtProp, 0, 0); wcout Get(L"Antecedent", 0, &vtProp, 0, 0))) { cout Release(); } // Cleanup // ======== pSvc->Release(); pLoc->Release(); pEnumerator->Release(); // pclsObj->Release(); CoUninitialize(); // return 0; // Program successfully completed. //execute the application int anInt = anapplication.exec(); return anInt; } //-----------------------------------------------------------------------------
