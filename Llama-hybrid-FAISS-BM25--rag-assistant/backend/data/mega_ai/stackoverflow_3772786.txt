[site]: stackoverflow
[post_id]: 3772786
[parent_id]: 3771989
[tags]: 
First off, I am not sure why you just don't return IQueryable and let the user of the method determine if they want it as a List, etc. Because IQueryables are not executed until actually needed, you can keep adding to the expression tree until you actually need it. In this case, when you change it to a List of objects, that is when the query will actually get executed against the databse when it is turned into a list. If you really want to keep the interface as an IList instead of an IQueryable, just add an additional expression to the expression tree before you compile. Since I have had limited work with the root level expression trees, I would likely give the syntax to you wrong, so here is a different type of example that may give you enough information as to what I am talking about: var query = something.Where( n => n.FirstName.StartsWith("N")) ; query = query.Where(n => n.created_at > DateTime.Now); return query.ToList(); I hope that makes sense. You can just continue to add criteria to the expression tree until it gets compiled and executed. I would still recommend passing arround IQueryable though, instead. In my example, you would just return the query instead of calling ToList first. It makes it easier for fluent syntax and will perform better with nHibernate because nHibernate will try to take all of the criteria into account before calling the database. If you only needed an aggragate or a count, for example, that would be handled at the database instead of pulling back all of the rows into a list and then iterating over it to get the aggregate or count.
