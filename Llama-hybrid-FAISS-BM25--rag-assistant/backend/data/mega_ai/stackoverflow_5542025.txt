[site]: stackoverflow
[post_id]: 5542025
[parent_id]: 5540185
[tags]: 
Your problem is that the CGI program is done, but the webserver hasn't been told it is done, and is waiting for that before actually saying to the browser that it is done. You'll need to figure out how to communicate that, or else come up with a hack to work around the bug. Here are a few possible strategies. In Unix the right way to tell the webserver that it is time to go away is to daemonize the background process. The details of how to do this are pretty Unix specific. However Googling for Win32 perl daemon lead me to Win32::Daemon and then Win32::Service , which may help you do something similar for Windows. I've seen comments without details suggesting that this will work. If you need help figuring this out, I would suggest going to Perlmonks and asking there. There is more Perl specific expertise there than here. Suppose that you have some sort of batch job scheduler available to you. Then instead of launching a job, you can just schedule a task to be done. The task gets picked up and run. This strategy is particularly useful if the job that you need to run is intensive enough that you'd like it to run somewhere other than your webserver. Your CGI script can turn around and issue an http request to the webserver for the job to start, which it doesn't wait for. Here is a brief example showing you how to do that: #! /usr/bin/perl -w use strict; use Carp qw(croak); use Data::Dumper qw(Dumper); use LWP::UserAgent; my $ua = LWP::UserAgent->new(); $ua->add_handler(response_header => sub {croak "complete"}, m_code => 200); my $response = $ua->get("http://www.perl.com/"); if ($response->is_success) { print "Request backgrounded\n"; } else { print "Uh, oh.\n"; }
