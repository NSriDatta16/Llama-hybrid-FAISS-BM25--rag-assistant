[site]: stackoverflow
[post_id]: 4575593
[parent_id]: 4575035
[tags]: 
how do you get rid of the overhead? You can force a table using the MEMORY/HEAP storage engine to recover residual space lost from deleted rows by ALTERing it, but not changing anything. e.g. ALTER TABLE my_table ENGINE=MEMORY; It will re-write the table. Backing that up with a quote from the documentation : To free up the memory used by rows that have been deleted, use ALTER TABLE ENGINE=MEMORY to force a table rebuild. EDIT maybe this isn't the best table type for this? It doesn't sound like the ideal application of a MEMORY table in my opinion -- by and large, I consider it a legacy engine. Some food-for-thought Firstly, MEMORY tables can't/don't use b-tree indexes (hash indexes only), so queries which could otherwise use an index for ORDERing or ranging (i.e. operations) resort to sorting/filtering manually/exhaustively. Secondly, Innodb tables will reside in RAM if your innodb_buffer_pool is large enough, and works better with concurrent threads, so it often performs as good if not better than a MEMORY table for most applications. Thirdly, perhaps most importantly, if your MySQL is ever turned off, you'll lose all data in your table. There are table truncation implications also if you're using replication.
