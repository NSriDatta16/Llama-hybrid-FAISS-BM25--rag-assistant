[site]: stackoverflow
[post_id]: 883221
[parent_id]: 883049
[tags]: 
Integer linear optimization for NP-hard problems Depending on your side constraints, you may be able to use the critical path method or (as suggested in a previous answer) dynamic programming . But many scheduling problems are NP-hard just like the classical traveling sales man --- a precise solution has a worst case of exponential search time, just as you describe in your problem. It's important to know that while NP-hard problems still have a very bad worst case solution time there is an approach that very often produces exact answers with very short computations (the average case is acceptable and you often don't see the worst case). This approach is to convert your problem to a linear optimization problem with integer variables. There are free-software packages (such as lp-solve) that can solve such problems efficiently. The advantage of this approach is that it may give you exact answers to NP-hard problems in acceptable time. I used this approach in a few projects. As your problem statement does not include more details about the side constraints, I cannot go into more detail how to apply the method. Edit/addition: Sample implementation Here are some details about how to implement this method in your case (of course, I make some assumptions that may not apply to your actual problem --- I only know the details form your question): Let's assume that you have 50 instructions cmd(i) (i=1..50) to be scheduled in 10 or less cycles cycle(t) (t=1..10). We introduce 500 binary variables v(i,t) (i=1..50; t=1..10) which indicate whether instruction cmd(i) is executed at cycle(t) or not. This basic setup gives the following linear constraints: v_it integer variables 0 Now, we have to specify your side conditions. Let's assume that operations cmd(1)...cmd(5) are multiplication operations and that you have exactly two multipliers --- in any cycle, you may perform at most two of these operations in parallel: sum(v_it: i=1..5) For each of your resources, you need to add the corresponding constraints. Also, let's assume that operation cmd(7) depends on operation cmd(2) and needs to be executed after it. To make the equation a little bit more interesting, lets also require a two cycle gap between them: sum(t*v(2,t): t=1..10) + 3 Note: sum(t*v(2,t): t=1..10) is the cycle t where v(2,t) is equal to one. Finally, we want to minimize the number of cycles. This is somewhat tricky because you get quite big numbers in the way that I propose: We give assign each v(i,t) a price that grows exponentially with time: pushing off operations into the future is much more expensive than performing them early: sum(6^t * v(i,t): i=1..50; t=1..10) --> minimum. # one target function I choose 6 to be bigger than 5 to ensure that adding one cycle to the system makes it more expensive than squeezing everything into less cycles. A side-effect is that the program will go out of it's way to schedule operations as early as possible. You may avoid this by performing a two-step optimization: First, use this target function to find the minimal number of necessary cycles. Then, ask the same problem again with a different target function --- limiting the number of available cycles at the outset and imposing a more moderate price penalty for later operations. You have to play with this, I hope you got the idea. Hopefully, you can express all your requirements as such linear constraints in your binary variables. Of course, there may be many opportunities to exploit your insight into your specific problem to do with less constraints or less variables. Then, hand your problem off to lp-solve or cplex and let them find the best solution!
