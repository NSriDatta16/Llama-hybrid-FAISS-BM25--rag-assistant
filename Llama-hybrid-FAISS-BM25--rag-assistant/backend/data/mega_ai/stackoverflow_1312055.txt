[site]: stackoverflow
[post_id]: 1312055
[parent_id]: 1302163
[tags]: 
This can easily be done with XPath 2.0 or with XPath 1.0 hosted by XSLT . With XPath 1.0 hosted by .NET this can be achieved in several steps: Make the appropriate "p" node the current node. Find the number of all children of the current "p" node: count(br) if N is the count, determined in step 2. for $k in 0 to N do: 3.1 Find all nodes that are preceded by $k elements: node()[not(self::br) and count(preceding::br) = $k] 3.2 For every such node found, get its string value 3.3 Concatenate all string values obtained in step 3.2. The result of this concatenation is all the text contained in the given paragraph . Note : In order to substitute what should stand for $k in step 3.1 it is necessary to dynamically construct this expression.
