[site]: stackoverflow
[post_id]: 4791841
[parent_id]: 4789242
[tags]: 
You have to keep in mind that Matlab uses a compiled fft library ( http://www.fftw.org/ ) for its fft functions, which besides operating much faster then a Matlab script, it is well optimized for many use-cases. So a first step might be writing your code in c/c++ and compiling it as a mex file you can use within Matlab. That will surely speed up your code at least an order of magnitude (probably more). Besides that, one simple optimization you can do is by considering 2 things: You assume your time series is real valued, so you can use the symmetry of the fft coeffs. Your time series is typically much longer then your fft coeffs vector, so it is better to iterate over bins instead of time points (thus vectorizing the longer vector). These two points are translated to the following loop: nn=(start+1 : round(2*DATAn/3))'; ttrend2 = zeros( (round(2*DATAn/3) - round(DATAn/3) + 1), 1); tic; for bn = 1:length(bins) arg = 2*pi*(bins(bn)-1)*(nn-1)/FFTn; ttrend2 = ttrend2 + 2*real(fftcoef(bn) * exp(i*arg)); end toc; Note you have to use this loop before you expand bins and fftcoef , since the symmetry is already taken into account. This loop takes 8.3 seconds to run with the parameters from your question, while it takes on my pc 141.3 seconds to run with your code.
