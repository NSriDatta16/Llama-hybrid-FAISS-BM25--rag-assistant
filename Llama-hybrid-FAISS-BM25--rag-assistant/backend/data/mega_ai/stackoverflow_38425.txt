[site]: stackoverflow
[post_id]: 38425
[parent_id]: 34571
[tags]: 
Having tried Cem Catikkas' solution using reflection for Java, I'd have to say his was a more elegant solution than I have described here. However, if you're looking for an alternative to using reflection, and have access to the source you're testing, this will still be an option. There is possible merit in testing private methods of a class, particularly with test-driven development , where you would like to design small tests before you write any code. Creating a test with access to private members and methods can test areas of code which are difficult to target specifically with access only to public methods. If a public method has several steps involved, it can consist of several private methods, which can then be tested individually. Advantages: Can test to a finer granularity Disadvantages: Test code must reside in the same file as source code, which can be more difficult to maintain Similarly with .class output files, they must remain within the same package as declared in source code However, if continuous testing requires this method, it may be a signal that the private methods should be extracted, which could be tested in the traditional, public way. Here is a convoluted example of how this would work: // Import statements and package declarations public class ClassToTest { private int decrement(int toDecrement) { toDecrement--; return toDecrement; } // Constructor and the rest of the class public static class StaticInnerTest extends TestCase { public StaticInnerTest(){ super(); } public void testDecrement(){ int number = 10; ClassToTest toTest= new ClassToTest(); int decremented = toTest.decrement(number); assertEquals(9, decremented); } public static void main(String[] args) { junit.textui.TestRunner.run(StaticInnerTest.class); } } } The inner class would be compiled to ClassToTest$StaticInnerTest . See also: Java Tip 106: Static inner classes for fun and profit
