[site]: stackoverflow
[post_id]: 5085628
[parent_id]: 5085556
[tags]: 
One optimization would be in your directional search. You only need to search down, left, and down-left diagonally as searching up, right, and up-right diagonally will give you the same result as simply reversing the string. EDIT: Of interest also might be Project Euler Problem #11 and a writeup of a solution using C# and LINQ here . This is a completely untested example of what I was trying to describe. static List Solve() { // Declaring a empty list of strings to hold our results up front. List words = new List (); // I'm using set as the term for your grid of letters. string set = @"ABCD EFGH HIJK LMNO"; // i'm explicitly defining the dimensions, you need to figure this out. int sizeX = 4; int sizeY = 4; // i'm also specifying a maximum word length. you might find a word like // supercalifragilisticexpialidocious, but i doubt it so lets not waste time. int maximumWordSize = 3; // first, our trie/wordlist/etc. assume `GetWordList()` gets a list of all // valid words with indicated number of characters. List wordList = GetWordList(3); // second, we load a character array with the set. char[,] data = new char[sizeX, sizeY]; string[] lines = set.Split('\n'); for (int i = 0; i w.Contains(data[x,y])); if (validWords.Count() > 0) { // ok, we have words. continue on our quest! // (this is where your initial qualifier changes if you use a trie // or other search method) char[] characters = char[maximumWordSize]; // search left for (int i = x; i Search(char[] Input, List WordList) { List result = new List (); string word = ""; // find forwards for (int i = 0; i
