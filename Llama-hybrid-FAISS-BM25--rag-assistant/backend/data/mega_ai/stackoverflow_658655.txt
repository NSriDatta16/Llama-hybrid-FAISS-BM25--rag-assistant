[site]: stackoverflow
[post_id]: 658655
[parent_id]: 658469
[tags]: 
Short answer: No (not that I know of*) Long answer: json_encode will only serialize public variables. As you can see per the JSON spec , there is no "function" datatype. These are both reasons why your methods aren't serialized into your JSON object. Ryan Graham is right - the only way to re-create these objects as non-stdClass instances is to re-create them post-deserialization. Example firstName = $firstName; $this->lastName = $lastName; } public static function createFromJson( $jsonString ) { $object = json_decode( $jsonString ); return new self( $object->firstName, $object->lastName ); } public function getName() { return $this->firstName . ' ' . $this->lastName; } } $p = new Person( 'Peter', 'Bailey' ); $jsonPerson = json_encode( $p ); $reconstructedPerson = Person::createFromJson( $jsonPerson ); echo $reconstructedPerson->getName(); Alternatively, unless you really need the data as JSON, you can just use normal serialization and leverage the __sleep() and __wakeup() hooks to achieve additional customization. * In a previous question of my own it was suggested that you could implement some of the SPL interfaces to customize the input/output of json_encode() but my tests revealed those to be wild goose chases.
