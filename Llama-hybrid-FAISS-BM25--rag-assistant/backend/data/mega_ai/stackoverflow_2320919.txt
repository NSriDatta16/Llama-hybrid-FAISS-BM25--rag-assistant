[site]: stackoverflow
[post_id]: 2320919
[parent_id]: 
[tags]: 
How can I duplicate the F# discriminated union type in C#?

I've created a new class called Actor which processes messages passed to it. The problem I am running into is figuring out what is the most elegant way to pass related but different messages to the Actor. My first idea is to use inheritance but it seems so bloated but it is strongly types which is a definite requirement. Have any ideas? Example private abstract class QueueMessage { } private class ClearMessage : QueueMessage { public static readonly ClearMessage Instance = new ClearMessage(); private ClearMessage() { } } private class TryDequeueMessage : QueueMessage { public static readonly TryDequeueMessage Instance = new TryDequeueMessage(); private TryDequeueMessage() { } } private class EnqueueMessage : QueueMessage { public TValue Item { get; private set; } private EnqueueMessage(TValue item) { Item = item; } } Actor Class /// Represents a callback method to be executed by an Actor. /// The type of reply. /// The reply made by the actor. public delegate void ActorReplyCallback (TReply reply); /// Represents an Actor which receives and processes messages in concurrent applications. /// The type of message this actor accepts. /// The type of reply made by this actor. public abstract class Actor : IDisposable { /// The default total number of threads to process messages. private const Int32 DefaultThreadCount = 1; /// Used to serialize access to the message queue. private readonly Locker Locker; /// Stores the messages until they can be processed. private readonly System.Collections.Generic.Queue MessageQueue; /// Signals the actor thread to process a new message. private readonly ManualResetEvent PostEvent; /// This tells the actor thread to stop reading from the queue. private readonly ManualResetEvent DisposeEvent; /// Processes the messages posted to the actor. private readonly List ActorThreads; /// Initializes a new instance of the Genex.Concurrency&lt;TRequest, TResponse&gt; class. public Actor() : this(DefaultThreadCount) { } /// Initializes a new instance of the Genex.Concurrency&lt;TRequest, TResponse&gt; class. /// public Actor(Int32 thread_count) { if (thread_count (); EnqueueEvent = new ManualResetEvent(true); PostEvent = new ManualResetEvent(false); DisposeEvent = new ManualResetEvent(true); ActorThreads = new List (); for (Int32 i = 0; i Posts a message and waits for the reply. /// The message to post to the actor. /// The reply from the actor. public TReply PostWithReply(TMessage message) { using (var wrapper = new Message(message)) { lock (Locker) MessageQueue.Enqueue(wrapper); PostEvent.Set(); wrapper.Channel.CompleteEvent.WaitOne(); return wrapper.Channel.Value; } } /// Posts a message to the actor and executes the callback when the reply is received. /// The message to post to the actor. /// The callback that will be invoked once the replay is received. public void PostWithAsyncReply(TMessage value, ActorReplyCallback callback) { if (callback == null) throw new ArgumentNullException("callback"); ThreadPool.QueueUserWorkItem(state => callback(PostWithReply(value))); } /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() { if (DisposeEvent.WaitOne(10)) { DisposeEvent.Reset(); PostEvent.Set(); foreach (var thread in ActorThreads) { thread.Join(); } ((IDisposable)PostEvent).Dispose(); ((IDisposable)DisposeEvent).Dispose(); } } /// Processes a message posted to the actor. /// The message to be processed. protected abstract void ProcessMessage(Message message); /// Dequeues the messages passes them to ProcessMessage. private void ProcessMessages() { while (PostEvent.WaitOne() && DisposeEvent.WaitOne(10)) { var message = (Message)null; while (true) { lock (Locker) { message = MessageQueue.Count > 0 ? MessageQueue.Dequeue() : null; if (message == null) { PostEvent.Reset(); break; } } try { ProcessMessage(message); } catch { } } } } /// Represents a message that is passed to an actor. protected class Message : IDisposable { /// The actual value of this message. public TMessage Value { get; private set; } /// The channel used to give a reply to this message. public Channel Channel { get; private set; } /// Initializes a new instance of Genex.Concurrency.Message class. /// The actual value of the message. public Message(TMessage value) { Value = value; Channel = new Channel(); } /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() { Channel.Dispose(); } } /// Represents a channel used by an actor to reply to a message. protected class Channel : IDisposable { /// The value of the reply. public TReply Value { get; private set; } /// Signifies that the message has been replied to. public ManualResetEvent CompleteEvent { get; private set; } /// Initializes a new instance of Genex.Concurrency.Channel class. public Channel() { CompleteEvent = new ManualResetEvent(false); } /// Reply to the message received. /// The value of the reply. public void Reply(TReply value) { Value = value; CompleteEvent.Set(); } /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() { ((IDisposable)CompleteEvent).Dispose(); } } }
