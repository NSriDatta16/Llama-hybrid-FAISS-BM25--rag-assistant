[site]: stackoverflow
[post_id]: 4317986
[parent_id]: 4317694
[tags]: 
This isn't a very good design and I really can't even tell what this enum is trying to accomplish. To start with, you're using generic methods that each enum value implements, which means the caller of the method gets to decide what type they want T to be... but that's not what you want, because the methods are in fact opinionated about what types of objects they'll return. Class foo = ValueTransformer.VALUE_B.getReturnType(); String string = ValueTransformer.VALUE_A.createVo(String.class, ""); The above is totally legal given your code, but your code does not actually handle this. Generic methods don't do what you seem to think they do. I feel like what you actually want is just a simple way to transform objects of specific types to objects of type ValueA or ValueB . The simplest way to do this is just to have each class that can be transformed in this way provide a method that does that on each such class: public class CanBeTranslatedToB { ... public ValueB toValueB() { ValueB result = new ValueB(); ... return result; } } Then, if you have an instance of CanBeTranslatedToB , rather than doing: CanBeTranslatedToB foo = ... ValueB b = ValueTransformer.VALUE_B.createVo(ValueB.class, foo); you'd just do: CanBeTranslatedToB foo = ... ValueB b = foo.toValueB(); That's much clearer and not error-prone like the enum version. If necessary, you can do various things to make this easier such as making an interfaces that define the toValueA() and toValueB() methods and making helper classes to provide any common behavior that all implementations need to use. I don't see any use for an enum like you describe. Edit: If you can't change the code for the classes that need to be transformed to ValueB etc., you have several options. The simplest (and probably best, in my opinion) way to handle that would be to add factory methods to ValueA and ValueB such as: // "from" would be another good name public static ValueB valueOf(CanBeTranslatedToB source) { ... } public static ValueB valueOf(AnotherClassForB source) { ... } Then you can just write: CanBeTranslatedToB foo = ... ValueB b = ValueB.valueOf(foo); If you don't want those methods on ValueB , you could have them in another class with method names like newValueB(CanBeTranslatedToB) . Finally, another option would be to use Guava and create a Function for each conversion. This is the closest to your original design, but it is type safe and works well with all the Function -accepting utilities Guava provides. You could collect these Function implementations in classes as you see fit. Here's an example of a singleton implementing a conversion from Foo to ValueB : public static Function fooToValueB() { return FooToValueB.INSTANCE; } private enum FooToValueB implements Function { INSTANCE; @Override public ValueB apply(Foo input) { ... } } However, I wouldn't use this as the only way to do the conversion... it would be better to have the static valueOf methods I mentioned above and provide such Function s only as a convenience if your application needs to transform whole collections of objects at once a lot.
