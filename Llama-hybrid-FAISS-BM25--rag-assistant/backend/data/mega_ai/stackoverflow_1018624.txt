[site]: stackoverflow
[post_id]: 1018624
[parent_id]: 1018407
[tags]: 
This assumes that the index sequence is a monotone ascending sequence of non-negative indices. The strategy is straightforward: for each index, bump up an enumerator on the collection to that point and yield the element. public static IEnumerable GetIndexedItems (this IEnumerable collection, IEnumerable indices) { int currentIndex = -1; using (var collectionEnum = collection.GetEnumerator()) { foreach(int index in indices) { while (collectionEnum.MoveNext()) { currentIndex += 1; if (currentIndex == index) { yield return collectionEnum.Current; break; } } } } } Advantages of this solution over other solutions posted: O(1) in extra storage -- some of these solutions are O(n) in space O(n) in time -- some of these solutions are quadradic in time works on any two sequences; does not require ICollection or IList. only iterates the collection once; some solutions iterate the collection multiple times (to build a list out of it, for instance.) Disadvantages: harder to read
