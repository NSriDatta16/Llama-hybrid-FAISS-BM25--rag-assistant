[site]: stackoverflow
[post_id]: 680011
[parent_id]: 
[tags]: 
Finding Strings Neighbors By Up To 2 Differing Positions

Given a seed string, I want to find its neighbors with at most differ in 2 positions. All the digits involve in generating string are only four (i.e. 0,1,2,3). This is the example for what I mean: # In this example, 'first' column # are neighbors with only 1 position differ. # The rest of the columns are 2 positions differ Seed = 000 100 110 120 130 101 102 103 200 210 220 230 201 202 203 300 310 320 330 301 302 303 010 011 012 013 020 021 022 023 030 031 032 033 001 002 003 Seed = 001 101 111 121 131 100 102 103 201 211 221 231 200 202 203 301 311 321 331 300 302 303 011 010 012 013 021 020 022 023 031 030 032 033 000 003 002 Hence given a tag of length L we will have 3*L + 9L(L-1)/2 neighbors But why this code of mine fails to generate it correctly? Especially when the seed string is other than "000". Other approaches are also welcomed, escpecially with speed improvement. Since we will be processing millions of seed tags of length 34 to 36. #include #include #include #include using namespace std; string ConvertInt2String(int IntVal) { std::string S; std::stringstream out; out NTg) { string StTg = ""; for (unsigned i = 0; i void prn_vec(const std::vector &arg, string sep="") { for (unsigned n = 0; n neighbors(vector & arg, int posNo, int baseNo) { // pass base position and return neighbors vector transfVec; transfVec = arg; //modified according to strager's first post transfVec[posNo % arg.size()] = baseNo; return transfVec; } int main () { vector numTag; numTag.push_back(0); numTag.push_back(0); numTag.push_back(1); // If "000" this code works, but not 001 or others // Note that in actual practice numTag can be greater than 3 int TagLen = static_cast (numTag.size()); for ( int p=0; p nbnumTag = neighbors(numTag, p, bval); string SnbnumTag = Vec2Str(nbnumTag); cout nbnumTag2 = neighbors(nbnumTag, l, cval); string SnbnumTag2 = Vec2Str(nbnumTag2); cout
