[site]: stackoverflow
[post_id]: 1167915
[parent_id]: 1166408
[tags]: 
What you can do is download the source from the link you discovered on Code Project. Unzip it, load the solution in Visual Studio and compile it. This will give you source, an unmanaged c dll and a .lib file. You can P/Invoke the functions in this dll, (there are only 5 simple functions exported, of which you need only two) or you can use this dll, lib, and the SFMT header file to create a managed wrapper dll you can use in C# without P/Invoke. I just tried this method and it was very simple to do. There was no explicit marshalling involved. Here's how. Once you have downloaded and compiled the source (you need the header and the lib file that is created in addition to the dll) create a new C++ CLR Class Library project. Call it WrapSFMT or something. Go the project properties. Under C++/Precompiled Headers, change to "Not using precompiled headers." Under the Linker/General/Additional Library Directories, enter the path to the SFMT.lib. Under Linker/Input/Additional Dependencies, add SFMT.lib. Close the property pages. Copy SFMT.h to your project folder and include it in the project. Edit WrapSFMT.h to read as follows: #pragma once #include "SFMT.H" using namespace System; namespace WrapSFMT { public ref class SRandom { public:SRandom(UInt32); public:UInt32 Rand32(void); }; } These declare the methods that will be in your class. Now edit WrapSFMT.cpp to read: #include "WrapSFMT.h" namespace WrapSFMT { SRandom::SRandom(UInt32 seed) { init_gen_rand(seed); } UInt32 SRandom::Rand32() { return gen_rand32(); } } These implement the methods you declared in the header file. All you are doing is calling functions from the SFMT.dll, and C++/CLI is automatically handling the conversion from unmanaged to managed. Now you should be able to build the WrapSFMT.dll and reference it in your C# project. Make sure the SFMT.dll is in the path, and you should have no problems.
