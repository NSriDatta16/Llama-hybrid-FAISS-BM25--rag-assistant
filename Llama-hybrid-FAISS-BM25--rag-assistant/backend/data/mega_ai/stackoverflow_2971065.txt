[site]: stackoverflow
[post_id]: 2971065
[parent_id]: 2971037
[tags]: 
Using the is keyword in C# (in the manner you have demonstrated above) is almost always a code smell. And it stinks. The problem is that something which is supposed to only know about an ICar is now required to keep track of several different classes that implement ICar . While this works (as in it produces code that operates), it's poor design. You're going to start off with just a couple cars... class Driver { private ICar car = GetCarFromGarage(); public void FloorIt() { if (this.car is Bmw) { ((Bmw)this.car).AccelerateReallyFast(); } else if (this.car is Toyota) { ((Toyota)this.car).StickAccelerator(); } else { this.car.Go(); } } } And later on, another car is going to do something special when you FloorIt . And you'll add that feature to Driver , and you'll think about the other special cases that need to be handled, and you'll waste twenty minutes tracking down every place that there is a if (car is Foo) , since it's scattered all over the code base now -- inside Driver , inside Garage , inside ParkingLot ... (I'm speaking from experience in working on legacy code here.) When you find yourself making a statement like if (instance is SomeObject) , stop and ask yourself why this special behavior needs to be handled here. Most of the time, it can be a new method in the interface/abstract class, and you can simply provide a default implementation for the classes that aren't "special". That's not to say that you should absolutely never check types with is ; however, you must be very careful in this practice because it has a tendency to get out of hand and become abused unless kept in check. Now, suppose you have determined that you conclusively must type-check your ICar . The problem with using is is that static code analysis tools will warn you about casting twice, when you do if (car is Bmw) { ((Bmw)car).ShiftLanesWithoutATurnSignal(); } The performance hit is probably negligible unless it's in an inner loop, but the preferred way of writing this is var bmw = car as Bmw; if (bmw != null) // careful about overloaded == here { bmw.ParkInThreeSpotsAtOnce(); } This requires only one cast (internally) instead of two. If you don't want to go that route, another clean approach is to simply use an enumeration: enum CarType { Bmw, Toyota, Kia } interface ICar { void Go(); CarType Make { get; } } followed by if (car.Make == CarType.Kia) { ((Kia)car).TalkOnCellPhoneAndGoFifteenUnderSpeedLimit(); } You can quickly switch on an enum, and it lets you know (to some extent) the concrete limit of what cars might be used. One downside to using an enum is that CarType is set in stone; if another (external) assembly depends on ICar and they added the new Tesla car, they won't be able to add a Tesla type to CarType . Enums also don't lend themselves well to class hierarchies: if you want a Chevy to be a CarType.Chevy and a CarType.GM , you either have to use the enum as flags (ugly in this case) or make sure you check for Chevy before GM , or have lots of || s in your checks against the enums.
