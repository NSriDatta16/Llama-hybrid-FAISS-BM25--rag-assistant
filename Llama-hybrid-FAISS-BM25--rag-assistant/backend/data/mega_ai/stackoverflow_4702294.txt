[site]: stackoverflow
[post_id]: 4702294
[parent_id]: 
[tags]: 
NSURLConnection Hanging on Second Call

I'm building an iPhone app that aggregates data from several different data sources and displays them together in a single table. For each data source, I've created a class ( WeatherProvider , TwitterProvider ) that handles connecting to the datasource, download the data and storing it in an object. I have another class ConnectionManager , that instantiates and calls each of the two provider classes, and merges the results into a single NSArray which is displayed in the table. When I run the program calling just the WeatherProvider or just the TwitterProvider, it works perfectly. I can call each of those objects again and again to keep them up-to-date without a problem. I can also call TwitterProvider and then WeatherProvider without a problem. However, if I call WeatherProvider then TwitterProvider, the TwitterProvider hangs just as I call: [[NSURLConnection alloc] initWithRequest:request delegate:self]; . Other points: - it doesn't seem to matter how long between when I call WeatherProvider and TwitterProvider, TwitterProvider still hangs. - in WeatherProvider, I'm using NSXMLParser with NSAutoreleasePool to parse the output from the WeatherProvider. - ConnectionManager creates an instance of WeatherProvider and TwitterProvider when the application is started, and reuses those instances when the user requests a data refresh. - I ran the app with the activity monitor connected and it verifies that the app is basically just hanging. No CPU usage, or additional memory allocations or network activity seems to be happening. There's a bunch of code spread across a couple files, so I've tried to include the relevant bits (as far as I can tell!) here. I very much appreciate any help you can provide, even if it is just additional approaches to debugging. WeatherProvider -(void)getCurrentWeather: (NSString*)lat lon:(NSString*)lon lastUpdate:(double)lastUpdate { double now = [[NSDate date] timeIntervalSince1970]; NSString *noaaApiUrl; // don't update if current forecast is TwitterProvider -(void)getLocationTimeline:(NSString*)lat lon:(NSString*)lon lastUpdate:(double)lastUpdate refreshUrl:(NSString*)newUrl { NSString *updateURL; if(tweets.count > 1) [tweets removeAllObjects]; updateURL = [NSString stringWithFormat:@"http://search.twitter.com/search.json?geocode=%@,%@,1mi&rpp=%@&page=1", lat, lon, TWITTER_LOCAL_UPDATES_URL_RESULTS]; _serviceResponse = [[NSMutableData data] retain]; NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:updateURL]]; [[NSURLConnection alloc] initWithRequest:request delegate:self]; } #pragma mark - #pragma mark NSURLConnection delegate methods - (void)connectionDidFinishLoading:(NSURLConnection *)connection { NSString *responseString = [[NSString alloc] initWithData:_serviceResponse encoding:NSUTF8StringEncoding]; // parse tweets [responseString release]; [_serviceResponse release]; [connection release]; // tell our delegate that we're done! [[self delegate] twitterUpdaterComplete:tweets.count]; } - (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response { [_serviceResponse setLength:0]; } - (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data { [_serviceResponse appendData:data]; } - (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error { [connection release]; [[self delegate] twitterUpdaterError:error]; }
