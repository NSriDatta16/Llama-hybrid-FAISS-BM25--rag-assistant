[site]: stackoverflow
[post_id]: 4268000
[parent_id]: 
[tags]: 
Preserving multiple xsd:any with JAXB using @XmlAnyElement

How can I support interleaved unknown XML using JAXB? Using @XmlAnyElement does not seem to be up to the job.. I am attempting to write an XML schema to allow interleaved elements from other namespaces, and use this with the built-in JAXB in Java 6. (I've not tried this fully with JAXB 2.2.1, as I don't have the luxury of requring my API users to do magic to endorse JAXB libraries, but I believe it does not work with 2.2.1 either) So, for instance, given the schema anything.xsd , this example.xml should be valid: before rootFile after rootFile Any XML from other namespaces should be allowed both before and after . Schema-wise this is quite straight forward using elements before and after the for . Interleaved around optional elements is trickier, but that's a separate post. Trick is to make a wrapping group optional instead: I've added jaxb:property to specify different property names for the before/after any-properties. I had to do this to avoid XJC complaining about Property "Any" is already defined . The problem is that JAXB seems to chuck all unknown elements of into the anyBefore property, as seen when marshalling out again the unmarshalled element (see the complete example Maven Project ): before rootFile after rootFile This makes it impossible to inspect rootFiles.getAnyAfter() to see which unknowns came where, but more seriously for me, impossible to serialize the XML out again without messing about the interleaved XML. XJC does correctly create two any -properties: @XmlAccessorType(XmlAccessType.FIELD) @XmlType(name = "", propOrder = { "anyBefore", "rootFile", "anyAfter" }) public static class RootFiles { @XmlAnyElement(lax = true) protected List anyBefore; @XmlElement(required = true) protected List rootFile; @XmlAnyElement(lax = true) protected List anyAfter; The JavaDoc for XmlAnyElement says: This annotation is mutually exclusive with XmlElement, XmlAttribute, XmlValue, XmlElements, XmlID, and XmlIDREF. There can be only one XmlAnyElement annotated JavaBean property in a class and its super classes. From this I've concluded that JAXB doesn't really care about the second @XmlAnyElement , and just places all direct unknowns into the first any property. I'm stuck as to what to do. Note that my main concern is to preserve the unknown elements in the right location (the order seems to be preserved), I don't particularly care about parsing them, just ensure they are somewhat in the same place when serialising the XML again after some modifications to the elements. Now you might wonder why I would design such a silly schema allowing random XML all over the place. It is unfortunately not my fault, I'm simply trying to manually convert this RELAX NG schema from the Adobe UCF specifications to an XML schema I can use with JAXB. The problem is this wording which allows any foreign XML elements and attributes in META-INF/container.xml: Conforming UCF User Agents MUST ignore unrecognized elements (and their contents) and unrecognized attributes in a container.xml file, including unrecognized elements and unrecognized attributes from other namespaces. Conforming container.xml files MUST be valid according to the RELAX NG UCF schema with the element as the root element after removing all elements (and child nodes of these elements) and attributes from other namespaces. Now I could of course just delete any such elements as it says I can ignore them, but I thought that if in the future or some extension they meant something, at least I could preserve such elements correctly.. However I find this difficult using JAXB. Are there any suggestions on how I can achieve this, like some magic properties to the Marshaller/Unmarshaller?
