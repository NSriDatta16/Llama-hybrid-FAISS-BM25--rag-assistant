[site]: stackoverflow
[post_id]: 2286148
[parent_id]: 2284594
[tags]: 
What happens here? Does it just grab an instance of the EJB from the application server's EJB pool? A JAX-WS web component endpoint (as opposed to a JAX-WS EJB endpoint) follows the typical servlet threading model, which means that typically there is one instance that is executed concurrently for each client. JAX-WS implementations are free to leverage pools of bean instances to handle a request in a fashion similar to stateless session EJB components. (source: Developing Applications for the Java TM EE Platform FJ-310). In all cases, it is fine to inject/look-up stateless beans because the container guarantees that the beans will always be thread safe. In affect, the container automatically serializes clients calls but uses instance pooling to make sure you still get concurrency benefits. If there is more than 1 EJB deployed to the server, how does it know which one to grab? Hmm... I didn't get this one. Can you clarify what you mean exactly? Why would there be any ambiguity? Where is the jndi lookup to the database done (maybe in the persistence.xml file)? In a Java EE environment, you specify your data source in a element in each persistence unit of the persistence.xml file (which can contain several persistence units) and the data source will be obtained by the EntityManager (only when needed, i.e. only if a data access is really needed). Do all of the EJBs share a common EntityManager ? No. The EntityManager is a non-thread-safe object that should be used once, for a single business process, a single unit of work, and then discarded. In a Java EE environment using EJB 3, the default pattern is "entitymanager-per-request". A request from the client is send to the EJB 3 persistence layer, a new EntityManager is opened, and all database operations are executed in this unit of work. Once the work has been completed (and the response for the client has been prepared), the persistence context is flushed and closed, as well as the entity manager object. (source: Chapter 4. Transactions and Concurrency ).
