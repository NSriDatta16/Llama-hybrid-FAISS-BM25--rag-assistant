[site]: stackoverflow
[post_id]: 5603829
[parent_id]: 5602863
[tags]: 
TL;DR Check the function sumIt_walk . It saves a static array where it builds the output and gives a simple mechanism of retrieving it. using array_walk traversal goes down to for the test case where foreach does 60s , on an array with 1.000.000 items. After seeing the above test case takes ~1minute to complete, I realized the approach was fundamentally flawed. I suspected the reason the array takes so long is due to memory swaps( further reading if you're interested ), I took the liberty of making a recursive function to pass to array_walk() that speeds up the process considerably (~5s as opposed to ~55). function sumIt_walk($item,$key,$return=false){ static $sum=array(); if($return){ // just to make it reusable $r=$sum; $sum=array(); return $r; } if(!isset($item['label']))return array_walk($item,'sumIt_walk'); $key=$item['label']; if(!isset($sum[$key]))$sum[$key]=array(0,0); $sum[$key][0]+=$item['eaten']; $sum[$key][1]+=$item['noteaten']; } I have also created 3 test cases with different approaches. The third one being a direct recursive function that's not passed being passed to array_walk. The results are remarkable: Rendering sample array took 4.257504940033 s. TEST CASE: foreach apples 16668129 16665262 bananas 16656715 16659333 oranges 16676978 16668761 Traversing array took 68.361897945404 s. Output took 1.3828277587891E-5 s. TEST CASE: array_walk apples 16668129 16665262 bananas 16656715 16659333 oranges 16676978 16668761 Traversing array took 3.6125140190125 s. Output took 1.3113021850586E-5 s. TEST CASE: recursive apples 16668129 16665262 bananas 16656715 16659333 oranges 16676978 16668761 Traversing array took 53.461534976959 s. Output took 1.3828277587891E-5 s. As you can see array_walk slices of 50s from the traversal time. Goes to show, built-in functions are awesome. '; function getSampleArray($days, $postsperday){ $arr=array(); $fruits=array('apples','bananas','oranges'); for($i=0;$i $fruits[rand(0,2)], 'eaten'=>rand(0,100), 'noteaten'=>rand(0,100), 'rotten'=>rand(0,100)); } $arr[date('Ymd',$i*60*60*24)]=$thisday; } return $arr; } function sumIt($arr, $return=false){ static $sum=array(); if($return){ // just to make it reusable $r=$sum; $sum=array(); return $r; } if(!isset($arr['label'])){ foreach($arr as $data)sumIt($data); return; } $key=$arr['label']; if(!isset($sum[$key]))$sum[$key]=array(0,0); $sum[$key][0]+=$arr['eaten']; $sum[$key][1]+=$arr['noteaten']; } function sumIt_walk($item,$key,$return=false){ static $sum=array(); if($return){ // just to make it reusable $r=$sum; $sum=array(); return $r; } if(!isset($item['label']))return array_walk($item,'sumIt_walk'); $key=$item['label']; if(!isset($sum[$key]))$sum[$key]=array(0,0); $sum[$key][0]+=$item['eaten']; $sum[$key][1]+=$item['noteaten']; } $timer=microtime(true); $result=getSampleArray(1000,1000); $rendersampledata=microtime(true)-$timer; echo 'Rendering sample array took '.$rendersampledata.' s.'."\n"; $testCases=array('foreach','array_walk','recursive'); for($i=0;$i $value){ echo $label.' '.$value[0].' '.$value[1]."\n"; } $outputtime = microtime(true) - $timer; echo 'Traversing array took '.$traversearray.' s. In test case '.$testCases[$i]."\n"; echo 'Output took '.$outputtime.' s. In test case '.$testCases[$i]."\n"; echo "\n\n"; } If you can slice even more computational time from that function, I urge you to post it here so we can have a reference. P.S. I thought about creating mix-matches of the three test-cases (foreach-recursive, array_walk-foreach,etc) But array_walk just seems to blow everything away and not merit any new test cases.
