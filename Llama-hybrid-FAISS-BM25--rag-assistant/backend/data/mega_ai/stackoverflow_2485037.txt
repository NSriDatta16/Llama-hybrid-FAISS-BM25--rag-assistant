[site]: stackoverflow
[post_id]: 2485037
[parent_id]: 2444339
[tags]: 
I think what I would do is pass a list of parameters, values, and delegates to the BackgroundWorker . That way you can write the assign-back code "synchronously" but have execution deferred until the values are actually retrieved. Start with a "request" class that looks something like this: class ParameterUpdate { public ParameterUpdate(string name, string value, Action callback) { this.Name = name; this.Value = value; this.Callback = callback; } public string Name { get; private set; } public string Value { get; set; } public Action Callback { get; private set; } } Then write your async code to use this: private void bwUpdateParameters_DoWork(object sender, DoWorkEventArgs e) { var updates = (IEnumerable )e.Argument; foreach (var update in updates) { WriteDeviceParameter(update.Name, update.Value); update.Value = ReadDeviceParameter(update.Name); } e.Result = updates; } private void bwUpdateParameters_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e) { var updates = (IEnumerable )e.Argument; foreach (var update in updates) { if (update.Callback != null) { update.Callback(update.Value); } } } Here's how you would kick off the update. Let's say you've got a bunch of member fields that you want to update with the actual values of the parameters that were used: // Members of the Form/Control class private string bandwidth; private string inputAttenuation; private string averaging; // Later on, in your "update" method var updates = new List { new ParameterUpdate("Bandwidth", "3000", v => bandwidth = v), new ParameterUpdate("InputAttenuation", "10", v => inputAttenuation = v), new ParameterUpdate("Averaging", "Logarithmic", v => averaging = v) }; bwUpdateParameters.RunWorkerAsync(updates); That's all you have to do. All of the actual work is done in the background, but you're writing simple variable-assignment statements as if they were in the foreground. The code is short, simple, and completely thread-safe because the actual assignments are executed in the RunWorkerCompleted event. If you need to do more than this, such as update controls in addition to variables, it's very simple, you can put anything you want for the callback, i.e.: new ParameterUpdate("Bandwidth", "3000", v => { bandwidth = v; txtBandwidth.Text = v; }) Again, this will work because it's not actually getting executed until the work is completed.
