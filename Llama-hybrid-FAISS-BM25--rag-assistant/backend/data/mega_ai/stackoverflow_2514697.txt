[site]: stackoverflow
[post_id]: 2514697
[parent_id]: 2514544
[tags]: 
First off, you have to understand that CPU usage is always an average over a certain time. At any given time, the CPU is either working or it is not. The CPU is never 40% working. We can, however, simulate a 40% load over say a second by having the CPU work for 0.4 seconds and sleep 0.6 seconds. That gives an average utilization of 40% over that second. Cutting it down to smaller than one second, say 100 millisecond chunks should give even more stable utilization. The following method will take an argument that is desired utilization and then utilize a single CPU/core to that degree: public static void ConsumeCPU(int percentage) { if (percentage 100) throw new ArgumentException("percentage"); Stopwatch watch = new Stopwatch(); watch.Start(); while (true) { // Make the loop go on for "percentage" milliseconds then sleep the // remaining percentage milliseconds. So 40% utilization means work 40ms and sleep 60ms if (watch.ElapsedMilliseconds > percentage) { Thread.Sleep(100 - percentage); watch.Reset(); watch.Start(); } } } I'm using a stopwatch here because it is more accurate than the the TickCount property, but you could likewise use that and use subtraction to check if you've run long enough. Two things to keep in mind: on multi core systems, you will have to spawn one thread for each core. Otherwise, you'll see only one CPU/core being exercised giving roughly "percentage/number-of-cores" utilization. Thread.Sleep is not very accurate. It will never guarantee times exactly to the millisecond so you will see some variations in your results To answer your second question, about changing the utilization after a certain time, I suggest you run this method on one or more threads (depending on number of cores) and then when you want to change utilization you just stop those threads and spawn new ones with the new percentage values. That way, you don't have to implement thread communication to change percentage of a running thread.
