[site]: stackoverflow
[post_id]: 4979854
[parent_id]: 4890383
[tags]: 
I assume you can find a point in the space that is in the territory. Call that Z. (Since you have several cities, you could pick an average city location as being sort of central.) Given the starting point Z, what I'd consider doing is generating a set of rays outward from that point, each ray having a lower and upper bound on size, and the set growing in number to get detail. I've sketched a scheme below. Nothing about it tested; feel free to suggest improvements. Each ray is represented by an angle Theta, and has an origin Z. Rather than one length, each ray has two associated lengths, Inside and Outside, which we're going to try to converge. The initial value of Inside is set to 0 and outside set to a value larger than the radius any possible territory ("Horizon"); we'll shrink Outside till it is inside the territory, and grow Inside until it is not quite outside the territory, using binary search (log2 N in the diameter of your game space). We also going to increase the number of rays as the end points spread out to acquire territory boundary detail. The final result is supposed to be a set of rays that establish a bound around the territory whose endpoints are no more than "spacing" apart. You can start with just one ray (theta=North(0), Inside=0, Outside=Horizon). Lets call the set of rays R. We assume the set of rays R is sorted by theta, and if we have a ray r from R, that next(r) is the next ray in the sorted set, with next(r) for the last ray in R being the first ray in the set. Since you know city locations, you might seed the set with rays having cities as Inside points. It should work either way. An additional parameter "threshold" gives you the degree of precision of your answer. R = empty add_to_R(0,0,Horizon) repeat until done done = true for each ray r in R guess = average(Inside(r),Outside(r)) if guess>threshold then done = false if interritory(Z+(Theta(r),guess)) then Inside(r)=guess else Outside(r)=guess for each ray r in R if (distance(Inside(r),Inside(next(r)))> spacing then add_to_R(average(Theta(r),Theta(next(r)), min(Inside(r),Inside(next(r)), max(Outside(r),Outside(next(r)) end The running cost should be log 2 in your maximum territory diameter, with a multiplier having to do with the circumference of the territory divided by the ray end-point spacing chosen. This scheme isn't perfect; it will fail in the presence of peninsulas of the territory that a ray happens to cross by not sampling within the peninsula. If peninsulas are arbitrarily thin, it would take arbitrarily many samples to discover them. You can perhaps choose a peninsula minimum width, and then adjust the algorithm to step outward when it finally finds a converged ray, in peninsula widths to make sure it hasn't goofed.
