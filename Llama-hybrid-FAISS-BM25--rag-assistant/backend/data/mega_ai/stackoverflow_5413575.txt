[site]: stackoverflow
[post_id]: 5413575
[parent_id]: 5410936
[tags]: 
What you would need, in terms of ingredients, would be: a method to download the updates - I would suggest HTTP(S) for that a method to encode the license, including what kind of updates you're entitled to and how long you're entitled to it. Ideally, this would be opaque to the user but easily verifiable on both ends (so an erroneous entry can be notified to the user without having to contact the server) an easy way to know whether updates are available, and perhaps when to check again What I would suggest would be to define a simple XML over HTTP service using an embeddable HTTP client, such as (shameless plug) Arachnida , with a simple API - something like: class UpdateAgent { /* boilerplate */ public : /* set the key to use. Throws an InvalidKey exception if not valid * validity is checked locally - no HTTP queries are used. * Key may have been invalidated on the server without notification * at this point */ void setKey(const std::string &key); // Get the key currently set std::string getKey() const; /* using a synchronous HTTPS query, check with the server if updates are * available for the current key. Throws on error: one of the QueryError * subclasses if there has been a query error, or InvalidKey is the * key is either not set or is not valid (i.e. invalidated server-side) */ bool isUpdateAvailable() const; /* etc. */ }; They key itself would, as seen above, be a string that, through its encoding, would contain some kind of information as to its validity - e.g. some kind of CRC to know whether the entered string is valid. The rest of the key - including its expiration date - could be managed server-side, although expiration information could also be encoded in the key itself (but that would mean changing the key if the user extends the license). As for the server-side, when presented with a key and a request for an update, the server would check the validity of the key check whether any updates are available for the software the key is for (information that may or may not be part of the key itself, depending on whether you want to manage it in a database or want it to be part of the license key) copy or hardlink the file into a place it can be downloaded, with a unique and hard-to-guess name provide the URL for download to the client - e.g. in an XML stream returned for the HTTP request start a time-out to remove the file after it hasn't been downloaded for N seconds/minutes/hours remove the file once it has been downloaded by the client If a download fails, it can be restarted or asked for again. If you want to charge for individual downloads, you'd need the client to confirm a successful download - or report an error on failure - so you don't count individual downloads twice. Of course, all this is off the top of my head - there might be some details I haven't thought of here. Each of the ingredients are pretty easy to come by. An open source version of Arachnida is available on SourceForge and I have some code to encode license keys if you need it (used it for another of my products), but I'm sure that you can write that if you don't want to use mine. A few things you might want to think of are secure authentication of your clients - so they don't share license keys - securing your HTTP connection so you don't end up publishing your updates to the world, etc. Neither the server nor the client need be very complicated to implement, as most of the building blocks already exist. HTH rlc
