[site]: stackoverflow
[post_id]: 1198026
[parent_id]: 1196203
[tags]: 
Firstly, I agree with those that suggest having a finalizer as a backup, but try to avoid it ever being called by explicitly calling myClass.Dispose or through 'using'. e.g. var myClass = new MyClass() try { //do stuff } finally { myClass.Dispose(); } or using (var myClass = new MyClass()) { //do stuff } Marshall.ReleaseComObject If you are using lots of COM objects, I also suggest you use Mashall.ReleaseComObject(comObj) to explicitly clean up references to the RCW. So, the code like this suggested elsewhere: if (comInstance != null) { comInstance.FreeStuff(); comInstance = null; } would become: if (comInstance != null) { comInstance.FreeStuff(); int count = Marshall.ReleaseComObject(comInstance); if (count != 0) { Debug.Assert(false, "comInstance count = " + count); Marshal.FinalReleaseComObject(comInstance); } comInstance = null; } While checking the return value of ReleaseComObject() is not strictly necessary, I like to check it to make sure things are being incremented/decremented as expected. The 2-dot rule If you decide to use this, something to be aware of is that some code may need to be refactored to properly release your COM objects. One in particular is what I call the 2-dot rule. Any line using COM objects that contain 2 dots needs close attention. For example, var name = myComObject.Address.Name; In this statement we get a reference to the Address COM object incrementing its RCW reference count, but we don't have an opportunity to call ReleaseComObject. A better way to do it would be to break it down (try..finally omitted for clarity): var address = myComObject.Address; var name = address.Name; MyReleaseComObject(address); where MyReleaseComObject is a utility method wrapping my count check and FinalReleaseComObject() from above.
