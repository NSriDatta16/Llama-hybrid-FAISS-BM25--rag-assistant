[site]: stackoverflow
[post_id]: 1393199
[parent_id]: 1392932
[tags]: 
Well, considering the "new package" is actually the class: org.eclipse.jdt.internal.ui.wizards.NewPackageCreationWizard which uses NewPackageWizardPage (source code) , you will see: public void init(IStructuredSelection selection) { IJavaElement jelem = getInitialJavaElement(selection); initContainerPage(jelem); String pName = ""; //$NON-NLS-1$ if (jelem != null) { IPackageFragment pf = (IPackageFragment) jelem .getAncestor(IJavaElement.PACKAGE_FRAGMENT); if (pf != null && !pf.isDefaultPackage()) pName = pf.getElementName(); } setPackageText(pName, true); updateStatus(new IStatus[] { fContainerStatus, fPackageStatus }); } With the getInitialJavaElement() being part of superclass NewContainerWizardPage : /** * Utility method to inspect a selection to find a Java element. * * @param selection the selection to be inspected * @return a Java element to be used as the initial selection, or null , * if no Java element exists in the given selection */ protected IJavaElement getInitialJavaElement( IStructuredSelection selection) { IJavaElement jelem = null; if (selection != null && !selection.isEmpty()) { Object selectedElement = selection.getFirstElement(); if (selectedElement instanceof IAdaptable) { IAdaptable adaptable = (IAdaptable) selectedElement; jelem = (IJavaElement) adaptable .getAdapter(IJavaElement.class); if (jelem == null) { IResource resource = (IResource) adaptable .getAdapter(IResource.class); if (resource != null && resource.getType() != IResource.ROOT) { while (jelem == null && resource.getType() != IResource.PROJECT) { resource = resource.getParent(); jelem = (IJavaElement) resource .getAdapter(IJavaElement.class); } if (jelem == null) { jelem = JavaCore.create(resource); // java project } } } } } if (jelem == null) { IWorkbenchPart part = JavaPlugin.getActivePage() .getActivePart(); if (part instanceof ContentOutline) { part = JavaPlugin.getActivePage().getActiveEditor(); } if (part instanceof IViewPartInputProvider) { Object elem = ((IViewPartInputProvider) part) .getViewPartInput(); if (elem instanceof IJavaElement) { jelem = (IJavaElement) elem; } } } if (jelem == null || jelem.getElementType() == IJavaElement.JAVA_MODEL) { try { IJavaProject[] projects = JavaCore.create( getWorkspaceRoot()).getJavaProjects(); if (projects.length == 1) { jelem = projects[0]; } } catch (JavaModelException e) { JavaPlugin.log(e); } } return jelem; } Between those two methods, you should be able to initialize your custom UI with the exact information (i.e., "relative source path") you want. If you look at the source of DirectoryFieldEditor , you will see it open its directory chooser dialog based on the value if its main Text field defined in StringFieldEditor : doLoad (): String JavaDoc value = getPreferenceStore().getString(getPreferenceName()); textField.setText(value); That means you need, in your custom UI, to get the preference store and associate the right path with an id. You will use that id for your DirectoryFieldEditor initialization. Y oucan see an example here . public static final String MY_PATH = "my.init.path"; IPreferenceStore store = myPlugin.getDefault().getPreferenceStore(); store.setValue(MY_PATH, theRightPath); myDirFieldEditor = new DirectoryFieldEditor(MY_PATH, "&My path", getFieldEditorParent()); As you mention in the comments, all this will only initialize the eclipse-part GUI, not the native windows explorer launched by a DirectoryDialog : this (the native interface) is based on: parameters stored in BROWSEINFO Structure used by the actual GUI SHBrowseForFolder Function , which actually displays a dialog box that enables the user to select a Shell folder. That GUI initialize a root path based on filter path, so you need to also initialize (on eclipse side) that filter field with a path in order to get it pick up by the Windows-GUI SHBrowseForFolder . According to DirectoryFieldEditor, that is exactly what getTextControl() (the field you initialized above) is for. But the problem comes from the fact that field has been initialized with a relative path. Since that path is unknown by the underlying OS, it defaults back to root OS path. You need to find a way to store the full system path of the project, not the relative path. That way, that full path will be recognized by the Os and used as initial path. For instance, from a IJavaElement , you can get its associated resource, and try to get the (full system) path from there. Actually, from the IPackageFragment you should be able to call getPath() , and check if the IPath returned contains the full system path.
