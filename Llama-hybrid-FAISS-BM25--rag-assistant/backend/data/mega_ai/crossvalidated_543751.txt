[site]: crossvalidated
[post_id]: 543751
[parent_id]: 
[tags]: 
Using Autoencoders to denoise timeseries

I've been trying to use Autoencoders to denoise time series using R. In my script, I create a function that receives the series to be denoised (as a vector) and the number of lagged observations numLag that will be used to denoise each observation (like a moving average window). First, I create a dataframe df in which each column is a lagged version of series . For instance, if numLag equals 10, than df will have 11 columns. After that, I fit an Autoencoder to df and then use the encoder to obtain denoised values for my time series. Here's the function: AE_smooth = function(numLag = 10, numEpoch = 500, batchSize = 32, act = "sigmoid", series){ df = data.frame(series = series) for(i in 1:numLag){ lag = paste0("lag",i) df[,lag] = data.table::shift(series,i) } df = na.omit(df) |> as.matrix() input = layer_input(shape = numLag) encoded = input |> layer_dense(units = 1, activation = act) decoded = encoded |> layer_dense(units = numLag, activation = act) autoencoder = keras_model(input, decoded) encoder = keras_model(input, encoded) autoencoder |> compile( optimizer = optimizer_adam(), loss = 'mean_squared_error' ) autoencoder |> fit( # Fitting model df[,-1],df[,-1], epochs = numEpoch, batch_size = batchSize, shuffle = FALSE, validation_data = list(df[,-1],df[,-1]), verbose = 1 ) smooth = predict(encoder,df[,-1]) |> as.vector() smooth = c(rep(NA,numLag),smooth) return(smooth) } The problem is: in addition to not being able to smooth properly, the function ends up returning different smoothed series for the same hyperparameters. I chose a certain set of hyperparameters and ran the exact same model 12 different times until convergence, but sometimes I get a denoised series (red) like this: and other times I get some kind of inversion of the denoised series: Any ideas on how I can improve my model? Thanks in advance!
