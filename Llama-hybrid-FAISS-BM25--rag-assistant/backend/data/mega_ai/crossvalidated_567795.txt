[site]: crossvalidated
[post_id]: 567795
[parent_id]: 567737
[tags]: 
From the fragmentary and undocumented R code you show, I suppose you want to do a two-sided, one-sample t test at level $\alpha = 0.05$ based on a sample from a normal population with standard deviation $\sigma=1.91$ and hope for power $0.80$ to detect a difference in population means of $1.$ Several methods are in common use, and they may give slightly different answers. Find sample size necessary to get power 80% using a comparable z-test. When the required $n$ is 30 or larger, the result will be approximately correct. Use an exact formula for the power of such a t test, based on a non-central t distribution. Many intermediate level applied statistics texts and mathematical statistics texts show the formula, and software such as R will do the necessary computation for the noncentral t distribution. Many statistical computer programs have 'power and sample' size procedures; most use the noncentral t distribution. Simulation of many t tests for normal data of a trial sample size $n$ from a population with appropriate $\mu$ and $\sigma$ to find the proportion that reject (approximate power). You have already seen computer output from R. Below is output from a recent release of Minitab statistical software. It gives $n = 31$ as the desired sample size--in agreement with your result from R. Power and Sample Size 1-Sample t Test Testing mean = null (versus ≠ null) Calculating power for mean = null + difference α = 0.05 Assumed standard deviation = 1.91 Sample Target Difference Size Power Actual Power 1 31 0.8 0.805289 Finally, here is a simulation in R, showing that (in appropriate circumstances) $n = 31$ gives power about 80%. [I use a 'for' loop because it seems to be more widely understood than more elegant structures in R. With $m = 10\,000$ iterations one can expect about two decimal places of accuracy.] set.seed(314) n = 31; mu.0 = 100; mu.a = 101; sg = 1.91 m = 10000; t.stat = numeric(m) for(i in 1:m) { x = rnorm(n, mu.a, sg) t.stat[i] = ( mean(x) - mu.0 )/( sd(x)/sqrt(n) ) } c = qt(.975, n-1); c # critical value [1] 2.042272 mean(abs(t.stat) >= c) # aprx power [1] 0.8037 Note: If discrepancies among the various formulas and computational methods you used are small, that may be due to rounding errors or approximations. If discrepancies are large, you need to verify you have correct formulas and are using correct syntax in programs.
