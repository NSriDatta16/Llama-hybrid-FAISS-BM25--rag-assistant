[site]: stackoverflow
[post_id]: 5298559
[parent_id]: 
[tags]: 
C Prog - Keeping a web server constantly listening

I am trying to learn winsock programming using online tutorials. This example is from the MSDN library, although modified. I have compiled it and it seems to be working fine for only one request. After handling a single request the server exits. I have read handling multiple request and making the server persistent can be done through threads, but have no idea how do so and no helpful examples found over the internet. Please help. #undef UNICODE #define WIN32_LEAN_AND_MEAN #include #include #include #include #include // Need to link with Ws2_32.lib #pragma comment (lib, "Ws2_32.lib") // #pragma comment (lib, "Mswsock.lib") #define DEFAULT_BUFLEN 4096 #define DEFAULT_PORT "27015" char recvbuf[DEFAULT_BUFLEN]; void handleBuffer() { recvbuf[DEFAULT_BUFLEN-1]='\0'; printf("\n************The server has received the following request***************\n"); printf("%s",recvbuf); } int __cdecl main(void) { WSADATA wsaData; SOCKET ListenSocket = INVALID_SOCKET, ClientSocket = INVALID_SOCKET; struct addrinfo *result = NULL,hints; char* sendbuf = "HTTP/1.0 200 OK\r\nServer: Test\r\nContent-Type: text/HTML\r\n\r\n Test Server This is test server responding. "; int iResult, iSendResult; int recvbuflen = DEFAULT_BUFLEN; char e; // Initialize Winsock iResult = WSAStartup(MAKEWORD(2,2), &wsaData); if (iResult != 0) { printf("WSAStartup failed with error: %d\n", iResult); return 1; } else printf("\nInitialising winsock...done"); ZeroMemory(&hints, sizeof(hints)); hints.ai_family = AF_INET; hints.ai_socktype = SOCK_STREAM; hints.ai_protocol = IPPROTO_TCP; hints.ai_flags = AI_PASSIVE; printf("\n"); // Resolve the server address and port iResult = getaddrinfo(NULL, DEFAULT_PORT, &hints, &result); if ( iResult != 0 ) { printf("getaddrinfo failed with error: %d\n", iResult); WSACleanup(); return 1; } else printf("\nResolving server address...done"); //localhost:27015/ // Create a SOCKET for connecting to server ListenSocket = socket(result->ai_family, result->ai_socktype, result->ai_protocol); if (ListenSocket == INVALID_SOCKET) { printf("socket failed with error: %ld\n", WSAGetLastError()); freeaddrinfo(result); WSACleanup(); return 1; } else printf("\nCreating connection socket...done"); // Setup the TCP listening socket iResult = bind( ListenSocket, result->ai_addr, (int)result->ai_addrlen); if (iResult == SOCKET_ERROR) { printf("bind failed with error: %d\n", WSAGetLastError()); freeaddrinfo(result); closesocket(ListenSocket); WSACleanup(); return 1; } else printf("\nCreating listening socket...done"); printf("\nWaiting for connection... "); freeaddrinfo(result); iResult = listen(ListenSocket, SOMAXCONN); if (iResult == SOCKET_ERROR) { printf("listen failed with error: %d\n", WSAGetLastError()); closesocket(ListenSocket); WSACleanup(); return 1; } // Accept a client socket ClientSocket = accept(ListenSocket, NULL, NULL); if (ClientSocket == INVALID_SOCKET) { printf("accept failed with error: %d\n", WSAGetLastError()); closesocket(ListenSocket); WSACleanup(); return 1; } // No longer need server socket closesocket(ListenSocket); iResult = recv(ClientSocket, recvbuf, recvbuflen,0); if (iResult > 0) { printf("Bytes received: %d\n", iResult); } else if (iResult == 0) printf("Connection closing...\n"); else { printf("recv failed with error: %d\n", WSAGetLastError()); closesocket(ClientSocket); WSACleanup(); return 1; } iSendResult = send(ClientSocket,sendbuf,(int)strlen(sendbuf), 0 ); if (iSendResult == SOCKET_ERROR) { printf("send failed with error: %d\n", WSAGetLastError()); closesocket(ClientSocket); WSACleanup(); return 1; } printf("Bytes sent: %d\n", iSendResult); handleBuffer(); // shutdown the connection since we're done iResult = shutdown(ClientSocket, SD_SEND); if (iResult == SOCKET_ERROR) { printf("shutdown failed with error: %d\n", WSAGetLastError()); closesocket(ClientSocket); WSACleanup(); return 1; } // cleanup closesocket(ClientSocket); WSACleanup(); printf("\n\nPress any key to quit."); getch(); return 0; }
