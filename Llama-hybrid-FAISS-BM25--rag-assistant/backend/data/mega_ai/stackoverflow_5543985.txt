[site]: stackoverflow
[post_id]: 5543985
[parent_id]: 5542927
[tags]: 
I would rewrite the test as IF CASE WHEN EXISTS (SELECT ...) THEN CASE WHEN EXISTS (SELECT ...) THEN 1 END END = 1 This guarantees short circuiting as described here but does mean you need to select the cheapest one to evaluate up front rather than leaving it up to the optimiser. In my extremely limited tests below the following seemed to hold true when testing 1. EXISTS AND EXISTS The EXISTS AND EXISTS version seems most problematic. This chains together some outer semi joins . In none of the cases did it re-arrange the order of the tests to try and do the cheaper one first ( an issue discussed in the second half of this blog post ). In the IF ... version it wouldn't have made any difference if it had as it did not short circuit. However when this combined predicate is put in a WHERE clause the plan changes and it does short circuit so that rearrangement could have been beneficial. /*All tests are testing "If False And False"*/ IF EXISTS(SELECT COUNT(*) FROM master..spt_monitor HAVING COUNT(*)=2) AND EXISTS (SELECT COUNT(*) FROM master..spt_values HAVING COUNT(*)=1) PRINT 'Y' /* Table 'spt_values'. Scan count 1, logical reads 9 Table 'spt_monitor'. Scan count 1, logical reads 1 */ IF EXISTS (SELECT COUNT(*) FROM master..spt_values HAVING COUNT(*)=1) AND EXISTS(SELECT COUNT(*) FROM master..spt_monitor HAVING COUNT(*)=2) PRINT 'Y' /* Table 'spt_monitor'. Scan count 1, logical reads 1 Table 'spt_values'. Scan count 1, logical reads 9 */ SELECT 1 WHERE EXISTS(SELECT COUNT(*) FROM master..spt_monitor HAVING COUNT(*)=2) AND EXISTS (SELECT COUNT(*) FROM master..spt_values HAVING COUNT(*)=1) /* Table 'Worktable'. Scan count 0, logical reads 0 Table 'spt_monitor'. Scan count 1, logical reads 1 */ SELECT 1 WHERE EXISTS (SELECT COUNT(*) FROM master..spt_values HAVING COUNT(*)=1) AND EXISTS(SELECT COUNT(*) FROM master..spt_monitor HAVING COUNT(*)=2) /* Table 'Worktable'. Scan count 0, logical reads 0 Table 'spt_values'. Scan count 1, logical reads 9 */ The plans for all these appear very similar. The reason for the difference in behaviour between the SELECT 1 WHERE ... version and the IF ... version is that for the former one if the condition is false then the correct behaviour is to return no result so it just chains the OUTER SEMI JOINS and if one is false then zero rows carry forward to the next one. However the IF version always needs to return a result of 1 or zero. This plan uses a probe column in its outer joins and sets this to false if the EXISTS test is not passed (rather than simply discarding the row). This means that there is always 1 row feeding into the next Join and it always gets executed. The CASE version has a very similar plan but it uses a PASSTHRU predicate which it uses to skip execution of the JOIN if the previous THEN condition was not met. I'm not sure why combined AND s wouldn't use the same approach. 2. EXISTS OR EXISTS The EXISTS OR EXISTS version used a concatenation ( UNION ALL ) operator as the inner input to an outer semi join. This arrangement means that it can stop requesting rows from the inner side as soon as the first one is returned (i.e. it can effectively short circuit) All 4 queries ended up with the same plan where the cheaper predicate was evaluated first. /*All tests are testing "If True Or True"*/ IF EXISTS(SELECT COUNT(*) FROM master..spt_monitor HAVING COUNT(*)=1) OR EXISTS (SELECT COUNT(*) FROM master..spt_values HAVING COUNT(*)<>1) PRINT 'Y' /* Table 'Worktable'. Scan count 0, logical reads 0 Table 'spt_monitor'. Scan count 1, logical reads 1 */ IF EXISTS (SELECT COUNT(*) FROM master..spt_values HAVING COUNT(*)<>1) OR EXISTS(SELECT COUNT(*) FROM master..spt_monitor HAVING COUNT(*)= 1) PRINT 'Y' /* Table 'Worktable'. Scan count 0, logical reads 0 Table 'spt_monitor'. Scan count 1, logical reads 1 */ SELECT 1 WHERE EXISTS(SELECT COUNT(*) FROM master..spt_monitor HAVING COUNT(*)= 1) OR EXISTS (SELECT COUNT(*) FROM master..spt_values HAVING COUNT(*)<>1) /* Table 'Worktable'. Scan count 0, logical reads 0 Table 'spt_monitor'. Scan count 1, logical reads 1 */ SELECT 1 WHERE EXISTS (SELECT COUNT(*) FROM master..spt_values HAVING COUNT(*)<>1) OR EXISTS(SELECT COUNT(*) FROM master..spt_monitor HAVING COUNT(*)=1) /* Table 'Worktable'. Scan count 0, logical reads 0 Table 'spt_monitor'. Scan count 1, logical reads 1 */ 3. Adding an ELSE It did occur to me to try De Morgan's law to convert AND to OR and see if that made any difference. Converting the first query gives IF NOT ((NOT EXISTS(SELECT COUNT(*) FROM master..spt_monitor HAVING COUNT(*)=2) OR NOT EXISTS (SELECT COUNT(*) FROM master..spt_values HAVING COUNT(*)=1))) PRINT 'Y' ELSE PRINT 'N' /* Table 'spt_monitor'. Scan count 1, logical reads 1 Table 'spt_values'. Scan count 1, logical reads 9 */ So this still doesn't make any difference to the short circuiting behaviour. However if you remove the NOT and reverse the order of the IF ... ELSE conditions it now does short circuit! IF (NOT EXISTS(SELECT COUNT(*) FROM master..spt_monitor HAVING COUNT(*)=2) OR NOT EXISTS (SELECT COUNT(*) FROM master..spt_values HAVING COUNT(*)=1)) PRINT 'N' ELSE PRINT 'Y' /* Table 'Worktable'. Scan count 0, logical reads 0 Table 'spt_monitor'. Scan count 1, logical reads 1 */
