[site]: stackoverflow
[post_id]: 1264987
[parent_id]: 1264952
[tags]: 
Without knowing the specifics the parser you're using, I can only guess at the bug, but there's a fairly easy to make bug the .NET framework I/O libs almost encourage you to make... Are you aware of the fact that Streams and TextReaders may read fewer bytes/characters than requested? In particular, TextReader.Read(char[] buffer, int index, int count)'s docs say: Return Value Type: System..::.Int32 The number of characters that have been read. The number will be less than or equal to count, depending on whether the data is available within the stream . This method returns zero if called when no more characters are left to read. Emphasis mine. For example, if you call reader.Read(buffer, 0, 100) you cannot assume that 100 characters have been read. Edit: It's very likely that the parser does assume this; and this explains your observed behavior : if you fully cache the stream in a MemoryStream, there will always be enough characters to fullfill the request - but if you don't, the parser will receive fewer characters than requested at unpredictable times whenever the underlying stream is "slow". Edit2: You can fix your bug by replacing all instances of TextReader.Read() in the parser with TextReader.ReadBlock().
