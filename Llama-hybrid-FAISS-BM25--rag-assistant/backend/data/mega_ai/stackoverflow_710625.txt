[site]: stackoverflow
[post_id]: 710625
[parent_id]: 710607
[tags]: 
Whoa there. There's a few problems, but your segfault is probably because you're passing a char* -- which is just a pointer, and then trying to cout it in disp() . Problem is, that pointer does not live in disp() , it lives in main() . You probably want to either deep-copy the char* , or use std::string . Doing it this way will not work. EDIT : See EDIT 2 You can not just assign name to the class's name variable. If you do that, you'll get unpredictable results - and you'll probably STILL segfault. Remember: in C/C++, objects are locally scoped unless allocated on the heap. In this case, in your ctor, you'd want to do something like: this->name = new char[ strlen( name ) + 1 ]; strcpy( this->name, name ); And in the destructor, you'll want to do something like: delete [] this->name; Note: my syntax may be completely wrong, and I realize the above code is inherently unsafe as you're not checking the char* to make sure it's not NULL, and you're not checking the return value of new. Nevertheless, this should get you started. EDIT 2: I stand corrected. String literals are treated as constant storage and thus live on for the duration of the program. Nevertheless , the lesson, I believe, is important: in general, when not dealing with string literals , passing a pointer (or array, etc.), you need to allocate storage for it and deep-copy. You also need to de-allocate appropriately when destroying said object.
