[site]: stackoverflow
[post_id]: 3461907
[parent_id]: 3459422
[tags]: 
As always, continuations yield an elegant tailcall solution: open System.Collections.Generic let cache = Dictionary () // TODO move inside let memoizedTRFactorial = let rec fac n k = // must make tailcalls to k match cache.TryGetValue(n) with | true, r -> k r | _ -> if n=0 then k 1 else fac (n-1) (fun r1 -> printfn "multiplying by %d" n //*** let r = r1 * n cache.Add(n,r) k r) fun n -> fac n id printfn "---" let r = memoizedTRFactorial 4 printfn "%d" r for KeyValue(k,v) in cache do printfn "%d: %d" k v printfn "---" let r2 = memoizedTRFactorial 5 printfn "%d" r2 printfn "---" // comment out *** line, then run this //let r3 = memoizedTRFactorial 100000 //printfn "%d" r3 There are two kinds of tests. First, this demos that calling F(4) caches F(4), F(3), F(2), F(1) as you would like. Then, comment out the *** printf and uncomment the final test (and compile in Release mode) to show that it does not StackOverflow (it uses tailcalls correctly). Perhaps I'll generalize out 'memoize' and demonstrate it on 'fib' next... EDIT Ok, here's the next step, I think, decoupling memoization from factorial: open System.Collections.Generic let cache = Dictionary () // TODO move inside let memoize fGuts n = let rec newFunc n k = // must make tailcalls to k match cache.TryGetValue(n) with | true, r -> k r | _ -> fGuts n (fun r -> cache.Add(n,r) k r) newFunc newFunc n id let TRFactorialGuts n k memoGuts = if n=0 then k 1 else memoGuts (n-1) (fun r1 -> printfn "multiplying by %d" n //*** let r = r1 * n k r) let memoizedTRFactorial = memoize TRFactorialGuts printfn "---" let r = memoizedTRFactorial 4 printfn "%d" r for KeyValue(k,v) in cache do printfn "%d: %d" k v printfn "---" let r2 = memoizedTRFactorial 5 printfn "%d" r2 printfn "---" // comment out *** line, then run this //let r3 = memoizedTRFactorial 100000 //printfn "%d" r3 EDIT Ok, here's a fully generalized version that seems to work. open System.Collections.Generic let memoize fGuts = let cache = Dictionary () let rec newFunc n k = // must make tailcalls to k match cache.TryGetValue(n) with | true, r -> k r | _ -> fGuts n (fun r -> cache.Add(n,r) k r) newFunc cache, (fun n -> newFunc n id) let TRFactorialGuts n k memoGuts = if n=0 then k 1 else memoGuts (n-1) (fun r1 -> printfn "multiplying by %d" n //*** let r = r1 * n k r) let facCache,memoizedTRFactorial = memoize TRFactorialGuts printfn "---" let r = memoizedTRFactorial 4 printfn "%d" r for KeyValue(k,v) in facCache do printfn "%d: %d" k v printfn "---" let r2 = memoizedTRFactorial 5 printfn "%d" r2 printfn "---" // comment out *** line, then run this //let r3 = memoizedTRFactorial 100000 //printfn "%d" r3 let TRFibGuts n k memoGuts = if n=0 || n=1 then k 1 else memoGuts (n-1) (fun r1 -> memoGuts (n-2) (fun r2 -> printfn "adding %d+%d" r1 r2 //%%% let r = r1+r2 k r)) let fibCache, memoizedTRFib = memoize TRFibGuts printfn "---" let r5 = memoizedTRFib 4 printfn "%d" r5 for KeyValue(k,v) in fibCache do printfn "%d: %d" k v printfn "---" let r6 = memoizedTRFib 5 printfn "%d" r6 printfn "---" // comment out %%% line, then run this //let r7 = memoizedTRFib 100000 //printfn "%d" r7
