[site]: stackoverflow
[post_id]: 2679153
[parent_id]: 2678906
[tags]: 
If there's never any garbage in gc.garbage, then I'm not sure what you're trying to do by enabling GC debugging. Sure, it'll tell you which objects are considered for cleanup, but that's not particularly interesting if you end up with no circular references that can't be cleaned up. If your program is using more and more memory according to the OS, there can generally be four different cases at play: Your application is storing more and more things, keeping references to each one so they don't get collected. Your application is creating circular references between objects that can't be cleaned up by the gc module (typically because one of them has a __del__ method.) Your application is freeing (and re-using) memory, but the OS doesn't want the memory re-used, so it keeps allocating new blocks of memory. The leak is a real memory leak but in a C/C++ extension module your code is using. From your description it sounds like it's unlikely to be #1 (as it would behave the same on any OS) and apparently not #2 either (since there's nothing in gc.garbage.) Considering #3, Windows (in general) has a memory allocator that's notoriously bad with fragmented allocations, but Python works around this with its obmalloc frontend for malloc() . It may still be an issue specific in Windows Server 2008 system libraries that make it look like your application is using more and more memory, though. Or it may be a case of #4, a C/C++ extension module, or a DLL used by Python or an extension module, with a memory leak.
