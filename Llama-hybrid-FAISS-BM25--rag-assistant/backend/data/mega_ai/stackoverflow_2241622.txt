[site]: stackoverflow
[post_id]: 2241622
[parent_id]: 2241006
[tags]: 
You should explain why you can't use malloc() , as there might be different solutions for different reasons, and there are several reasons why it might be forbidden or unavailable on small/embedded systems: concern over memory fragmentation. In this case a set of routines that allocate fixed size memory blocks for one or more pools of memory might be the solution. the runtime doesn't provide a malloc() - I think most modern toolsets for embedded systems do provide some way to link in a malloc() implementation, but maybe you're using one that doesn't for whatever reason. In that case, using Doug Lea's public domain malloc might be a good choice, but it might be too large for your system (I'm not familiar with the MPC 555 off the top of my head). If that's the case, a very simple, custom malloc() facility might be in order. It's not too hard to write, but make sure you unit test the hell out of uit because it's also easy to get details wrong. For example, I have a set of very small routines that use a brain dead memory allocation strategy using blocks on a free list (the allocator can be compile-time configured for first, best or last fit). I give it an array of char at initialization, and subsequent allocation calls will split free blocks as necessary. It's nowhere near as sophisticated as Lea's malloc() , but it's pretty dang small so for simple uses it'll do the trick. many embedded projects forbid the use of dynamic memory allocation - in this case, you have to live with statically allocated structures
