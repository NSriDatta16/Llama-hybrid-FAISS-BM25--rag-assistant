[site]: stackoverflow
[post_id]: 1303030
[parent_id]: 
[tags]: 
Two-finger rotation gesture on the iPhone?

I'm working on an iPhone app with a lot of different gesture inputs that you can do. Currently there is single finger select / drag, two finger scroll, and two finger pinch zoom-in / zoom-out. I want to add in two finger rotation (your fingers rotate a point in between them), but I can't figure out how to get it to work right. All the other gestures were linear so they were only a matter of using the dot or cross product, pretty much. I'm thinking I've got to store the slope between the previous two points of each finger, and if the angle between the vectors is near 90, then there is the possibility of a rotation. If the next finger movement angle is also near 90, and the direction of the vector on one finger changed positively and changed negatively, then you've got a rotation. The problem is, I need a really clean distinction between this gesture and the other ones - and the above isn't far enough removed. Any suggestions? EDIT: Here's how I did it in a vector analysis manner (as opposed to the suggestion below about matching pixels, note that I use my Vector struct in here, you should be able to guess what each function does): //First, find the vector formed by the first touch's previous and current positions. struct Vector2f firstChange = getSubtractedVector([theseTouches get:0], [lastTouches get:0]); //We're going to store whether or not we should scroll. BOOL scroll = NO; //If there was only one touch, then we'll scroll no matter what. if ([theseTouches count] 0) { scroll = YES; } //Otherwise, they're in different directions so we should zoom or rotate. else { //Store the vectors represented by the two sets of touches. struct Vector2f previousDifference = getSubtractedVector([lastTouches get:1], [lastTouches get:0]); struct Vector2f currentDifference = getSubtractedVector([theseTouches get:1], [theseTouches get:0]); //Also find the normals of the two vectors. struct Vector2f previousNormal = getNormalizedVector(&previousDifference); struct Vector2f currentNormal = getNormalizedVector(&currentDifference ); //Find the distance between the two previous points and the two current points. float previousDistance = getMagnitudeOfVector(&previousDifference); float currentDistance = getMagnitudeOfVector(&currentDifference ); //Find the angles between the two previous points and the two current points. float angleBetween = atan2(previousNormal.y,previousNormal.x) - atan2(currentNormal.y,currentNormal.x); //If we had a short change in distance and the angle between touches is a big one, rotate. if ( fabsf(previousDistance - currentDistance) = ROTATE_MAX_ANGLE) { if (angleBetween > 0) { printf("Rotate right.\n"); } else { printf("Rotate left.\n"); } } else { //Get the dot product of the differences of the two points and the two vectors. struct Vector2f differenceChange = getSubtracted(&secondChange, &firstChange); float dotDifference = getDot(&previousDifference, &differenceChange); if (dotDifference > 0) { printf("Zoom in.\n"); } else { printf("Zoom out.\n"); } } } } if (scroll) { prinf("Scroll.\n"); } You should note that if you're just doing image manipulation or direct rotation / zooming, then the above approach should be fine. However, if you're like me and you're using a gesture to cause something that takes time to load, then it's likely that you'll want to avoid doing the action until that gesture has been activated a few times in a row. The difference between each with my code is still not perfectly separate, so occasionally in a bunch of zooms you'll get a rotation, or vise versa.
