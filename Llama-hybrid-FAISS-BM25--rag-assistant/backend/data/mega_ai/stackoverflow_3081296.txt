[site]: stackoverflow
[post_id]: 3081296
[parent_id]: 3080326
[tags]: 
This is a fairly difficult thing to do in SQL at all; you probably won't be able to do it through the ORM. You can't use GROUP BY for this. That's used for telling SQL how to group items for aggregation, which isn't what you're doing here. "SELECT x, y FROM table GROUP BY x" is illegal SQL, because the value of y is meaningless. Let's look at this with a clear schema in mind: CREATE TABLE objects ( id INTEGER PRIMARY KEY, name VARCHAR ); CREATE TABLE comments ( object_id INTEGER REFERENCES objects (id), text VARCHAR NOT NULL, date TIMESTAMP NOT NULL ); INSERT INTO objects (id, name) VALUES (1, 'object 1'), (2, 'object 2'); INSERT INTO comments (object_id, text, date) VALUES (1, 'object 1 comment 1', '2010-01-02'), (1, 'object 1 comment 2', '2010-01-05'), (2, 'object 2 comment 1', '2010-01-08'), (2, 'object 2 comment 2', '2010-01-09'); SELECT * FROM objects o JOIN comments c ON (o.id = c.object_id); The most elegant way I've seen for doing this is Postgresql 8.4's windowing functions. SELECT * FROM ( SELECT o.*, c.*, rank() OVER (PARTITION BY object_id ORDER BY date DESC) AS r FROM objects o JOIN comments c ON (o.id = c.object_id) ) AS s WHERE r = 1; That'll select the first comment for each object by date, newest first. If you don't see what this is doing, execute the inner SELECT on its own and watch how it generates rank(), which makes it pretty straightforward. I know other ways of doing this with Postgresql, but I don't know how to do this in other databases. Trying to compute this dynamically is likely to give you serious headaches--and it takes more work to make these complex queries perform well, too. Chances are you're better off doing this the simple way: store a last_comment_id field for each object and update it when a comment is added or deleted, so you can just join and sort. You could probably use SQL triggers to handle this updating automatically.
