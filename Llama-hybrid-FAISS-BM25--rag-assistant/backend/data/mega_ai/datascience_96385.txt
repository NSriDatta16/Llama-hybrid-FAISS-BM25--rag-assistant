[site]: datascience
[post_id]: 96385
[parent_id]: 
[tags]: 
How to design a model for contour recognition? In particular, how to shape the output layer?

I want to design and train a neural network for the automatic recognition of the edges , in some microscopic images. I am using Keras for a start, I may consider PyTorch later. The structure of the images is rather simple, with some dark areas , and some clear areas , relatively easy to distinguish, and the task is to select the pixels of the contour between dark and clear areas. The transition between dark and clear is gradual, so my result is not a single line of edge pixels, but rather a 10 or 15 wide ribbon of edge pixels. I have manually annotated 200-something images, so for each image I have another image, of the same size, where the pixels of the contours are black, and all the other pixels are white. I have seen many tutorials on how to design , compile and fit a model (a neural network), and then how to test it, using the manually annotated data. However, most of the tutorials work on problems of classification, where the number of neurons in the output layer is the number of categories. My problem is not a problem of classification , and ideally my output should be an image of the same size of the input. So, here is my question: What is the best way to design the output layer? Is a layer with a number of neurons equal to the number of pixels the best idea? Or this is a waste, and there is a more efficient way? Addendum The images are "easy", but it is still difficult to find the contour pixels, so it is worth using the machine learning approach. The transition between dark and clear is a little gradual, so my result is not a single line of pixels on the edge, but rather a band, a 10 or 15 wide ribbon of edge pixels. Since I am after a ribbon of pixels, my categories should be "edge" and "not-edge". If I use the categories "dark pixels" and "clear pixels", and then numerically find the pixels between the two areas I do not get the "ribbon" result, which I need.
