[site]: stackoverflow
[post_id]: 239926
[parent_id]: 239865
[tags]: 
Here it is again, only counting to the square root, as others mentioned. I suppose that people are attracted to that idea if you're hoping to improve performance. I'd rather write elegant code first, and optimize for performance later, after testing my software. Still, for reference, here it is: public static bool Divides(this int potentialFactor, int i) { return i % potentialFactor == 0; } public static IEnumerable Factors(this int i) { foreach (int result in from potentialFactor in Enumerable.Range(1, (int)Math.Sqrt(i)) where potentialFactor.Divides(i) select potentialFactor) { yield return result; if (i / result != result) { yield return i / result; } } } Not only is the result considerably less readable, but the factors come out of order this way, too.
