[site]: stackoverflow
[post_id]: 1816813
[parent_id]: 1815705
[tags]: 
As others have already said, the problem is that the signatures between the functions are different. Class member functions always have a "secret" extra parameter, the this pointer. So you can never pass a member function where a global function is expected. You can hack around this either with libraries such as Boost.Bind, or by making the function a static member of the class. But the simplest, and most elegant solution is to use a different threading API. Boost.Thread is a very nice threading library for C++ (pthreads is designed for C, and that's why it doesnt play well with C++ features such as class methods). I'd recommend using that. Your code could be rewritten as something like this: class ClientHandler { public: ClientHandler(/* All the parameters you want to pass to the thread. Unlike pthreads you have complete type safety and can pass as many parameters to this constructor as you like */){...} void operator()() // boost.thread calls operator() to run the thread, with no parameters. (Since all parameters were passed in the constructor and saved as member variables { string reqUpdate = "91"; // Request for update string recvMSG; while (true) { sleep(5); sending(sock,reqUpdate); // send recvMSG = receiving(sock); // receive QString output(recvMSG); emit signal_chat(output, 0); // Print message to text box } } // whatever arguments you want to pass to the thread can be stored here as member variables }; boost::threead_group gr; // can store all your threads here, rather than being limited to your fixed-size array gr.create_thread(ClientHandler(/* construct a ClientHandler object with the parameters you like*/));
