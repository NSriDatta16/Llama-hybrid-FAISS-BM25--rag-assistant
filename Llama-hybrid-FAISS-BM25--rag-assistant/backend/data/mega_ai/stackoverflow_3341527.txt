[site]: stackoverflow
[post_id]: 3341527
[parent_id]: 3340837
[tags]: 
There are two ways to find out: you could test it with data you could analyze your source code Let's look at the source code. lists are built of linked cons cells length needs to walk once through a list for EVERY recursive call of FILTER you compute the length of a. BAD! (Use ENDP instead.) REMOVE needs to walk once through a list for every recursive call you compute REMOVE twice: BAD! (Instead of using REMOVE on a , recurse with the REST.) the call to FILTER will not necessarily be an optimized tail call. In some implementations it might, in some you need to tell the compiler that you want to optimize for tail calls, in some implementations no tail call optimization is available. If not, then you get a stack overflow on long enough lists. (Use looping constructs like DO, DOLIST, DOTIMES, LOOP, REDUCE, MAPC, MAPL, MAPCAR, MAPLIST, MAPCAN, or MAPCON instead of recursion, when applicable.) Summary: that's very naive code with poor performance. Common Lisp provides this built in: SET-DIFFERENCE should do what you want. http://www.lispworks.com/documentation/HyperSpec/Body/f_set_di.htm#set-difference
