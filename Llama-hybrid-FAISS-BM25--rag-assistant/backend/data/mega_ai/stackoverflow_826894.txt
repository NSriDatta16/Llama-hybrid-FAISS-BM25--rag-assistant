[site]: stackoverflow
[post_id]: 826894
[parent_id]: 727030
[tags]: 
I did this the other day with Generic Extension methods on the WCF service client (DataServiceClient). It uses Actions and Funcs to pass around the actual ServiceClient calls. The final client usage syntax is a little funky (if you don't like lambdas), but this method does FaultException/Abort wrapping AND caching: public static class ProxyWrapper { // start with a void wrapper, no parameters public static void Wrap(this DataServiceClient _svc, Action operation) { bool success = false; try { _svc.Open(); operation.Invoke(); _svc.Close(); success = true; } finally { if (!success) _svc.Abort(); } } // next, a void wrapper with one generic parameter public static void Wrap (this DataServiceClient _svc, Action operation, T p1) { bool success = false; try { _svc.Open(); operation.Invoke(p1); _svc.Close(); success = true; } finally { if (!success) _svc.Abort(); } } // non-void wrappers also work, but take Func instead of Action public static TResult Wrap (this DataServiceClient _svc, Func operation, T p1) { TResult result = default(TResult); bool success = false; try { _svc.Open(); result = operation.Invoke(p1); _svc.Close(); success = true; } finally { if (!success) _svc.Abort(); } return result; } } On the client side, we have to call them like this: internal static DBUser GetUserData(User u) { DataServiceClient _svc = new DataServiceClient(); Func fun = (x) => _svc.GetUserById(x); return _svc.Wrap (fun, u.UserId); } See the plan here? Now that we have a generic set of wrappers for WCF calls, we can use the same idea to inject some cacheing. I went "low tech" here, and just started throwing around strings for the cache key name... You could do something more elegant with reflection, no doubt. public static TResult Cache (this DataServiceClient _svc, string key, Func operation) { TResult result = (TResult)HttpRuntime.Cache.Get(key); if (result != null) return result; bool success = false; try { _svc.Open(); result = operation.Invoke(); _svc.Close(); success = true; } finally { if (!success) _svc.Abort(); } HttpRuntime.Cache.Insert(key, result); return result; } // uncaching is just as easy public static void Uncache (this DataServiceClient _svc, string key, Action operation, T p1) { bool success = false; try { _svc.Open(); operation.Invoke(p1); _svc.Close(); success = true; } finally { if (!success) _svc.Abort(); } HttpRuntime.Cache.Remove(key); } Now just call Cache on your Reads and Uncache on your Create/Update/Deletes: // note the parameterless lambda? this was the only tricky part. public static IEnumerable GetAllDBUsers() { DataServiceClient _svc = new DataServiceClient(); Func fun = () => _svc.GetAllUsers(); return _svc.Cache ("AllUsers", fun); } I like this method because I didn't have to recode anything server-side, just my WCF proxy calls (which were admittedly a little brittle / smelly to have scattered about everywhere). Substitute in your own WCF proxy conventions and standard caching procedures, and you're good to go. It's a lot of work to create all the generic wrapper templates at first too, but i only went up to two parameters and it helps all my caching operations share a single function signature (for now). Let me know if this works for you or if you have any improvements.
