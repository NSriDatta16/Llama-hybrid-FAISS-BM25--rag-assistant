[site]: stackoverflow
[post_id]: 1053781
[parent_id]: 1053658
[tags]: 
I think the question you might be trying to ask is, "What are packages in Java, and how does the import keyword relate to them?" . Your confusion about directory structures might stem from the fact that some other languages have include directives that use file names to literally include the contents of the specified file in your source code at compile time. C/C++ are examples of languages that use this type of include directive. Java's import keyword does not work this way. As others have said, the import keyword is simply a shorthand way to reference one or more classes in a package. The real work is done by the Java Virtual Machine's class loader (details below). Let's start with the definition of a "Java package", as described in the Wikipedia article : A Java package is a mechanism for organizing Java classes into namespaces similar to the modules of Modula. Java packages can be stored in compressed files called JAR files, allowing classes to download faster as a group rather than one at a time. Programmers also typically use packages to organize classes belonging to the same category or providing similar functionality. In Java, source code files for classes are in fact organized by directories, but the method by which the Java Virtual Machine (JVM) locates the classes is different from languages like C/C++. Suppose in your source code you have a package named "com.foo.bar", and within that package you have a class named "MyClass". At compile time, the location of that class's source code in the file system must be {source}/com/foo/bar/MyClass.java , where {source} is the root of the source tree you are compiling. One difference between Java and languages like C/C++ is the concept of a class loader. In fact, the concept of a class loader is a key part of the Java Virtual Machine's architecture. The job of the class loader is to locate and load any class files your program needs. The "primordial" or "default" Java class loader is usually provided by the JVM. It is a regular class of type ClassLoader , and contains a method called loadClass() with the following definition: // Loads the class with the specified name. // Example: loadClass("org.apache.nutch.plugin.Extension") Class loadClass(String name) This loadClass() method will attempt to locate the class file for the class with given name, and it produces a Class object which has a newInstance() method capable of instantiating the class. Where does the class loader search for the class file? In the JVM's class path. The class path is simply a list of locations where class files can be found. These locations can be directories containing class files. It can even contain jar files, which can themselves contain even more class files. The default class loader is capable of looking inside these jar files to search for class files. As a side note, you could implement your own class loader to, for example, allow network locations (or any other location) to be searched for class files. So, now we know that whether or not "com.foo.bar.MyClass" is in a class file in your own source tree or a class file inside a jar file somewhere in your class path, the class loader will find it for you, if it exists. If it does not exist, you will get a ClassNotFoundException . And now to address the import keyword: I will reference the following example: import com.foo.bar.MyClass; ... public void someFunction() { MyClass obj1 = new MyClass(); org.blah.MyClass obj2 = new org.blah.MyClass("some string argument"); } The first line is simply a way to tell the compiler "Whenever you see a variable declared simply as type MyClass , assume I mean com.foo.bar.MyClass . That is what's happening in the case of obj1 . In the case of obj2 , you are explicitly telling the compiler "I don't want the class com.foo.bar.MyClass , I actually want org.blah.MyClass ". So the import keyword is just a simple way of cutting down on the amount of typing programmers have to do in order to use other classes. All of the interesting stuff is done in the JVM's class loader. For more information about exactly what the class loader does, I recommend reading an article called The Basics of Java Class Loaders
