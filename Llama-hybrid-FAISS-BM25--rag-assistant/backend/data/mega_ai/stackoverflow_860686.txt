[site]: stackoverflow
[post_id]: 860686
[parent_id]: 860200
[tags]: 
I just can talk about NHibernate. There you need a field for the primary key, it's up to you if you take business data (not recommended) or a surrogate key with no business meaning. Typical scenarios are: auto-incrementing value generated by the database guid generated by NHibernate guid generated by the business logic There is a big advantage to have a unique id. When you pass your object around, for instance to the client and back to the server, you can't rely on memory identity. You could even have several instances in memory of the same business instance. The business instance is identified by the id. Id-based comparison is a matter of taste. Personally I like simple and reliable code, and id-based comparison is simple and reliable, while deep-comparison is always a bit risky, error-prone, unmaintainable. So you end up with operator == comparing the memory identity and Equals comparing the business (and database) identity. NHibernate is the less intrusive way to map a class model to a relational database I know. In our large project we have primary keys and version properties (they are used for optimistic locking). You could argue that this is intrusive, because it is not used for the business logic. NH doesn't require to have these properties. (however it needs one of the properties as primary key.) But consider: It just works better, eg. pessimistic locking is only possible with a appropriate property, faster: int id's perform better on many databases then other data types and easier: taking properties with a meaning to the business are discouraged for several reasons. So why making your life harder than necessary? Edit: Just read the documentation and found that NHibernate does not need an id property in the persistent class! If you don't have an indentifier, you can't use some features . It is recommended to have it, it just makes your life easier.
