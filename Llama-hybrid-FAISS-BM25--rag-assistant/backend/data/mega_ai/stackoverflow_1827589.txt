[site]: stackoverflow
[post_id]: 1827589
[parent_id]: 1827102
[tags]: 
While lain beat me to writing an example, I'll post it anyhow just in case... The process of writing a wrapper to access your own library is the same as accessing one of the standard .Net libraries. Example C# class code in a project called CsharpProject: using System; namespace CsharpProject { public class CsharpClass { public string Name { get; set; } public int Value { get; set; } public string GetDisplayString() { return string.Format("{0}: {1}", this.Name, this.Value); } } } You would create a managed C++ class library project (example is CsharpWrapper) and add your C# project as a reference to it. In order to use the same header file for internal use and in the referencing project, you need a way to use the right declspec. This can be done by defining a preprocessor directive ( CSHARPWRAPPER_EXPORTS in this case) and using a #ifdef to set the export macro in your C/C++ interface in a header file. The unmanaged interface header file must contain unmanaged stuff (or have it filtered out by the preprocessor). Unmanaged C++ Interface Header file (CppInterface.h): #pragma once #include // Sets the interface function's decoration as export or import #ifdef CSHARPWRAPPER_EXPORTS #define EXPORT_SPEC __declspec( dllexport ) #else #define EXPORT_SPEC __declspec( dllimport ) #endif // Unmanaged interface functions must use all unmanaged types EXPORT_SPEC std::string GetDisplayString(const char * pName, int iValue); Then you can create an internal header file to be able to include in your managed library files. This will add the using namespace statements and can include helper functions that you need. Managed C++ Interface Header file (CsharpInterface.h): #pragma once #include // .Net System Namespaces using namespace System; using namespace System::Runtime::InteropServices; // C# Projects using namespace CsharpProject; ////////////////////////////////////////////////// // String Conversion Functions inline String ^ ToManagedString(const char * pString) { return Marshal::PtrToStringAnsi(IntPtr((char *) pString)); } inline const std::string ToStdString(String ^ strString) { IntPtr ptrString = IntPtr::Zero; std::string strStdString; try { ptrString = Marshal::StringToHGlobalAnsi(strString); strStdString = (char *) ptrString.ToPointer(); } finally { if (ptrString != IntPtr::Zero) { Marshal::FreeHGlobal(ptrString); } } return strStdString; } Then you just write your interface code that does the wrapping. Managed C++ Interface Source file (CppInterface.cpp): #include "CppInterface.h" #include "CsharpInterface.h" std::string GetDisplayString(const char * pName, int iValue) { CsharpClass ^ oCsharpObject = gcnew CsharpClass(); oCsharpObject->Name = ToManagedString(pName); oCsharpObject->Value = iValue; return ToStdString(oCsharpObject->GetDisplayString()); } Then just include the unmanaged header in your unmanaged project, tell the linker to use the generated .lib file when linking, and make sure the .Net and wrapper DLLs are in the same folder as your unmanaged application. #include // Include the wrapper header #include "CppInterface.h" void main() { // Call the unmanaged wrapper function std::string strDisplayString = GetDisplayString("Test", 123); // Do something with it printf("%s\n", strDisplayString.c_str()); }
