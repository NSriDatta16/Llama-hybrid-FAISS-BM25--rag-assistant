[site]: stackoverflow
[post_id]: 508372
[parent_id]: 508324
[tags]: 
Absolutely - we just recently had an issue with our app where it all of a sudden started hitting some major slowdowns. It turned out we had a cubic (O(n^3)) algorithm right in the middle of a very major function. It had been hidden away beneath layers of abstraction. Figuring out what had happened required mapping out the function call graph and looking at the details. Admittedly once we had done that, it's not like I had to apply any math to notice a O(n^3) algorithm, but that's mostly because 3 years of Analysis of Algorithms in university has given me a general feel for what a cubic algorithm looks like. Anyway, it turns out that N had increased just a little bit, but it right at a cusp of going from taking a few hundred milliseconds to taking a couple seconds and then up into minutes - so the issue hadn't shown up until just recently. For the most part, you're going to be using pre-packaged algorithms that have defined complexities. Quicksort is O(n^2) worst case and O(n*log(n)) average case, binary search is O(log(n)), etc.. libraries will generally specify what their performance characteristics are, and you only need to worry about how they compose.
