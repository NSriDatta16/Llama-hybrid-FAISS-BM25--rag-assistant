[site]: stackoverflow
[post_id]: 3030644
[parent_id]: 2931278
[tags]: 
Thanks for the reply. I have pretty much given up on getting this to work in the way I think it should. Of course how I think things should happen isn't how they do happen. :) Here's basically how it works, but it seems to be off by a pixel in some cases and the circles seem to be missing sections when things land on some boundary conditions I have yet to figure out. Personally I think this is unacceptable to be inside application code and should be in the Android libraries... wink wink, nudge nudge if you work for Google. :) private class LinearMapCanvas { private final Canvas canvas_; // hold a wrapper to the actual canvas. // scaling and translating values: private double scale_; private int translateX_; private int translateY_; // linear mapping from my coordinate system to the display's: private double mapX(final double x) { final double result = translateX_ + scale_*x; return result; } private double mapY(final double y) { final double result = translateY_ - scale_*y; return result; } public LinearMapCanvas(final Canvas canvas) { canvas_ = canvas; // Find the extents of your drawing coordinates: final double minX = extentArray_[0]; final double minY = extentArray_[1]; final double maxX = extentArray_[2]; final double maxY = extentArray_[3]; // deltas: final double dx = maxX - minX; final double dy = maxY - minY; // The display's available pixels, accounting for margins and pen stroke width: final int width = width_ - strokeWidth_ - 2*margin_; final int height = height_ - strokeWidth_ - 2*margin_; final double scaleX = width / dx; final double scaleY = height / dy; scale_ = Math.min(scaleX , scaleY); // Pick the worst case, so the drawing fits // Translate so the image is centered: translateX_ = (int)((width_ - (int)(scale_*dx))/2.0 - scale_*minX); translateY_ = (int)((height_ - (int)(scale_*dy))/2.0 + scale_*maxY); } // wrappers around the canvas functions you use. These are only two of many that would need to be wrapped. Annoying and error prone, but beats any alternative I can find. public void drawCircle(final float cx, final float cy, final float radius, final Paint paint) { canvas_.drawCircle((float)mapX(cx), (float)mapY(cy), (float)(scale_*radius), paint); } public void drawLine(final float startX, final float startY, final float stopX, final float stopY, final Paint paint) { canvas_.drawLine((float)mapX(startX), (float)mapY(startY), (float)mapX(stopX), (float)mapY(stopY), paint); } ... }
