[site]: stackoverflow
[post_id]: 2831584
[parent_id]: 2831263
[tags]: 
The idea of an exception is so that a function can report failure without having to return special values. In ye old PHP, the only way a function could say it had a problem was by returning some special value like false or -1 . This is not pleasant. For example, suppose I am writing a variant of file_get_contents(). The typical return value is a handle - represented by a positive integer. However, there are two basic problems I can encounter: the file you specified was not found, or the file you specified was not readable. To indicate an error I might return a negative number - because handles are positive - that associates to the particular cause of error. Let's say that -1 means the file wasn't there and -2 means the file wasn't readable. Now we have a problem that -1 and -2 do not inherently mean anything to someone reading the code. To rectify this we introduce the global constants FILE_NOT_FOUND and FILE_NOT_READABLE. Let's see some resultant code. By having different error codes we can act accordingly to what the problem really is. That functionality is well and fine. The issue is purely in how the code reads. $result is a horrible variable name. Variable names should be descriptive and obvious, like $friendListFile . The real name for $result is $fileContentsOrErrorCode which is not only too long, it examplifies how we are overloading a single variable with two meanings. You never, ever, want to have the same data mean two things. We want a separate $errorCode and $fileContents ! So how do we get around this problem? One not-really-a-solution some PHP libraries have used is to have their my_file_get_contents() -like functions return false if they encounter a problem. To disambiguate what the problem actually was we instead call my_file_get_contents_getError() . This almost works. define('FILE_OKAY', 0); define('FILE_NOT_FOUND', -1); define('FILE_NOT_READABLE', -2); $my_file_get_contents_error = FILE_OKAY; function my_file_get_contents_getError() { // blah blah blah } function my_file_get_contents($file) { global $my_file_get_contents_error; // blah blah blah // whoa, an error? return false and store the error code in // $my_file_get_contents_error // no error? set $my_file_get_contents_error to FILE_OKAY } $friendListFile = getDefaultFriendListFile(); $result = my_file_get_contents($friendListFile); if (my_file_get_contents_getError() == FILE_NOT_FOUND) { deleteFriendListFromMenu(); } elseif (my_file_get_contents_getError() == FILE_NOT_READABLE) { alertUserAboutPermissionProblem(); } elseif (my_file_get_contents_getError() == FILE_OKAY) { useFriendList($result); } else { die('I have no idea what happened. my_file_get_contents_getError() returns ' . my_file_get_contents_getError() ); } As a note, yes, we can do a much better job by avoiding a global variable and other such little bits. Consider this the nuts-and-bolts demonstration. We still cannot call $result anything better than $fileContentsOrFalseIfError . That problem has not been fixed. I have now rectified one problem that you may have noticed in the earlier example. What if we do not cover all of the error codes? If a programmer decides that there needs to be a -3 code we weren't originally detecting it! We could have checked if $result was a string to make sure it wasn't an error code, but we aren't supposed to really care about types in PHP, right? Now that we can utilize a second return value from my_file_get_contents_getError() it is no problem to include a success code. There is now a brand new problem that has emerged. Fix one and find three more eh? The new problem is that only the most-recent error code can be kept. This is terribly fragile! If anything else calls my_file_get_contents() before you deal with your error code, their code will overwrite yours! Gah, now we need to keep a list of functions that are unsafe to call before you deal with the return value from my_file_get_contents_getError(). If you don't do that, you have to keep as an ad-hoc coding convention that you always call my_file_get_contents_getError() immediately after my_file_get_contents() in order to save the error code that belongs to you before it is mysteriously overwritten. Wait! Why don't we just hand out identifiers to our callers? In order to use my_file_get_contents() you now have to ask create_my_file_get_contents_handle() for some number that will disambiguate you with all other callers. Now you can call my_file_get_contents($myHandle, $myFile) and the error code can be stored in a special location just for you. Now when you call my_file_get_contents_getError($myHandle) you can access that special place, get your error code, and no one has stepped on your toes. Er, but if there are many callers we don't want to have zillions of useless error codes laying around. We had better ask users to call destroy_my_file_get_contents_handle($myHandle) when they are done so we can free some memory. I hope this is all feeling very familiar to ye old PHP mantras. This is all so crazy, just make it simple, please! What would it mean if the language supported a better mechanism to react to errors? Clearly, trying to create some solution with the existing tools is confusing, obnoxious, and error-prone. Enter exceptions! All of a sudden our old headaches of special return values and handles and coding conventions have been cured! We can now truly rename $result to $fileContents . If my_file_get_contents() has a problem, the assignment is aborted altogether and we jump right down to the appropriate catch block. Only if there is no error do we even think about giving $fileContents a value or calling useFriendList() . No longer are we plagued by multiple callers stepping on each other's error codes! Every call to my_file_get_contents() will instantiate its own exceptions, if the error arises. No memory problems! The garbage collector will happily clean up no-longer-used exception objects without you thinking about it. Using ye old handle system we had to remember to manually destroy the handle, lest have it lurk around forever in memory. There are many other benefits and traits to exceptions. I strongly recommend looking to other sources to learn about these. Particularly interesting are how they bubble up the execution stack until some caller can catch them. Also interesting is how you can catch an exception, try to fix the problem, and then rethrow the exception if you can not. Do not forget that exceptions are objects! There is loads of flexibility to be gained by that. For exceptions that no one can catch, look into the exception handler. My intent to answer the question was to demonstrate why we need exceptions. By doing this, I hope it is easy to infer what problems we can solve with them.
