[site]: stackoverflow
[post_id]: 5072760
[parent_id]: 5062218
[tags]: 
The point about efficiently determining whether a tree is balanced without paying attention to its size , is that once you know the right branch is more than one level deeper than the left branch, it doesn't matter exactly how much deeper it is. 2 levels deeper? 3? 100? We don't care, and it could be considered inefficient to find out only to throw away the result. isBalanced :: BinaryTree a -> Bool isBalanced = and . treeToBalanceSize treeToBalanceSize :: BinaryTree a -> BalanceSize treeToBalanceSize Empty = [] treeToBalanceSize (Node l r) = True : mergeBalanceSizes (treeToBalanceSize l) (treeToBalanceSize r) mergeBalanceSizes :: BalanceSize -> BalanceSize -> BalanceSize mergeBalanceSizes [] [] = [] mergeBalanceSizes [x] [] = [x] mergeBalanceSizes [] [y] = [y] mergeBalanceSizes (x : xs) (y : ys) = (x && y) : mergeBalanceSizes xs ys mergeBalanceSizes _ _ = [False] type BalanceSize = [Bool] Satisfy yourself that If tree is balanced and of size size , then treeToBalanceSize tree = replicate size True . If tree is unbalanced, then treeToBalanceSize tree will end with a False . Evaluating mergeBalanceSizes [True] list does not cause list to be evaluated beyond its third element.
