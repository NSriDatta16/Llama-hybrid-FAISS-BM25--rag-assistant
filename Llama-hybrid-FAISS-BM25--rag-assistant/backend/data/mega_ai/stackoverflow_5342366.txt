[site]: stackoverflow
[post_id]: 5342366
[parent_id]: 5341349
[tags]: 
I was going to answer this saying use an object as a lookup then use hasOwnProperty to determine if the property is set on the filter Object. From actually testing my method along with these two (creating a mock set of data with strings of numbers (100,000 of them) and the variance between the methods in terms of run-time is negligble (ranges between 130 and 160ms). I think basically all three of these have the same running time. Here's my full code so you can mess around and point out if I did something that invalidates my testing somehow but this seems to make sense to me, using indexOf it needs to iterate across the set until it finds the object (assuming a purely linear collection not a tree) same with hasOwnProperty (needs to get list of all properties and iterate across them, unless there's a mechanism built-in to find the property more efficiently: I'm going to try and think this through from a pure data perspective and see if it's even possible to get better running time than this or if it's just the nature of the problem that necessitates a certain number of checks (asymptotic analysis). Good question. [Edit] Okay after thinking this through I believe without using a more complex data structure (and incurring the processor time cost up front in creating/re-organizing the data structure... thinking of keeping a balanced tree for search) I'm pretty sure any method will result in an equivalent or worse running time than these methods (that is linear running time or worse O(n)). Using a Tree structure you would get running times of O(log n) for search but incur more processing overhead in keeping the tree balanced (doing rotations as necessary). If anyone can invalidate this statement I would be happy if you did so, but I believe this is all true. http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/binarySearchTree.htm
