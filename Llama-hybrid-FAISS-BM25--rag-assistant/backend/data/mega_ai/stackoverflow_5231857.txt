[site]: stackoverflow
[post_id]: 5231857
[parent_id]: 5231302
[tags]: 
Seeing as you don't mind the obsolete EJB call continuing on the server, why not allow the calling thread to terminate 'naturally' but to discard the result because its call has been superceded by another thread? I don't have time to provide a sample implementation, but you may find that you get some mileage with Future s and the related Java concurrency classes. Edit Further to this, you may find something like this would do the trick, but it feels hacky to me and I'm sure there are more elegant solutions. On the calling thread (perhaps the onclick method of a button): AsynchronousResultManager.registerRequest("UNIQUE_IDENTIFIER", runnableExecuteRequest); The registerRequest would do something like: registerClick(String id, Runnable execution) { AtomicReference ref = executions.get(id); //executions is a Map created as a a computing map by Guava MapMaker execution.setReference(ref); //so that the Runnable has a reference to it later ref.set(execution); //this will overwrite an existing reference to a previous invocation. //here you need to actually kick off your thread in whatever way works best for you } The runnable that executes the request would be a subclass of: public abstract class RequestRunnable implements Runnable { private AtomicReference ref; public void run() { doRunInternal(); //actually go off and do the request to the J2EE server if (this == ref.get()) { //ie if the current runnable is the same as in the reference, we can proceed to actually dispatch the result dispatchResult(); //this method would do something like add a runnable to the SwingWorkerThread } } protected abstract void doRunInternal(); protected abstract void dispatchResult(); public void setReference(AtomicReference ref) { this.ref = ref; } } This will probably crash and burn, but hopefully it points you down a line of enquiry...
