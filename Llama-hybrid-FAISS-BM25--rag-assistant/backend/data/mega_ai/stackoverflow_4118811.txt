[site]: stackoverflow
[post_id]: 4118811
[parent_id]: 4112131
[tags]: 
You say in response to @Charlie's answer that ideally you would like information about how the program spends it's time. There's another viewpoint - you need to know why the program spends its time. The reason each cycle is spent is a chain of reasons, where each link is a line of code on the call stack. The chain is no stronger than its weakest link. Unless the program is as fast as possible, you've got "bottlenecks". For example, if a "bottleneck" is wasting 20% of the time, then it consists of an optimizable line of code (i.e. poorly justified) that is on the stack 20% of the time. All you have to do is find it. If 10,000 samples of the stack are taken, it will be on about 2,000 of them. If 10 samples are taken, it will be on 2 of them, on average. In fact, if you randomly pause the program several times and study the call stack, if you see an optimizable line of code on as few as 2 samples , you've found a "bottleneck". You can fix it, get a nice speedup, and repeat the whole process. That is the basis of this technique . Regardless, thinking in terms of gprof concepts will not serve you well.
