[site]: stackoverflow
[post_id]: 3800144
[parent_id]: 3798255
[tags]: 
A large offset does not consume extra memory; it just requires that CoreAnimation deals with large numbers. This is fine, except... CGFloat is a float on device (IIRC it's a double on Mac OS X). This means it can represent integers up to about 2 24 (about 16.7 million), thus half-integers up to around 8 million (and the "retina display" has half-size pixels). If the user scrolls very far, then you'll lose accuracy. I'm not sure where precisely this happens. You can try setting contentSize and contentOffset to very large values and seeing what happens. If you really need UIDatePicker-style "forever" scrolling, you have a few options: Implement your own. It's not too difficult, and performance won't be that bad (I think you get a scrollViewDidScroll: callback per frame). Make the contentSize "sufficiently big" (around 1 million, but note that it should be a multiple of the page size) and the content offset somewhere in the middle. Reset the contentOffset to the the middle-ish when the user's stopped scrolling: scrollViewDidEndDragging:willDecelerate: (but only if decelerate == NO ) scrollViewDidEndDecelerating: scrollViewDidEndScrollingAnimation: scrollViewDidScrollToTop: (possibly; I'm not sure if it sends scrollViewDidEndScrollingAnimation: too). This means the user can hit the end and bounce if they try really hard (a million iPhone "points" is about 160 m). Oh well.
