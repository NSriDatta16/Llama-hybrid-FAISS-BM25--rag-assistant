[site]: stackoverflow
[post_id]: 4130175
[parent_id]: 
[tags]: 
C++ memory allocation: 'new' throws bad_alloc?

In my application I save voxel-data (compressed byte array) and trying to load it back again into memory. But my application crashes in Windows 7 machine (64 bit ,12 GB) giving bad_alloc . This works fine on Linux ,and even runs on some other Windows 7 machine with 4 GB memory. Compressed bye size is about 200Mb and uncompressed byte size is about 300Mb.(so only 500 MB reserved before this 'new' statement,which leaves almost 8 GB excluding system memory ). I don't run any other major memory allocation steps before this ,so I don't think memory is fragmented. I use MinGW GCC version 4.5.0 Any tips on this ? thanks in advance. QFile fileVol(strVFile); //Read VolumeData fileVol.open(QIODevice::ReadOnly); QDataStream volstream(&fileVol); QByteArray volCmprsdByteArray; //This holds the compressed byte array //Read some additional information int nx, ny, nz, bbp; int voltype; volstream >> nx; volstream >> ny; volstream >> nz; volstream >> bbp; volstream >> voltype; volstream >> volCmprsdByteArray; //read our compressed voxel-data //we have original uncompressed pixel data QByteArray volUncmprsdByeArray = qUncompress(volCmprsdByteArray); int uncompressedSize = volUncmprsdByeArray.size(); // size of the byte array qDebug("new char for uncompressed data size %d",uncompressedSize); unsigned char* volumeData=NULL; //Trying to allocate new memory try { // ##### breaks here. #### volumeData =new unsigned char[uncompressedSize]; } catch (std::bad_alloc e) { cout
