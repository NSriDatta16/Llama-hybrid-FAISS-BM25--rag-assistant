[site]: stackoverflow
[post_id]: 101890
[parent_id]: 99297
[tags]: 
Can the vtable be modified or even directly accessed at runtime? Not portably, but if you don't mind dirty tricks, sure! WARNING : This technique is not recommended for use by children, adults under the age of 969 , or small furry creatures from Alpha Centauri. Side effects may include demons which fly out of your nose , the abrupt appearence of Yog-Sothoth as a required approver on all subsequent code reviews, or the retroactive addition of IHuman::PlayPiano() to all existing instances] In most compilers I've seen, the vtbl * is the first 4 bytes of the object, and the vtbl contents are simply an array of member pointers there (generally in the order they were declared, with the base class's first). There are of course other possible layouts, but that's what I've generally observed. class A { public: virtual int f1() = 0; }; class B : public A { public: virtual int f1() { return 1; } virtual int f2() { return 2; } }; class C : public A { public: virtual int f1() { return -1; } virtual int f2() { return -2; } }; A *x = new B; A *y = new C; A *z = new C; Now to pull some shenanigans... Changing class at runtime: std::swap(*(void **)x, *(void **)y); // Now x is a C, and y is a B! Hope they used the same layout of members! Replacing a method for all instances (monkeypatching a class) This one's a little trickier, since the vtbl itself is probably in read-only memory. int f3(A*) { return 0; } mprotect(*(void **)x,8,PROT_READ|PROT_WRITE|PROT_EXEC); // Or VirtualProtect on win32; this part's very OS-specific (*(int (***)(A *)x)[0] = f3; // Now C::f1() returns 0 (remember we made x into a C above) // so x->f1() and z->f1() both return 0 The latter is rather likely to make virus-checkers and the link wake up and take notice, due to the mprotect manipulations. In a process using the NX bit it may well fail.
