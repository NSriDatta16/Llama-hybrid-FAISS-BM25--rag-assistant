[site]: stackoverflow
[post_id]: 5276667
[parent_id]: 5268006
[tags]: 
For an array of L items, why not pack the order into L*ceil(log2(L)) bits? (ceil(log2(L)) is the number of bits needed to hold L unique values). For example, here is the representation of the "unshuffled" shuffle, taking the items in order: L=2: 0 1 (2 bits) L=3: 00 01 10 (6 bits) L=4: 00 01 10 11 (8 bits) L=5: 000 001 010 011 100 (15 bits) ... L=8: 000 001 010 011 100 101 110 111 (24 bits) L=9: 0000 0001 0010 0011 0100 0101 0110 0111 1000 (36 bits) ... L=16: 0000 0001 ... 1111 (64 bits) L=128: 00000000 000000001 ... 11111111 (1024 bits) The main advantage to this scheme compared to @user470379's answer, is that it is really easy to extract the indexes, just shift and mask. No need to regenerate the permutation table. This should be a big win for large L: (For 128 items, there are 128! = 3.8562e+215 possible permutations). (Permutations == "possibilities"; factorial = L! = L * (L-1) * ... * 1 = exactly the way you are calculating possibilities) This method also isn't that much larger than storing the permutation index. You can store a 128 item shuffle in 1024 bits (32 x 32-bit integers). It takes 717 bits (23 ints) to store 128!. Between the faster decoding speed and the fact that no temporary storage is required for caclulating the permutation, storing the extra 9 ints may be well worth their cost. Here is an implementation in Ruby that should work for arbitrary sizes. The "shuffle instruction" is contained in the array instruction . The first part calculates the shuffle using a version of the Fisher-Yates algorithm that @Theran mentioned # Some Setup and utilities sizeofInt = 32 # fix for your language/platform N = 16 BitsPerIndex = Math.log2(N).ceil IdsPerWord = sizeofInt/BitsPerIndex # sets the n'th bitfield in array a to v def setBitfield a,n,v mask = (2**BitsPerIndex)-1 idx = n/IdsPerWord shift = (n-idx*IdsPerWord)*BitsPerIndex a[idx]&=~(mask >shift)&mask end #create the shuffle instruction in linear time nwords = (N.to_f/IdsPerWord).ceil # num words required to hold instruction instruction = Array.new(nwords){0} # array initialized to 0 #the "inside-out" Fisherâ€“Yates shuffle for i in (1..N-1) j = rand(i+1) setBitfield(instruction,i,getBitfield(instruction,j)) setBitfield(instruction,j,i) end #Here is a way to visualize the shuffle order #delete ".reverse.map{|s|s.to_i(2)}" to visualize the way it's really stored p instruction.map{|v|v.to_s(2).rjust(BitsPerIndex*IdsPerWord,'0').scan( Regexp.new('.'*BitsPerIndex)).reverse.map{|s|s.to_i(2)}} Here is an example of applying the shuffle to an array of characters: A=(0...N).map{|v|('A'.ord+v).chr} puts A*'' #Apply the shuffle to A in linear time for i in (0...N) print A[getBitfield(instruction,i)] end print "\n" #example: for N=20, produces > ABCDEFGHIJKLMNOPQRST > MSNOLGRQCTHDEPIAJFKB Hopefully this won't be too hard to convert to javascript, or any other language.
