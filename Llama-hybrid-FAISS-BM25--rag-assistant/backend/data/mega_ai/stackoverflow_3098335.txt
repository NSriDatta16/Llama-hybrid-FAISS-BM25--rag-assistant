[site]: stackoverflow
[post_id]: 3098335
[parent_id]: 3098281
[tags]: 
You want to organize your #includes (and libraries, for that matter) in a DAG (directed, acyclic graph). That's the complicated way of saying "avoid cycles between header files": If B includes A, A should not include B. So, using "one big master main.h " is not the right approach, because it's hard to #include only direct dependencies. Each .cpp file should include its own .h file. That .h file should only include things that it itself requires to compile. There is usually no main.h , because main.cpp nobody needs the definition of main. Furthermore, you'll want include guards to protect you against multiple includes. For example //player.h #ifndef PLAYER_H_ #define PLAYER_H_ #include "vector.h" // Because we use Vector #include "health.h" // Because we use Health class Player { private: Vector playerPos; public: Health playerHealth; }; #endif - //vector.h #ifndef VECTOR_H_ #define VECTOR_H_ struct Vector { int X; int Y; int Z; }; #endif - //health.h #ifndef HEALTH_H_ #define HEALTH_H_ class Health { private: int curHealth; int maxHealth; public: int getHealth() const; void setHealth(int inH); void modHealth(int inHM); }; #endif The only time you want to aggregate a bunch of #include s into a single header is when you're providing it as a convenience for a very large library. In your current example, you're going a little overboard - each class doesn't need its own header file. It can all go in main.cpp. The c preprocessor literally inserts the file from a #include into the file that includes it (unless it has already been inserted, which is why you need the include guards). It allows you to use the classes defined in those files because you now have access to their definition.
