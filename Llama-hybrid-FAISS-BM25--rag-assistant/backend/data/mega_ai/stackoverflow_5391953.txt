[site]: stackoverflow
[post_id]: 5391953
[parent_id]: 5307253
[tags]: 
Steps Step 1: Iterate through all solutions. Step 2: Find the cheapest solution. Create pieces inventory For an array of possible pieces (include single pieces of each color), make at least n duplicates of each piece, where n = max(board#/piece# of each color). Therefore, at most n of that piece can cover all of the entire board's colors by area. Now we have a huge collection of possible pieces, bounded because it is guaranteed that a subset of this collection will completely fill the board. Then it becomes a subset problem, which is NP-Complete. Solving the subset problem For each unused piece in the set For each possible rotation (e.g. for a square only 1, for a rectangle piece 2, for an elbow piece 4) For each possible position in the *remaining* open places on board matching the color and rotation of the piece - Put down the piece - Mark the piece as used from the set - Recursively decent on the board (with already some pieces filled) Optimizations Obviously being an O(2^n) algorithm, pruning of the search tree early is of utmost importance. Optimizations must be done early to avoid long-running. n is a very large number; just consider a 48x48 board -- you have 48x48xc (where c = number of colors) just for single pieces alone. Therefore, 99% of the search tree must be pruned from the first few hundred plies in order for this algorithm to complete in any time. For example, keep a tally of the lowest cost solution found so far, and just stop searching all lower plies and backtrack whenever the current cost plus (the number of empty board positions x lowest average cost for each color) > current lowest cost solution. For example, further optimize by always favoring the largest pieces (or the lowest average-cost pieces) first, so as to reduce the baseline lowest cost solution as quickly as possible and to prune as many future cases as possible. Finding the cheapest Calculate cost of each solution, find the cheapest! Comments This algorithm is generic. It does not assume a piece is of the same color (you can have multi-colored pieces!). It does not assume that a large piece is cheaper than the sum of smaller pieces. It doesn't really assume anything. If some assumptions can be made, then this information can be used to further prune the search tree as early as possible. For example, when using only single-colored pieces, you can prune large sections of the board (with the wrong colors) and prune large number of pieces in the set (of the wrong color). Suggestion Do not try to do 48x48 at once. Try it on something small, say, 8x8, with a reasonably small set of pieces. Then increase number of pieces and board size progressively. I really have no idea how long the program will take -- but would love for somebody to tell me!
