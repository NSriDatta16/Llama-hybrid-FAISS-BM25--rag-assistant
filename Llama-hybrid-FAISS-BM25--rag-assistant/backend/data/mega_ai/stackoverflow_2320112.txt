[site]: stackoverflow
[post_id]: 2320112
[parent_id]: 2319926
[tags]: 
The whole point of Java Beans is that a system (GUI Builder, in particular) can examine a Java Bean and configure it without any previous knowledge of that component. Although this is fairly cool, it's really only useful in this specific situation and these days annotations would work MUCH better. So the reason they use bound properties was simply to support this drop-in GUI component technology, and I wouldn't really prefer it over events unless you need to support a reflective gui-building system. Response to @Mike rodent Let's say you allow your user to create a class that you will control. This class has a "Main" and can handle a couple events. Normally you have your user do something like this: class UserClass(someClass) { void mainMethod() { someClass.addEventListener(new EventListener() { public void eventsHappen(Event e){ event1(e) } } } someClass.addDifferentEventListener(new DifferentEventListener() { public void eventsHappen(DifferentEvent e){ event2(e) } } } } public void event1(Event e) { //java code for event 1 } public void event2(DifferentEvent e) { // java code for event 2 } } Anyway, you get the idea. Of course, you assume that this class is registered somewhere--probably in an xml/config file. You read it, instantiate it and execute the mainMethod(defined by agreement or by interface) and it registers itself and starts getting calls to the event handlers. Now here's how you can accomplish the same thing with annotations: (You might recognize the pattern--it's pretty much how Junit annotates tests.) class UserClass() { @Event1 void event1Method(Event e) { event1's code } @Event2 void event2Method(AnotherEvent e) { event2's code } } This is much more straight-froward and removes most of the boilerplate, and it also removes the need for an agreement or interface, annotations are more clearly defined and independant. (You don't actually even NEED the event annotations if you care to inspect the parameters being passed into the methods, but dragons lie in that general direction). You still need the class registered somewhere, but this time you just scan each method for your event annotations and register them yourself. Since it's only a few lines of code to read and process a class like this, why restrict this pattern to unit testing? Another thing I found really neat, I used this pattern for Groovy classes that were "plugged-in" to my Java program. Since I was compiling all the classes in a given directory anyway, scanning for annotations was trivial.. The effect to the user is that he drops in (or edits) a properly annotated groovy text file and my code immediately compiles, integrates and starts calling their event handlers.
