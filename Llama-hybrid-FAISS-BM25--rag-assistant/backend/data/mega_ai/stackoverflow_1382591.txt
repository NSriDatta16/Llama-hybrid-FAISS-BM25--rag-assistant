[site]: stackoverflow
[post_id]: 1382591
[parent_id]: 1382529
[tags]: 
The main difference in calling C++ functions instead of C functions apart from the name mangling are the 'hidden' features like this pointers that are implicitly passed to member functions. The C runtime layer doesn't know anything about these, implicit type conversions and other fun C++ features, so if you intend to call C++ through a C interface, you might have to fake these features if necessary. Assuming that you can hold at least a void * to the object you intend to call and the data it requires, you can degrade the following C++ call matrix->multiply(avector); to a C call if you create a C wrapper function: extern "C" void matrix_multiply(void *cpp_matrix, void *cpp_vector) { reinterpret_cast (cpp_matrix)->multiply(reinterpret_cast (cpp_vector); } Obviously the function matrix_multiply would sit in the C++ source code and compiled as such but it does expose a C interface to the outside world. As long as you can interact with the opaque pointers, you're OK with the translation shims above. Admittedly this is not necessarily the most elegant solution for a problem like this but I've used it in the past in situations like yours. The other option would be to make the C++ calls directly by treating them as C calls with additional parameters and supplying all the required information yourself, but that does move you into the realm of compiler-specific code very quickly. Basically, you would still be holding the opaque pointers to C++ objects, but you'd have to work out the mangled name of the function you want to call. Once you've got that function name, you'll have to supply the this pointer (which is implicit in C++ and semi-implicit in the example above) and the correct parameters and then call the function. It can be done but as mentioned, puts you deeply in to the realm of compiler and even compiler-version specific behaviour.
