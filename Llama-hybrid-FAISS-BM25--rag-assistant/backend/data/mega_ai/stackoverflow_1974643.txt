[site]: stackoverflow
[post_id]: 1974643
[parent_id]: 1974508
[tags]: 
Transactional memory fits here the best. An option could be a transactional storage. Sample implementation you can find here: http://www.codeproject.com/KB/dotnet/Transactional_Repository.aspx Memento pattern Also let me describe a possible pattern on how to implement such behavior: Define a base class TransactionalEntity . This class contains dictionary of properties. All your transactional classes inherit from the TransactionalEntity and should operate over some sort of Dependency Properties/Fields , i.e. properties(getters/setters) which store it's values not in local class fields, but in dictionary, which is stored in the base class. Then you define TransactionContext class. TransactionContext class internally contains a set of dictionaries (one dictionary for each entity that participates in the transaction) and when a transactional entity participates in transaction, it writes all data to the dictionary in the transaction context. Then all you need is basically four methods: TransactionContext.StartTransaction(); TransactionalEntity.JoinTransaction(TransactionContext context); //if your language/framework supports Thread Static fields, then you do not need this method TransactionContext.CommitTransaction(); TransactionContext.RollbackTransaction(); To sum up, you need to store state in base class TransactionalEntity and during transaction TransactionalEntity will cooperate with TransactionContext . I hope, I've explained it well enough.
