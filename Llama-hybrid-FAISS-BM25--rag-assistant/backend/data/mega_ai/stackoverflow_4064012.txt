[site]: stackoverflow
[post_id]: 4064012
[parent_id]: 4063308
[tags]: 
First, I hope your two classes inherit from NSObject and are not root classes. Making a new root in Objective-C on iOS is actually quite difficult unless you keep your instances entirely in isolation from Foundation/UIKit. Two possible solutions: Don't access the iVar directly. Make and use the accessors, likely via an @property directive. This is the "more correct" solution in that a class implemented in library A should likely not be diddling the ivars of a class from library B directly. Going through the accessor better preserves encapsulation and acknowledges that direct iVar access is an extremely atypical pattern in Objective-C (largely limited only to a class accessing it's own iVars directly). Declare the iVars to be @public and diddle away. Fragile, atypical, and fraught with peril. Private in Objective-C really means "that compilation unit over there can't see this declaration over here". Thus, if you want, you can declare a property -- say -- to be publicly readonly and privately readwrite: Foo.h: @interface Foo.... @property(readonly) int x; @end Foo+Private.h: @interface Foo() @property(readwrite) int x; @end Foo.m: #import "Foo+Private.h" @implementation Foo @synthesize x; @end Anything that imports Foo.h will only see that x is readonly. The implementation of Foo will see that it is readwrite. So will anything else that imports Foo+Private.h.
