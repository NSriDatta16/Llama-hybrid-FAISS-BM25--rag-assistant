[site]: stackoverflow
[post_id]: 4686140
[parent_id]: 4686011
[tags]: 
There's a great recursive solution to this problem based on the following observations: The reverse of the empty list is the empty list. The reverse of a singleton list is itself. The reverse of a list of a node N followed by a list L is the reverse of the list L followed by the node N. You can therefore implement the reverse function using pseudocode along these lines: void reverseList(Node node) { if (node == null) return; // Reverse of empty list is itself. if (node.next == null) return; // Reverse of singleton list is itself. reverseList(node.next); // Reverse the rest of the list appendNodeToList(node, node.next); // Append the new value. } A naive implementation of this algorithm runs in O(n 2 ), since each reversal requires an append, which requires an O(n) scan over the rest of the list. However, you can actually get this working in O(n) using a clever observation. Suppose that you have a linked list that looks like this: n1 --> n2 --> [rest of the list] If you reverse the list beginning at n2, then you end up with this setup: n1 [reverse of rest of the list] --> n2 | ^ +------------------------------------------+ So you can append n1 to the reverse of the rest of the list by setting n1.next.next = n1 , which changes n2 , the new end of the reverse list, to point at n1: [reverse of the rest of the list] --> n2 --> n1 And you're golden! Again more pseudocode: void reverseList(Node node) { if (node == null) return; // Reverse of empty list is itself. if (node.next == null) return; // Reverse of singleton list is itself. reverseList(node.next); // Reverse the rest of the list node.next.next = node; // Append the new value. } EDIT: As Ran pointed out, this uses the call stack for its storage space and thus risks a stack overflow. If you want to use an explicit stack instead, you can do so like this: void reverseList(Node node) { /* Make a stack of the reverse of the nodes. */ Stack s = new Stack (); for (Node curr = node; node != null; node = node.next) s.push(curr); /* Start unwinding it. */ Node curr = null; while (!s.empty()) { Node top = s.pop(); /* If there is no node in the list yet, set it to the current node. */ if (curr == null) curr = top; /* Otherwise, have the current node point to this next node. */ else curr.next = top; /* Update the current pointer to be this new node. */ curr = top; } } I believe that this similarly inverts the linked list elements.
