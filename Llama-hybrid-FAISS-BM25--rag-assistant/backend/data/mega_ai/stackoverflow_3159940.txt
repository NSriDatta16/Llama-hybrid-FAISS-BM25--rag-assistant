[site]: stackoverflow
[post_id]: 3159940
[parent_id]: 3159914
[tags]: 
DataBinding expects the class it's bound to to raise INotifyPropertyChanged to indicate that a value has been altered and needs to be re-read; unfortunately implementing this still requires some manual coding (or something like PostSharp to IL-weave the necessary code). So, to support databinding you can't use automatically implemented properties, or be bound directly to the field--neither gives you the opportunity to raise the necessary events (the binding will work, but the value won't be updated when changed). Another shortcoming of DataBinding is that it doesn't consider threading. If a background thread modifies a databound value then the databinding will try to make a cross-threaded call to update the UI--which is bad. The best workaround I've found is to let bindable classes hold an instance of their UI's Synchronization Context , which will let you ensure updates to the UI are invoked on the UI thread. using System.ComponentModel; namespace MyWebGrocer.Uma.UI { public class BoundClass : INotifyPropertyChanged { private string _Name; private int _Age; public event PropertyChangedEventHandler PropertyChanged; public string Name { get { return _Name; } set { _Name = value; OnPropertyChanged("Name"); } } public int Age { get { return _Age; } set { _Age = value; OnPropertyChanged("Age"); } } protected void OnPropertyChanged(string propertyName) { var propertyChanged = PropertyChanged; if (propertyChanged != null) { PropertyChanged(this, new PropertyChangedEventArgs(propertyName)); } } } } I know it all sounds discouraging--these shortcomings of databinding were learned the hard way. However, it's better to be aware of--and compensate for--these issues early on before they manifest as bigger problems.
