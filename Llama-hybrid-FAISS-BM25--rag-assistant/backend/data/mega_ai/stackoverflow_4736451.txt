[site]: stackoverflow
[post_id]: 4736451
[parent_id]: 4736293
[tags]: 
Attention: if you have different interfaces for one class, then this could break constraints: The equals method implements an equivalence relation on non-null object references: It is reflexive: for any non-null reference value x, x.equals(x) should return true. It is symmetric: for any non-null reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true. It is transitive: for any non-null reference values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true. It is consistent: for any non-null reference values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified. @see: java doc for Object.equals If you have three Classes A, B, C tree Itnerfaces I1, I2, I3: A implments Interface I1 and I2, B implments I2 and I3 C implments I1 and I3. Then you could have this situation: A equals B because of I2 B equals C because of I3 but: A not equals C because of I3 This would violate the transitive constraint! This could cause in hard to find bugs! This is only a warning, to think twice before you start to declare this as a major architecture style. Added: Instead I recommend to implement something that is similar to the Comparator, but not to compare but to check for "equals", its meaning would be something like "equals in respect to X" (where X is for example one of your interface)
