[site]: stackoverflow
[post_id]: 2886343
[parent_id]: 2886279
[tags]: 
So you are looking something provides these properties, 1. If h(x1) == y1, then there is an inverse function h_inverse(y1) == x1 2. Because the inverse function exists, there cannot be a value x2 such that x1 != x2, and h(x2) == y1. Knuth's Multiplicative Method In Knuth's "The Art of Computer Programming", section 6.4, a multiplicative hashing scheme is introduced as a way to write hash function. The key is multiplied by the golden ratio of 2^32 (2654435761) to produce a hash result. hash(i)=i*2654435761 mod 2^32 Since 2654435761 and 2^32 has no common factors in common, the multiplication produces a complete mapping of the key to hash result with no overlap. This method works pretty well if the keys have small values. Bad hash results are produced if the keys vary in the upper bits. As is true in all multiplications, variations of upper digits do not influence the lower digits of the multiplication result. Robert Jenkins' 96 bit Mix Function Robert Jenkins has developed a hash function based on a sequence of subtraction, exclusive-or, and bit shift. All the sources in this article are written as Java methods, where the operator '>>>' represents the concept of unsigned right shift. If the source were to be translated to C, then the Java 'int' data type should be replaced with C 'uint32_t' data type, and the Java 'long' data type should be replaced with C 'uint64_t' data type. The following source is the mixing part of the hash function. int mix(int a, int b, int c) { a=a-b; a=a-c; a=a^(c >>> 13); b=b-c; b=b-a; b=b^(a >> 13); a=a-b; a=a-c; a=a^(c >>> 12); b=b-c; b=b-a; b=b^(a >> 5); a=a-b; a=a-c; a=a^(c >>> 3); b=b-c; b=b-a; b=b^(a >> 15); return c; } You can read details from here
