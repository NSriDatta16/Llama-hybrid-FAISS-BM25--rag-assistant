[site]: stackoverflow
[post_id]: 2847794
[parent_id]: 2847787
[tags]: 
It’s always the constructor taking an int that’s called in this case. This is called an implicit conversion and is semantically equivalent to the following code: CTest b(5); The assignment operator is never invoked in an initialisation. Consider the following case: CTest b = CTest(5); Here, we call the constructor (taking an int ) explicitly and then use that temporary value to initialise b . But once again, no assignment operator is ever called. Strictly speaking, pre-C++17 both cases could call the copy (or move) constructor after creating an object of type CTest . But in fact the C++ standard actively encouraged compilers to optimise the copy constructor call here 1 , and all compilers have optimised this for decades. Since C++17, a copy constructor is no longer called for the code above: even though the code still looks as if a copy (or move) were performed, the value of CTest(5) is constructed directly into the storage of b , no temporary is created. 2 1 See ISO/IEC 14882:1998 [class.copy]/15. This is known as copy elison (in particular URVO , which confusingly stands for “unnamed return value optimisation”, even though it also applies in initialisation expressions which are not return statements). 2 See ISO/IEC 14882:2017 [dcl.init]/17.6.1 ( working draft N4659 ).
