[site]: stackoverflow
[post_id]: 2212500
[parent_id]: 2186709
[tags]: 
For performance questions please refer to this blogpost: http://meshy.org/2009/12/13/widefinder-2-with-clojure.html This shows a Clojure implementation of the WideFinder2 challenge which is faster than both Java, Scala and single threaded C. Compare with official times. Regarding Daniels remark that Clojure will never be faster, we see that its obviously incorrect based on the results above. Mutability is faster than immutability which is Clojures default, yet Clojure allows for local transients (ie. temporarily mutable data), so that one can achieve optimal speed. Refer to clj-me.cgrand.net for many optimization techniques. In conclusion: Clojure can be as fast as you would like it to be while still allowing you to maintain a simple elegant and robust codebase, almost a unique combination.
