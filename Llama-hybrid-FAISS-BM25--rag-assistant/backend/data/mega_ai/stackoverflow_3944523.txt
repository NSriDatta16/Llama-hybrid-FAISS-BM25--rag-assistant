[site]: stackoverflow
[post_id]: 3944523
[parent_id]: 3944170
[tags]: 
Normally what you would do is use a Monad Transformer with an StateT and a IO, this because the view (GUI) needs IO in order to respond, however once you defined your Monad Transformer in a newtype , you would like to make the signatures of the game logic only with the MonadState interface, that way you still have the benefit of non-IO-ness changes. Code below explaining what I mean: {-# LANGUAGE GeneralizedNewtypeDeriving #-} import Control.Monad.State data GameState = GameState { ... } deriving (Show) newtype GameMonad a = GameMonad (StateT GameState IO a) deriving (Monad, MonadState GameState, MonadIO) -- This way, now you have a monad with the state of the info -- what would you like now is being able to modify the state, without actually -- having IO capabilites. movePlayerOnState :: (MonadState GameState) m => Position -> m () -- In this function we get the state out of the state monad, and then we modify -- with a pure function, then put the result back again -- Other times you would like to have the GUI API available, requiring the IO monad -- for that renderGameFromState :: MonadIO m => GameState -> m () -- in this method you would use liftIO method to call the GUI API This code is fairly complex if you don't understand monads, but my rule of thumb is, find out what the State Monad is for, understand what Monad Transformers are (without the need of understanding how they work) and how to use the StateT monad. I can point you to a Sokoban project I did with other teammate that might be useful, it uses ncurses as the GUI, but you can get the idea of the logic and how we managed states on the Game http://github.com/roman/HaskBan Good Luck.
