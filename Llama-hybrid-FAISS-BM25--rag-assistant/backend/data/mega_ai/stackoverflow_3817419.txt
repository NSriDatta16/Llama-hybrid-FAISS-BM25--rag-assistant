[site]: stackoverflow
[post_id]: 3817419
[parent_id]: 3810269
[tags]: 
I find this quite mind-screwing, and the committee has more such fun . So I think it's likely I have some errors in the below. So please read it with care :) Third paragraph For a class template specialization, a class member template specialization, or a specialization for a class member of a class template, if the specialization is implicitly instantiated because it is referenced from within another template specialization, if the context from which the specialization is referenced depends on a template parameter, and if the specialization is not instantiated previous to the instantiation of the enclosing template, the point of instantiation is immediately before the point of instantiation of the enclosing template. In other words, if a class template or a nested class of a class template is instantiated, and the context that causes that instantiation depends on a template parameter, the template/nested class is instantiated immediately before the point of instantiation of the template that refers to it. The context in the other specialization can either depend on template parameters, which is the case for primary templates, partial specializations and members of a class template, or it does not depend on template parameters, which is the case for references from within explicit specializations. Otherwise [i.e. the context is nondependent], the point of instantiation for such a specialization immediately precedes the namespace scope declaration or definition that refers to the specialization. This distinction is important. Consider what would happen if the point of instantiation for specializations from dependent contexts would preceede immediately to the namespace scope declaration or definition that refers to it template struct A { typedef typename A ::type *type; }; template struct A { typedef T type; }; typedef A ::type ptr; This template is supposed to add N pointer declarators. So A is int** for example. The context around typedef A ::type is non-dependent, so A is instantiated before the typedef declaration. Within A , we have A ::type , which appears in a dependent context and which references A ::type . So the Standard requires us to instantiate A at the same point we instantiated A . If we would instantiate this immediately before the namespace scope declaration that referred to it (before the primary template definition), we would not notice the partial specialization A when processing `A ::type within A because we would instantiate A before that specialization. Second paragraph This is just so that names looked up in default arguments are consistent with names looked up in the rest of the function that they are used for (i.e their POI is the same as the POI of their function template / member function of class template). First paragraph This is basically the same as the third paragraph. However, function templates are instantiated after the entity that refer to them so that recursive uses are possible, like in the following example. In contrast, class templates are instantiated before the entity that refer to them because the entity required that class type to be complete. If the class type's POI would be after that entity, the class type would still be non-existent. template void f(T); template struct A { void g() { f(0); } void h() { /* do a dance */ } }; template void f(T t) { A a; a.h(); } void g() { A a; a.g(); } If f would be instantiated before A , then it could not access a.h() because at that point it did not exist yet. Therefor, function templates are instantiated after the entity that refer to them, and class templates are instantiated before the entity that refer to them.
