[site]: stackoverflow
[post_id]: 5126949
[parent_id]: 2874887
[tags]: 
My experience: RDBMS: Frankly, I don't like working with SQL, a 15-year old language, but the reality is that you're forced to if you want anything usable, such as bulk inserts (the LINQ-to-Entity ORM framework does not support bulk inserts, so it takes 30 seconds for a 20,000 record insert, compared to 500ms for a bulk insert in SQL). You end up having to use ADO.NET for database insertions. There are some advantages of an RDBMS over an object database, namely, the data is independent of the calling application (however, this is a weakness also, as the mapping layer makes everything slower, more complex, and more brittle). Bottom line: Spent 6 weeks with the LINQ-to-Entity ORM framework and Microsoft SQL Server 2008 R2. Reasonably steep learning curve. Object databases: Tried an object database, namely, the free, open source db4o . Discovered that I could persist my objects with one line of code. No schema changes to deal with, it just worked. Instant support for POCO (Plain Old Class Objects). Create your class in code, then persist it. Its possible to do the same with the Entity framework, however, its a lot of work with manual mapping, and it breaks very easy. Turn on transparent persistence, and it has automatic lazy loading in the background - no more checking for objects that are not loaded because of lazy loading in the Entity framework. The performance of object databases is also impressive: if you have 10 million rows in an object database, and indexing turned on, its 16ms for a three-column select. That's decent. Bottom line: After 1 week I had the same solution as using a RDBMS for persistence, however, it was much cleaner, much less code, and more maintainable - and if I really wanted, I could use use a service to synchronize the db4o database with MSSQL. For really large systems in the enterprise world, consisting of say 250 million rows in a table, things like sharding and options such as clustered indexing vs. non-clustered indexing become important for performance. In this case, db4o wouldn't work, it may require something more enterprisey. However, if you a trivially easy method of persisting objects, then an object database will fit the bill. All the work of learning SQL, setting up the mapping in the ORM, dealing with installation of MSSQL, implementing your own bulk loading procedures, etc just disappears, leaving you with clean, elegant 100% managed code. I suspect that one of the reasons that vendors have not embraced object databases as that the database market is worth $3 billion per year, and there is no reason to kill the cash cow just yet. Disclaimer: I have no affiliation with either Microsoft or db4o .
