[site]: stackoverflow
[post_id]: 3461692
[parent_id]: 3456738
[tags]: 
This is how I did it when I wrote a similar library several months back. And yes, your optimizer will remove empty, inline function calls. If you declare them out-of-line (not in the header file), your compiler will NOT inline them unless you use LTO. namespace Reporting { const extern std::string logFileName; void Report(std::string msg); void Report(std::string msg, std::string msgLogAdd); void Log(std::string msg); void Message(std::string msg); #ifdef DEBUG inline void Debug_Log(std::string message) { return Log(message); } inline void Debug_Message(std::string message) { return Message(message); } inline void Debug_Report(std::string message) { return Report(message); } inline void Debug_Assert(bool test, std::string message) { /* Not sure what to do here */ } #else inline void Debug_Log(std::string) {} inline void Debug_Message(std::string) {} inline void Debug_Report(std::string) {} inline void Debug_Assert(std::string) {} #endif }; Just as a side note, don't pass strings by value unless you need to make a copy anyways. Use a const reference instead. It prevents an expensive allocation + strcpy on the string for EVERY function call. EDIT: Actually, now that I think about it, just use a const char*. Looking at the assembly, it's a LOT faster, especially for empty function bodies. GCC optimizes this out at -O1, I don't think there's much of an issue with this: clark@clark-laptop /tmp $ cat t.cpp #include inline void do_nothing() { } int main() { do_nothing(); return 0; } clark@clark-laptop /tmp $ g++ -O1 -S t.cpp clark@clark-laptop /tmp $ cat t.s .file "t.cpp" .text .globl main .type main, @function main: .LFB32: .cfi_startproc movl $0, %eax ret .cfi_endproc .LFE32: .size main, .-main .ident "GCC: (Gentoo 4.5.0 p1.2, pie-0.4.5) 4.5.0" .section .note.GNU-stack,"",@progbits After a bit of tweaking, it seems that this will only be a FULL removal if you use const char*, NOT std::string or const std::string&. Here's the assembly for the const char*: clark@clark-laptop /tmp $ cat t.cpp inline void do_nothing(const char*) { } int main() { do_nothing("test"); return 0; } clark@clark-laptop /tmp $ g++ -O1 -S t.cpp clark@clark-laptop /tmp $ cat t.s .file "t.cpp" .text .globl main .type main, @function main: .LFB1: .cfi_startproc movl $0, %eax ret .cfi_endproc .LFE1: .size main, .-main .ident "GCC: (Gentoo 4.5.0 p1.2, pie-0.4.5) 4.5.0" .section .note.GNU-stack,"",@progbits And here's with const std::string&... .file "t.cpp" .section .rodata.str1.1,"aMS",@progbits,1 .LC0: .string "test" .text .globl main .type main, @function main: .LFB591: .cfi_startproc subq $24, %rsp .cfi_def_cfa_offset 32 leaq 14(%rsp), %rdx movq %rsp, %rdi movl $.LC0, %esi call _ZNSsC1EPKcRKSaIcE movq (%rsp), %rdi subq $24, %rdi cmpq $_ZNSs4_Rep20_S_empty_rep_storageE, %rdi je .L11 movl $_ZL22__gthrw_pthread_cancelm, %eax testq %rax, %rax je .L3 movl $-1, %eax lock xaddl %eax, 16(%rdi) jmp .L4 .L3: movl 16(%rdi), %eax leal -1(%rax), %edx movl %edx, 16(%rdi) .L4: testl %eax, %eax jg .L11 leaq 15(%rsp), %rsi call _ZNSs4_Rep10_M_destroyERKSaIcE .L11: movl $0, %eax addq $24, %rsp .cfi_def_cfa_offset 8 ret .cfi_endproc .LFE591: .size main, .-main [Useless stuff removed...] .ident "GCC: (Gentoo 4.5.0 p1.2, pie-0.4.5) 4.5.0" .section .note.GNU-stack,"",@progbits Huge difference, eh?
