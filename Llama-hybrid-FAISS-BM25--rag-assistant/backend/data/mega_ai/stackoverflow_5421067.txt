[site]: stackoverflow
[post_id]: 5421067
[parent_id]: 4916020
[tags]: 
Short answers: Composition over inheritance . Program against interfaces . Principle of Least Privilege . Role interfaces . I'd suggest you do a google on them after reading my post ;) For one thing, you do not need InputStream to inherit from ViewController as VieController.doSaveAsXML() is public. Even if it had private|protected|package visibility, we should not use inheritance only to access a method on some other class that is not visible to us. Inheritance is for inheriting , refining or extending behavior, not for accessing methods. You can always pass the controller as an argument type to your input stream. If your input stream needs to access all methods in the controller, pass the controller as is (or have the controller implement an interface with all the methods in it.) First important thing to notice is that your InputStream doesn't really need access to a controller. It only need access to something that can do file opening functions for it - it needs a file opener . Second important thing to notice is that the controller (typically) doesn't need to know how to open files either. A controller is typically an organizer or orchestrator (for lack of a better word.) As such, it doesn't need to be a file opener (or implement file opening logic itself.) The controller just needs a reference to a a file opener . Just like the input stream , the controller needs to simply delegate file opening logic to a file opener . In other words: your input stream needs to have access to a file opener your controller also only needs to have access to a file opener your controller initializes your input stream, and so, it needs to pass a file opener to it during initialization because of the above, the controller itself needs to receive, instantiates or be configured with a file opener itself. since the file opener is external to both the stream and the controller, the file opener should be an interface (which can be implemented by a xml file opener or any opener for that matter.) java pseudocode: public interface FileOpener { public void doOpen(); } public class XMLOpener implements FileOpener { public void doOpen(){ ... do xml specific file opening ... } } public interface Stream { /** inits stream with controller **/ public void init(FileOpener FileOpener); public void kickIt(); } public interface Controller { // defines other methods implemented by actual interfaces. public void kickIt(); } public class ViewController implements Controller { private Stream stream; private FileOpener opener; public ViewController( final Stream stream. final FileOpener opener ) { this.stream = stream; this.opener = opener; this.stream.init(this.opener); } public void kickIt(){ stream.kickIt() ); } public class InputStream implements Stream { private FileOpener opener; public InputStream() { } public Stream init(final FileOpener opener ) { this.opener = opener; } public void kickIt() { this.opener.doOpen(); } } .... Controller controller = new ViewController( new InputStream(), new XMLOpener() ); Whether you go all the way making everything working against interface handlers, that's a design decision that we have to make with every project. But this approach (or something inspired by it) is typically the way to go. It is much harder this way (but not impossible) to come up with cyclical dependencies, and when they do occur, they are a matter of configuration, and not of an intrinsic problem with you object model. Hope it helps.
