[site]: stackoverflow
[post_id]: 1069854
[parent_id]: 772050
[tags]: 
Unfortunately, I can't address your primary issue (caching the subdomains) except to say that everything I have read implies that Django can't handle this in any elegant manner. Its possible this has changed for version 1.1, but if so I haven't come across anything about it. In my particular application I can't cache the subdomains anyway, so I have not looked into what internal modifications might be required to make this work better. However, regarding the manner of accessing subdomain views, another option you might consider is something like this: class SubdomainMiddleware: """ Make the company specified by the subdomain available to views for appropriate processing. """ def process_request(self, request): """ Populate a company attribute on the request object with the company indicated by the requested subdomain. """ domain_parts = request.get_host().split('.') if (len(domain_parts) > 2): subdomain = domain_parts[0] if (subdomain.lower() == 'www'): subdomain = '' else: subdomain = '' if subdomain != '': try: request.company = Company.objects.get(subdomain=subdomain) except Company.DoesNotExist: return HttpResponseRedirect(''.join(['http://test.com', reverse('findcompany')])) else: request.company = None I think this is fairly self-explanatory--it is a heavily modified version of something I found on djangosnippets . It simply parses the subdomain, looks it up in the company table, and if that is a valid company it gets appended to the request object for handling by the view. This way, if test.com/test and sub.test.com/test are both valid then the view can contain that logic, rather than pushing it down into the middleware. Also, garbage subdomains are easily passed off to a search url. I had intended to compare this to your middleware (more for my own education than anything else), but the URL you provided for your code returns a 404.
