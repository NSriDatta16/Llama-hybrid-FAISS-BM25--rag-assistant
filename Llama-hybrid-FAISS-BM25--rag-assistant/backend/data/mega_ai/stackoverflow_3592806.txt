[site]: stackoverflow
[post_id]: 3592806
[parent_id]: 3525043
[tags]: 
In my opinion, that RPG tutorial you mention has a slight defect. What I believe is causing your confusion is the following section's code: ... Consequently, we typically call the send() API like this: D miscdata S 25A D rc S 10I 0 C eval miscdata = 'The data to send goes here' C eval rc = send(s: %addr(miscdata): 25: 0) c if rc ... If you read the documentation of send() you will see that the return value does not indicate an error if it is greater than -1 yet in the code above it seems as if an error has occurred. In fact, the sum of the return values must equal the size of the buffer assuming that you keep moving the pointer into the buffer to reflect what has been sent. Look here in Beej's Guide to Network Programming . You might also like to look at Richard Stevens' book UNIX Network Programming, Volume 1 for really detailed explanations. As to the problem of determining if the last send before close() did the actual send ... well the paragraph above explains how to determine what portion of the data was sent. However, calling close() will attempt to send all unsent data unless SO_LINGER is set. fnctl() is used to control blocking while setsockopt() is used to set SO_LINGER . The abstraction of network communications being used is BSD sockets. There are some slight differences in implementations across OS's but it is generally quite homogeneous. This means that one can generally use documentation written for other OS's for the broad overview. Most of the time .
