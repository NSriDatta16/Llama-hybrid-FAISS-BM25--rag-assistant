[site]: crossvalidated
[post_id]: 278595
[parent_id]: 
[tags]: 
Error measure that takes "comparatively low" sample size into account in time series

I have a lot of mean squared displacement graphs, and because of the nature of the experiment they're all over the place. The x-axis is the lag time used to calculate the y-axis values. Not exactly a time-series, though in a sense they are, since the lag time can only be as long as the number of time-points in an experiment. To spot trends I've taken the average and plotted errors as +/- SEM like so But I feel that this only tells me "I have 2 very long recordings that are very similar", but not "you only have 2, albeit similar, data points at time 75 compared with 100s of datapoints at time 1, and therefore your descriptive error should be enormous". Is this the wrong way about it? Would it be better to plot a 95% confidence interval and compare those between samples? If you want to plot the second graph, data is here: https://notebin.cc/1ehclngnq4g Copy-paste into a text and save as CSV onto the desktop, then run library(readr) test % group_by(condition, lipase, lag) %>% summarise(mean_msd = mean(msd), sd = sd(msd)/sqrt(length(msd)), # Standard error of the mean upper_sd = mean_msd + sd, lower_sd = mean_msd - sd) # Plot averaged MSD curves with real curves #### ggplot(data = test_summary, aes(x = lag, y = mean_msd, fill = lipase)) + ggtitle("Lagged ensemble MSD") + xlab("dt lag") + ylab(" ") + geom_line() + geom_line(stat = "smooth", method = "loess", col = "skyblue") + geom_ribbon(aes(ymax=upper_sd, ymin=lower_sd), alpha=0.1, fill = "red", col = "red", size = 0.1) + scale_y_continuous(expand = c(0,0)) + scale_x_continuous(expand = c(0,0)) + coord_cartesian(ylim = c(0, 2), xlim =c(1,100)) + theme_tufte(base_size = 12, base_family = "Droid Sans") + theme(axis.text = element_text(color = "black"), axis.line = element_line(), strip.text.y = element_blank(), strip.background = element_rect(color = "white"), legend.position = "none", legend.text = element_text(size = 10, family = "Droid Sans"), plot.margin = unit(c(5.5, 10, 5.5, 5.5), "points")) + # Fixes the right margin overflow facet_wrap(condition ~ lipase, scales = "free")
