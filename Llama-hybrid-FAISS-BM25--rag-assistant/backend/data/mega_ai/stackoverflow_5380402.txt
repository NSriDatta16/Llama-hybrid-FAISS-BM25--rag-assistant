[site]: stackoverflow
[post_id]: 5380402
[parent_id]: 
[tags]: 
Ninject, Generic Referential Bindings

I think this falls under the concept of contextual binding , but the Ninject documentation, while very thorough, does not have any examples close enough to my current situation for me to really be certain. I'm still pretty confused. I basically have classes that represent parameter structures for queries. For instance.. class CurrentUser { string Email { get; set; } } And then an interface that represents its database retrieval (in the data layer) class CurrentUserQuery : IQueryFor { public CurrentUserQuery(ISession session) { this.session = session; } public Member ExecuteQuery(CurrentUser parameters) { var member = session.Query ().Where(n => n.Email == CurrentUser.Email); // validation logic return member; } } Now then, what I want to do is to establish a simple class that can take a given object and from it get the IQueryFor class, construct it from my Ninject.IKernel (constructor parameter), and perform the ExecuteQuery method on it, passing through the given object. The only way I have been able to do this was to basically do the following... Bind >().To (); This solves the problem for that one query. But I anticipate there will be a great number of queries... so this method will become not only tedious, but also very prone to redundancy. I was wondering if there is an inherit way in Ninject to incorporate this kind of behavior. :- In the end, my (ideal) way of using this would be ... class HomeController : Controller { public HomeController(ITransit transit) { // injection of the transit service } public ActionResult CurrentMember() { var member = transit.Send(new CurrentUser{ Email = User.Identity.Name }); } } Obviously that's not going to work right, since the Send method has no way of knowing the return type. I've been dissecting Rhino Service Bus extensively and project Alexandria to try and make my light, light, lightweight implementation. Update I have been able to get a fairly desired result using .NET 4.0 dynamic objects, such as the following... dynamic Send (object message); And then declaring my interface... public interface IQueryFor { K Execute(T message); } And then its use ... public class TestCurrentMember { public string Email { get; set; } } public class TestCurrentMemberQuery : IConsumerFor { private readonly ISession session; public TestCurrentMemberQuery(ISession session) { this.session = session; } public Member Execute(TestCurrentMember user) { // query the session for the current member var member = session.Query () .Where(n => n.Email == user.Email).SingleOrDefault(); return member; } } And then in my Controller... var member = Transit.Send ( new TestCurrentMember { Email = User.Identity.Name } ); effectively using the as my 'Hey, This is what implements the query parameters!'. It does work, but I feel pretty uncomfortable with it. Is this an inappropriate use of the dynamic function of .NET 4.0? Or is this more the reason why it exists in the first place? Update (2) For the sake of consistency and keeping this post relative to just the initial question, I'm opening up a different question for the dynamic issue.
