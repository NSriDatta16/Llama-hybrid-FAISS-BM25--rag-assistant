[site]: stackoverflow
[post_id]: 5237753
[parent_id]: 5237704
[tags]: 
I can't seem to find anything wrong with what you provide. If you have a struct, e.g.: struct account{ int a,b,c,d; float e,f,g,h; } Then you can indeed create an array of accounts using: struct account *accounts = (struct account *) malloc(numAccounts * sizeof(account)); Note that for C the casting of void* (retun type of malloc) is not necessary. It will get upcasted automatically. [edit] Ahhh! I see your problem now! Right. Yes you can still access accounts[150], but basically what happens is that accounts will point to some memory location. accounts[150] simply points 150 times the size of the struct further. You can get the same result by doing this: *(accounts + 150) , which basically says: Give me the value at location accounts+150. This memory is simply not reserved, and therefore causes undefined behavior. It basically comes down to: Don't do this!
