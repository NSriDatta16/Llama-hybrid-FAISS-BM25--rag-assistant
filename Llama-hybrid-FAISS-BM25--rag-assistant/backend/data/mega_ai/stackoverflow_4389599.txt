[site]: stackoverflow
[post_id]: 4389599
[parent_id]: 4389565
[tags]: 
One possible optimization would be to precompute the output for any input byte. So you'd have: private static byte[] DecodedBytes = PrecomputeDecodedBytes(); public static byte[] DecodeVOQ(byte[] data) { for (int i = 0; i It's quite possible that that will be slower than your existing bitshifting algorithm though. EDIT: I've just tried comparing this with the original bitshift but using a temporary local variable: they're about the same. Have you benchmarked the current performance? Is it definitely too slow? In particular, loading the file from just about any storage medium will be much much slower than the cost of decoding. I've just tried this on my laptop - for 200MB of data, it takes about half a second. (EDIT: With Marcelo's answer, it takes under half a second.) Is that really too slow? Would you be happy to use more than one processor? It's an embarrassingly parallelizable routine, after all. If you're using .NET 4, the TPL may well make this pretty simple. I should emphasize again though that this isn't "encryption" - it's a mild form of obfuscation, in the same way that the base-64 encoding of a username/password for basic HTTP authentication is.
