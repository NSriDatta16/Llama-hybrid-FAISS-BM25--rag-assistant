[site]: stackoverflow
[post_id]: 5130641
[parent_id]: 5120644
[tags]: 
I have three concerns you might want to consider before I get to the answer: Why do you need to find the underlying jar/ear/war/class file? Are you worried about running malicious code? If so, then I strongly recommend using code signing and security policies instead. Those are the proper tools that come built-in with the platform. Application servers as well as enterprise applications might use custom class loaders that could store the jar or class files in a way that isn't immediately accessible to other applications. I can't remember any examples of such, but this bear in mind that Java does not impose or mandate any one way for how class loaders maps resources to physical files, as long as they do it consistently. By design, the interface for loading classes and resources is deliberately decoupled from the idiosyncrasies of the underlying operating system. Especially enterprise application implementations could have an incentive to mess with the way jar files are stored if it helps speed up and manage class loader managed resources. For clustered environments, you're probably out of luck. All the pieces that facilitate communication between the different nodes in a cluster are not prescribed nor governed by the Java Enterprise Edition specification. A particular vendor might have proprietary interfaces that allow you to determine which node a remote interface is talking to, but since the goal of clustering and load balancing is to make it transparent to the app and its clients, you're probably even less likely to get access to this information. Okay, on to the answer. You might want to try looking into Class.getProtectionDomain and ProtectionDomain.getCodeSource : ProtectionDomain protectionDomain = someObject.getClass().getProtectionDomain(); SourceLocation sourceLocation = protectionDomain.getCodeSource(); URL url = sourceLocation.getLocation(); Beware that calling getProtectionDomain might cause a SecurityException depending on the security policy in effect. Update: It sounds like your software is struggling with security and trust issues. But you don't have to inspect the binary code each and every time you run the code. You can achieve the same level of trust with code signing . How? You sign the code. When an external application needs to interact with your library, ask for a copy of the binary code for inspection. When you're satisfied with the result, sign the code using your own private key. Next, set up a security policy that will only allow applications signed by you to run. With e.g. RSA and a 2048 bit key, or even larger key sizes, it is practically impossible to substitute any part of the signed code with today's known attacks against RSA. This strategy require that you control the application server and the JVM on which it is running. If your trust issues go beyond this, you probably need to start thinking about mandating an open source application server, where you can inspect the source code and sign the binaries, and, ultimately, the JVM itself. Without knowing specific details about your architecture and setup, I will still recommend leveraging the security features built into the Java platform.
