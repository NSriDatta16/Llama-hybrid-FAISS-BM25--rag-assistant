[site]: stackoverflow
[post_id]: 3108451
[parent_id]: 3107924
[tags]: 
Just want to add an example of a situation in which reinterpret_cast is used. Imagine a library gives you a pointer to a raw network packet. To make sense of the data-structure you can use structs, and then cast pointers to those structs. Note that there is no way for the compiler to verify whether you are doing something sensible here or just are going to read in memory where you shouldn't. In a real life situation you would first check the size of the packet to assert that it is big enough for your structs to fit in. In the below code IPfragment constructor gets a packet and then casts that pointer into something sensible. I have added the definitions below. If someone still thinks this use of reinterpret_cast is unjustified I'm glad to here about a better way to do it. IPfragment::IPfragment( const byte* const pkt_data ) : ethernetHeader( reinterpret_cast ( pkt_data ) ) , ipHeader ( reinterpret_cast ( pkt_data + ETHER_HEADER_LEN ) ) , payload ( reinterpret_cast ( ipHeader ) + ( ipHeader->ver_hl & 0x0f ) *4 ) { } These are the definitions: typedef uint8_t byte ; typedef uint16_t word ; typedef uint32_t dword ; #define ETHER_ADDR_LEN 6 // Ethernet addresses are 6 bytes #define ETHER_HEADER_LEN 14 // Ethernet headers are 14 bytes #define ETHER_TYPE_IP4 8 struct EthernetHeader { byte etherDestHost[ETHER_ADDR_LEN]; // Destination host address byte etherSrcHost [ETHER_ADDR_LEN]; // Source host address word etherType; // IP? ARP? RARP? etc }; /* 4 bytes IP address */ struct IPaddress { byte byte1, byte2, byte3, byte4; }; /* IPv4 header */ struct IPheader { byte ver_hl ; // Version (4 bits) + Internet header length (4 bits) byte tos ; // Type of service word tlen ; // Total length word identification ; // Identification word flags_fo ; // Flags (3 bits) + Fragment offset (13 bits) byte ttl ; // Time to live byte proto ; // Protocol word crc ; // Header checksum IPaddress saddr ; // Source address IPaddress daddr ; // Destination address dword op_pad ; // Option + Padding }; class IPfragment { public: const IPheader* const ipHeader; const EthernetHeader* const ethernetHeader; const byte* const payload; IPfragment( const byte* const pkt_data ); // rest of code omitted for brevity }
