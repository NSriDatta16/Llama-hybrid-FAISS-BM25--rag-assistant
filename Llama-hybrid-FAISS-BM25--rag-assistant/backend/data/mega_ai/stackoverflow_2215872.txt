[site]: stackoverflow
[post_id]: 2215872
[parent_id]: 2215843
[tags]: 
This line seems to sum up the crux of your problem: The issue with this is that now you can't call any new methods (only overrides) on the implementing class, as your object reference variable has the interface type. You are pretty stuck in your current implementation, as not only do you have to attempt a cast, you also need the definition of the method(s) that you want to call on this subclass. I see two options: 1. As stated elsewhere, you cannot use the String representation of the Class name to cast your reflected instance to a known type. You can, however, use a String equals() test to determine whether your class is of the type that you want, and then perform a hard-coded cast: try { String className = "com.path.to.ImplementationType";// really passed in from config Class c = Class.forName(className); InterfaceType interfaceType = (InterfaceType)c.newInstance(); if (className.equals("com.path.to.ImplementationType") { ((ImplementationType)interfaceType).doSomethingOnlyICanDo(); } } catch (Exception e) { e.printStackTrace(); } This looks pretty ugly, and it ruins the nice config-driven process that you have. I dont suggest you do this, it is just an example. 2. Another option you have is to extend your reflection from just Class / Object creation to include Method reflection. If you can create the Class from a String passed in from a config file, you can also pass in a method name from that config file and, via reflection, get an instance of the Method itself from your Class object. You can then call invoke ( http://java.sun.com/javase/6/docs/api/java/lang/reflect/Method.html#invoke(java.lang.Object , java.lang.Object...)) on the Method , passing in the instance of your class that you created. I think this will help you get what you are after. Here is some code to serve as an example. Note that I have taken the liberty of hard coding the params for the methods. You could specify them in a config as well, and would need to reflect on their class names to define their Class obejcts and instances. public class Foo { public void printAMessage() { System.out.println(toString()+":a message"); } public void printAnotherMessage(String theString) { System.out.println(toString()+":another message:" + theString); } public static void main(String[] args) { Class c = null; try { c = Class.forName("Foo"); Method method1 = c.getDeclaredMethod("printAMessage", new Class[]{}); Method method2 = c.getDeclaredMethod("printAnotherMessage", new Class[]{String.class}); Object o = c.newInstance(); System.out.println("this is my instance:" + o.toString()); method1.invoke(o); method2.invoke(o, "this is my message, from a config file, of course"); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (NoSuchMethodException nsme){ nsme.printStackTrace(); } catch (IllegalAccessException iae) { iae.printStackTrace(); } catch (InstantiationException ie) { ie.printStackTrace(); } catch (InvocationTargetException ite) { ite.printStackTrace(); } } } and my output: this is my instance:Foo@e0cf70 Foo@e0cf70:a message Foo@e0cf70:another message:this is my message, from a config file, of course
