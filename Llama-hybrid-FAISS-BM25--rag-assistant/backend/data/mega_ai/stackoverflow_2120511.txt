[site]: stackoverflow
[post_id]: 2120511
[parent_id]: 2104353
[tags]: 
Summary of first answer: You cannot define a complex ODO in COBOL where the ODO object is contained within a table. Consequently it is not possible for XML GENERATE to produce a varying number of "childern" for each occurance of a "parent". You have to live with fixed table dimensions and empty nodes. Round two: Have you considered re-parsing/re-constructing the generated XML string to eliminate the empty nodes? This may sound a little odd but it may not be all that difficult. Have a look at the following program and the output it produces... IDENTIFICATION DIVISION. PROGRAM-ID. EXAMPLE1. DATA DIVISION. WORKING-STORAGE SECTION. 77 I PIC S9(4) BINARY. 77 XL PIC S9(4) BINARY. 77 XML-TAG PIC X(34). 01 XML-DATA. 05 XML-MSG-A PIC X(8000). 05 XML-CHARS-A PIC S9(4) BINARY. 05 XML-MSG-B PIC X(8000). 05 XML-CHARS-B PIC S9(4) BINARY. 01 SOURCE-REC. 05 REPEATING-PARENT OCCURS 5 TIMES. 10 PARENT-NAME PIC X(7). 10 CHILD-COUNT PIC 9. 10 REPEATING-CHILD OCCURS 5 TIMES. 15 CHILD-NAME PIC X(6). 01 XML-STACK. 05 SP PIC S9(4) BINARY. 05 STACK-REC OCCURS 500 TIMES. 15 NODE-NAME PIC X(31). 15 NODE-POS PIC S9(4) BINARY. 15 NODE-IS-EMPTY PIC X. 88 NODE-IS-EMPTY-YES VALUE 'Y'. 88 NODE-IS-EMPTY-NO VALUE 'N'. 15 EMPTY-WHEN-IND PIC X. 88 EMPTY-ZERO-OR-SPACE VALUE 'Z'. 88 EMPTY-NEVER VALUE 'N'. PROCEDURE DIVISION. INITIALIZE SOURCE-REC. MOVE 'p-1' TO PARENT-NAME (1) MOVE 2 TO CHILD-COUNT (1) MOVE 'c-1-1' TO CHILD-NAME (1 1) MOVE 'c-1-2' TO CHILD-NAME (1 2) MOVE 'p-2' TO PARENT-NAME (2) MOVE 0 TO CHILD-COUNT (2) MOVE 'p-3' TO PARENT-NAME (3) MOVE 1 TO CHILD-COUNT (3) MOVE 'c-3-1' TO CHILD-NAME (3 1) XML GENERATE XML-MSG-A FROM SOURCE-REC COUNT IN XML-CHARS-A MOVE ZERO TO XML-CHARS-B MOVE SPACES TO XML-MSG-B XML PARSE XML-MSG-A(1:XML-CHARS-A) PROCESSING PROCEDURE CLEAN-UP PERFORM VARYING I FROM 1 BY 80 UNTIL I > XML-CHARS-B DISPLAY XML-MSG-B (I:80) END-PERFORM GOBACK . CLEAN-UP SECTION. COMPUTE XL = FUNCTION LENGTH (XML-TEXT) EVALUATE XML-EVENT WHEN 'START-OF-ELEMENT' ADD 1 TO SP MOVE XML-TEXT(1:XL) TO NODE-NAME (SP) COMPUTE NODE-POS (SP) = XML-CHARS-B + 1 STRING ' ' DELIMITED BY SIZE INTO XML-TAG MOVE XML-TAG TO XML-MSG-B (XML-CHARS-B + 1:XL + 2) COMPUTE XML-CHARS-B = XML-CHARS-B + XL + 2 SET NODE-IS-EMPTY-YES (SP) TO TRUE ***** EVALUATE XML-TEXT(1:XL) ***** WHEN 'CHILD-COUNT' ***** SET EMPTY-NEVER (SP) TO TRUE ***** WHEN OTHER SET EMPTY-ZERO-OR-SPACE (SP) TO TRUE ***** END-EVALUATE WHEN 'CONTENT-CHARACTERS' IF EMPTY-ZERO-OR-SPACE (SP) AND (XML-TEXT(1:XL) = ZERO OR XML-TEXT(1:XL) = SPACE) CONTINUE ELSE SET NODE-IS-EMPTY-NO (SP) TO TRUE MOVE XML-TEXT(1:XL) TO XML-MSG-B (XML-CHARS-B + 1:XL) COMPUTE XML-CHARS-B = XML-CHARS-B + XL END-IF WHEN 'END-OF-ELEMENT' IF NODE-IS-EMPTY-YES (SP) COMPUTE XML-CHARS-B = NODE-POS (SP) - 1 SUBTRACT 1 FROM SP ELSE STRING ' ' DELIMITED BY SIZE INTO XML-TAG MOVE XML-TAG TO XML-MSG-B (XML-CHARS-B + 1:XL + 3) COMPUTE XML-CHARS-B = XML-CHARS-B + XL + 3 SUBTRACT 1 FROM SP IF SP > ZERO SET NODE-IS-EMPTY-NO (SP) TO TRUE ELSE MOVE SPACES TO XML-MSG-B (XML-CHARS-B + 1:) END-IF END-IF END-EVALUATE . Gives you the following XML string (cut into 80 character chunks) p-1 2 c-1-1 c-1-2 p-2 p-3 1 c-3-1 All of the empty nodes have been removed. Note the commented lines of code in the above program. By re-activating these you can preserve the empty REPEATING-PARENT nodes. Depending on your needs, the determination of what constitutes an empty node may be somewhat more complex. At any rate this might get you a little closer to where you want to be. Cheers...
