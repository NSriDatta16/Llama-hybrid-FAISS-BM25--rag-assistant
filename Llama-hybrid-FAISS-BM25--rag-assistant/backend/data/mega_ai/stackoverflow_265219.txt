[site]: stackoverflow
[post_id]: 265219
[parent_id]: 264744
[tags]: 
I had great success with this Passive Screen pattern. In my opinion, the big problem of the traditional MVC architecture is that people stuff way too much into the form classes. This increases the amount of manual testing you have to do. The more automated testing you can do after you compile, the more bugs you will catch at your desk. In a complex application, the side effects from even minor changes occur all too often. The trick to solving this is making a controller assembly that the form assembly (or EXE) references. Every form has a corresponding class in the assembly. Clicking a button will call ThisForm.ThisButton( ) which will then fire objects lower in your framework. Each form implements an interface so that, if the controller class needs additional information from the form, it has a interface to retrieve it. Then for your unit testing you simulate an operator performing complex operations by implementing dummy classes to fire events and feed information to the controller classes. The controller classes don't know any different as the dummy classes implement all the expected interfaces. There is an important exception and that is for trivial dialogs. For dialogs that have a few check boxes I feel this organization is overkill. I use the command pattern a lot. So in the assembly where I define the Command objects, I put the SIMPLE dialog associated with that command. How simple a dialog has to be to get this treatment is up to you. I like to structure my applications as follows. Utility - This is an assembly that has stuff I use all the time - Math functions, file function, etc. Objects - This has the specific objects I am using for this application. UIFramework - This defines all form and controller interfaces. Commands - This has all the Command objects that manipulate my application objects. UI - Objects that implement the controller interfaces EXE - Forms that implement the form interface and calls the controller objects.
