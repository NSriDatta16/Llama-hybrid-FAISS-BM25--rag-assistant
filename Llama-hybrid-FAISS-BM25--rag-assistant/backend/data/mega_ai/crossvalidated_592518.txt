[site]: crossvalidated
[post_id]: 592518
[parent_id]: 
[tags]: 
Average marginal means with marginaleffects

Is there a way to obtain averaged marginal predictions (predict then average like the margins command in Stata, not average then predict like emmeans in R) using the marginaleffects package? I am looking for a package in R that does most (preferably all that margins does in Stata) in terms of not only calculating estimated marginal means and effect (average then predict) but also for g-computation (counterfactual) type work (predict then average). It seems that the stdReg package does some of the latter, but the marginaleffects package seems to provide more functionality (except average marginal means, unless I am missing something). > library(marginaleffects) > library(emmeans) > dat_pen dat_pen $large_penguin body_mass_g > median(dat_pen $body_mass_g, na.rm = TRUE), 1, 0) > dat_pen$ species mod # Marginal Means using marginaleffects > marginalmeans(mod, variables = "species", wts = "proportional", type = "response") # group contrasts - same as emmeans term value marginalmean conf.low conf.high p.value 1 species Adelie 0.673429299 0.481262121 0.82090040 7.574010e-02 2 species Chinstrap 0.008595151 0.001845815 0.03905814 1.713151e-09 3 species Gentoo 0.983397972 0.884729508 0.99781723 9.053009e-05 > # Marginal Means using emmeans > emmeans(mod, ~ species, weights = "prop", type = "response") species prob SE df asymp.LCL asymp.UCL Adelie 0.6734 0.08962 Inf 0.48126 0.8209 Chinstrap 0.0086 0.00672 Inf 0.00185 0.0391 Gentoo 0.9834 0.01702 Inf 0.88473 0.9978 Results are averaged over the levels of: island Confidence level used: 0.95 Intervals are back-transformed from the logit scale > > # The stdReg::stdGlm function standardises (i.e. calculates the counterfactual marginal means) in R, like margins in Stata > summary(stdReg::stdGlm(fit = mod, data = dat_pen, X = "species")) Formula: large_penguin ~ species + bill_length_mm + island Family: binomial Link function: logit Exposure: species Estimate Std. Error lower 0.95 upper 0.95 Adelie 0.5821 0.0435 0.4969 0.667 Chinstrap 0.0602 0.0204 0.0202 0.100 Gentoo 0.9061 0.0826 0.7441 1.068 > > # How do I replicate this with the marginaleffects package? I wasn't sure whether to put this response here or as an answer (not sure how these things work as I don't have an answer to my own question)... Thanks Russ, I have used your emmeans package a lot - thank you for the work you do on it and your help with questions relating to emmeans on these forums. I got interested in the counterfactual/G-computation stuff when I was asked to help with an analysis recently, but my causal inference knowledge is pretty limited at this stage. I have been trying to understand what the differences between emmeans and margins in Stata (and then the marginal effects package) and how these relate to causal estimates of population-average effects. There seems to be varying terminology around marginal means and effects and so the way that I have tried to break it down is to think of methods that produce what I call: Marginal means (at means) - averaging and then predicting (essentially plugging covariate values into a regression equation). Average marginal means - predict the outcome on each row of the data (using the individual covariate combinations observed in the data) and then averaging the predicted values (Stata margins and stdReg). I thought emmeans used the first method but maybe I haven’t understood properly how emmeans works under the hood. From what I can now understand, it doesn’t seem to matter whether you ‘average and then predict’ or ‘predict and then average’ in the linear model case or the glm using the linear scale (as long as you use proportional and not equal weights). Where I think there are differences are in the case of estimating marginal means on the response scale of a non-linear model. Hopefully the code and output I’ve included might show this. Again, I am no expert and these are just thoughts on what I think I am observing when I experiment with different packages and options. Would certainly appreciate your thoughts… > library(dplyr) > # Proportions of levels within island variable > dat_pen |> + group_by(island) |> + na.omit(island) |> + summarise(n = n()) |> + mutate( prop = sprintf("%0.5f", n / sum(n))) # A tibble: 3 × 3 island n prop 1 Biscoe 163 0.48949 2 Dream 123 0.36937 3 Torgersen 47 0.14114 > # Mean of bill length > mean(dat_pen$bill_length_mm, na.rm = T) [1] 43.92193 > > # Calculate marginal probabilities (at means) for each level of species. > # My initial understanding of what emmeans essentially did (average and then predict). i.e. values can be plugged straight into the regression equation and a marginal odds/probability calculated. > # Adelie > # First calculate odds (using proportional weights for the sake of the exercise) > (odds odds/(1 + odds) # probability [1] 0.6741204 > # Chinstrap > (odds odds/(1 + odds) # probability [1] 0.008621998 > # Gentoo > (odds odds/(1 + odds) # probability [1] 0.9834492 > > # But now I realise 'average then predict' vs 'predict then average' doesn't matter for the linear model, only for the non-linear model. > # Furthermore, for the non-linear model e.g. logistic regression model, there will be a difference whether you 'predict then average' on the linear or the response scale. > > # Standardisation/G-computation (predict then average - at least as I understand it). > # This uses the observed covariate combinations in the data and is what stdReg and Stata's margins (margins default) do but I don't think emmeans can? (at least on the response scale - would be great if it could) > > # Calculate average marginal probabilities for each level of species. > # First on the linear scale > # Adelie > dat_pen_Adelie dat_pen_Adelie$species dat_pen_Adelie$pred_outcome Expec_Y_Adelie exp(Expec_Y_Adelie)/(1 + exp(Expec_Y_Adelie)) [1] 0.6734293 > # Chinstrap > dat_pen_Chinstrap dat_pen_Chinstrap$species dat_pen_Chinstrap$pred_outcome Expec_Y_Chinstrap exp(Expec_Y_Chinstrap)/(1 + exp(Expec_Y_Chinstrap)) [1] 0.008595151 > # Gentoo > dat_pen_Gentoo dat_pen_Gentoo$species dat_pen_Gentoo$pred_outcome Expec_Y_Gentoo exp(Expec_Y_Gentoo)/(1 + exp(Expec_Y_Gentoo)) [1] 0.983398 > > # Then on the response scale > # Adelie > dat_pen_Adelie dat_pen_Adelie$species dat_pen_Adelie$pred_outcome (Expec_Y_Adelie # Chinstrap > dat_pen_Chinstrap dat_pen_Chinstrap$species dat_pen_Chinstrap$pred_outcome (Expec_Y_Chinstrap # Gentoo > dat_pen_Gentoo dat_pen_Gentoo$species dat_pen_Gentoo$pred_outcome (Expec_Y_Gentoo
