[site]: stackoverflow
[post_id]: 2499425
[parent_id]: 2496477
[tags]: 
Kubi's answer is good. Rereading Apple's Guide until you grok it is really mandatory. In the mean time, you may benefit by adopting this strict set of practices I follow to avoid accidental memory errors. These prescribe a little more typing than is strictly necessary, and they're probably slightly less efficient at runtime than they could be, but following these rules consistently will protect you against the most common memory management errors. Then as you become more comfortable with memory management, you may choose to selectively deviate from these rules, although I still rarely do. Declare a property for every object instance variable you create. Declare it as (nonatomic, retain), unless it's an object your class doesn't own, like a delegate, which would create a circular reference. In that case, declare it as (nonatomic, assign) to avoid leaking all the objects in that cycle. @property (nonatomic, retain) NSString *title; @property (nonatomic, assign) id delegate; Even if an object instance variable is intended only for private use by the class, declare a property for it in a class extension at the top of your .m file so that the synthesized setter method can take care of memory management for you. // Widget.m @interface Widget() @property (nonatomic, retain) NSString *privateState; @end @implementation Widget @synthesize title, delegate, privateState; // ... @end Any time you assign an instance variable object, always set it through the property using self. self.title = @"Title"; In your dealloc, set every object property to nil. If you've followed the above practices, this will simultaneously release your instance variables properly and set them to nil to guard against EXC_BAD_ACCESS. Make dealloc the first method in your class so you don't forget any properties. - (void) dealloc { self.title = nil; self.delegate = nil; self.privateState = nil; [super dealloc]; } For every custom class you write, make sure it has at least one class factory method that delegates to an init method with the same parameters and autoreleases the returned object. This confines almost all alloc and init calls to these factory methods rather than scattering them throughout your code. - (id)initWithTitle:(NSString *)theTitle delegate:(id )theDelegate { if (self = [super init]) { self.title = theTitle; self.delegate = theDelegate; self.privateState = @"start"; } return self; } + (id)widgetWithTitle:(NSString *)theTitle delegate:(id )theDelegate { return [[[self alloc] initWithTitle:theTitle delegate:theDelegate] autorelease]; } Whenever you instantiate an object, always do it through a factory class method if possible. This gives you an autoreleased object, so you don't have to release it unless you retain it. self.widget = [Widget widgetWithTitle:@"My Widget" delegate:self]; When you need to instantiate an object that has no appropriate factory class method, autorelease it on the same line, so you don't forget to do it later. (Exception: release manually if you're doing this thousands of times in a tight loop.) self.containerView = [[[UIView alloc] initWithFrame:self.bounds] autorelease]; If you're releasing an object that has a delegate or similar property that points back in a circular reference, set that property to nil first. This prevents EXC_BAD_ACCESS in the event that an object outlives its delegate and tries to call a method on the delegate after it's been dealloced. - (void)dealloc { self.widget.delegate = nil; self.widget = nil; self.containerView = nil; [super dealloc]; } Many experienced developers manage memory successfully without following all of these practices. If you understand memory management and don't tend to have memory related bugs, I'd certainly encourage you to stick with whatever works for you. But if you're new to iPhone memory management, or if your code is plagued with accidental memory related bugs, I hope you find these practices as helpful as I have.
