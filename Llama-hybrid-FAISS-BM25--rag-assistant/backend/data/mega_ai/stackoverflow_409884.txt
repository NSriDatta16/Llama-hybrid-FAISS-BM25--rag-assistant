[site]: stackoverflow
[post_id]: 409884
[parent_id]: 409563
[tags]: 
If you are going to use the code pattern in your example, call it TryDoSomething, and catch only specific exceptions. Also consider using an Exception Filter when logging exceptions for diagnostic purposes. VB has language support for Exception filters. The link to Greggm's blog has an implementation that can be used from C#. Exception filters have better properties for debuggability over catch and rethrow. Specifically you can log the problem in the filter and let the exception continue to propagate. That method allows an attaching a JIT (Just in Time) debugger to have the full original stack. A rethrow cuts the stack off at the point it was rethrown. The cases where TryXXXX makes sense are when you are wrapping a third party function that throws in cases that are not truly exceptional, or are simple difficult to test without calling the function. An example would be something like: // throws NumberNotHexidecimalException int ParseHexidecimal(string numberToParse); bool TryParseHexidecimal(string numberToParse, out int parsedInt) { try { parsedInt = ParseHexidecimal(numberToParse); return true; } catch(NumberNotHexidecimalException ex) { parsedInt = 0; return false; } catch(Exception ex) { // Implement the error policy for unexpected exceptions: // log a callstack, assert if a debugger is attached etc. LogRetailAssert(ex); // rethrow the exception // The downside is that a JIT debugger will have the next // line as the place that threw the exception, rather than // the original location further down the stack. throw; // A better practice is to use an exception filter here. // see the link to Exception Filter Inject above // http://code.msdn.microsoft.com/ExceptionFilterInjct } } Whether you use a pattern like TryXXX or not is more of a style question. The question of catching all exceptions and swallowing them is not a style issue. Make sure unexpected exceptions are allowed to propagate!
