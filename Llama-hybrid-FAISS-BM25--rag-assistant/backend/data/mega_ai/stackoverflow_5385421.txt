[site]: stackoverflow
[post_id]: 5385421
[parent_id]: 
[tags]: 
Weird behavior of GeoPoint and/or android.maps.Projection when panning a MapView at max zoom level

I've run into a weird problem with points getting offset using the google maps package. I have a MapView with a route displayed on it. I noticed that if I zoom all the way in, and then pan around, my route was getting clipped near the edges of the window. After much debugging of my own code, I discovered that even a simple case like this was enough to repro the issue: GeoPoint midPoint = projection.fromPixels(mapView.getWidth()/2, mapView.getHeight()/2); GeoPoint nextPoint = new GeoPoint(midPoint.getLatitudeE6(), midPoint.getLongitudeE6()); pathPaint.setColor(0xFF00FF00); projection.toPixels(midPoint, screenPoint); canvas.drawCircle(screenPoint.x, screenPoint.y, 5, pathPaint); pathPaint.setColor(0xFF0000FF); projection.toPixels(nextPoint, screenPoint); canvas.drawCircle(screenPoint.x, screenPoint.y, 5, pathPaint); This uses the Projection class returned by MapView.getProjection() to translate pixels coordinates into a GeoPoint. It then creates a second GeoPoint using the same lat/long. Finally it translates both of these GeoPoints back into screen coordinates and draws two circles, one on top of the other, at this location. Except, as you pan around, the second circle gets offset from the first. They have identical lat/lon coordinates (I check after the drawing), but end up getting translated to different screen coordinates. My debugging has focused on panning horizontally, but I believe that panning vertically can hit a similar problem, based on what I was seeing with my original app code. As far as I can tell, any points that are created by the maps package work fine, but any that are created by calling new GeoPoint(lat, lon) exhibit this behavior. I have created a simple stripped-down application that exhibits this behavior, pasted below. (Map tiles won't download because I didn't bother to sign it, but you don't need them to see the issue.) Just launch it, zoom in all the way, and start panning left or right. Watch the green and blue points diverge, and witness the Log.d prints that state they still have equal lat/lon. (Is there a better/preferred way for posting sample projects? Sorry, this is my first posting here.) src/example/mysample/MapOverlay.java: package example.mysample; import java.util.ArrayList; import android.content.Context; import android.graphics.Canvas; import android.graphics.Paint; import android.graphics.Point; import android.graphics.Color; import android.graphics.DashPathEffect; import android.graphics.RadialGradient; import android.graphics.Shader; import android.view.MotionEvent; import com.google.android.maps.GeoPoint; import com.google.android.maps.MapView; import com.google.android.maps.Overlay; import com.google.android.maps.Projection; import android.util.Log; class MapOverlay extends Overlay { public MapOverlay(MapScreen activity) { super(); paint = new Paint(); paint.setStyle(Paint.Style.FILL_AND_STROKE); paint.setAntiAlias(true); } @Override public boolean onTouchEvent(MotionEvent e, MapView mapView) { int motionAction = e.getAction(); if ( motionAction == MotionEvent.ACTION_MOVE ) { dragging = true; } if ( motionAction == MotionEvent.ACTION_UP || motionAction == MotionEvent.ACTION_CANCEL ) { dragging = false; } return super.onTouchEvent(e, mapView); } @Override public void draw(Canvas canvas, MapView mapView, boolean shadow) { if (!shadow && !dragging) { Projection projection = mapView.getProjection(); // Draw two circles at the center // One with a virgin point, one that we constructed with the same coordinates GeoPoint midPoint = projection.fromPixels(mapView.getWidth()/2, mapView.getHeight()/2); GeoPoint nextPoint = new GeoPoint(midPoint.getLatitudeE6(), midPoint.getLongitudeE6()); paint.setColor(0xFF00FF00); projection.toPixels(midPoint, screenPoint); canvas.drawCircle(screenPoint.x, screenPoint.y, 5, paint); paint.setColor(0xFF0000FF); projection.toPixels(nextPoint, screenPoint); canvas.drawCircle(screenPoint.x, screenPoint.y, 5, paint); // These print EQUAL. Log.d("BKC DEBUG", "Midpoint and our own midpoint have " + ((midPoint.getLatitudeE6() == nextPoint.getLatitudeE6()) ? "EQUAL" : "UNEQUAL") + " latitudes, and " + ((midPoint.getLongitudeE6() == nextPoint.getLongitudeE6()) ? "EQUAL" : "UNEQUAL") + " longitudes"); } } private Paint paint; private boolean dragging; private Point screenPoint = new Point(); } src/example/mysample/MapScreen.java: package example.mysample; import android.os.Bundle; import android.view.View; import android.widget.Toast; import android.util.Log; import com.google.android.maps.MapActivity; import com.google.android.maps.MapController; import com.google.android.maps.MapView; import com.google.android.maps.GeoPoint; public class MapScreen extends MapActivity { @Override public void onCreate(Bundle icicle) { super.onCreate(icicle); setContentView(R.layout.map); mapView = (MapView)findViewById(R.id.map_map); mapView.setBuiltInZoomControls(true); mapView.getOverlays().add(new MapOverlay(this)); MapController controller; controller = mapView.getController(); controller.setZoom(17); controller.animateTo(new GeoPoint(36000000, -90000000)); } @Override public boolean isRouteDisplayed() { return true; } private MapView mapView; } res/layout/map.xml: AndroidManifest.xml: build.xml (unchanged from template): [This is typically used for code obfuscation. Compiled code location: ${out.classes.absolute.dir} If this is not done in place, override ${out.dex.input.absolute.dir}] --> /platforms/ /ant/ant_rules_r#.xml To customize existing targets, there are two options: - Customize only one target: - copy/paste the target into this file, *before* the task. - customize it to your needs. - Customize the whole script. - copy/paste the content of the rules files (minus the top node) into this file, *after* the task - disable the import of the rules by changing the setup task below to . - customize to your needs. -->
