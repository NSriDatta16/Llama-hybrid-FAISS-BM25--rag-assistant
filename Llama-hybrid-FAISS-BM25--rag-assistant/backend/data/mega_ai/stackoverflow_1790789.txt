[site]: stackoverflow
[post_id]: 1790789
[parent_id]: 1790550
[tags]: 
I've got two possible solutions here for you. Both are just generic running average functions that work on any list of numbers. (could be made to work with any iterable) Generator based: nums = [cauchy(3,1) for x in xrange(10)] def running_avg(numbers): for count in xrange(1, len(nums)+1): yield sum(numbers[:count])/count print list(running_avg(nums)) List Comprehension based (really the same code as the earlier): nums = [cauchy(3,1) for x in xrange(10)] print [sum(nums[:count])/count for count in xrange(1, len(nums)+1)] Generator-compatabile Generator based: Edit : This one I just tested to see if I could make my solution compatible with generators easily and what it's performance would be. This is what I came up with. def running_avg(numbers): sum = 0 for count, number in enumerate(numbers): sum += number yield sum/(count+1) See the performance stats below, well worth it. Performance characteristics: Edit : I also decided to test Orip's interesting use of multiple generators to see the impact on performance. Using timeit and the following (1,000,000 iterations 3 times): print "Generator based:", ', '.join(str(x) for x in Timer('list(running_avg(nums))', 'from __main__ import nums, running_avg').repeat()) print "LC based:", ', '.join(str(x) for x in Timer('[sum(nums[:count])/count for count in xrange(1, len(nums)+1)]', 'from __main__ import nums').repeat()) print "Orip's:", ', '.join(str(x) for x in Timer('list(itertools.islice(running_avgs, 10))', 'from __main__ import itertools, running_avgs').repeat()) print "Generator-compatabile Generator based:", ', '.join(str(x) for x in Timer('list(running_avg(nums))', 'from __main__ import nums, running_avg').repeat()) I get the following results: Generator based: 17.653908968, 17.8027219772, 18.0342400074 LC based: 14.3925321102, 14.4613749981, 14.4277560711 Orip's: 30.8035550117, 30.3142540455, 30.5146529675 Generator-compatabile Generator based: 3.55352187157, 3.54164409637, 3.59098005295 See comments for code: Orip's genEx based: 4.31488609314, 4.29926609993, 4.30518198013 Results are in seconds, and show the LC new generator-compatible generator method to be consistently faster, your results may vary though. I expect the massive difference between my original generator and the new one is the fact that the sum isn't calculated on the fly.
