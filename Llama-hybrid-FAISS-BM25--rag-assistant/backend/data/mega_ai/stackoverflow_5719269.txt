[site]: stackoverflow
[post_id]: 5719269
[parent_id]: 5719207
[tags]: 
No, what you're asking isn't possible, for a couple of reasons. .NET doesn't allow one class to directly inherit from multiple classes. The project needs to refer to the parent class's library when it is compiled, so it can't be assigned a new parent class at runtime. Usually when you run into a situation where you want to do what you're describing, it's because you're using an architecture that doesn't separate concerns well enough. I'm just guessing here, but you'll probably be more flexible if you use an approach like this: public interface IBaseObject { int ObjectId {get;} } public class CashRegister : IBaseObject { int IBaseObject.ObjectId { get {return CashRegisterId;} } public int CashRegisterId {get;set;} } public class BaseObjectUtil { public void SomeGenericBaseObjectMethod(IBaseObject baseObject) { var objectId = baseObject.ObjectId; // Do something with the object ID. } } public class SomeUtility { private BaseObjectUtil _baseObjectUtil; public SomeUtility(BaseObjectUtil baseObjectUtil) { _baseObjectUtil = baseObjectUtil; } public void DoSomethingImportant(CashRegister register) { _baseObjectUtil.SomeGenericBaseObjectMethod(register); } } You'll notice that so far we don't have any code that relies on CouchDb. Now, say there's another project that wants to be able to use the above project, but wants to be able to perform additional operations based on the CouchDb information. You might do something like this: public interface ICouchDbObject { string TableName {get;} } public class CouchDbUtil { public void SomeCouchDbSpecificMethod(ICouchDbObject couchDbObject) { var tableName = couchDbObject.TableName; // Do something with the table name. } } public class CouchDbCashRegister : CashRegister, ICouchDbObject { string ICouchDbObject.TableName {get{return "CashRegisters";}} } In this project, when you need a cash register, you would use a CouchDbCashRegister , which would allow you to call the CouchDb-specific methods on your CouchDbUtil class, while still allowing you to call the baseline utility methods in your BaseObjectUtil class. Furthermore, if you leverage a DI framework like Ninject to create your objects, you can actually make it so that all CashRegisters that get created in your second project are actually CouchDbCashRegisters. Bind .To ();
