[site]: stackoverflow
[post_id]: 2242784
[parent_id]: 
[tags]: 
Ninject kernel creation inside a class library

I have a class that has dependencies that I've wired up with Ninject. public interface IFoo {} public class MyObject { [Inject] IFoo myfoo; } In the real implementation I'm using property injection, but just to quickly illustrate, I'll inject on the field. As I understand, instead of newing instances of MyObject, in order to get the dependencies to be properly injected, I need to use kernel.Get () The thing I'm stumbling on however is that MyObject will only be used in the context of a class library. The intention is for end applications to create their own modules and pass it into a kernel instance to hydrate. Given that, what's generally the most pragmatic way to approach surfacing a generic instance of a Ninject kernel to my class library so that instances of MyObject (and other similar cases) can be hydrated? My first inclination is some sort of factory that internalizes a singleton kernel--which the applications themselves have to hydrate/initialize by loading up a module. So in RandomService.cs var myKernel = NinjaFactory.Unleash(); var myobj = myKernel.Get (); myobj.foo(); Before I go too far down this path though, I need to do a sanity check to make sure that the thinking is sound or that there isn't some obvious other thing that I'm missing. I'm obviously new to IoC and feel like I grok the basics, but not necessarily the best real world ways to use it.
