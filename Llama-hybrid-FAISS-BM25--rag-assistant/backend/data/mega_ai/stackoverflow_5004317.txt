[site]: stackoverflow
[post_id]: 5004317
[parent_id]: 5004209
[tags]: 
In embedded systems malloc() is often used to allocate memory on startup that will be used while the system is running and never free()d. But you shouldn't do something like this periodically since it will use up your memory if you don't free() it again. What you are doing in your example is leak one buffer worth of memory each round in the while loop. What you should do is either, call free() in your loop but be aware this can still fragment menmory which is especially bad in an long running embedded system. If you know in advance how much memory you will need in advance: malloc the buffer once outside the loop and reuse it in the loop: response = malloc(MAX_BUF_SIZE); while (1) { get_file(response, MAX_BUF_SIZE); /* always good to pass the buf size and check */ ... use response ... } Or if you don't know the size in advance one pattern can be: response = NULL; size = 0; while (1) { get_file(&response, &size); ... use response ... } void get_file(char **buf, int *s) { size = ... somehow determine the needed size ... if (size > *s) *buf = realloc(*buf, size); /* only does free/malloc internaly if it has to no room */ strncpy(*buf, whatver, size); } And you should always use strncpy and never strcpy please! The use of strcpy in your example is confusing, it can't be seen where response gets its memory, is it statically allocated? Has it been malloced before? If response already points to a vaid buffer you should just pass the pointer to the buffer to your getFile() and directly copy the buffer there. If response doesn't point to a valid memory buffer this will not work anyway.
