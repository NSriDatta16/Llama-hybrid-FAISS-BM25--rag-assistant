[site]: stackoverflow
[post_id]: 3108745
[parent_id]: 3108631
[tags]: 
If you want to have a C API call a member function, you have to pass two pieces of data: the (static member) function and the object for which it is to be invoked. Usually, C API callbacks have some form of "user data", often a void* , through which you can tunnel your object's address: // Beware, brain-compiled code ahead! typedef void (*callback)(int data, void* user_data); void f(callback cb, void* user_data); class cpp_callback { public: virtual ~cpp_callback() {} // sometimes needed void cb(int data) = 0; callback* get_callback() const {return &cb_;} private static void cb_(int data, void* user_data) { cpp_callback* that = reinterpret_cast (user_Data); that->cb(data); } }; class my_callback { public: void cb(int data) { // deal with data } }; void g() { my_callback cb; f(cb.get_callback(), &cb); } That pcapCallback doesn't look as if it has user data, though, unless that's what param is. If that's indeed the case, you'll have to store the callback object's address in some global variable before calling the API. Something like this: // Beware, brain-compiled code ahead! typedef void (*callback)(int data); void f(callback cb); class cpp_callback { public: cpp_callback() : the_old_cb_(this) {std::swap(the_cb_,the_old_cb_);} virtual ~cpp_callback() {std::swap(the_cb_,the_old_cb_);} void cb(int data) = 0; callback* get_callback() const {return &cb_;} private static cpp_callback* the_cb_; cpp_callback* the_old_cb_; static void cb_(int data, void* user_data) { the_cb_->cb(data); } }; class my_callback { public: void cb(int data) { /* deal with data */ } }; void g() { my_callback cb; f(cb.get_callback(), &cb); } As always with global data, this is perilous if more than one instance of the callback is alive. I have tried to minimize the harm so that it works if their lifetimes are nested. Anything else, though, will hurt.
