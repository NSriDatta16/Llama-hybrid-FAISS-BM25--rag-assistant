[site]: stackoverflow
[post_id]: 5432860
[parent_id]: 5429501
[tags]: 
Properly handling float precision issues can be tricky. You should not rely on float equality (that's what list comprehension implicitely does for the last element). List comprehensions on float are useful when you generate an infinite stream. In other cases, you should pay attention to the last comparison. If you want a fixed number of elements, and include both lower and upper endpoints, I suggest you write this kind of function: let range from to_ count = assert (count > 1) let count = count - 1 [ for i = 0 to count do yield from + float i * (to_ - from) / float count] range 21.5 40.5 21 When I know the last element should be included, I sometimes do: let a = [ for z in min .. dl .. max + dl*0.5 -> z ]
