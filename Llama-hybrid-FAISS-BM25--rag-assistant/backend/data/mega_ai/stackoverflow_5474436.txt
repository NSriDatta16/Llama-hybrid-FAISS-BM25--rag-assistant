[site]: stackoverflow
[post_id]: 5474436
[parent_id]: 1917433
[tags]: 
I like LBuskin's summary. With regards to the fragile base class problem, there is one case where I am thinking protected events may be a contender for best practice: you have events truly intended for internal class use (as opposed to strategies perhaps like the OP's Render), such as Initializing or EnabledChanging, you have the potential for a large inheritance hierarchy (deep and/or broad), with multiple levels needing to act on the event ( multiple non-public consumers !) you do not want to rely on each derived class remembering to invoke base.OnSomethingHappened(). (Avoid fragile base class problem.) order of handling the event does not matter (otherwise use a chain of base.OnSomethingHappened() to control the order.) the event applies to some kind of internal state change and would not be meaningful to an external class (otherwise use a public event ). For example, a public Initializing event would typically be a cancellable event that occurs before any internal initializing occurs. A protected Initializing event should not be exposed to the user of the class as a cancellable event because the class may already be partially initialized. This avoids the need to document virtual protected methods with "derived classes should call base method" and hope that you or others who derive classes always read the documentation and follow it. It also avoids uncertainty in wondering whether the call to the base method should be called at the beginning of the overridden method, or in the middle or end. Note: If you think a base class attaching to its own event is silly, there is nothing stopping you from having a non-virtual method in the base class. In the OP's case, I would think the Init and possibly Move events might meet the above criteria depending on circumstances. Typically, it is unlikely to ever have more than one Render method, so an abstract method (or empty virtual method, if this class lets you run simulations without drawing anything) method that did not need to invoke any base Render method seems most likely here. A strategy (public delegate) for Render would be helpful if external components may know how to draw the class to the graphics target, perhaps with alternate visual styling (i.e. 2D vs 3D). It seems unlikely for a Render method, but perhaps may apply to other functions not mentioned, especially ones that apply an algorithm (trend line averaging method, etc.).
