[site]: stackoverflow
[post_id]: 4503332
[parent_id]: 3539274
[tags]: 
While I realize this thread is 4+ months stale now, it's worth noting that Akka has a new HTTP module implementation that transfers the request into an actor efficiently. This approach leverages the asynchronous servlet API (also works with Jetty continuations) to enable the suspended request to be passed through the system as a message and resumed at any point; eliminating, for instance, the need to use !! to trigger actor work and respond in the annotated POJO. Likewise, since the request is suspended in the container, and the context is flipped into an actor as quick as possible, there are no threads blocking to handle the response or future. One naive way the above example might be rewritten today: class TestEndpoint extends Actor with Endpoint { def hook(uri:String) = uri == "/test" def provide(uri:String) = actorOf[TestService].start override def preStart = { ActorRegister.actorsFor[classOf[RootEndpoint]).head ! Endpoint.Attach(hook, provide) } def receive = handleHttpRequest } class TestService extends Actor { def receive = { case get:Get => get.timeout(SomeObject.TimeoutInSeconds) // for example get.OK(SomeObject.slowDBMethod) case other:RequestMethod => other.NotAllowed("Invalid method for this endpoint") } } More documentation can be found on the akka site: http://doc.akkasource.org/http
