[site]: stackoverflow
[post_id]: 1871433
[parent_id]: 760376
[tags]: 
Consider the implementation of a snakes and ladders games In a procedural design we might write a function like function move(int n) { pos += n; switch(pos) { case 6: pos = 10; break; case 12: pos = 4; break; case 15: pos = 32; break; case 16: pos = 8; break; // ... } } in an object design language we would create a linked list of Square instances, with some Ladder and Snake instances that branch to other squares. class Square def initialize(next) @tokens = [] @next = next end def next(n) n == 0 ? self : next.next(n-1) end def move(token,n) tokens.remove(token) target = self.next(n) target.tokens as you can see, we implement the game rules in the objects as well as the way they are composed (rather than in a switch case statement). This has the advantage that it is simple to add new game rules at development time, you'll just write a new subclass of Square it is simple to change the layout of the game at runtime (might sound strange for a game, but for your average business app, this is what you want) this flexibility is what makes OO so powerful.
