[site]: stackoverflow
[post_id]: 4881443
[parent_id]: 
[tags]: 
Clojure's 'let' equivalent in Scala

Often I face following situation: suppose I have these three functions def firstFn: Int = ... def secondFn(b: Int): Long = ... def thirdFn(x: Int, y: Long, z: Long): Long = ... and I also have calculate function. My first approach can look like this: def calculate(a: Long) = thirdFn(firstFn, secondFn(firstFn), secondFn(firstFn) + a) It looks beautiful and without any curly brackets - just one expression. But it's not optimal, so I end up with this code: def calculate(a: Long) = { val first = firstFn val second = secondFn(first) thirdFn(first, second, second + a) } Now it's several expressions surrounded with curly brackets. At such moments I envy Clojure a little bit. With let function I can define this function in one expression. So my goal here is to define calculate function with one expression . I come up with 2 solutions. 1 - With scalaz I can define it like this (are there better ways to do this with scalaz?): def calculate(a: Long) = firstFn |> {first => secondFn(first) |> {second => thirdFn(first, second, second + a)}} What I don't like about this solution is that it's nested. The more val s I have the deeper this nesting is. 2 - With for comprehension I can achieve something similar: def calculate(a: Long) = for (first From one hand this solution has flat structure, just like let in Clojure, but from the other hand I need to wrap functions' results in Option and receive Option as result from calculate (it's good it I'm dealing with nulls, but I don't... and don't want to). Are there better ways to achieve my goal? What is the idiomatic way for dealing with such situations (may be I should stay with val s... but let way of doing it looks so elegant)? From other hand it's connected to Referential transparency . All three functions are referentially transparent (in my example firstFn calculates some constant like Pi), so theoretically they can be replaced with calculation results. I know this, but compiler does not, so it can't optimize my first attempt. And here is my second question: Can I somehow (may be with annotation) give hint to compiler, that my function is referentially transparent, so that it can optimize this function for me (put some kind of caching there, for example)? Edit Thanks everybody for the great answers! It's just impossible to select one best answer (may be because they all so good) so I will accept answer with the most up-votes, I think it's fair enough.
