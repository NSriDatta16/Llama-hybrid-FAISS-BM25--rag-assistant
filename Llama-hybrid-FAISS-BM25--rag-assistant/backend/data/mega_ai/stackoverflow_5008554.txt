[site]: stackoverflow
[post_id]: 5008554
[parent_id]: 5007469
[tags]: 
iText[Sharp]'s parser package doesn't yet handle lineTo or curveTo commands. It's a goal, but not one that's been important enough to implement as yet. Other Things are getting attention at the moment. If you're feeling adventurous, you should check out PdfContentStreamProcessor. In a private function populateOperators , there's a long list of commands that are currently handled (in one fashion or another). You'd need to write similar command classes for all the line art commands (moveTo, lineTo, rect, stroke, fill, clip), and expose them in some way. Actually, if all you want to do is COUNT the number of paths, you could just implement stroke and fill to increment some static integer[s], then check them after parsing. Should be fairly simple (I'm writing in Java, but it's easy enough to translate): private static class CountOps implements ContentOperator { public static int operationCount = 0; public void invoke(PdfContentStreamProcessor processor, PdfLiteral operator, ArrayList operands) { ++operationCount; } } Ah! registerContentOperator is a public function. You don't need to change iText's source at all: PdfContentStreamProcessor proc = new PdfContentStreamProcessor(null); CountOps counter = new CountOps(); proc.registerContentOperator("S", countOps); // stroke the path proc.registerContentOperator("s", countOps); // close & stroke proc.registerContentOperator("F", countOps); // fill, backward compat proc.registerContentOperator("f", countOps); // fill proc.registerContentOperator("f*", countOps); // fill with event-odd winding rule proc.registerContentOperator("B", countOps); // fill & stroke proc.registerContentOperator("B*", countOps); // fill & stroke with even-odd proc.registerContentOperator("b", countOps); // close, fill, & stroke proc.registerContentOperator("b*", countOps); // close, fill, & stroke with even-odd proc.processContent( contentBytes, pageResourceDict ); int totalStrokesAndFills = CountOps.operationCount; // note that stroke&fill operators will be counted once, not twice. Something like that. Only a null RenderListener will cause a null pointer exception if you run into any text or images. You could whip up a no-op listener yourself or use one of the existing ones and ignore its output. PS: iTextSharp 5.0.6 should be released any day now if it isn't out already.
