[site]: stackoverflow
[post_id]: 1244538
[parent_id]: 1244180
[tags]: 
Google 'open source "file lifecycle management"'. I'm sorry, I'm only aware of commercial SAN apps, not if there are F/OSS alternatives. The way the commercial apps work is the filesystem appears normal -- all files are present. However, if the file has not been accessed in a certain period (for us, this is 90 days), the file is moved to secondary storage. That is, all but the first 4094 bytes are moved. After a file is archived, if you seek (read) past byte 4094 there is a slight delay while the file is pulled back in from secondary storage. I'm guessing files smaller than 4094 bytes are never sent to secondary storage, but I'd never thought about it. The only problem with this scheme is if you happen to have something that tries to scan all of your files (a web search index, for example). That tends to pull everything back from secondary storage, fills up primary, and the IT folks start giving you the hairy eyeball. (I'm, ahem , speaking from some slight experience.) You might try asking this over on ServerFault.com. If you're handy, you might be able to come up with a similar approach using cron and shell scripts. You'd have to replace the 4094-byte stuff with symlinks (and note, the below is not tested). # This is the server's local storage, available via network SOURCE_STORAGE_PATH=/opt/network/mounted/path # This is the remote big backup mount TARGET_STORAGE_PATH=/mnt/remote/drive # This is the number of days to start archiving files DAYS_TO_ARCHIVE=90 # Find old files that are not already symlinks, using temp files # NOTE: You might have to account for spaces in file names TEMP_FILE=$(mktemp) find ${SOURCE_STORAGE_PATH} -atime +${DAYS_TO_ARCHIVE} -a -not -type l > ${TEMP_FILE} # This probably needs to change, if too many files in TEMP_FILE... # this would be a good point to drop into something like Perl for FILE in $(cat ${TEMP_FILE}); do # split source into path and file name BASE_PATH=$(dirname ${FILE}); FILE_NAME=$(basename ${FILE}) # path to target TARGET_PATH=${TARGET_STORAGE_PATH}/${BASE_PATH} # make sure target exists (note -p option to mkdir) [ -d "${TARGET_PATH}" ] || mkdir -p ${TARGET_PATH} # move source to target mv ${FILE} ${TARGET_PATH} # replace source with symlink to target ln -s ${TARGET_PATH}/${FILE_NAME} ${FILE} done
