[site]: stackoverflow
[post_id]: 4497284
[parent_id]: 4470012
[tags]: 
Static and dynamic are jargon words that refer to the point in time at which some programming element is resolved. Static indicates that resolution takes place at the time a program is constructed. Dynamic indicates that resolution takes place at the time a program is run. Static and Dynamic Typing Typing refers to changes in program structure that are due to the differences between data values: integers, characters, floating point numbers, strings, objects and so on. These differences can have many effects, for example: memory layout (e.g. 4 bytes for an int, 8 bytes for a double, more for an object) instructions executed (e.g. primitive operations to add small integers, library calls to add large ones) program flow (simple subroutine calling conventions versus hash-dispatch for multi-methods) Static typing means that the executable form of a program generated at build time will vary depending upon the types of data values found in the program. Dynamic typing means that the generated code will always be the same, irrespective of type -- any differences in execution will be determined at run-time. Note that few real systems are either purely one or the other, it is just a question of which is the preferred strategy. Static and Dynamic Binding Binding refers to the association of names in program text to the storage locations to which they refer. In static binding , this association is predetermined at build time. With dynamic binding , this association is not determined until run-time. Truly static binding is almost extinct. Earlier assemblers and FORTRAN, for example, would completely precompute the exact memory location of all variables and subroutine locations. This situation did not last long, with the introduction of stack and heap allocation for variables and dynamically-loaded libraries for subroutines. So one must take some liberty with the definitions. It is the spirit of the concept that counts here: statically bound programs precompute as much as possible about storage layout as is practical in a modern virtual memory, garbage collected, separately compiled application. Dynamically bound programs wait as late as possible. An example might help. If I attempt to invoke a method MyClass.foo() , a static-binding system will verify at build time that there is a class called MyClass and that class has a method called foo . A dynamic-binding system will wait until run-time to see whether either exists. Contrasts The main strength of static strategies is that the program translator is much more aware of the programmer's intent. This makes it easier to: catch many common errors early, during the build phase build refactoring tools incur a significant amount of the computational cost required to determine the executable form of the program only once, at build time The main strength of dynamic strategies is that they are much easier to implement, meaning that: a working dynamic environment can be created at a fraction of the cost of a static one it is easier to add language features that might be very challenging to check statically it is easier to handle situations that require self-modifying code
