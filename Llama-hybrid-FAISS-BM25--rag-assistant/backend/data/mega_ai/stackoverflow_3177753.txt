[site]: stackoverflow
[post_id]: 3177753
[parent_id]: 
[tags]: 
Partially protected interface but without abstract class

I have following code. And I need to hide one function of the interface. interface IOne { int FunctionOne(); } interface ITwo { double FunctionTwo(); } interface IInterfaceToImplement : IOne, ITwo { void AFunctionToImplement(); } public abstract MyBaseClass : TheVeryHeavyBaseClass , IInterfaceToImplement { public abstract void AFunctionToImplement(); // How to force this one to be protected? public virtual int FunctionOne() { return 0; } public virtual double FunctionTwo() { return 0.0; } } public MyConcreteClass : MyBaseClass { public override void AFunctionToImplement(); // How to force this one to be protected? } As you can see I have base class. And I need the AFunctionToImplement() to be hidden. Do I have poor classes design? Any suggestions on how to protected the function from being called? EDIT. Answer to Pavel Minaev question in the comments. I need every concrete class implement the list of functions from IInterfaceToImplement. Also I need every concrete class to be able to store classes of IInterfaceToImplement type. This is tree-like data storage. Every 'branch' of the storage have to perform same operations as any other branch. But nobody else except the 'root' and other 'braches' must call these operations. EDIT2 My solution. Thanks Matthew Abbott and Pavel Minaev. I finally realized my problem - it is brain. :) No, I'm joking. :) The problem is - I thought of root and branch classes as of the same branch. Now I understand - the root should not implement IInterfaceToImplement . See the solution: public class MyRootClass : IOne, ITwo { private IInterfaceToImplement internalData = new MyConcreteClass(); public int FunctionOne() { return this.internalData.FunctionOne(); } public double FunctionTwo() { return this.internalData.FunctionTwo(); } }
