[site]: stackoverflow
[post_id]: 3119497
[parent_id]: 3118600
[tags]: 
Without seeing the data and its exact distribution, I can't say for certain what the best method is, but I would suggest that you start each group of 1-4 records with a byte whose 8 bits indicate the following: 0-1 Number of bytes of ID that should be borrowed from previous record 2-4 Format of position record 6-7 Number of succeeding records that use the same 'mode' byte Each position record may be stored one of eight ways; all types other than 000 use signed displacements. The number after the bit code is the size of the position record. 000 - 8 - Two full four-byte positions 001 - 3 - Twelve bits for X and Y 010 - 2 - Ten-bit X and six-bit Y 011 - 2 - Six-bit X and ten-bit Y 100 - 4 - Two sixteen-bit signed displacements 101 - 3 - Sixteen-bit X and 8-bit Y signed displacement 110 - 3 - Eight-bit signed displacement for X; 16-bit for Y 111 - 2 - Two eight-bit signed displacements A mode byte of zero will store all the information applicable to a point without reference to any previous point, using a total of 13 bytes to store 12 bytes of useful information. Other mode bytes will allow records to be compacted based upon similarity to previous records. If four consecutive records differ only in the last bit of the ID, and either have both X and Y within +/- 127 of the previous record, or have X within +/- 31 and Y within +/- 511, or X within +/- 511 and Y within +/- 31, then all four records may be stored in 13 bytes (an average of 3.25 bytes each (a 73% reduction in space). A "greedy" algorithm may be used for compression: examine a record to see what size ID and XY it will have to use in the output, and then grab up to three more records until one is found that either can't "fit" with the previous records using the chosen sizes, or could be written smaller (note that if e.g. the first record has X and Y displacements both equal to 12, the XY would be written with two bytes, but until one reads following records one wouldn't know which of the three two-byte formats to use). Before setting your format in stone, I'd suggest running your data through it. It may be that a small adjustment (e.g. using 7+9 or 5+11 bit formats instead of 6+10) would allow many data to pack better. The only real way to know, though, is to see what happens with your real data.
