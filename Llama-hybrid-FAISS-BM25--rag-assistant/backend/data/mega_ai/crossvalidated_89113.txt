[site]: crossvalidated
[post_id]: 89113
[parent_id]: 
[tags]: 
Estimating a confidence interval around the average of an interacted treatment effect

I've got a causal inference situation with heterogeneous treatment effects. In addition to simply estimating coefficients, I'd like to get an average effect of the treatment at the covariate values that I observed in my dataset. For example: $$ y = \alpha+\beta_1 T + \beta_2Z + \beta_3 (T\times Z) + X'\gamma + \epsilon $$ I want to know the effect of the treatment $T$ (binary) across the gradient of $Z$ (continuous) that I observe. The expectation is the average of linear combinations -- that's easy. But the spread of the estimate seems a bit tricky. I think I've come up with a reasonable method -- basically take the parameter covariance matrix only for the treatment and the interacted variables, and use that to get the variances of each linear combination of data-parameter groups that I observe, sum those variances, get an SE, and make CI's like normal. it should work because $$ var\left(\displaystyle\sum X'\beta\right) = \displaystyle\sum var\left(X'\beta\right) = \displaystyle\sum X'V_pX $$ where $\beta$, $X$, and $V_p$ are only the subsets of the $\beta$'s, X's and the parameter covariance matrix that correspond to either the treatment or the interaction(s). Here's is silly little example in R: #Population model set.seed(413) d = data.frame( T = rbinom(1000,1,.5) ,Z = runif(1000) ,x1 = rnorm(1000) ,x2 = rnorm(1000) ) y = with(d,10+5*T+5*Z+-10*T*Z + 10*x1+10*x2+rnorm(1000,sd=10)) #Fit linear model library(mgcv) #using mgcv because the predict lpmatrix functionality is useful, though this is parametric m = gam(y~T*Z+x1+x2,data=d) summary(m) #Caluclate Average treatment effect on the treated c1 = m$model$T*m$coef[names(m$coef)=="T"] c2 = m$model$Z*m$model$Z*m$coef[names(m$coef)=="T:Z"] ATET = (c1+c2)[m$model$T==1] hist(ATET); abline(v = mean(ATET),lty=2,lwd=2) lpm = predict(m,type='lpmatrix') lpm = lpm[,grepl("T",colnames(lpm))] vcv = vcov(m) vcv = vcv[grepl("T",colnames(vcv)),grepl("T",colnames(vcv))] variances = diag((lpm)%*%vcv%*%t(lpm)) variances = variances[m$model$T==1] se = sqrt(sum(vars)) abline(v=mean(ATET)+se*1.96,col="red",lty=2,lwd=2) abline(v=mean(ATET)-se*1.96,col="red",lty=2,lwd=2) My basic question: is this right? Does my 95% CI have the advertised coverage properties? I guess that I am more of an applied coder than a proper statistician, so I'd appreciate reassurance from people who are more confident in such matters. EDIT: One more question about this -- the parameter covariance matrix that I'm using (cluster-robust) comes with a degree of freedom correction already in it. Does that justify the assumption that this interval is normally distributed? Or should I use $t$ with some number of degrees of freedom? Or would that be double-counting somehow?
