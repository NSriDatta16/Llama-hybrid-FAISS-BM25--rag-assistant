[site]: stackoverflow
[post_id]: 3722336
[parent_id]: 3721552
[tags]: 
I will be up front here, this is a very minimalist implementation and I have not had the time to really test the performance characteristics of this. There is probably just enough to maybe do some performance testing of your own. The idea I got when looking at your problem was to create a custom Stream which uses a BlockingCollection as the storage medium. Basically this will give you a stream that you can read/write from different threads and will throttle the producer if the consumer side gets behind. I reitterate, this is not a robust implementation, just a quick proof of concept, many more error checks need to be put in place, argument validations and a decent scheme for handling the Close of a stream. Currently if you close the stream while there is still data in the underlying BlockingCollection, you can no longer read the data. If I get sometime tomorrow I will flesh this out a little more, but maybe you can give some feedback first. Update: Yurik has provided an implementation of this solution as a wiki, enhancements should be directed to that answer. public class BlockingStream : Stream { private BlockingCollection _data; private CancellationTokenSource _cts = new CancellationTokenSource(); private int _readTimeout = -1; private int _writeTimeout = -1; public BlockingStream(int maxBytes) { _data = new BlockingCollection (maxBytes); } public override int ReadTimeout { get { return _readTimeout; } set { _readTimeout = value; } } public override int WriteTimeout { get { return _writeTimeout; } set { _writeTimeout = value; } } public override bool CanTimeout { get { return true; } } public override bool CanRead { get { return true; } } public override bool CanSeek { get { return false; } } public override bool CanWrite { get { return true; } } public override void Flush() { return; } public override long Length { get { throw new NotImplementedException(); } } public override long Position { get { throw new NotImplementedException(); } set { throw new NotImplementedException(); } } public override long Seek(long offset, SeekOrigin origin) { throw new NotImplementedException(); } public override void SetLength(long value) { throw new NotImplementedException(); } public override int ReadByte() { int returnValue = -1; try { byte b; if (_data.TryTake(out b, ReadTimeout, _cts.Token)) { returnValue = (int)b; } } catch (OperationCanceledException) { } return returnValue; } public override int Read(byte[] buffer, int offset, int count) { int bytesRead = 0; byte b; try { while (bytesRead When you construct the stream, you pass the maximum number of bytes the stream should buffer before blocking the writer. Here is a small test of the functionality, this is the only test that was done... class Program { static BlockingStream _dataStream = new BlockingStream(10); static Random _rnd = new Random(); [STAThread] static void Main(string[] args) { Task producer = new Task(() => { Thread.Sleep(1000); for (int i = 0; i { int i = 0; while (true) { Console.WriteLine("{0} \t-\t {1}",_dataStream.ReadByte(), i++); // Slow the consumer down. Thread.Sleep(500); } }); producer.Start(); consumer.Start(); Console.ReadKey(); }
