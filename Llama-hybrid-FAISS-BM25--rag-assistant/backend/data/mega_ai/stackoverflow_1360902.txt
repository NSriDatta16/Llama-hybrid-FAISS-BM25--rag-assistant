[site]: stackoverflow
[post_id]: 1360902
[parent_id]: 1360770
[tags]: 
Because all of your search parameters are flags that can be either 0 or 1, you might consider bitmasking. Each of your filters would represent a value that is a power of 2: $filter_1 = 1; $filter_2 = 2; $filter_3 = 4; ... $filter_8 = 256; ... $filter_16 = 65536; By using PHP's bitwise operators , you can easily store all 16 filter values in a single integer. For instance, the value "257" can only be reached using a combination of filter_1 and filter_8. If the user selected filter_1 and filter_8, you could determine the bitmask by doing: $bitmask = $filter_1 | $filter_8 //gives 257 With a unique bitmask representing the state of all your filters, you can simply use that as your cache key as well, with no expensive md5 operations needed. So in this case, you would save a file named "257" into your cache. This technique gives you an easy tool to invalidate your cache with as well, as you can check new and updated records to determine which filters they match, and delete any file that has that "bit" set in the name, ie. if ( ((int)$filename) & $filter == $filter) unlink($filename); . If your tables have frequent writes, this could cause some performance issues for scanning your cache, but it's a decent technique for a read-heavy application. This is an approach I love to use when dealing with bits or flags. You should consider carefully if you really need caching like this however. If you only have a few users of the system, are you really going to be having performance problems based on a few search queries? As well, MySQL has built-in query caching which performs very well on a high-read application. If your result page generation routines are expensive, then caching the output fragments can definitely be beneficial, but if you're only talking about microseconds of performance here for a handful of users, it might not be worth it.
