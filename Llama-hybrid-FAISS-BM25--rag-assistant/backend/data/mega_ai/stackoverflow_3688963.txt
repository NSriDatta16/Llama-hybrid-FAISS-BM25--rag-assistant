[site]: stackoverflow
[post_id]: 3688963
[parent_id]: 3688748
[tags]: 
Maybe this isn't the most elegant solution since I'm using "Distinct" to filter out duplicate results but here is one way in C#. The general idea is that you split the number into an array of 1's then you just combine each node side-by-side together like a tree and select distinct combinations. I pictured it like this: [1,1,1] / \ [2,1] [1,2] \ / [3] class Program { static void Main(string[] args) { Console.Write("Enter an integer value: "); int num = int.Parse(Console.ReadLine()); var y = new int[num]; for (int x = 0; x r.Length) .ToArray(); foreach (var result in results) { Console.Write('['); for (int x = 0; x 0) Console.Write(", "); Console.Write(result[x]); } Console.WriteLine(']'); } Console.ReadKey(true); } public class ArrayComparer : IEqualityComparer { bool IEqualityComparer .Equals(int[] x, int[] y) { if (x.Length == y.Length) { for (int z = 0; z .GetHashCode(int[] obj) { return 0; } } public static IEnumerable Combine(int[] values, int num) { int val = 0; for (int x = 0; x 0) { for (int x = 0; x x + 1) combined[x] = values[x] + values[x + 1]; for (int y = x + 2; y Outputs: Enter an integer value: 4 [1, 1, 1, 1] [2, 1, 1] [1, 2, 1] [1, 1, 2] [3, 1] [2, 2] [1, 3] [4]
