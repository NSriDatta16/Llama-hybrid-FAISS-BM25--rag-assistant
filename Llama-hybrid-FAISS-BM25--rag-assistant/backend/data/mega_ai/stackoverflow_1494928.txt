[site]: stackoverflow
[post_id]: 1494928
[parent_id]: 1494812
[tags]: 
I imagine the designers of the Set interface and HashSet class wanted to ensure that the remove(Object) method defined on the Collection interface was also applicable to Set ; this method returns a boolean denoting whether the object was successfully removed. If the designers wanted to provide functionality whereby remove(Object) returned the "equal" object already in the Set this would mean a different method signature. Also, given that the object being removed is logically equal to the object passed to remove(Object) it is arguable about the value added in returning the contained object. However, I have had this problem myself before and have used a Map to solve the problem. Note that in Java, a HashSet uses a HashMap internally and so there isn't additional storage overhead in using a HashMap instead.
