[site]: stackoverflow
[post_id]: 930723
[parent_id]: 930675
[tags]: 
I'm also trying to learn Haskell. A solution for this question could be: paragraphs :: [String] -> [[String]] paragraphs [] = [] paragraphs lines = p : (paragraphs rest) where (p, rest) = span (/= "") (dropWhile (== "") lines) where I'm using the functions from Data.List . The ones I'm using are already available from the Prelude, but you can find their documentation in the link. The idea is to find the first paragraph using span (/= "") . This will return the paragraph, and the lines following. We then recurse on the smaller list of lines which I call rest . Before splitting out the first paragraph, we drop any empty lines using dropWhile (== "") . This is important to eat the empty line(s) separating the paragraphs. My first attempt was this: paragraphs :: [String] -> [[String]] paragraphs [] = [] paragraphs lines = p : (paragraphs $ tail rest) where (p, rest) = span (/= "") lines but this fails when we reach the final paragraph since rest is then the empty string: *Main> paragraphs ["foo", "bar", "", "hehe", "", "bla", "bla"] [["foo","bar"],["hehe"],["bla","bla"]*** Exception: Prelude.tail: empty list Dropping empty lines solves this, and it also makes the code treat any number of empty lines as a paragraph separator, which is what I would expect as a user.
