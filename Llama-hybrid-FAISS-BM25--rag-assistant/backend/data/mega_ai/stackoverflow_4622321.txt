[site]: stackoverflow
[post_id]: 4622321
[parent_id]: 4622071
[tags]: 
One problem you will have is that making User.ID unique will be non-trivial. The problem is that two writes to the database could occur on different shards, both check at about the same time for existing entries that match the uniqueness constraint and find none, then both create identical entries (with regard to the unique property) and then you have an invalid database state. To solve this, appengine provides a means of ensuring that certain datastore entities are always placed on the same physical machine. To do this, you make use of the entity keys to tell google how to organize the entities. Lets assume you want the username to be unique. Change User to look like this: class User(db.Model): datejoined = db.DateTimeProperty(auto_now_add=True) Yes, that's really it. There's no username since that's going to be used in the key, so it doesn't need to appear separately. If you like, you can do this... class User(db.Model): datejoined = db.DateTimeProperty(auto_now_add=True) @property def name(self): return self.key().name() To create an instance of a User , you now need to do something a little different, you need to specify a key_name in the init method. someuser = User(key_name='john_doe') ... someuser.save() Well, really you want to make sure that users don't overwrite each other, so you need to wrap the user creation in a transaction. First define a function that does the neccesary check: def create_user(username): checkeduser = User.get_by_key_name(username) if checkeduser is not None: raise db.Rollback, 'User already exists!' newuser = User(key_name=username) # more code newuser.put() Then, invoke it in this way db.run_in_transaction(create_user, 'john_doe') To find a user, you just do this: someuser = User.get_by_key_name('john_doe') Next, you need some way to associate the content to its user, and visa versa. One solution is to put the content into the same entity group as the user by declaring the user as a parent of the content. To do this, you don't need to change the content at all, but you create it a little differently (much like you did with User): somecontent = Content(parent=User.get_by_key_name('john_doe')) So, given a content item, you can look up the user by examining its key: someuser = User.get(somecontent.key().parent()) Going in reverse, looking up all of the content for a particular user is only a little trickier. allcontent = Content.gql('where ancestor is :user', user=someuser).fetch(10)
