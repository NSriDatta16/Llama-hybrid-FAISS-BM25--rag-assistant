[site]: stackoverflow
[post_id]: 3664052
[parent_id]: 3663826
[tags]: 
Since this is a homework exercise, here are some hints about things you need to take into account when writing Java micro-benchmarks (like this): 1 - The Java compilers are smart. If they figure out that some part of your code does not contribute to the visible results of that code, they will optimize it away. To prevent this from distorting your benchmark results, you typically need to ensure that your benchmarking loops affect the outcome of the program in some way. For example, have them do some cheap calculation that contributes to a result and print out that result at the end of the becnchmark. 2 - JVMs take a time to "warm up". When you start an application in a typical Sun JVM (and others), your code is initially interpreted by a bytecode interpreter. After a bit, the JVM decides it is worth JIT compiling your code to native code ... and one that has happened your code starts running a lot faster. (But during the JIT compilation, it may appear to run really slowly.) To prevent this from distorting your benchmark results, you typically need to arrange that your loops (in fact your entire benchmark) are run multiple times. I typically, make the entire benchmark a method, and run it a number of times in a loop. I then look at the numbers to see the point at which they stabilize, and only pay attention to the numbers after that point. 3 - Benchmarks that involve repeated creation of objects / arrays have a tendency to trigger garbage collection at "random" points. If the GC runs (depending on the GC settings) in the middle of a benchmark loop, the time taken to run that loop may be inflated. Depending on what it is you are trying to measure, this may be give you anomalous results. If you are trying to exclude garbage collection overheads, you could set the initial JVM heap size to a very large number so that the GC never has to run. Alternatively, you could manually remove the anomalous results by eye, or by correlating with GC runs reported in the GC log file. OTOH, if you want to include GC overheads, use a typical heap size, run the loops a large number of time and calculate the average time per loop.
