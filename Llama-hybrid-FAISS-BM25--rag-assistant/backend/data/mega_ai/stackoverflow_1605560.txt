[site]: stackoverflow
[post_id]: 1605560
[parent_id]: 1605312
[tags]: 
You have already gotten a few good answers concerning the errors in you myString::swap() function. Yet, I'd like to add another one. There's some many things wrong with that function, I first found it hard to think of where to begin. But then I realized that you fail on some fundamental issue which I'd like to point out: As a convention, a function called swap is expected to perform its task in O(1) without ever throwing an exception. (Yes, I know, there are exceptions: std::tr1::array<>::swap() . But those should be very well justified.) Your implementation fails on both accounts. It is O(n) ( strcpy ) and might throw an exception ( new ) -- and it does so unnecessarily and without justification. When you look at myString , you'll see that it only has two pieces of member data, which both are of built-in type. That means swapping two objects of this class is really simple to do while keeping to the conventions mentioned above: just swap the member data. That's as simple as calling std::swap on them: void myString::swap(myString &from) { std::swap(this->stringPtr,from.stringPtr); std::swap(this->stringLen,from.stringLen); } This is will never fail (swapping two pointers and two integers cannot fail), executes in O(1), is very easy to understand (well, once you get a grip on that swapping, anyway; it is an idiomatic form of implementing a class-specific swap function), and consists of two lines of code calling something well-tested in the standard library instead of 8 lines of code doing error-prone (and, in your case, erroneous) manual memory management. Note 1: Once you've done this, you should specialize std::swap to call your implementation for your class: namespace std { // only allowed for specializing function templates in the std lib template<> inline void std::swap (myString& lhs, myString& rhs) { lhs.swap(rhs); } Note 2: The best (simple, exception-safe, and self-assignment-safe) way to implement assignment for your class is to use its swap : myString& myString::operator=(const myString& rhs) { myString tmp(rhs); // invoke copy ctor this->swap(tmp); // steal data from temp and leave it with our own old data return *this; } // tmp will automatically be destroyed and takes our old data with it
