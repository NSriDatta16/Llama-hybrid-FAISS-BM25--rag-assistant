[site]: stackoverflow
[post_id]: 4946018
[parent_id]: 4944852
[tags]: 
Starting by writing these 'empty' functions. They will replace the standard new and delete by your own: void *operator new (size_t memorySize); void *operator new[] (size_t memorySize); void *operator new (size_t memorySize, const std::nothrow_t &) throw (); void *operator new[] (size_t memorySize, const std::nothrow_t &) throw (); void operator delete (void *memoryPointer); void operator delete[] (void *memoryPointer); void operator delete (void *memoryPointer, const std::nothrow_t &) throw (); void operator delete[] (void *memoryPointer, const std::nothrow_t &) throw (); Then write separate functions to allocate and deallocate memory: void *myNew (size-t memorySize); void myDelete (void *memoryPointer); Call your myNew and myDelete in the functions mentioned in the beginning. Implement myNew and myDelete by using HeapAlloc and HeapFree. Then make a global variable and mark it like this (this is Visual Studio): #pragma init_seg(lib) This will make sure your global variable is initialized first, and cleaned up last. So far, we have covered the basis. To get real leak-reporting-functionality, you will need to store information about allocated memory in your myNew function. Use the destructor of your global variable to report all leaks. Additionally, you could use StackWalk to get the call stack and also store this with each memory allocation. Some will probably wonder why you want to do this instead of using other tools: in my experience, leak reporting in Visual Studio is limited. It doesn't show you the call stack, but only the direct caller, which makes it meaningless. some tools use #define to replace new, delete, alloc, ..., but this can gives problems in quite some cases (e.g. a class method which is called free (seen this in Qt), or the delete is done in a header, but a new in a .lib which must be linked in (also seen in Qt)). other tools require you to make interactive snapshots of your application and compare them afterwards. In my approach above, you get automatic leak reporting (no manual action needed, always at end of the application, ...). Once you have your own memory manager, you can start thinking about adding other functionality (e.g. memory statistics based on the call stack, tricks to find memory overwrites, tricks to find code that reuses memory after it has been deleted, ...).
