[site]: stackoverflow
[post_id]: 1649523
[parent_id]: 1648976
[tags]: 
Edit: Oops, missed a simple thing due to stupidity. This solution isn't correct, although I am keeping it here as it is still avg(n+log(n)). Thanks to ShreevatsaR for pointing out my stupidity. I did consider the tree search, but completly missed the idea of backtracking to find the second highest number in log(n). Anyway, here follows my proof for why the inferior algorithm is no more than avg(n+log(n)). In real life it should still perform pretty well at least. First compare against the second highest recorded number. Only if that comparison succeeds, compare against the highest recorded number. To prove that it is on average n+log n, we simply have to prove that the first comparison only succeeds log(n) times on average. And that is fairly simple to see or demonstrate. Assume P as the the actual position of the current second largest number in a sorted version of the list, and run the algorithm If P>2 then when a larger number is found, the new P will on average be no more than P/2. If P=2 then the first comparison can not succeed, as there is no number that is greater than the current second largest number. P can at most equal N From 2, 3 and 4 it should be trivial to see that the first comparison can not succeed more than log(N) times on average.
