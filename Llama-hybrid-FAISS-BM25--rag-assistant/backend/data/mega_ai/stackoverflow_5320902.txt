[site]: stackoverflow
[post_id]: 5320902
[parent_id]: 5150790
[tags]: 
You can consider leveraging the ModelForm functionality and if you know in advance what parts of a model will appear in a particular report the only question then is what "view" of the Model you want to generate. The end user can then specify the instance objects (from one or more models) that they are interested in and the ordering of those objects. You then build the final report from these components. One of the shortcomings of Django (although someone please correct me if I'm wrong about this) is that form object rendering is always in the context of an editable form, even though often it would be very nice to have a "read-only" view of the form. Where this has been an issue for me I've simply implemented a "renderer" on the Model class itself (this is not very Django-esque, but it better fits my ideas of OOD and encapsulation). Typically I create as_row() and as_rotable() methods on my Model which self render to HTML in either a "one instance per row" or "one field per row and one instance per table" format. Generic Views should help with this, but I haven't quite figured out how to make this work smoothly, so for the moment I'm left with something like the example below. url.py: from gridportal.wsmr.views import list, create, view, edit, copy, delete, reset ... url(r'task/(?P \d+)/?$', view, {'tmpl': 'wsmr/wsmrtask_detail.html'}, name="task_view"), ... views.py: from gridportal.wsmr.forms import WSMRTaskViewForm ... def view(request, id, tmpl): task = get_object_or_404(WSMRTask, pk=id) form = WSMRTaskViewForm(instance=task) return render_to_response(tmpl, {'object': form,}, context_instance=RequestContext(request)) forms.py: class WSMRTaskViewForm(ModelForm): class Meta: model = WSMRTask wsmr/wsmrtask_detail.html: {% extends "base.html" %} {% block content %} {{ object.instance.as_rotable|safe }} {% endblock %} models.py: class WSMRTask(GridTask): ... def as_row(self): return GridTask.as_row(self) + """ %s %s %s """ % (self.task_url, basename(self.mtz.name), basename(self.mtz.name), self.resolution, self.solvent) def as_rotable(self): return GridTask.as_rotable(self) + """ MTZ %s resolution (A) %s solvent %s """ % (self.task_url, basename(self.mtz.name), basename(self.mtz.name), self.resolution, self.solvent)
