[site]: stackoverflow
[post_id]: 3784463
[parent_id]: 3784411
[tags]: 
The elegant recursive solution (in pseudo-code): def sum (node): if node == NULL: return 0 return node->value + sum (node->left) + sum (node->right) then just use: total = sum (root) This correctly handles the case of a NULL root node. And if you want to see it in action in C++, here's some code using that algorithm. First, the structure for a node and the sum function: #include typedef struct sNode { int value; struct sNode *left; struct sNode *right; } tNode; int sum (tNode *node) { if (node == 0) return 0; return node->value + sum (node->left) + sum (node->right); } Then the code below is a test harness code for inserting nodes: static tNode *addNode (tNode *parent, char leftRight, int value) { tNode *node = new tNode(); node->value = value; node->left = 0; node->right = 0; if (parent != 0) { if (leftRight == 'L') { parent->left = node; } else { parent->right = node; } } return node; } And, finally, the main function for constructing the following tree, one that covers all of the valid possibilities (empty node, node with two children, node with no children, node with one right child and node with one left child): 10 / \ 7 20 / \ 3 99 \ 4 \ 6 The code to construct that tree and report the sum at various points is shown here: int main (void) { // Empty tree first. tNode *root = 0; std::cout left,'L',3); addNode (root->left->left,'R',4); addNode (root->left->left->right,'R',6); addNode (root->right,'R',99); std::cout This outputs (the correct): 0 10 37 149
