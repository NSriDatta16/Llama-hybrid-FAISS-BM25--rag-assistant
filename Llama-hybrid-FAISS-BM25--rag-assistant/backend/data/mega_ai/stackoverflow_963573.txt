[site]: stackoverflow
[post_id]: 963573
[parent_id]: 953343
[tags]: 
I asked around, and this is the recommendation someone gave me; it looks reasonable. In your NSCell subclass, in whatever method is invoked by the event loop upon setting a new value, do something like this: - (void)whateverMethodInCellSubclassIsTriggeredByEventLoop:(id)value { NSTableView *tableView = [self controlView]; NSTableColumn *column = [[tableView tableColumns] objectAtIndex:[tableView editedColumn]]; NSInteger rowIndex = [tableView editedRow]; NSDictionary *bindingInfo = [column infoForBinding:NSValueBinding]; id modelObject = nil; if ([controlView isKindOfClass:[NSOutlineView class]]) { NSTreeNode *item = [outlineView itemAtRow:rowIndex]; modelObject = [item representedObject]; } else if ([controlView isKindOfClass:[NSTableView class]]) { NSArrayController *controller = [bindingInfo objectForKey:NSObservedObjectKey]; modelObject = [[controller arrangedObjects] objectAtIndex:rowIndex]; } [modelObject setValue:value forKeyPath:[bindingInfo objectForKey:NSObservedKeyPathKey]]; } This is fairly generic code that leverages the binding info available on the table column to get the model object and key path to which your changes should be pushed, and to use generic KVC to push the changes. It should work for both table and outline views as well as for arbitrary model objects, Core Data or not.
