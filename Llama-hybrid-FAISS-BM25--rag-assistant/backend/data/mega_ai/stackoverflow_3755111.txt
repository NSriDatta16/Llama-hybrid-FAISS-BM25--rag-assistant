[site]: stackoverflow
[post_id]: 3755111
[parent_id]: 
[tags]: 
How Do I define a Double Brackets/Double Iterator Operator, Similar to Vector of Vectors'?

I'm porting code that uses a very large array of floats, which may trigger malloc failures from c to c++. I asked a question about whether I should use vectors or deques and Niki Yoshiuchi generously offered me this example of a safely wrapped type: template class VectorDeque { private: enum TYPE { NONE, DEQUE, VECTOR }; std::deque m_d; std::vector m_v; TYPE m_type; ... public: void resize(size_t n) { switch(m_type) { case NONE: try { m_v.resize(n); m_type = VECTOR; } catch(std::bad_alloc &ba) { m_d.resize(n); m_type = DEQUE; } break; } } }; I needed a 2D vector of vectors/deque of deques, so I modified it to the following code: template class VectorDeque { private: enum STORAGE_CONTAINER { NONE, DEQUE, VECTOR }; std::deque > x_d,y_d,z_d; std::vector > x_v,y_v,z_v; TYPE my_container; public: void resize(size_t num_atoms, size_t num_frames) { switch(m_type) { case NONE: try { x_v.resize(num_atoms); for (unsigned int couter=0;couter I now want to be able to define my bracket operators so that I can have a statement like x[1][2] directly access whichever is the real memory container I'm using (given by the value of my enumerated variable. I've seen a couple of tutorials floating around about overriding the brackets operator, but have positively no idea to override double brackets. How can you overload double brackets? Additionally, how would you overload double iterators (in case I want to use an iterator, as opposed to direct indexing)? EDIT 1: Based on the solution from Martin York/Matteo Italia I devised the following class: template class VectorDeque2D { public: class VectorDeque2D_Inner_Set { VectorDeque2D& parent; int first_index; public: // Just init the temp object VectorDeque2D_Inner_Set(My2D& p, int first_Index) : parent(p), first_Index(first_index) {} // Here we get the value. T& operator[](int second_index) const { return parent.get(first_index,second_index);} }; // Return an object that defines its own operator[] that will access the data. // The temp object is very trivial and just allows access to the data via // operator[] VectorDeque2D_Inner_Set operator[](unsigned int first_index) { return (*this, x); } void resize_first_index(unsigned int first_index) { try { my_vector.resize(first_index); my_container = VECTOR; } catch(std::bad_alloc &e) { my_deque.resize(first_index); my_container = DEQUE; } } void resize_second_index(unsigned int second_index) { try { for (unsigned int couter=0;couter > my_vector; std::deque > my_deque; STORAGE_CONTAINER my_container; T& get(int x,int y) { T temp_val; if(my_container == VECTOR) { temp_val = my_vector[first_index][second_index]; } else if(my_container == DEQUE) { temp_val = my_deque[first_index][second_index]; } return temp_val; } }; Finally a size-safe 2D container!! Thanks guys!
