[site]: stackoverflow
[post_id]: 426183
[parent_id]: 423924
[tags]: 
You can, but I would use a simple POJO just to keep things cleanly separated. Keep in mind that the value stored in the singleton will only be accessible by the same thread that handled the servlet request, so if you're doing any asynch, you will need to account for that. Here's a super basic impl: public class OrgId { public static ThreadLocal orgId = new ThreadLocal (); } Since the Organizational Id is resident in the session, you could set the value of the ThreadLocal in an early servlet filter like this (not much error checking): public class OrgIdFilter implements Filter { public void doFilter(ServletRequest servletrequest, ServletResponse servletresponse, FilterChain filterchain) throws java.io.IOException, javax.servlet.ServletException { int orgId = 0; HttpServletRequest req = (HttpServletRequest) servletRequest; HttpSession session = req.getSession(); orgId = Integer.parseInt(session.getAttribute("OrganizationalIdAttr")); try { OrgId.orgId.set(orgId); filterChain.doFilter(servletRequest, servletresponse); } finally { OrgId.orgId.set(null); // Important to clear after request !! } } } This assumes that the orgId is in the session when the filter is called, but if not, you get the idea.... Then in your interceptor (or pretty much anywhere) you can get the thread's current orgId with: OrgId.orgId.get(); // Might be null..... A potential snafu here is that all these components (filter, OrgId and interceptor) need to be loaded by the same class loader to ensure that the OrgId class is effectively a singleton, otherwise, with multiple instances of the ThreadLocal hanging around it won't work consistently, or at all. Needless to say, all this needs to be happening in the same VM. I am not sure if this is the cleanest way to solve this problem, but it does get you your orgId where you need it.
