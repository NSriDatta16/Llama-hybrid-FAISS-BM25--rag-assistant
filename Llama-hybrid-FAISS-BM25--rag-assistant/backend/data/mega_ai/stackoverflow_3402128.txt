[site]: stackoverflow
[post_id]: 3402128
[parent_id]: 3402081
[tags]: 
You could do something like this: (tested in Octave, should work in matlab) octave-3.2.3:17> toohigh = (x>=10) toohigh = 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 octave-3.2.3:18> nbr_avg = filter2(ones(3,3)/9,x) nbr_avg = 0.00000 1.33333 2.33333 2.33333 1.00000 0.44444 2.77778 5.44444 5.00000 2.66667 1.66667 6.11111 8.77778 7.11111 2.66667 1.88889 5.44444 8.00000 6.11111 2.55556 1.88889 5.00000 6.77778 4.88889 1.77778 0.66667 1.66667 3.44444 2.77778 1.77778 0.44444 1.00000 1.88889 1.44444 0.88889 octave-3.2.3:19> y=x; y(toohigh) = nbr_avg(toohigh) y = 0.00000 0.00000 0.00000 0.00000 0.00000 0.00000 0.00000 5.44444 9.00000 0.00000 0.00000 4.00000 9.00000 7.11111 0.00000 0.00000 5.44444 8.00000 0.00000 0.00000 0.00000 2.00000 4.00000 8.00000 0.00000 0.00000 4.00000 5.00000 8.00000 0.00000 0.00000 0.00000 0.00000 0.00000 0.00000 The filter2 function allows you to filter on neighbors (not sure what function you want...), and if you use a boolean index matrix ( toohigh in this case) to select those members of the original matrix that are too high, you can replace them with the ones you want. More specifically, filter2 allows you to convolve with an arbitrary matrix. The matrix of all ones does a spatial low pass filter. note: my math doesn't match yours. I'm not quite sure why you want to average only the nonzero neighbors (that gives higher weight to nonzero neighbors when there are zeros), but if you wanted to do that, you could do filter2(ones(3,3),x) ./ M where M = filter2(ones(3,3),(x ~= 0)) is the count of nonzero neighbors.
