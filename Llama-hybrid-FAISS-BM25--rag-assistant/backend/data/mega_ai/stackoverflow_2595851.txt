[site]: stackoverflow
[post_id]: 2595851
[parent_id]: 
[tags]: 
Trying to retrieve the contents of UITableView cell on selection by user

I have set up a UITableView-based app, which has a .plist for holding the data. The .plist has a dictionary as its root, followed by a number of Arrays, each containing the data-strings that display in the table. Everything is working fine until the point where I select a row. I have set it up so I get an alert with the results of the button press and it is here that I want to see the contents of the cell being produced. Instead of the expected string e.g. "data line 1", all I get is the number of the row within the section. I have gone backwards and forwards but don't seem to be getting anywhere although I am sure it is something simple. The code compiles fine, with no warnings or errors, and if I can just get the string of the selected cell I will be well on my way, so any help appreciated. I know that I need to do more following the NSUInteger row = [indexPath row]; part but that's where my mind dries up... Here is the relevant 'selection' section, if I need to post more code please let me know, and I really appreciate any help with this...(please forgive my 'alert' message, I was just happy at that point that I get SOMETHING back from the row selection!) - (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath { [tableView deselectRowAtIndexPath:indexPath animated:YES]; NSUInteger row = [indexPath row]; NSString *message = [[NSString alloc] initWithFormat: @"You selected Cell %d from this Section, "@"which is a very good choice indeed!" @"Unfortunately I can't work out how to get the info out of the cell so it's not much use at the moment!" @"Still, this is a good chance to see how much space I have in an alert box!", row]; UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"My God! It works..." message:message delegate:nil cancelButtonTitle:@"You are awesome Karl!!" otherButtonTitles:nil]; [alert show]; [message release]; [alert release]; } Update: In fact, to make things easier, here is ALL the code! As I said, all I am trying to do is to get the string-data out of the chosen cell, from there I want to open up a new view based upon the results, so all I need at this stage is the 'result'. I know the code isn't pretty, and there are bound to be plenty of errors etc but non seem important at this stage as it compiles and runs with no problems, I just don't get the result I need from a button press! Any help or advice would be much appreciated, and if someone could actually write the line or so of code I need to put in and explain 'why' I would be over-the-moon! #import "my_firstApp.h" #import "NSDictionary-MutableDeepCopy.h" @implementation my_firstAppViewController @synthesize names; @synthesize keys; @synthesize table; @synthesize search; @synthesize allNames; @synthesize tempImageType; @synthesize tempImageName; @synthesize finalImageName; @synthesize tempSubtitle; @synthesize finalSubtitleName; @synthesize tempSubtitleType; @synthesize finalSubtitleText; @synthesize setValue; #pragma mark - #pragma mark Custom Methods -(void)resetSearch { NSMutableDictionary *allNamesCopy = [self.allNames mutableDeepCopy]; self.names = allNamesCopy; [allNamesCopy release]; NSMutableArray *keyArray = [[NSMutableArray alloc] init]; [keyArray addObject:UITableViewIndexSearch]; [keyArray addObjectsFromArray:[[self.allNames allKeys] sortedArrayUsingSelector:@selector(compare:)]]; self.keys = keyArray; [keyArray release]; } -(void)handleSearchForTerm:(NSString *)searchTerm { NSMutableArray *sectionsToRemove = [[NSMutableArray alloc] init]; [self resetSearch]; for (NSString *key in self.keys) { NSMutableArray *array = [names valueForKey:key]; NSMutableArray *toRemove = [[NSMutableArray alloc] init]; for (NSString *name in array) { if ([name rangeOfString:searchTerm options:NSCaseInsensitiveSearch].location==NSNotFound) [toRemove addObject:name]; } if ([array count] == [toRemove count]) [sectionsToRemove addObject:key]; [array removeObjectsInArray:toRemove]; [toRemove release]; } [self.keys removeObjectsInArray:sectionsToRemove]; [sectionsToRemove release]; [table reloadData]; } - (void)viewDidLoad { NSString *path = [[NSBundle mainBundle] pathForResource:@"dataList" ofType:@"plist"]; NSDictionary *dict = [[NSDictionary alloc] initWithContentsOfFile:path]; self.allNames = dict; [dict release]; [self resetSearch]; [table reloadData]; [table setContentOffset:CGPointMake(0.0, 44.0) animated:NO]; } - (void)viewDidUnload { // Release any retained subviews of the main view. // e.g. self.myOutlet = nil; self.names = nil; self.keys = nil; self.table = nil; self.search = nil; self.allNames = nil; } - (void)dealloc { [names release]; [keys release]; [table release]; [search release]; [allNames release]; [tempImageName release]; [tempImageType release]; [finalImageName release]; [tempSubtitle release]; [finalSubtitleName release]; [tempSubtitleType release]; [finalSubtitleText release]; [setValue release]; [super dealloc]; } #pragma mark - #pragma mark Table View Data Source Methods - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView { return ([keys count] >0) ?[keys count] : 1; } - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section { if ([keys count] ==0) return 0; NSString *key = [keys objectAtIndex:section]; NSArray *nameSection = [names objectForKey:key]; return [nameSection count]; } - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { NSUInteger section = [indexPath section]; NSUInteger row = [indexPath row]; NSString *key = [keys objectAtIndex:section]; NSArray *nameSection = [names objectForKey:key]; static NSString *SectionsTableIdentifier = @"SectionsTableIdentifier"; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier: SectionsTableIdentifier ]; if (cell == nil) { cell = [[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier: SectionsTableIdentifier ] autorelease]; } cell.textLabel.text = [nameSection objectAtIndex:row]; tempSubtitle=[nameSection objectAtIndex:row]; finalSubtitleText = [[NSBundle mainBundle] pathForResource:tempSubtitle ofType:@"txt"]; NSString *fileContents = [NSString stringWithContentsOfFile:finalSubtitleText encoding:NSUTF8StringEncoding error:nil]; cell.detailTextLabel.text = fileContents; cell.detailTextLabel.textColor = [UIColor grayColor]; cell.detailTextLabel.font = [UIFont systemFontOfSize:13]; tempImageName=[nameSection objectAtIndex:row]; tempImageType=@".png"; finalImageName=[tempImageName stringByAppendingString:tempImageType]; UIImage *image = [UIImage imageNamed:finalImageName]; cell.imageView.image = image; return cell; } - (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section { if ([keys count] == 0) return nil; NSString *key = [keys objectAtIndex:section]; if (key == UITableViewIndexSearch) return nil; return key; } - (NSArray *)sectionIndexTitlesForTableView:(UITableView *)tableView { if (isSearching) return nil; return keys; } #pragma mark - #pragma mark Table View Delegate Methods -(NSIndexPath *)tableView:(UITableView *)tableView willselectRowAtIndexPath:(NSIndexPath *)indexPath { [search resignFirstResponder]; isSearching = NO; search.text = @""; [tableView reloadData]; return indexPath; } #pragma mark - #pragma mark Search Bar Delegate Methods -(void)searchBarSearchButtonClicked:(UISearchBar *)searchBar { NSString *searchTerm = [searchBar text]; [self handleSearchForTerm:searchTerm]; } -(void)searchBar:(UISearchBar *)searchBar textDidChange:(NSString *)searchTerm { if ([searchTerm length] ==0) { [self resetSearch]; [table reloadData]; return; } [self handleSearchForTerm:searchTerm]; } -(void)searchBarCancelButtonClicked:(UISearchBar *)searchBar { isSearching = NO; search.text = @""; [self resetSearch]; [table reloadData]; [searchBar resignFirstResponder]; } -(void)searchBarTextDidBeginEditing:(UISearchBar *)searchBar { isSearching = YES; [table reloadData]; } - (NSInteger)tableView:(UITableView *)tableView sectionForSectionIndexTitle:(NSString *)title atIndex:(NSInteger)index { NSString *key = [keys objectAtIndex:index]; if (key == UITableViewIndexSearch) { [tableView setContentOffset:CGPointZero animated:NO]; return NSNotFound; } else return index; } - (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath { [tableView deselectRowAtIndexPath:indexPath animated:YES]; NSUInteger row = [indexPath row]; NSString *message = [[NSString alloc] initWithFormat: @"You selected Cell %d from this Section, "@"which is a very good choice indeed!" @" Unfortunately I can't work out how to get the info out of the cell so it's not much use at the moment!" @" Still, this is a good chance to see how much space I will have for the info I need to present!", row]; UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"My God! It works..." message:message delegate:nil cancelButtonTitle:@"You are awesome Karl!!" otherButtonTitles:nil]; [alert show]; [message release]; [alert release]; } @end
