[site]: stackoverflow
[post_id]: 721285
[parent_id]: 720482
[tags]: 
This is answered in perlfaq4 's answer to "How can I tell whether a certain element is contained in a list or array?" . To search the perlfaq, you could search through the list of all questions in perlfaq using your favorite browser. From the command line, you can use the -q switch to perldoc to search for keywords. You would have found your answer by searching for "list": perldoc -q list (portions of this answer contributed by Anno Siegel and brian d foy) Hearing the word "in" is an indication that you probably should have used a hash, not a list or array, to store your data. Hashes are designed to answer this question quickly and efficiently. Arrays aren't. That being said, there are several ways to approach this. In Perl 5.10 and later, you can use the smart match operator to check that an item is contained in an array or a hash: use 5.010; if( $item ~~ @array ) { say "The array contains $item" } if( $item ~~ %hash ) { say "The hash contains $item" } With earlier versions of Perl, you have to do a bit more work. If you are going to make this query many times over arbitrary string values, the fastest way is probably to invert the original array and maintain a hash whose keys are the first array's values: @blues = qw/azure cerulean teal turquoise lapis-lazuli/; %is_blue = (); for (@blues) { $is_blue{$_} = 1 } Now you can check whether $is_blue{$some_color}. It might have been a good idea to keep the blues all in a hash in the first place. If the values are all small integers, you could use a simple indexed array. This kind of an array will take up less space: @primes = (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31); @is_tiny_prime = (); for (@primes) { $is_tiny_prime[$_] = 1 } # or simply @istiny_prime[@primes] = (1) x @primes; Now you check whether $is_tiny_prime[$some_number]. If the values in question are integers instead of strings, you can save quite a lot of space by using bit strings instead: @articles = ( 1..10, 150..2000, 2017 ); undef $read; for (@articles) { vec($read,$_,1) = 1 } Now check whether vec($read,$n,1) is true for some $n. These methods guarantee fast individual tests but require a re-organization of the original list or array. They only pay off if you have to test multiple values against the same array. If you are testing only once, the standard module List::Util exports the function first for this purpose. It works by stopping once it finds the element. It's written in C for speed, and its Perl equivalent looks like this subroutine: sub first (&@) { my $code = shift; foreach (@_) { return $_ if &{$code}(); } undef; } If speed is of little concern, the common idiom uses grep in scalar context (which returns the number of items that passed its condition) to traverse the entire list. This does have the benefit of telling you how many matches it found, though. my $is_there = grep $_ eq $whatever, @array; If you want to actually extract the matching elements, simply use grep in list context. my @matches = grep $_ eq $whatever, @array;
