[site]: stackoverflow
[post_id]: 5063783
[parent_id]: 5063607
[tags]: 
There is no generic way for a function to refer to itself. Consider using a decorator instead. If all you want as you indicated was to print information about the function that can be done easily with a decorator: from functools import wraps def showinfo(f): @wraps(f) def wrapper(*args, **kwds): print(f.__name__, f.__hash__) return f(*args, **kwds) return wrapper @showinfo def aa(): pass If you really do need to reference the function, then just add it to the function arguments: def withself(f): @wraps(f) def wrapper(*args, **kwds): return f(f, *args, **kwds) return wrapper @withself def aa(self): print(self.__name__) # etc. Edit to add alternate decorator : You can also write a simpler (and probably faster) decorator that will make the wrapped function work correctly with Python's introspection: def bind(f): """Decorate function `f` to pass a reference to the function as the first argument""" return f.__get__(f, type(f)) @bind def foo(self, x): "This is a bound function!" print(self, x) >>> foo(42) 42 >>> help(foo) Help on method foo in module __main__: foo(self, x) method of builtins.function instance This is a bound function! This leverages Python's descriptor protocol: functions have a __get__ method that is used to create bound methods. The decorator simply uses the existing method to make the function a bound method of itself. It will only work for standalone functions, if you wanted a method to be able to reference itself you would have to do something more like the original solution.
