[site]: stackoverflow
[post_id]: 2268603
[parent_id]: 2265234
[tags]: 
The standard way to have global access to the current session in a threaded environment is ScopedSession . There are some important aspects to get right when integrating with your framework, mainly transaction control and clearing out sessions between requests. A common pattern is to have an autocommit=False (the default) ScopedSession in a module and wrap any business logic execution in a try-catch clause that rolls back in case of exception and commits if the method succeeded, then finally calls Session.remove(). The business logic would then import the Session object into global scope and use it like a regular session. There seems to be an existing CherryPy-SQLAlchemy integration module , but as I'm not too familiar with CherryPy, I can't comment on its quality. Having queries encapsulated as functions is just fine. Not everything needs to be in a class. If they get too numerous just split into separate modules by topic. What I have found useful is too factor out common criteria fragments. They usually fit rather well as classmethods on model classes. Aside from increasing readability and reducing duplication, they work as implementation hiding abstractions up to some extent, making refactoring the database less painful. (Example: instead of (Foo.valid_from func.current_timestamp()) you'd have Foo.is_valid() )
