[site]: datascience
[post_id]: 94518
[parent_id]: 
[tags]: 
Function call stack: train_function error while training Bidirectional LSTM

I am a beginner in Machine Learning and I have been trying to develop a LSTM Neural Network using Sequential Model. The following is my model where I am getting this error: [[{{node sequential/bidirectional/forward_lstm/while/body/_1/sequential/bidirectional/forward_lstm/while/lstm_cell_1/MatMul}}]] Hint: If you want to see a list of allocated tensors when OOM happens, add report_tensor_allocations_upon_oom to RunOptions for current allocation info. [Op:__inference_train_function_3646] Function call stack: train_function What is causing this error? I looked up and tried some solutions myself, doesn't seem to work Model: import keras import pickle from sklearn.utils import shuffle import tensorflow as tf from keras.layers import LSTM from keras.models import Sequential from keras.layers import Dense from keras.layers import Bidirectional from sklearn.preprocessing import MinMaxScaler import matplotlib.pyplot as plt X = [] for i in range(0, 30): print(i) pickle_in = open("X_1min_" + str(i) + ".pickle", "rb") if i == 0: X = numpy.array(pickle.load(pickle_in)) else: X = (numpy.append(X, numpy.array(pickle.load(pickle_in)), 0)) pickle_in.close() X = numpy.array(X) print(X) P = [] for i in range(0, 30): print(i) pickle_in = open("P_1min_" + str(i) + ".pickle", "rb") P.extend(pickle.load(pickle_in)) pickle_in.close() P = numpy.array(P) print(P) # To get target Y N_future = 60 def obtain_Y(price, price_low, price_high): print("Getting Y") Y = [] for i in range(len(price) - N_future - 1): temp = numpy.max(price_high[i:i + N_future]) Y.append(temp) Y = numpy.array(Y) print("done") return Y X = X[:-N_future - 1] COINS = 0 print("COINS: " + str(COINS)) Y = obtain_Y(P[:, COINS * 3], P[:, COINS * 3 + 1], P[:, COINS * 3 + 2]) pickle.dump(Y, open("Y_1min" + str(COINS) + ".sav", 'wb')) X = X[N_future:] Y = Y[N_future:] ### Spliting to training and testing dataset NUM_POINTS = 43200 * 4 # 43200*3 means data from latest 3 months are used for test X_train = numpy.array(X[:-NUM_POINTS]) Y_train = numpy.array(Y[:-NUM_POINTS]) X_test = numpy.array(X[-NUM_POINTS:]) Y_test = numpy.array(Y[-NUM_POINTS:]) remove_data = len(X_train) % 5000 X_train = X_train[remove_data:] Y_train = Y_train[remove_data:] X_train = shuffle(X_train) Y_train = shuffle(Y_train) ### Scaling input X_train and X_Test, and target Y_train (not Y_test) scalerX = MinMaxScaler() scalerX.fit(X_train) pickle.dump(scalerX, open("scalerX_1min" + str(COINS) + ".sav", 'wb')) X_train = scalerX.transform(X_train) X_test = scalerX.transform(X_test) scalerY = MinMaxScaler() scalerY.fit(numpy.reshape(Y_train, (-1, 1))) pickle.dump(scalerY, open("scalerY_1min" + str(COINS) + ".sav", 'wb')) Y_train_scaled = scalerY.transform(numpy.reshape(Y_train, (-1, 1))) reshapedX = X_train.reshape(224, 5000, 16) X_train = reshapedX reshapedY = Y_train_scaled.reshape(224, 5000, 1) Y_train_scaled = reshapedY model = Sequential() model.add(Bidirectional(LSTM(200, input_shape=(5000,16 ,10 ), activation='relu', return_sequences=True))) model.add(Dense(100, activation='relu')) model.add(Dense(50, activation='relu')) model.add(Dense(1, activation='sigmoid')) model.compile(loss='mean_absolute_error', optimizer='adam') keras.backend.set_value(model.optimizer.learning_rate, 0.0001) model.fit(X_train, Y_train_scaled, epochs=150, batch_size=5000, verbose=1) predictions = model.predict(X_train) predictions = scalerY.inverse_transform(predictions) MeanAE_train = numpy.mean(abs(numpy.reshape(predictions, (1, -1)) - Y_train)) print("MeanAE_train: " + str(MeanAE_train)) MaxAE_train = numpy.mean(abs(numpy.reshape(predictions, (1, -1)) - Y_train)) print("MaxAE_train: " + str(MaxAE_train)) accuracy_train = [] for i in range(len(predictions)): accuracy_train.append(abs(predictions[i] - Y_train[i]) / Y_train[i] * 100) accuracy_train = numpy.array(accuracy_train) print("Training accuracy: " + str(100 - numpy.mean(accuracy_train)) + "%") plt.figure() plt.plot(Y_train) plt.plot(predictions) plt.title('Training') plt.legend(['Ideal', 'Prediction']) print("\n") predictions = model.predict(X_test) predictions = scalerY.inverse_transform(predictions) MeanAE_test = numpy.mean(abs(numpy.reshape(predictions, (1, -1)) - Y_test)) print("MeanAE_test: " + str(MeanAE_test)) MaxAE_test = numpy.max(abs(numpy.reshape(predictions, (1, -1)) - Y_test)) print("MaxAE_test: " + str(MaxAE_test)) accuracy_test = [] for i in range(len(predictions)): accuracy_test.append(abs(predictions[i] - Y_test[i]) / Y_test[i] * 100) accuracy_test = numpy.array(accuracy_test) print("Testing accuracy: " + str(100 - numpy.mean(accuracy_test)) + "%") plt.figure() plt.plot(Y_test) plt.plot(predictions) plt.title('Training') plt.legend(['Ideal', 'Prediction']) plt.show(block=True)
