[site]: stackoverflow
[post_id]: 5691882
[parent_id]: 
[tags]: 
how to write a 'destructive' dolist macro in lisp

I am trying to write a simple bubble sort in Common Lisp (also works in Emacs Lisp), in a most intuitive way: (defun bubble-sort-long (list) (labels ((rec (list acc) (if (null list) (nreverse acc) (progn (dolist (x (cdr list)) (if ( This doesn't work. Because rotatef only swap the value of temporary variable x and (car list), instead of the compared element in the list. Trace result goes as follows: >(setf a '(1 3 2 5 4)) >(trace bubble-sort) >(bubble-sort a) 0: (BUBBLE-SORT-LONG (1 3 2 5 4)) 0: BUBBLE-SORT-LONG returned (1 2 2 4 4) I guess the most direct way to tackle would be defining a 'destructive' dolist macro which assign a x which directly point to the iterated element in the list. Something like a ndolist, so that I can make the following work: (setf a '(1 2 3)) (ndolist (x a) (setf x (+ 1 x))) would produce: (2 3 4). In addition, if you can provide more intuitive thoughts on bubble sorting using lisp, please also give a hint. In ruby, similar algorithm would be something like: class Array def bubble_sort self.each_with_index do |a,j| i=j+1 while i self[i]) self[j],self[i]=self[i],self[j] end i=i+1 end end end What is fun is I still have to use the "parallel assignment" to swap the value. Ruby doesn't support(encourage) swap using temporary variable through reference in C/C++ style.
