[site]: stackoverflow
[post_id]: 2249983
[parent_id]: 2249711
[tags]: 
You could try something like this. #include //Try to convert arg to result in a similar way to boost::lexical_cast //but return true/false rather than throwing an exception. template bool convert( const T1 & arg, T2 & result ) { std::stringstream interpreter; return interpreter >result && interpreter.get() == std::stringstream::traits_type::eof(); } template double to_double( const T & t ) { double retval=0; if( ! convert(t,retval) ) { /* Do something about failure */ } return retval; } template double is_double( const T & t ) { double retval=0; return convert(t,retval) ); } The convert function does basically the same things as boost::lexical_cast, except lexical cast is more careful about avoiding allocating dynamic storage by using fixed buffers etc. It would be possible to refactor the boost::lexical_cast code into this form, but that code is pretty dense and tough going - IMHO its a pity that lexical_cast wasn't implemented using somethign like this under the hood... then it could look like this: template T1 lexical_cast( const T2 & t ) { T1 retval; if( ! try_cast (t,retval) ) throw bad_lexical_cast(); return retval; }
