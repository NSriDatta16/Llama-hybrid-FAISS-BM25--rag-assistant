[site]: stackoverflow
[post_id]: 702460
[parent_id]: 702415
[tags]: 
There are a number of ways you can do this: Use Thread.join() in your main thread to wait in a blocking fashion for each Thread to complete, or Check Thread.isAlive() in a polling fashion -- generally discouraged -- to wait until each Thread has completed, or Unorthodox, for each Thread in question, call setUncaughtExceptionHandler to call a method in your object, and program each Thread to throw an uncaught Exception when it completes, or Use locks or synchronizers or mechanisms from java.util.concurrent , or More orthodox, create a listener in your main Thread, and then program each of your Threads to tell the listener that they have completed. How to implement Idea #5? Well, one way is to first create an interface: public interface ThreadCompleteListener { void notifyOfThreadComplete(final Thread thread); } then create the following class: public abstract class NotifyingThread extends Thread { private final Set listeners = new CopyOnWriteArraySet (); public final void addListener(final ThreadCompleteListener listener) { listeners.add(listener); } public final void removeListener(final ThreadCompleteListener listener) { listeners.remove(listener); } private final void notifyListeners() { for (ThreadCompleteListener listener : listeners) { listener.notifyOfThreadComplete(this); } } @Override public final void run() { try { doRun(); } finally { notifyListeners(); } } public abstract void doRun(); } and then each of your Threads will extend NotifyingThread and instead of implementing run() it will implement doRun() . Thus when they complete, they will automatically notify anyone waiting for notification. Finally, in your main class -- the one that starts all the Threads (or at least the object waiting for notification) -- modify that class to implement ThreadCompleteListener and immediately after creating each Thread add itself to the list of listeners: NotifyingThread thread1 = new OneOfYourThreads(); thread1.addListener(this); // add ourselves as a listener thread1.start(); // Start the Thread then, as each Thread exits, your notifyOfThreadComplete method will be invoked with the Thread instance that just completed (or crashed). Note that better would be to implements Runnable rather than extends Thread for NotifyingThread as extending Thread is usually discouraged in new code. But I'm coding to your question. If you change the NotifyingThread class to implement Runnable then you have to change some of your code that manages Threads, which is pretty straightforward to do.
