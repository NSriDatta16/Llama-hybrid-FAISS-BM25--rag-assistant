[site]: stackoverflow
[post_id]: 3479127
[parent_id]: 3478985
[tags]: 
It is the same as a code-point for code-point comparison, that is to say one that pays no attention to case-folding, cultural orderings, composition, or anything other than the Unicode value. This is pretty useless when considering strings as a piece of human-readable text, but sometimes you just want to be able to put the strings into an ordering, as some algorithms (binary search as you say) need a consistent ordering, but the details of that consistent ordering is not significant. It is important to note though, that the ordinal comparison on strings offered by .NET works on the UTF-16 used internally which does not maintain code-point ordering. If we compare a string with just the character U+FF61 and a string with just the character U+10002, then .NET will store the latter as surrogate pairs, of 0xD800 and 0XDC02. Hence: string.CompareOrdinal("\U0000ff61", "\U00010002"); and string.Compare("\U0000ff61", "\U00010002", StringComparison.Ordinal); both return values great than zero, even though the former is lower in code-point value than the latter (I used the \U form rather than the \u form to make that clearer). If by "the actual unicode strings" you mean the .NET UTF-16 strings, then the answer to your question is no, for the opposite reason to that which led to your thinking it might work.
