[site]: stackoverflow
[post_id]: 5279722
[parent_id]: 5279593
[tags]: 
In Common Lisp: (defun esoteric-sum (a b) (let ((and (logand a b))) (if (zerop and) ;; No carrying necessary. (logior a b) ;; Combine the partial sum with the carried bits again. (esoteric-sum (logxor a b) (ash and 1))))) That's taking the bitwise-and of the numbers, which figures out which bits need to carry, and, if there are no bits that require shifting, returns the bitwise-or of the operands. Otherwise, it shifts the carried bits one to the left and combines them again with the bitwise-exclusive-or of the numbers, which sums all the bits that don't need to carry, until no more carrying is necessary. Here's an iterative alternative to the recursive form above: (defun esoteric-sum-iterative (a b) (loop for first = a then (logxor first second) for second = b then (ash and 1) for and = (logand first second) until (zerop and) finally (return (logior first second)))) Note that the function needs another concession to overcome Common Lisp's reluctance to employ fixed-width two's complement arithmetic—normally an immeasurable asset—but I'd rather not cloud the form of the function with that accidental complexity. If you need more detail on why that works, please ask a more detailed question to probe the topic.
