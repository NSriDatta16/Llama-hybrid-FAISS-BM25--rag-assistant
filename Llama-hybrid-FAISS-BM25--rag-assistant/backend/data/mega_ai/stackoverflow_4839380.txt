[site]: stackoverflow
[post_id]: 4839380
[parent_id]: 4839314
[tags]: 
The problem is that you don't have an array. An array would look like { "common_name" : [ "name1", "name2", "name3" ] } With a structure like that, Mongo can index the elements of the array in a single index and quickly find any document that contains any single item from the array. You could use an array and simply define the offsets to be what you want, e.g. [0] is the name and [1] is the type etc. With that in place you can now find any document quickly. You could do this in addition to keeping the data in the named fields (but clearly that would increase storage so isn't recommended). If your autocomplete doesn't need to be totally up-to-date with the latest documents added to the collection you could instead run a map-reduce job to build a separate collection that you use just for autocomplete. The map step would emit for each of the individual name fields in a document (so 4x as many documents after emit) and the reduce step would count up how many of each name there were (so 1x the number of unique names across all fields). You could index the resulting collection by name and count which would allow your autocomplete to recommend the most common names first.
