[site]: stackoverflow
[post_id]: 1072254
[parent_id]: 1029158
[tags]: 
The CSLA library can help with this situation a lot. However, if you want to self implement : You have a master object, the master object contains a list of child objects. The detail form can edit a child object directly. Since everything is reference types, the master object is automatically updated. The issue is knowing that the master object is dirty, and therefore should be persisted to your database or whatnot. CSLA handles this with an IsDirty() property. In the master object you would query each child object to see if it is dirty, and if so persist everything (as well as tracking if the master object itself is dirty) You can also handle this is the INotifyPropertyChanged interface. As for some of your other questions : You want to separate your logic. The entity can handle storage of its own properties, and integrity rules for itself, but logic for how different object interact with each other should be separate. Look into patterns such as MVC or MVP. In this case, creation of a new child object should either be in the master object, or should be in a separate business logic object that creates the child and then adds it to the parent. For IDs, using GUIDs as the ID can save you quite a bit of problems, because then you don't have to talk to the database to determine a correct ID. You can keep a flag on the object for if it is new or not (and therefore should be inserted or updated). Again, CSLA handles all of this for you, but does have quite a bit of overhead. regarding undo on cancel : CSLA has n-level undo implemented, but if you are trying to do it by hand, I would either use your CopyFrom function, or refresh the object's data from the persistance layer on cancel (re-fetch).
