[site]: stackoverflow
[post_id]: 4935218
[parent_id]: 4934550
[tags]: 
I don't profess to be an expert in this area, however I felt compelled to at least profile this to some extent (knowing full well that my fictitious scenario will differ substantially from your own) and here is what I came up with: It seems, at least for me, EndsWith takes the lead with LastIndexOf consistently coming in second, some timings are: SubString: 00:00:00.0191877 Contains: 00:00:00.0201980 CompareInfo: 00:00:00.0255181 EndsWith: 00:00:00.0120296 LastIndexOf: 00:00:00.0133181 These were gleaned from processing 100,000 strings where the desired suffix appeared in all strings and so to me simply echoes Jon's answer (where the benefit is both speed and descriptiveness). And the code used to come to these results: class Program { class Profiler { private Stopwatch Stopwatch = new Stopwatch(); public TimeSpan Elapsed { get { return Stopwatch.Elapsed; } } public void Start() { Reset(); Stopwatch.Start(); } public void Stop() { Stopwatch.Stop(); } public void Reset() { Stopwatch.Reset(); } } static string suffix = "_sfx"; static Profiler profiler = new Profiler(); static List input = new List (); static List output = new List (); static void Main(string[] args) { GenerateSuffixedStrings(); FindStringsWithSuffix_UsingSubString(input, suffix); Console.WriteLine("SubString: {0}", profiler.Elapsed); FindStringsWithSuffix_UsingContains(input, suffix); Console.WriteLine("Contains: {0}", profiler.Elapsed); FindStringsWithSuffix_UsingCompareInfo(input, suffix); Console.WriteLine("CompareInfo: {0}", profiler.Elapsed); FindStringsWithSuffix_UsingEndsWith(input, suffix); Console.WriteLine("EndsWith: {0}", profiler.Elapsed); FindStringsWithSuffix_UsingLastIndexOf(input, suffix); Console.WriteLine("LastIndexOf: {0}", profiler.Elapsed); Console.WriteLine(); Console.WriteLine("Press any key to exit..."); Console.ReadKey(); } static void GenerateSuffixedStrings() { for (var i = 0; i strings, string suffix) { output.Clear(); profiler.Start(); foreach (var s in strings) { if(s.Substring(s.Length - 4) == suffix) output.Add(s); } profiler.Stop(); } static void FindStringsWithSuffix_UsingContains(IEnumerable strings, string suffix) { output.Clear(); profiler.Start(); foreach (var s in strings) { if (s.Contains(suffix)) output.Add(s); } profiler.Stop(); } static void FindStringsWithSuffix_UsingCompareInfo(IEnumerable strings, string suffix) { var ci = CompareInfo.GetCompareInfo("en-GB"); output.Clear(); profiler.Start(); foreach (var s in strings) { if (ci.IsSuffix(s, suffix)) output.Add(s); } profiler.Stop(); } static void FindStringsWithSuffix_UsingEndsWith(IEnumerable strings, string suffix) { output.Clear(); profiler.Start(); foreach (var s in strings) { if (s.EndsWith(suffix)) output.Add(s); } profiler.Stop(); } static void FindStringsWithSuffix_UsingLastIndexOf(IEnumerable strings, string suffix) { output.Clear(); profiler.Start(); foreach (var s in strings) { if (s.LastIndexOf(suffix) == s.Length - 4) output.Add(s); } profiler.Stop(); } } EDIT: As commented, I attempted this again with only some of the strings having a suffix applied and these are the results: SubString: 00:00:00.0079731 Contains: 00:00:00.0243696 CompareInfo: 00:00:00.0334056 EndsWith: 00:00:00.0196668 LastIndexOf: 00:00:00.0229599 The string generator method was updated as follows, to produce the strings: static void GenerateSuffixedStrings() { var nxt = false; var rnd = new Random(); for (var i = 0; i Further, this trend continues if none of the string have a suffix: SubString: 00:00:00.0055584 Contains: 00:00:00.0187089 CompareInfo: 00:00:00.0228983 EndsWith: 00:00:00.0114227 LastIndexOf: 00:00:00.0199328 However, this gap shortens again when assigning a quarter of the inputs a suffix (the first quarter, then sorting to randomise the coverage): SubString: 00:00:00.0302997 Contains: 00:00:00.0305685 CompareInfo: 00:00:00.0306335 EndsWith: 00:00:00.0351229 LastIndexOf: 00:00:00.0322899 Conclusion? IMO, and agreeing with Jon, EndsWith seems the way to go (based on this limited test, anyway). Further Edit: To cure Jon's curiosity I ran a few more tests on EndsWith , with and without Ordinal string comparison... On 100,000 strings with a quarter of them suffixed: EndsWith: 00:00:00.0795617 OrdinalEndsWith: 00:00:00.0240631 On 1,000,000 strings with a quarter of them suffixed: EndsWith: 00:00:00.5460591 OrdinalEndsWith: 00:00:00.2807860 On 10,000,000 strings with a quarter of them suffixed: EndsWith: 00:00:07.5889581 OrdinalEndsWith: 00:00:03.3248628 Note that I only ran the last test once as generating the strings proved this laptop is in need of a replacement
