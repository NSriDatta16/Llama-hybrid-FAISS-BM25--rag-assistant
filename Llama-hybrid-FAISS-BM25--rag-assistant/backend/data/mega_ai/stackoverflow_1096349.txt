[site]: stackoverflow
[post_id]: 1096349
[parent_id]: 1096341
[tags]: 
Converting a void* to a function pointer directly is not allowed (should not compile using any of the casts) in C++98/03. It is conditionally supported in C++0x (an implementation may choose to define the behavior and if it does define it, then it must do what the standard says it should do. A void* , as defined by the C++98/03 standard, was meant to point to objects and not to contain function pointers or member pointers. Knowing that what you are doing is heavily implementation dependent, here is one option that should compile and work (assuming 32 bit pointers, use long long for 64 bit) on most platforms, even though it is clearly undefined behavior according to the standard: void *gptr = dlsym(some symbol..) ; typedef void (*fptr)(); fptr my_fptr = reinterpret_cast (reinterpret_cast (gptr)) ; And here is another option that should compile and work, but carries the same caveats with it as the above: fptr my_ptr = 0; reinterpret_cast (my_ptr) = gptr; Or, in Slow motion... // get the address which is an object pointer void (**object_ptr)() = &my_ptr; // convert it to void** which is also an object pointer void ** ppv = reinterpret_cast (object_ptr); // assign the address in the memory cell named by 'gptr' // to the memory cell that is named by 'my_ptr' which is // the same memory cell that is pointed to // by the memory cell that is named by 'ppv' *ppv = gptr; It essentially exploits the fact that the address of the function pointer is an object pointer ( void (**object_ptr)() ) - so we can use reinterpret_cast to convert it to any other object pointer: such as void** . We can then follow the address back (by dereferencing the void** ) to the actual function pointer and store the value of the gptr there. yuk - by no means well-defined code - but it should do what you expect it to do on most implementations.
