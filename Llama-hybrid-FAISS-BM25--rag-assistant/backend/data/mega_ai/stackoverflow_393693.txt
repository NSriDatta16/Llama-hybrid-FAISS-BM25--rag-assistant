[site]: stackoverflow
[post_id]: 393693
[parent_id]: 393675
[tags]: 
In my humble opinion, there are three kinds of return-cases that you should take into consideration: Object property manipulation The first is the manipulation of object properties. The pattern you describe here is very often used when manipulating objects. A very typical scenario is using it together with a factory. Consider this hypothetical creation call: // When the object has manipulative methods: Pizza p = PizzaFactory().create().addAnchovies().addTomatoes(); // When the factory has manipulative methods working on the // object, IMHO more elegant from a semantic point of view: Pizza p = PizzaFactory().create().addAnchovies().addTomatoes().getPizza(); It allows for a quick grasp at what exactly is being created or how an object is manipulated, because the methods form one human-readable expression. It's definitely nice, but don't overuse. A rule of thumb is that this might be used with methods whose return value you could also declare as void. Evaluating object properties The second might be when a method evaluates something on an object. Consider, for example, the method car.getCurrentSpeed() , that could be interpreted as a message to an object asking for the current speed and returning that. It would simply return the value, not too complicated. :) Make object do this or that The third might be when a method makes an perform an operation, returning some sort of value indicating how well the caller's intention was fulfilled - but laying out such a method could be difficult: int new_gear = 20; if (car.gears.changeGear(new_gear)) // does that mean success or fail? This is where you can see a difficulty in designing the method. Should it return 0 upon success or failure? How about -1 if the gear could not be set, because the car only has 5 gears? Does that mean the current gear is at -1 now, too? The method could return the gear it changed to, meaning you would have to compare the argument supplied to the method to the return code. That would work. On the other hand, you could simply return either true or false for failure or false or true for failure. Which one to use could be decided by estimating if you'd expect those method calls to rather fail or succeed. In my humble opinion, there is a way to better express the semantics of such return values, by giving them a semantic description. Future developers interacting with your objects will love you for not having to look up the comments or documentation for your methods: class GearSystem { // (...) public: enum GearChangeResult { GearChangeSuccess, NonExistingGear, MechanicalGearProblem }; GearChangeResult changeGear (int gear); }; That way, it becomes perfectly obvious for any programmer looking at your code, what the return value means (consider: if (gears.changeGear(20) == GearSystem::GearChangeSuccess) - much clearer what that means than the example above) Antipattern: Failures as return codes. The fourth possibility for a return value I actually omitted, because in my opinion it isn't any: when there's an error in your program, like a logic error or a failure that needs to be dealt with - you could theoretically return a value indicating so. But today, that's not done so often anymore (or should not be), because for that, there are exceptions.
