[site]: stackoverflow
[post_id]: 246736
[parent_id]: 246499
[tags]: 
Be careful some of the design patterns literature. There are are several broad species of class definitions. Classes for persistent objects (which are like rows in relational tables) and collections (which are like the tables themselves) are one thing. Some of the " Gang of Four " design patterns are more applicable to active, application objects, and less applicable to persistent objects. While you wrestle through something like Abstract Factory , you'll be missing some key points of OO design as it applies to persistent objects. The Object Mentor What is Object-Oriented Design? page has mich of you really need to know to transition from relational design to OO design. Normalization, BTW, isn't a blanket design principle that always applies to relational databases. Normalization applies when you have update transactions, to prevent update anomalies. It's a hack because relational databases are passive things; you either have to add processing (like methods in a class) or you have to pass a bunch of rules (normalization). In the data warehouse world, where updates are rare (or non-existent) that standard normalization rules aren't as relevant. Consequently, there's no "normalize like this" for object data models. In OO Design, perhaps the most important rule for designing persistent objects is the Single Responsibility Principle . If you design your classes to have good fidelity to real-world objects, and you allocate responsibilities to those classes in a very focused way, you'll be happy with your object model. You'll be able to map it to a relational database with relatively few complexities. Turns out, that when you look at things from a responsibility point of view, you find that 2NF and 3NF rules fit with sound responsibility assignment. Unique keys still matter. And derived data becomes the responsibility of a method function, not a persistent attribute.
