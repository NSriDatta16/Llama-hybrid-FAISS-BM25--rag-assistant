[site]: stackoverflow
[post_id]: 707754
[parent_id]: 707016
[tags]: 
I could be wrong, but it seems to me that you're coming from the wrong end. There are two distinct issues you need to address. Firstly, making sure that the PropertyGrid is only ever accessed on the UI thread. If any of its methods (including property getter/setters) are accessed from other threads, you'll suffer pain in mysterious ways. The exceptions are InvokeRequired() and Invoke , of course. Secondly, making sure your search thread can run properly. To solve the first problem, either make sure your objects are never modified except by the UI thread, or make all of your event triggers thread aware so that your objects events (such as PropertyChanged) are only ever triggered on the UI thread. The second problem is easier - as long as your search thread only READS from your core objects, everything should work fine. Yes, your search thread might inadvertently see some partially updated data, but is that really an issue? A couple of final thoughts ... Don't implement your search to iterate through the PropertyGrid itself; obtain a list of the objects up front (they don't need to be clones) and work through that instead. Have you considered using Idle Processing to do the search? The Application object fires an event every time the application runs out of messages to process - you could hook into this and perform 1 step of your search each time the event is fired. Kind of a poor-mans threading, but with none of the mutex/lock/semaphone headaches. I've used this to very good effect in the past. Update : If I recall correctly, PropertyGrid respects the IEditableObject interface, calling BeginEdit as soon as you start modifying a row, and EndEdit when you move to a different row. You could leverage this to prevent your search thread from seeing incomplete changes. Update 2 : Following up, I've discovered what you already knew - that PropertyGrid doesn't respect the IEditableObject interface. I do have another suggestion - though it might be more work than you want to invest. Around the time when the System.Transactions namespace was introduced in .NET 2.0, I saw an article on using the ambient transaction to provide thread-isolation for objects. The idea is that your object properties have dual storage. First you have the committed value, visible to all threads, and you have a thread-local variable used to store uncommitted values on a per-thread basis. When a property is modified, the object enlists in any ambient transaction by storing the new value in the thread local. When the transaction commits or rolls back, the value for the thread is either stored or discarded. Unfortunately, I can't find the original article, though it seems that CSLA provides this support. Hope this helps.
