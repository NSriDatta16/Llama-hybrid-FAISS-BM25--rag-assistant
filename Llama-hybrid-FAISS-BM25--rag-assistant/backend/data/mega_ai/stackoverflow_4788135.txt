[site]: stackoverflow
[post_id]: 4788135
[parent_id]: 
[tags]: 
Distortion with 'pixel accurate' OpenGL rendering of sprites

To define what I'm trying to do: I want to be able to take an arbitrary 'sprite' image from a ^2x^2 sized PNG, and display just the pixels of interest to a given x/y position on screen. My results are the problem - major distortion - it looks awful! (Note these SS's are in iPhone sim but on real retina device they appear the same.. junky). Here is a screenshot of the source PNG in 'preview' - which looks wonderful (any variations on rendering that I describe in this question look almost exactly like the junky one) Previously, I've asked a question about displaying a non-power-of-2 texture as a sprite using OpenGL ES 2.0 (although this applies to any OpenGL). I'm close, but I have some issues that I can't resolve. I think there are probably multiple bugs - I think there's some bug where I'm basically aliasing what I'm displaying by rendering large then squashing x2 or vice versa but I can't see it. Additionally, there are off by one errors and I cannot get a handle on them. I can't visually identify them occurring but I know for sure they're there. I'm working in 960 x 640 landscape (on iPhone4 retina display). So I expect 0->959 moves left to right, 0->639 moves bottom to top. (And I think I'm seeing opposite of this - but that's not what this question is about) To make things easy what I'm trying to achieve in this test case is a FULL SCREEN 960x640 display of a PNG file. Just one of them. I display a red background first so that it's obvious if I'm covering the screen or not. Update: I realized the 'glViewport' inside of the setFramebuffer call was setting my width and height backwards. I noticed this because when I would set my geometry to draw from 0,0 to 100,100 it drew in a rectangle not a square. When I swapped these, that call does draw a square. However, using that same call, my entire screen fills with vertex range of 0,0 -> 480,320 (half 'resolution').. don't understand that. However no matter where I push on from this, I'm still not getting a good looking result Here's my vertex shader: attribute vec4 a_position; attribute vec2 a_texCoord; varying vec2 v_texCoord; // Gives 'landscape' full screen.. mat4 projectionMatrix = mat4( 2.0/640.0, 0.0, 0.0, -1.0, 0.0, 2.0/960.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 1.0); // Gives a 1/4 of screen.. (not doing 2.0/.. was suggested in previous SO Q) /*mat4 projectionMatrix = mat4( 1.0/640.0, 0.0, 0.0, -1.0, 0.0, 1.0/960.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 1.0); */ // Apply the projection matrix to the position and pass the texCoord void main() { gl_Position = a_position; gl_Position *= projectionMatrix; v_texCoord = a_texCoord; } Here's my fragment shader: precision mediump float; varying vec2 v_texCoord; uniform sampler2D s_texture; void main() { gl_FragColor = texture2D(s_texture, v_texCoord); } Here's my draw code: #define MYWIDTH 960.0f #define MYHEIGHT 640.0f // I have to refer to 'X' as height although I'd assume I use 'Y' here.. // I think my X and Y throughout this whole block of code is screwed up // But, I have experimented flipping them all and verifying that if they // Are taken from the way they're set now to swapping X and Y that things // end up being turned the wrong way. So this is a mess, but unlikely my problem #define BG_X_ORIGIN 0.0f // ALSO NOTE HERE: I have to put my 'dest' at 640.0f.. --- see note [1] below #define BG_X_DEST 640.0f #define BG_Y_ORIGIN 0.0f // --- see note [1] below #define BG_Y_DEST 960.0f // These are texturing coordinates, I texture starting at '0' px and then // I calculate a percentage of the texture to use based on how many pixels I use // divided by the actual size of the image (1024x1024) #define BG_X_ZERO 0.0f #define BG_Y_USEPERCENTAGE BG_X_DEST / 1023.0f #define BG_Y_ZERO 0.0f #define BG_X_USEPERCENTAGE BG_Y_DEST / 1023.0f // glViewport(0, 0, MYWIDTH, MYHEIGHT); // See note 2.. it sets glViewport basically, provided by Xcode project template [(EAGLView *)self.view setFramebuffer]; // Big hack just to get things going - like I said before, these could be backwards // w/respect to X and Y static const GLfloat backgroundVertices[] = { BG_X_ORIGIN, BG_Y_ORIGIN, BG_X_DEST, BG_Y_ORIGIN, BG_X_ORIGIN, BG_Y_DEST, BG_X_DEST, BG_Y_DEST }; static const GLfloat backgroundTexCoords[] = { BG_X_ZERO, BG_Y_USEPERCENTAGE, BG_X_USEPERCENTAGE, BG_Y_USEPERCENTAGE, BG_X_ZERO, BG_Y_ZERO, BG_X_USEPERCENTAGE, BG_Y_ZERO }; // Turn on texturing glEnable(GL_TEXTURE_2D); // Clear to RED so that it's obvious when I'm not drawing my sprite on screen glClearColor(1.0f, 0.0f, 0.0f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); // Texturing parameters - these make sense.. don't think they are the issue glActiveTexture(GL_TEXTURE0); glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);//GL_LINEAR); glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);//GL_LINEAR); // Update attribute values. glVertexAttribPointer(ATTRIB_VERTEX, 2, GL_FLOAT, 0, 0, backgroundVertices); glEnableVertexAttribArray(ATTRIB_VERTEX); glVertexAttribPointer(ATTRIB_TEXCOORD, 2, GL_FLOAT, 0, 0, backgroundTexCoords); glEnableVertexAttribArray(ATTRIB_TEXCOORD); glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, background->textureId); // I don't understand what this uniform does in the texture2D call in shader. glUniform1f(uniforms[UNIFORM_SAMPLERLOC], 0); // Draw the geometry... glDrawArrays(GL_TRIANGLE_STRIP, 0, 4); // present the framebuffer see note [3] [(EAGLView *)self.view presentFramebuffer]; Note [1] : If I set BG_X_DEST to 639.0f I do not get full coverage of the 640 pixels, I get red showing through on the right hand side. But this doesn't make sense to me - I'm aiming for pixel perfect and I have to draw my sprite geometry from 0 to 640 which is 641 pixels when I only have 640!!! red line appearing with 639f instead of 640f And if I set BG_Y_DEST to 959.0f I do not get the red line show throug. red line top bug appearing with 958f instead of 960 or 959f This may be a good clue as to what bug(s) I have going on. Note: [2] - included in the OpenGL ES 2 framework by Xcode - (void)setFramebuffer { if (context) { [EAGLContext setCurrentContext:context]; if (!defaultFramebuffer) [self createFramebuffer]; glBindFramebuffer(GL_FRAMEBUFFER, defaultFramebuffer); glViewport(0, 0, framebufferWidth, framebufferHeight); } } Note [3]: - included in the OpenGL ES 2 framework by Xcode - (BOOL)presentFramebuffer { BOOL success = FALSE; if (context) { [EAGLContext setCurrentContext:context]; glBindRenderbuffer(GL_RENDERBUFFER, colorRenderbuffer); success = [context presentRenderbuffer:GL_RENDERBUFFER]; } return success; } Note [4] - relevant image loading code (I have used PNG with and without alpha channel and actually it doesn't seem to make any difference... I also have tried to change my code up to be ARGB instead of RGBA and that's wrong - since A = 1.0 everywhere, I get a very RED image, which makes me think the RGBA is in fact valid and this code is right.): update: I have switched this texture loading to a completely different setup using CG/ImageIO calls and it looks identical to this so I assume it's not some kind of aliasing or color compression done by the image libraries (unless they both go to the same fundamental calls, which is possible..) // Otherwise it isn't already loaded glEnable(GL_TEXTURE_2D); glActiveTexture(GL_TEXTURE0); glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);//GL_LINEAR); glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);//GL_LINEAR); // TODO Next 2 can prob go later on.. glGenTextures(1, &(newTexture->textureId)); // generate Texture // Use this before 'drawing' the texture to the memory... glBindTexture(GL_TEXTURE_2D, newTexture->textureId); NSString *path = [[NSBundle mainBundle] pathForResource:[NSString stringWithUTF8String:newTexture->filename.c_str()] ofType:@"png"]; NSData *texData = [[NSData alloc] initWithContentsOfFile:path]; UIImage *image = [[UIImage alloc] initWithData:texData]; if (image == nil) NSLog(@"Do real error checking here"); newTexture->width = CGImageGetWidth(image.CGImage); newTexture->height = CGImageGetHeight(image.CGImage); CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); void *imageData = malloc(newTexture->height * newTexture->width * 4 ); CGContextRef myContext = CGBitmapContextCreate (imageData, newTexture->width, newTexture->height, 8, 4 * newTexture->width, colorSpace, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big ); CGColorSpaceRelease(colorSpace); CGContextClearRect(myContext, CGRectMake(0, 0, newTexture->width, newTexture->height)); CGContextDrawImage(myContext, CGRectMake(0, 0, newTexture->width, newTexture->height), image.CGImage); // Texture is created! glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, newTexture->width, newTexture->height, 0, GL_RGBA, GL_UNSIGNED_BYTE, imageData); CGContextRelease(myContext); free(imageData); [image release]; [texData release];
