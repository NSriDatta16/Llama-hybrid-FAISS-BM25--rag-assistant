[site]: stackoverflow
[post_id]: 2085766
[parent_id]: 2085671
[tags]: 
Why does it have to be a property? If it were a method, GetChecksum() then you would not have to have any special logic so that it does not include itself in the checksum calculation. Now, what you have created is pretty much exactly the same as what the existing GetHashCode() method is for — just provide an implementation of this instead. Typically one would code the GetHashCode() for each class explicitly although a quick web search will reveal approaches that use reflection to provide a generic (though slower) mechanism. Ususally one would take each field one wants to include the in the hashcode, convert it to an integer and multiply it by a fixed number such that the different objects with different values for the fields give different hashcodes that are well spread across the integer range. As an example, Resharper generates GetHashCode() methods that look like this: public override int GetHashCode() { unchecked { int result = a; result = (result * 397) ^ (b != null ? b.GetHashCode() : 0); result = (result * 397) ^ c.GetHashCode(); return result; } } Where a is an int, b is a string and c is a long. The interim value (result) is mulitplied by 397 and put to the power of the next component's hashcode at each step. The unchecked means that if the integer is overflowed (which is likely) then we discard the overflow and wrap around. This should give a reasonable coverage of the integer space in most cases — though I would recommend testing the coverage as a poor hashcode can have serious consequences on the performance of your system. Care should be taken to handle zeroes of any field so that you do not multiply by zero and end up with a large number of objects that all have a zero hash-code.
