[site]: stackoverflow
[post_id]: 3597343
[parent_id]: 3584305
[tags]: 
Let me just expand on Sjoerd's answer. The problem you are facing is due to not being able to access MyUser type from the test assembly. That problem is easily fixed with InternalsVisibleTo assembly attribute. I would however recommend to rethink your design and get rid of IMyUser interface and instead just use MyUser class (which should be public). Normally you put services behind interfaces, not entities. Are there any good reasons for providing multiple implementations of IMyUser ? Have a look at how much cleaner this implementation is: public interface IData { MyUser GetUserById(int id); } public class UserLogic { private IData da; public UserLogic(IData da) { this.da = da; } public MyUser GetMyUserById(int id) { return da.GetUserById(id); } } internal class MyUser { int Id { get; set; } string Name { get; set; } } There is another solution, if you insist on having IMyUser interface and its internal implementation. Your existing solution, if I infer the contents of IData.GetUserById correctly, goes something like this: public class UserData : IData { T GetUserById (int id) where T : IMyUser, new(){ T returned = new T(); //fill in properties returned.Name = "test"; return returned; } } The above code is a slight violation of SRP(warning, PDF) and mixes two responsibilities - retrieving an entity from persistent storage and creating an instance of the entity. Not only that, it also puts the creation responsibility on the interface, which is even worse. Decoupling those responsibilities using Abstract Factory and Dependency Injection(PDF) patterns will lead to much cleaner design that does not suffer from the same problem as before. public interface IMyUserFactory { IMyUser Create(); } public interface IData { IMyUser GetUserById(int id); } internal MyUserFactory : IMyUserFactory { public IMyUser Create() {return new MyUser();} } internal class UserData : IData { IMyUserFactory m_factory; public UserData(IMyUserFactory factory) { m_factory = factory; } public IMyUser GetUserById(int id) { IMyUser returned = m_factory.Create(); //fill in properties returned.Name = "test"; return returned; } } //and finally UserLogic class public class UserLogic { private IData da; public UserLogic(IData da) { this.da = da; } public IMyUser GetMyUserById(int id) { return da.GetUserById(id); } } //The test then becomes trivial [TestMethod] public void Test() { var data = new Mock (); data.Setup(d => d.GetUserById(1)).Returns(new Mock ().Object); var logic = new UserLogic(data.Object); var result = logic.GetMyUserById(1); }
