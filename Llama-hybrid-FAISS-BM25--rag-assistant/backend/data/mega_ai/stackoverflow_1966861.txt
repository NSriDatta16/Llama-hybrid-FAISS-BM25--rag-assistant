[site]: stackoverflow
[post_id]: 1966861
[parent_id]: 1966820
[tags]: 
In C, arrays are accessed using similar mechanics to pointers, but they're very different in how the definitions work - an array definition actually causes the space for the array to be allocated. A pointer definition will cause enough storage to be allocated to refer (or "point") to some other part of memory. unsigned char bar[6]; creates storage for 6 unsigned characters. The C array semantics say that, when you pass an array to another function, instead of creating a copy of the array on the stack, a pointer to the first element in the array is given as the parameter to the function instead. This means that void pass_char_ref(unsigned char *foo) is not taking an array as an argument, but a pointer to the array. Updating the pointer value (as in foo = "hello"; , which overwrites the pointer 's value with the address of the compiled-in string "hello" ) does not affect the original array. You modify the original array by dereferencing the pointer, and overwriting the memory location it points to. This is something that the strcpy routine does internally, and this is why people are suggesting you use void pass_char_ref(unsigned char *foo) { strcpy(foo, "hello"); } instead. You could also say (for sake of exposition): void pass_char_ref(unsigned char *foo) { foo[0] = 'h'; foo[1] = 'e'; foo[2] = 'l'; foo[3] = 'l'; foo[4] = 'o'; foo[5] = 0; } and it would behave correctly, too. (this is similar to how strcpy will behave internally.) HTH
