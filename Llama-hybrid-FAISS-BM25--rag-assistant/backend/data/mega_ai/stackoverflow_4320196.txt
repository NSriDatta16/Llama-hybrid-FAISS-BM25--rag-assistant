[site]: stackoverflow
[post_id]: 4320196
[parent_id]: 4320085
[tags]: 
Please do not use nested vectors if the size of your storage is known ahead of time , i.e. there is a specific reason why e.g. the first index must be of size 6, and will never change. Just use a plain array. Better yet, use boost::array . That way, you get all the benefits of having a plain array (save huge amounts of space when you go multi-dimensional), and the benefits of having a real object instantiation. Please do not use nested vectors if your storage must be rectangular , i.e. you might resize one or more of the dimensions, but every "row" must be the same length at some point. Use boost::multi_array . That way, you document "this storage is rectangular", save huge amounts of space and still get the ability to resize, benefits of having a real object, etc. The thing about std::vector is that it (a) is meant to be resizable and (b) doesn't care about its contents in the slightest, as long as they're of the correct type. This means that if you have a vector > , then all of the "row vectors" must maintain their own separate book-keeping information about how long they are - even if you want to enforce that they're all the same length. It also means that they all manage separate memory allocations, which hurts performance (cache behaviour), and wastes even more space because of how std::vector reallocates. boost::multi_array is designed with the expectation that you may want to resize it, but won't be constantly resizing it by appending elements (rows, for a 2-dimensional array / faces, for a 3-dimensional array / etc.) to the end. std::vector is designed to (potentially) waste space to make sure that operation is not slow. boost::multi_array is designed to save space and keep everything neatly organized in memory. That said : Yes, you do need to do something before you can index into the vector. std::vector will not magically cause the indexes to pop into existence because you want to store something there. However, this is easy to deal with: You can default-initialize the vector with the appropriate amount of zeros first, and then replace them, by using the (size_t n, const T& value = T()) constructor. That is, std::vector foo(10); // makes a vector of 10 ints, each of which is 0 because a "default-constructed" int has the value 0. In your case, we need to specify the size of each dimension, by creating sub-vectors that are of the appropriate size and letting the constructor copy them. This looks like: typedef vector d1; typedef vector d2; typedef vector d3; typedef vector d4; d4 result(2, d3(7, d2(480, d1(31)))); That is, an unnamed d1 is constructed of size 31, which is used to initialize the default d2 , which is used to initialize the default d3 , which is used to initialize result . There are other approaches, but they're much clumsier if you just want a bunch of zeroes to start. If you're going to read the entire data set from a file, though: You can use .push_back() to append to a vector. Make an empty d1 just before the inner-most loop, in which you repeatedly .push_back() to fill it. Just after the loop, you .push_back() the result onto the d2 which you created just before the next-innermost loop, and so on. You can resize a vector beforehand with .resize() , and then index into it normally (up to the amount that you resized to).
