[site]: stackoverflow
[post_id]: 398184
[parent_id]: 323604
[tags]: 
I agree that these are good ideas: Magic numbers at the beginning. Pretty much required in *nix: File version number for backwards compatibility. Endianness specification. But your fourth one is overkill, because #2 lets you add fields as long as you change the version number (and as long as you don't need forward compatibility ). possibly reserve some space for further per-file attributes that might be necessary in the future? Also, the idea of imposing a block-structure on your file, expressed in many other answers, seems less like a universal requirement for binary files than a solution to a problem with certain kinds of payloads. In addition to 1-3 above, I'd add these: simple checksum or other way of detecting that the contents are intact. Otherwise you can't trust magic bytes or version numbers. Be careful to spec which bytes are included in the checksum. Typically you would include all bytes in the file that don't already have error detection. version of your software (including the most granular number you have, e.g. build number) that wrote the file. You're going to get a bug report with an attached file from someone who can't open it and they will have no clue when they wrote the file because the error didn't occur then. But the bug is in the version that wrote it, not in the one trying to read it. Make it clear in the spec that this is a binary format, i.e. all values 0-255 are allowed for all bytes (except the magic numbers). And here are some optional ones: If you do need forward compatibility, you need some way of expressing which "chunks" are "optional" (like png does), so that a previous version of your software can skip over them gracefully. If you expect these files to be found "in the wild", you might consider embedding some clue to find the spec. Imagine how helpful it would be to find the string http://www.w3.org/TR/PNG/ in a png file.
