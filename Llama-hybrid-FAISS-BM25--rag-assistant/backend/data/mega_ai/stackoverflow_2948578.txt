[site]: stackoverflow
[post_id]: 2948578
[parent_id]: 
[tags]: 
JPA entitylisteners and @embeddable

I have a class hierarchy of JPA entities that all inherit from a BaseEntity class: @MappedSuperclass @EntityListeners( { ValidatorListener.class }) public abstract class BaseEntity implements Serializable { // other stuff } I want all entities that implement a given interface to be validated automatically on persist and/or update. Here's what I've got. My ValidatorListener: public class ValidatorListener { private enum Type { PERSIST, UPDATE } @PrePersist public void checkPersist(final Object entity) { if (entity instanceof Validateable) { this.check((Validateable) entity, Type.PERSIST); } } @PreUpdate public void checkUpdate(final Object entity) { if (entity instanceof Validateable) { this.check((Validateable) entity, Type.UPDATE); } } private void check(final Validateable entity, final Type persist) { switch (persist) { case PERSIST: if (entity instanceof Persist) { ((Persist) entity).persist(); } if (entity instanceof PersistOrUpdate) { ((PersistOrUpdate) entity).persistOrUpdate(); } break; case UPDATE: if (entity instanceof Update) { ((Update) entity).update(); } if (entity instanceof PersistOrUpdate) { ((PersistOrUpdate) entity).persistOrUpdate(); } break; default: break; } } } and here's my Validateable interface that it checks against (the outer interface is just a marker, the inner contain the methods): public interface Validateable { interface Persist extends Validateable { void persist(); } interface PersistOrUpdate extends Validateable { void persistOrUpdate(); } interface Update extends Validateable { void update(); } } All of this works, however I would like to extend this behavior to Embeddable classes. I know two solutions: call the validation method of the embeddable object manually from the entity validation method: public void persistOrUpdate(){ // validate my own properties first // then manually validate the embeddable property: myEmbeddable.persistOrUpdate(); // this works but I'd like something that I don't have to call manually } use reflection, checking all properties to see if their type is of one of their interface types. This would work, but it's not pretty. Is there a more elegant solution?
