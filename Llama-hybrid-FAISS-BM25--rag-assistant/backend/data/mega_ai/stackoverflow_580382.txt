[site]: stackoverflow
[post_id]: 580382
[parent_id]: 579965
[tags]: 
I would not want to implement locking using your approach as described above, simply because of the reasons you mentioned in the second paragraph. What I would do is to have a timestamp column in the table. Whenever an attempt is made to write to that table, it should be read first then its timestamp noted (say, in a session variable somewhere). Before writing the updated information back into the row I will take a look at the timestamp and ensure that its timestamp is exactly the same one that I saw (and noted in the session var). If it's not, someone updated the row while I wasn't looking (in this case, while you presented a form to the user and the user has not submitted the form back to the server yet). This approach is what many O/RMs use to ensure that one session is not overwriting changes made in another session inadvertently. The upside to this approach is that you do not run the chance of a "lock" getting left by a user who's abandoned the session, and you don't need to have a cron job to unlock stale locks. The downside to this approach is that you would only know about the collision the moment you try to update the record in the DB. This means the user would have already submitted a form containing the data changes, and you would have to inform the user that he/she has to try again (after, say, presenting the updated/latest information from that record).
