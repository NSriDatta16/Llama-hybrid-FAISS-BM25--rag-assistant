[site]: stackoverflow
[post_id]: 5054204
[parent_id]: 
[tags]: 
Derby - How to handle additions to objective fields

I'm looking to create a table for users and tracking their objectives. The objectives themselves would be on the order of 100s, if not 1000s, and would be maintained in their own table, but it wouldn't know who completed them - it would only define what objectives are available. Objective: ID | Name | Notes | ----+---------+---------+ | | | Now, in the Java environment, the users will have a java.util.BitSet for the objectives. So I can go /* in class User */ boolean hasCompletedObjective(int objectiveNum) { if(objectiveNum objectives.length()) throw new IllegalArgumentException("Objective " + objectiveNum + " is invalid. Use a constant from class Objective."); return objectives.get(objectivenum); } I know internally, the BitSet uses a long[] to do its storage. What would be the best way to represent this in my Derby database? I'd prefer to keep it in columns on the AppUser table if at all possible, because they really are elements of the user. Derby does not support arrays (to my knowledge) and while I'm not sure the column limit, something seems wrong with having 1000 columns, espeically since I know I will not be querying the database with things like SELECT * FROM AppUser WHERE AppUser.ObjectiveXYZ What are my options, both for storing it, and marshaling it into the BitSet? Are there viable alternatives to java.util.BitSet? Is there a flaw in the general approach? I'm open to ideas! Thanks! *EDIT: If at all possible, I would like the ability to add more objectives with only a data modification, not a table modification. But again, I'm open to ideas!
