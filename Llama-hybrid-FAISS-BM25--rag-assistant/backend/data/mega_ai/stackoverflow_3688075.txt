[site]: stackoverflow
[post_id]: 3688075
[parent_id]: 
[tags]: 
Is libsvm accurate?

With StompChicken's corrections (I miscomputed one dot product, ugh!) the answer appears to be yes. I have since tested the same problem using a precomputed kernel with the same correct results. If you are using libsvm StompChickens clear, organized computations are a very nice check. Original Question: I am about to start using precomputed kernels in libSVM. I had noticed Vlad's answer to a question and I thought it would be wise to confirm that libsvm gave correct answers. I started with non-precomputed kernels, just a simple linear kernel with 2 classes and three data points in 3 dimensional space. I used the data 1 1:3 2:1 3:0 2 1:3 2:3 3:1 1 1:7 3:9 The model file generated by a call to svm-train -s 0 - t 0 contains svm_type c_svc kernel_type linear nr_class 2 total_sv 3 rho -1.53951 label 1 2 nr_sv 2 1 SV 0.4126650675419768 1:3 2:1 3:0 0.03174528241667363 1:7 3:9 -0.4444103499586504 1:3 2:3 3:1 However when I compute the solution by hand that is not what I get. Does anyone know whether libsvm suffers from errors or can anyone compare notes and see whether they get the same thing libsvm does? The coefficients a1 , a2 , a3 returned by libsvm are should be the values that make a1 + a2 + a3 - 5*a1*a1 + 12*a1*a2 - 21*a1*a3 - 19*a2*a2/2 + 21*a2*a3 - 65*a3*a3 as large as possible with the restrictions that a1 + a3 = a2 and each of a1 , a2 , a3 is required to lie between 0 and 1 (the default value of C). The above model file says the answer is a1 = .412665... a2 = .444410... a3 = .031745... But one just has to substitute a2 = a1 + a3 into the big formula above and confirm both partial derivatives are zero to see if this solution is correct (since none of a1 , a2 , a3 is 0 or 1) but they are not zero. Am I doing something wrong, or is libsvm giving bad results? (I am hoping I am doing something wrong.)
