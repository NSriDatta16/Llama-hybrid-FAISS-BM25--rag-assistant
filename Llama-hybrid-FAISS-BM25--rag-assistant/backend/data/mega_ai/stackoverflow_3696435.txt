[site]: stackoverflow
[post_id]: 3696435
[parent_id]: 3696275
[tags]: 
There are a lot of things wrong with this code: As KennyTM notes, the ampersand is in the wrong place. You are passing a B* to a function that takes a B&, they aren't the same in C++ The design shown in your php fragment appears to misdesigned. While what you are doing is something you might want to do at times, you'll usually want to use a constructor instead, C++ and PHP alike. You are putting code directly in the file, this isn't allowed in C++, put it in the main function instead memory management: you are using new without delete (or a smart pointer class) You are using class B in class A while class A doesn't know about class B (it is defined later) - you should put class B on top (or perhaps use forward declaration) A few ways to make your code work properly are shown below. include using std::auto_ptr; class B { } class A { public: A(); SetB(B& b); private: B b1; // a B made in the constructor B b2; // a COPY of the original B you make } A::A() : b1(/*whatever you want to pass to B's constructor*/) { } A::SetB(B& b) { b2 = b; } int main(int agrc, char** argv) { A firstA(); B firstB(); firstA.SetB(firstB); A* secondA = new A(); B* secondB = new B(); secondA->SetB(*secondB); auto_ptr thirdA(new A()); auto_ptr thirdB(new B()); thirdA->SetB(*thirdB); // whatever other code delete secondA; delete secondB; } Note that id you call SetB only once (and there is no problem with cyclic depndencies between the different objects you are creating), but you do want the flexibility of constructing the B outside the class, you can instead make a parameter of the constructor. Also note that you are making a copy of the B you create in main - if you want to use the came copy in the class (as you would in PHP), you should use a member reference (in which case you will need to set what it refers to in the constructor, you can't do so in the SetB function. Then, note that there are serious problems with the secondA, secondB approach and as such it is not recommended (above nothing will go wrong, however, it is easy to get code that leaks memory this way (and hard to find out where the leak is) and on top of that when you want to use exceptions, you will need exception safe code, which is not achievable using plain old pointers. Lastly, note that you mix and match here. There is no problem at all with using firstA and thirdB together, for example.
