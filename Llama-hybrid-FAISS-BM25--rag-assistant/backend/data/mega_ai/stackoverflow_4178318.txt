[site]: stackoverflow
[post_id]: 4178318
[parent_id]: 4177996
[tags]: 
The crash occurs because your declaration of variable 'p' allocates only enough space on your stack for a single (int *) pointer, but then you stuff values into (&p + 2), etc. so you end up overwriting who-knows-what. It behaves differently with or without gdb because the who-knows-what part just might not be critical in one environment but is critical in the other. You might be able to "fix" your program by making sure that the space you're about to trash isn't anything critical. int main(){ int* p; char junk[100]; /* ADD THIS */ Now, the space following the storage allocated for 'p' will (most likely) be the junk char array, which you can get away with overwriting. (At least that "fixes" the program on my particular Linux system, when I compile with "gcc -O0 -g"). All that said -- the method you're using there is not in any way portable or safe. The compiler makes no promise that its going to arrange the storage allocations in the particular order that we declare them. Also, compiling with different optimization switches may change the behavior. So while this might be an interesting exercise, you should certainly not expect this sort of method to work consistently. Manually manipulating the C stack this way is a BAD IDEA!
