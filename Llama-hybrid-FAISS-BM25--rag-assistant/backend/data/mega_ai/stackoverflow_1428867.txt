[site]: stackoverflow
[post_id]: 1428867
[parent_id]: 1428679
[tags]: 
There is no need to use non-standard functions, it is not hard to write your own allocator with the necessary functionality. You have to know the size when you allocate the block, so simply retain that information. There are few situations IMO when you would not know that information, since by definition you knew it when it was allocated. However if you need such functionality, you can do that simply by wrapping malloc(), and pre-pending the size to the block. void* smalloc( size_t size ) { // allocate block with additional space for size void* blk = malloc( size + sizeof(size_t) ) ; // set the size *((size_t*)blk) = size ; // return pointer to block after size field (user block) return ((size_t*)blk) + 1 ; } void sfree( const void* blk ) { // Free from the size field address, not the user block free( ((const size_t*)blk) - 1 ) ; } size_t ssize( const void* blk ) { // Size is immediately before user block return *(((size_t*)blk) - 1) ; } On Jim Buck's point; On some target's, some jiggering may be needed to preserve necessary alignment. Some targets will generate less efficient code if alignment is not optimal, others will cause an abort. So beware of this solution. Personally I am wary of teh need for this solution! One solution perhaps would be to use a data structure such as a hash table with the malloc address as the key, and the size as the content, and using the same wrapper technique store the size separately from the block - at the expense or performance, additional storage, and perhaps some finite limit on capacity in terms of number of blocks that can be managed. However you do it, the fundamental point remains valid - wrap the basic service to provide what you need.
