[site]: stackoverflow
[post_id]: 5014876
[parent_id]: 5014680
[tags]: 
Let A and B be the 2 intersection points (you can ignore it when there is no, or 1 intercetion point). Then calculate the length of the circular line segment between A and B . With this information, you should be able to draw the arc using Graphics' drawArc(...) method (if I'm not mistaken...). EDIT Well, you don't even need the length of the circular line segment. I had the line-intersection code laying around, so I built a small GUI around it how you could paint/view the ARC of such intersecting circles (there are a bit of comments in the code): import javax.swing.*; import java.awt.*; import java.awt.event.*; import java.awt.geom.Arc2D; /** * @author: Bart Kiers */ public class GUI extends JFrame { private GUI() { super("Circle Intersection Demo"); initGUI(); } private void initGUI() { super.setSize(600, 640); super.setDefaultCloseOperation(EXIT_ON_CLOSE); super.setLayout(new BorderLayout(5, 5)); final Grid grid = new Grid(); grid.addMouseMotionListener(new MouseMotionAdapter() { @Override public void mouseDragged(MouseEvent e) { Point p = new Point(e.getX(), e.getY()).toCartesianPoint(grid.getWidth(), grid.getHeight()); grid.showDraggedCircle(p); } }); grid.addMouseListener(new MouseAdapter() { @Override public void mouseReleased(MouseEvent e) { Point p = new Point(e.getX(), e.getY()).toCartesianPoint(grid.getWidth(), grid.getHeight()); grid.released(p); } @Override public void mousePressed(MouseEvent e) { Point p = new Point(e.getX(), e.getY()).toCartesianPoint(grid.getWidth(), grid.getHeight()); grid.pressed(p); } }); super.add(grid, BorderLayout.CENTER); super.setVisible(true); } public static void main(String[] args) { SwingUtilities.invokeLater(new Runnable() { @Override public void run() { new GUI(); } }); } private static class Grid extends JPanel { private Circle c1 = null; private Circle c2 = null; private Point screenClick = null; private Point currentPosition = null; public void released(Point p) { if (c1 == null || c2 != null) { c1 = new Circle(screenClick, screenClick.distance(p)); c2 = null; } else { c2 = new Circle(screenClick, screenClick.distance(p)); } screenClick = null; repaint(); } public void pressed(Point p) { if(c1 != null && c2 != null) { c1 = null; c2 = null; } screenClick = p; repaint(); } @Override public void paintComponent(Graphics g) { Graphics2D g2d = (Graphics2D) g; g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); g2d.setColor(Color.WHITE); g2d.fillRect(0, 0, super.getWidth(), super.getHeight()); final int W = super.getWidth(); final int H = super.getHeight(); g2d.setColor(Color.LIGHT_GRAY); g2d.drawLine(0, H / 2, W, H / 2); // x-axis g2d.drawLine(W / 2, 0, W / 2, H); // y-axis if (c1 != null) { g2d.setColor(Color.RED); c1.drawOn(g2d, W, H); } if (c2 != null) { g2d.setColor(Color.ORANGE); c2.drawOn(g2d, W, H); } if (screenClick != null && currentPosition != null) { g2d.setColor(Color.DARK_GRAY); g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.5f)); Circle temp = new Circle(screenClick, screenClick.distance(currentPosition)); temp.drawOn(g2d, W, H); currentPosition = null; } if (c1 != null && c2 != null) { g2d.setColor(Color.BLUE); g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.4f)); Point[] ips = c1.intersections(c2); for (Point ip : ips) { ip.drawOn(g, W, H); } g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.2f)); if (ips.length == 2) { g2d.setStroke(new BasicStroke(10.0f)); c1.highlightArc(g2d, ips[0], ips[1], W, H); } } g2d.dispose(); } public void showDraggedCircle(Point p) { currentPosition = p; repaint(); } } private static class Circle { public final Point center; public final double radius; public Circle(Point center, double radius) { this.center = center; this.radius = radius; } public void drawOn(Graphics g, int width, int height) { // translate Cartesian(x,y) to Screen(x,y) Point screenP = center.toScreenPoint(width, height); int r = (int) Math.rint(radius); g.drawOval((int) screenP.x - r, (int) screenP.y - r, r + r, r + r); // draw the center Point screenCenter = center.toScreenPoint(width, height); r = 4; g.drawOval((int) screenCenter.x - r, (int) screenCenter.y - r, r + r, r + r); } public void highlightArc(Graphics2D g2d, Point p1, Point p2, int width, int height) { double a = center.degrees(p1); double b = center.degrees(p2); // translate Cartesian(x,y) to Screen(x,y) Point screenP = center.toScreenPoint(width, height); int r = (int) Math.rint(radius); // find the point to start drawing our arc double start = Math.abs(a - b) If you start the GUI above and then type 100 0 130 -80 55 180 in the text box and hit return, you'll see the following: ... Changed the code so that circles can be drawn by pressing- and dragging the mouse. Screenshot:
