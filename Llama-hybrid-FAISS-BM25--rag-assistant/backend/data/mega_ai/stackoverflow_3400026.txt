[site]: stackoverflow
[post_id]: 3400026
[parent_id]: 
[tags]: 
A better solution to Crypt Kicker?

While this seems like a duplicate of Crypt Kicker Problem , it isn't. I've solved the problem, but I'm not all together that satisfied with my solution. The problem statement is: A common but insecure method of encrypting text is to permute the letters of the alphabet. In other words, each letter of the alphabet is consistently replaced in the text by some other letter. To ensure that the encryption is reversible, no two letters are replaced by the same letter. Your task is to decrypt several encoded lines of text, assuming that each line uses a different set of replacements, and that all words in the decrypted text are from a dictionary of known words. Input The input consists of a line containing an integer n, followed by n lowercase words, one per line, in alphabetical order. These n words compose the dictionary of words which may appear in the decrypted text. Following the dictionary are several lines of input. Each line is encrypted as described above. There are no more than 1,000 words in the dictionary. No word exceeds 16 letters. The encrypted lines contain only lower case letters and spaces and do not exceed 80 characters in length. Output Decrypt each line and print it to standard output. If there are multiple solutions, any one will do. If there is no solution, replace every letter of the alphabet by an asterisk. Sample Input 6 and dick jane puff spot yertle bjvg xsb hxsn xsb qymm xsb rqat xsb pnetfn xxxx yyy zzzz www yyyy aaa bbbb ccc dddddd Sample Output dick and jane and puff and spot and yertle **** *** **** *** **** *** **** *** ****** I brute forced the problem: I bucketed the dictionary into a set based on length. Then I did a recursive brute force where I tried every possible substitution based on word length and backtracked if there wasn't a match. It works, but I'm very unsatisfied with the solution. I may just be obsessing, but it seems like there should be a more elegant way to solve the problem. My code is below: #include #include #include #include #include #include #include using namespace std; bool Find(vector > &dict,vector &line, map &dec,int spot){ //Check that the end of the line hasn't been reached if(spot ::iterator it=dict[sSize].begin();it!=dict[sSize].end();it++){ bool notMatch=false; for(int i=0;i (line[spot][i],(*it)[i])); //Keep decoding if(Find(dict,line,dec,spot+1)) return true; //If decoding failed, then remove added characters for(int i=0;i (b[i],'*')); } return false; } return true; } int main(){ int size; cin >> size; vector > dict; dict.resize(17); string grab; for(int i=0;i > grab; dict[grab.size()].insert(grab); } while(getline(cin,grab)){ stringstream in(stringstream::in |stringstream::out); in line; while(in >> grab) line.push_back(grab); map dec; Find(dict,line,dec,0); for(int i=0;i Also, I'm not particularly interested in solutions that wouldn't work in c++. Just because it's the language I work with in the programming contest, so I'm confined to it for solving these problems. I also know that there are quite a few stylistic and minor efficiency things that I could do differently that don't concern me too much, I'm missing a break or two. Mainly I'm just wondering if there's a simpler solution, or if my implementation is over-complicating things. Thanks.
