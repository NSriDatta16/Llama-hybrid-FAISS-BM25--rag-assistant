[site]: stackoverflow
[post_id]: 838743
[parent_id]: 833496
[tags]: 
You should throw Exceptions. Exceptions are mapped to HRESULTS by the Framework, and HRESULTs are the standard way to return errors to COM clients, so this is the way to go. Each Exception type has an HResult property. When managed code called from a COM Client throws an exception, the runtime passes the HResult to the COM client. If you want application-specific HRESULT codes, you can create your own custom Exception types and set the Exception.HResult property. One point to note is that the call stack information will be lost when an Exception is thrown to a COM client. It can therefore be a good idea to log exceptions before propagating to the COM client. One technique I sometimes use is the following: explicitly implement a ComVisible interface for COM clients that logs and rethrows exceptions. COM clients use the ComVisible interface that logs exceptions before propagating them. .NET clients use the concrete class and are expected to make their own arrangements for exception handling. It's a bit long-winded to write but can be helpful when you're subsequently troubleshooting. Another advantage of this approach is that you can have an API tailored to the restrictions of COM for COM clients, and a more standard API for standard .NET clients. For example, COM clients are restricted to passing arrays by reference, whereas passing by reference is discouraged for .NET clients. Example: [ ComVisible(true), GuidAttribute("..."), Description("...") ] public interface IMyComVisibleClass { // Text from the Description attribute will be exported to the COM type library. [Description("...")] MyResult MyMethod(...); [Description("...")] MyOtherResult MyArrayMethod([In] ref int[] ids,...); } ... [ ComVisible(true), GuidAttribute("..."), ProgId("..."), ClassInterface(ClassInterfaceType.None), Description("...") ] public class MyComVisibleClass : IMyComVisibleClass { public MyResult MyMethod(...) { ... implementation without exception handling ... } public MyOtherResult MyArrayMethod(int[] ids,...) { ... input parameter does not use ref keyword for .NET clients ... ... implementation without exception handling ... } MyResult IMyComVisibleClass.MyMethod(...) { // intended for COM clients only try { return this.MyMethod(...); } catch(Exception ex) { ... log exception ... throw; // Optionally wrap in a custom exception type } } MyOtherResult IMyComVisibleClass.MyArrayMethod(ref int[] ids, ...) { // intended for COM clients only try { // Array is passed without ref keyword return this.MyArrayMethod(ids, ...); } catch(Exception ex) { ... log exception ... throw; // Optionally wrap in a custom exception type } } }
