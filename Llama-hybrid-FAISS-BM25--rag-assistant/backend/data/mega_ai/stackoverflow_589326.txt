[site]: stackoverflow
[post_id]: 589326
[parent_id]: 587840
[tags]: 
You could use the Raw Input API to distinguish between the keyboard and the scanner like I did recently. It doesn't matter how many keyboard or keyboard-like devices you have hooked up; you will see a WM_INPUT before the keystroke is mapped to a device-independent virtual key that you typically see in a KeyDown event. Far easier is to do what others have recommended and configure the scanner to send sentinel characters before and after the barcode. (You usually do this by scanning special barcodes in the back of the scanner's user manual.) Then, your main form's KeyPreview event can watch those roll end and swallow the key events for any child control if it's in the middle of a barcode read. Or, if you wanted to be fancier, you could use a low-level keyboard hook with SetWindowsHookEx() to watch for those sentinels and swallow them there (advantage of this is you could still get the event even if your app didn't have focus). I couldn't change the sentinel values on our barcode scanners among other things so I had to go the complicated route. Was definitely painful. Keep it simple if you can! -- Your update, seven years later: If your use case is reading from a USB barcode scanner, Windows 10 has a nice, friendly API for this built-in in Windows.Devices.PointOfService.BarcodeScanner . It's a UWP/WinRT API, but you can use it from a regular desktop app as well; that's what I'm doing now. Here's some example code for it, straight from my app, to give you the gist: { using System; using System.Linq; using System.Threading.Tasks; using System.Windows; using Windows.Devices.Enumeration; using Windows.Devices.PointOfService; using Windows.Storage.Streams; using PosBarcodeScanner = Windows.Devices.PointOfService.BarcodeScanner; public class BarcodeScanner : IBarcodeScanner, IDisposable { private ClaimedBarcodeScanner scanner; public event EventHandler BarcodeScanned; ~BarcodeScanner() { this.Dispose(false); } public bool Exists { get { return this.scanner != null; } } public void Dispose() { this.Dispose(true); GC.SuppressFinalize(this); } public async Task StartAsync() { if (this.scanner == null) { var collection = await DeviceInformation.FindAllAsync(PosBarcodeScanner.GetDeviceSelector()); if (collection != null && collection.Count > 0) { var identity = collection.First().Id; var device = await PosBarcodeScanner.FromIdAsync(identity); if (device != null) { this.scanner = await device.ClaimScannerAsync(); if (this.scanner != null) { this.scanner.IsDecodeDataEnabled = true; this.scanner.ReleaseDeviceRequested += WhenScannerReleaseDeviceRequested; this.scanner.DataReceived += WhenScannerDataReceived; await this.scanner.EnableAsync(); } } } } } private void WhenScannerDataReceived(object sender, BarcodeScannerDataReceivedEventArgs args) { var data = args.Report.ScanDataLabel; using (var reader = DataReader.FromBuffer(data)) { var text = reader.ReadString(data.Length); var bsea = new BarcodeScannedEventArgs(text); this.BarcodeScanned?.Invoke(this, bsea); } } private void WhenScannerReleaseDeviceRequested(object sender, ClaimedBarcodeScanner args) { args.RetainDevice(); } private void Dispose(bool disposing) { if (disposing) { this.scanner = null; } } } } Granted, you'll need a barcode scanner that supports the USB HID POS and isn't just a keyboard wedge. If your scanner is just a keyboard wedge, I recommend picking up something like a used Honeywell 4600G off eBay for like $25. Trust me, your sanity will be worth it.
