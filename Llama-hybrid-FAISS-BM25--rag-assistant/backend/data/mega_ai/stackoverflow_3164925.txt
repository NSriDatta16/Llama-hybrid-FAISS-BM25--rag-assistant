[site]: stackoverflow
[post_id]: 3164925
[parent_id]: 3164602
[tags]: 
The paragraph is basically saying that you encode your states as individual classes - then the instance type is the "state" and the classes don't need any instance variables because their type encodes all the information you need. E.g say I want to have three states "Open", "Active" and "Closed". I might define the following classes: abstract class State {}; class Open extends State { public Open() {} } class Active extends State { public Active() {} } class Closed extends State { public Closed() {} } -- Another option - I'd suspect this is the combination with flyweight being hinted at in the GOF text would be to create a state class which a bunch of static members (one for each state) which can then be shared - public class State { private string name; private State(String name) { this.name = name; } public final static State OPEN = new State("Open"); public final static State ACTIVE = new State("Active"); public final static State CLOSED = new State("Closed"); } I had to go digging to remind myself of how all this stuff worked in detail. Kerievsky has a good description of this (I've heavily borrowed from one of his examples above!) and how the state transitions can be handled by sub-classing from the state class, to create classes that manage each transition. See "Refactoring to Patterns" (ISBN: 0321213351) EDIT(2): His web site has a class diagram for his example - http://www.industriallogic.com/xp/refactoring/alteringConditionalsWithState.html
