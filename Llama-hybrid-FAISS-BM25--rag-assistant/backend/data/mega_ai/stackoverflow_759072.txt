[site]: stackoverflow
[post_id]: 759072
[parent_id]: 758823
[tags]: 
Assuming you need maximum granularity, the ability to "grant" each and any row to any of very many users, then you have a many-to-many relation, yes? So apply the following pattern: Add a tables of users. Then, for each restricted table, so the following: Rename it tablename + "_base". create a many-to-many table that associates that table's id with a user id, called tablename + "allowed_user". create a view with the name table name that joins tablename_base to table_name_allowed_user, with a select* from tablename_base and user_id from tablename_allowed_user. This view should meet Oracle's requirements rto be "inherently updatable." Now comes the hard part. You need to add "and user_id = $user_id" to every query. Find the various functions you're using to make queries. Wrap those function(s) in ones that gets the user id from the session and add that predicate. One passable way to do this is to read select string, find the all "where"s (for subqueries there may be more that one), and replace it with "where (user = $user) and ". For queries that don't have a where, you'll need to insert this before any "group by" or "order by". This is fragile, so obviously you'll test that this works for all pages (you have an automated test for all pages, right?), and add hacks to cover special cases. "update" statements won't have to change; "inserts" will presumably insert both to the view and then do a separate insert to the table's "allow_user" table with the id of the inserting user, to automatically grant teh inserting user acces to what he inserted. If your number of users is more limited, or you're restricting types of users, you can go with a strategy of multiple views named for the user or type; then you'd replace tables names in the queries with the appropriate views.
