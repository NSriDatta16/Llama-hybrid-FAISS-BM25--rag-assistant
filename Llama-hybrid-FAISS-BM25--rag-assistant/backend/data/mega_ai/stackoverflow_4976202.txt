[site]: stackoverflow
[post_id]: 4976202
[parent_id]: 
[tags]: 
C++ Pointer Math

Got a question about C++ Pointer addition. If you look at the screen shot provided you can basically see I'm doing a memcpy(m_pBuf + m_iWritePtr .... and this memory pointer addition is not working as expected. I had thought that the addition of m_pBuf + m_iWritePtr would add m_iWritePtr bytes to my memory address m_pBuf. m_pBuf is a pointer to a structure array; i.e. (T *)m_pBuf = new T[cnt] where T is a typename and cnt is the number of T objects allocated. T is, in this case a simple structure. The sizeof(T) in this case is 260. The memcpy call is throwing a fault and I know my pointer math is wrong but I'm not 100% sure why. The memcpy is coded to, I thought, to take the base address and add some n * 260 bytes to get an offset into the buffer. NOTE: This code use to work when this was not a template implementation and T was simply a char *. Now that T is a template of some typename, the offset addition no longer works as expected. So if you look at the screen shot below, here are the results of various calculations/references I did using the compiler's debugger/inspector and a calculator: The memory address of m_pBuf = 0x01E7E0E0 The memory address of m_pBuf[1] = 0x01E8EE04 the memory address of m_pBuf+1 = 0x01E8EE04 the memory address of m_pBuf++ = 0x01E8EBFC the memory address of m_pBuf+260 = 0x01E7E1E4 (the calculator's result) I'm trying to understand what's going on here. The first two seem correct but I don't understand why none of these are equal. This is 32bit compiler on Windows 7-64bit. To further explain, this is a ring buffer of type T with a size of n * T objects of storage. Here is the code: template bool TMsgBuffer ::PutMsgEx(T *pBuf, unsigned long nObjCount ) { bool bResult = false; unsigned long MaxWriteSize, nPutLen; Lock(); MaxWriteSize = GetMaxWriteSize(); // this returns size of my buffer in total. nPutLen = nObjCount * m_nObjSize; // m_nObjSize is set else where to sizeof(T) if(nPutLen
