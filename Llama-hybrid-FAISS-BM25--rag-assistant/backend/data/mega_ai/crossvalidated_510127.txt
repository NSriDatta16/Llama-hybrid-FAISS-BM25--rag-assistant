[site]: crossvalidated
[post_id]: 510127
[parent_id]: 506994
[tags]: 
Note that the question states that These proportions all relate to the same sample (n=28). They are not independent of each other. However, if we were to assume independence , then we could use the approach of Newcombe, R.G., 1998. Interval estimation for the difference between independent proportions: comparison of eleven methods. Statistics in medicine, 17(8), pp.873-890. Who presents APPENDIX I: MULTIPLICATIVE SCALE SYMMETRY OF CONDITIONAL INTERVALS DERIVED FROM THE WILSON SCORE INTERVAL In Newcombe, 1998's notation, if: CI [f/(f+g)] = [L,U] Then: CI [f/g] = [L/(1-L),U/(1-U)] In the case in this question, this gives: I = 55% [-26%, 224%] In python: import statsmodels.api x1 = 17 x2 = 11 CL = 0.95 n = x1+x2 P_E = x1/(n-x1) -1 print('Point Estimate = ',P_E) low, high = statsmodels.stats.proportion.proportion_confint(x1, n, alpha=1-CL, method='wilson') L_1 = low / (1-low) -1 H_1 = high / (1-high) -1 print('CI = ',L_1, H_1) Coverage I think the coverage is around 99.88%, vastly over the target 95%. Figure 1, Coverage Probability (CP) against P(10) I assessed it with a simulation, using the same approach as for the Bootstrap answer. With 100,000 samples for each of the same 4 P(10) values that I used to asses the bootstrap technique it took 41 seconds to run. In python: import numpy as np import pandas as pd import time import statsmodels.api import matplotlib.pyplot as plt n = 28 print('sample size (n) = ',n) nrep = 100000 print('coverage sample size = ',nrep) CL = 0.95 print('Confidence Level = ',CL) start = time.time() d_CP = {} d_Re = {} P_10s = [0.00, 0.04, 0.08, 0.12] for P_10 in P_10s: pvals = [.3, P_10, (.3-P_10), .4] print('Prob ',pvals) print('total P = ',sum(pvals)) P11 = pvals[0] P10 = pvals[1] P01 = pvals[2] P00 = pvals[3] I_T = (P11+P01)/(P11+P10)-1 print('True I = ',I_T) print('Estimate the Coverage Probability using simulation') CP = [] for it in range(nrep): # Generate sample data ExeS = np.random.multinomial(n, pvals) x11 = ExeS[0] x10 = ExeS[1] x01 = ExeS[2] x00 = ExeS[3] low, high = statsmodels.stats.proportion.proportion_confint((x11+x01), (x11*2+x10+x01), alpha=1-CL, method='wilson') L_1 = low / (1-low) -1 H_1 = high / (1-high) -1 # Check whether the interval contains the true value if (I_T L_1): CP.append(1) else: CP.append(0) # results d_Re[P_10] = CP d_CP[P_10] = sum(CP)/len(CP) print('CP = ',d_CP[P_10]) end = time.time() print('time = ',end - start) # CI CI_Low = [] CI_High = [] for P_10 in d_CP.keys(): low, high = statsmodels.stats.proportion.proportion_confint(d_CP[float(P_10)]*nrep, nrep, alpha=1-0.95, method='wilson') CI_Low.append(low) CI_High.append(high) print('Plot') df_G1 = pd.DataFrame({'P_10' : list(d_CP.keys()), 'CP' : list(d_CP.values()), 'Lo' : CI_Low, 'Hi' : CI_High}) fig, ax1 = plt.subplots(1,1) df_G1.plot(x='P_10', y='Hi', legend=False, ax=ax1, label='95% CI', linewidth=5, color='k', linestyle='--') df_G1.plot(x='P_10', y='CP', legend=False, ax=ax1, label='CP', linewidth=5, color='k', linestyle='-') df_G1.plot(x='P_10', y='Lo', legend=False, ax=ax1, label='95% CI', linewidth=5, color='k', linestyle='--') for item in ([ax1.title, ax1.xaxis.label, ax1.yaxis.label] + ax1.get_xticklabels() + ax1.get_yticklabels()): item.set_fontsize(22) plt.xlabel(' $P(10)$ ') plt.ylabel(' $CP$ ') plt.xlim([0,0.12]) plt.ylim([0.998,1]) plt.xticks([0.00, 0.04, 0.08, 0.12]) plt.yticks([0.998,0.999,1]) plt.grid(which='both', color='b') fig = plt.gcf() fig.set_size_inches(4,4) plt.show() plt.clf()
