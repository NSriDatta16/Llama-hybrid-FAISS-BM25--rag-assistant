[site]: crossvalidated
[post_id]: 534283
[parent_id]: 
[tags]: 
Multi-Multi-Class Classification

I'd like to build a model that can output results for several multi-class classification problems at once. Suppose you have diagnostic data about a product that needs to be repaired and you want to predict the quantity of various part numbers that will be needed to repair the product. The input data is the same for all part numbers to be predicted. Here's a concrete example. You have 2 part numbers that can get replaced, part A and part B. For part A you can replace 0, 1, 2, or 3 of them on the product. For part B you can replace 0, 2 or 4 (replaced in pairs). How can a Tensorflow/Keras Neural Network be configured to have outputs such that the probabilities of replacing part A 0, 1, 2, and 3 times sum to 1. With similar behavior for part B (probabilities sum to 1). Simple code like the code below would treat all of the values as coming from the same discrete probability distribution. How can this be modified to create 2 discrete probability distributions in the output: def baseline_model(): # create model model = Sequential() model.add(Dense(8, input_dim=4, activation='relu')) model.add(Dense(7, activation='softmax')) # Compile model model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy']) return model UPDATE Based on the comment(s) from @Ceph, will something like this work? import tensorflow as tf from tensorflow.keras.layers import Input, Dense, Flatten, Concatenate from mypackage import get_my_data, compiler_args data = get_my_data() # obviously, this is a stand-in for however you get your data. input_layer = Input(data.shape[1:]) hidden = Flatten()(input_layer) hidden = Dense(192, activation='relu')(hidden) main_output = Dense(192, activation='relu')(hidden) # I'm going to build each individual parallel set of layers separately part_a = Dense(10, activation='relu')(main_output) output_a = Dense(4, activation='softmax')(part_a) # multi-class classification for part A part_b = Dense(10, activation='relu')(main_output) # note that it is main_output again output_b = Dense(3, activation='softmax')(part_b) # multi-class classification for part B final_output = Concatenate()([output_a, output_b]) # Combine the outputs into final output layer model = tf.keras.Model(input_layer, final_output) model.compile(**compiler_args) model.summary()
