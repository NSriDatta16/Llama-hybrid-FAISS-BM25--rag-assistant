[site]: stackoverflow
[post_id]: 5450159
[parent_id]: 
[tags]: 
What type erasure techniques are there, and how do they work?

(With type erasure, I mean hiding some or all of the type information regarding a class, somewhat like Boost.Any .) I want to get a hold of type erasure techniques, while also sharing those, which I know of. My hope is kinda to find some crazy technique that somebody thought of in his/her darkest hour. :) The first and most obvious, and commonly taken approach, that I know, are virtual functions. Just hide the implementation of your class inside an interface based class hierarchy. Many Boost libraries do this, for example Boost.Any does this to hide your type and Boost.Shared_ptr does this to hide the (de)allocation mechanic. Then there is the option with function pointers to templated functions, while holding the actual object in a void* pointer, like Boost.Function does to hide the real type of the functor. Example implementations can be found at the end of the question. So, for my actual question: What other type erasure techniques do you know of? Please provide them, if possible, with an example code, use cases, your experience with them and maybe links for further reading. Edit (Since I wasn't sure wether to add this as an answer, or just edit the question, I'll just do the safer one.) Another nice technique to hide the actual type of something without virtual functions or void* fiddling, is the one GMan employs here , with relevance to my question on how exactly this works. Example code: #include #include // NOTE: The class name indicates the underlying type erasure technique // this behaves like the Boost.Any type w.r.t. implementation details class Any_Virtual{ struct holder_base{ virtual ~holder_base(){} virtual holder_base* clone() const = 0; }; template struct holder : holder_base{ holder() : held_() {} holder(T const& t) : held_(t) {} virtual ~holder(){ } virtual holder_base* clone() const { return new holder (*this); } T held_; }; public: Any_Virtual() : storage_(0) {} Any_Virtual(Any_Virtual const& other) : storage_(other.storage_->clone()) {} template Any_Virtual(T const& t) : storage_(new holder (t)) {} ~Any_Virtual(){ Clear(); } Any_Virtual& operator=(Any_Virtual const& other){ Clear(); storage_ = other.storage_->clone(); return *this; } template Any_Virtual& operator=(T const& t){ Clear(); storage_ = new holder (t); return *this; } void Clear(){ if(storage_) delete storage_; } template T& As(){ return static_cast *>(storage_)->held_; } private: holder_base* storage_; }; // the following demonstrates the use of void pointers // and function pointers to templated operate functions // to safely hide the type enum Operation{ CopyTag, DeleteTag }; template void Operate(void*const& in, void*& out, Operation op){ switch(op){ case CopyTag: out = new T(*static_cast (in)); return; case DeleteTag: delete static_cast (out); } } class Any_VoidPtr{ public: Any_VoidPtr() : object_(0) , operate_(0) {} Any_VoidPtr(Any_VoidPtr const& other) : object_(0) , operate_(other.operate_) { if(other.object_) operate_(other.object_, object_, CopyTag); } template Any_VoidPtr(T const& t) : object_(new T(t)) , operate_(&Operate ) {} ~Any_VoidPtr(){ Clear(); } Any_VoidPtr& operator=(Any_VoidPtr const& other){ Clear(); operate_ = other.operate_; operate_(other.object_, object_, CopyTag); return *this; } template Any_VoidPtr& operator=(T const& t){ Clear(); object_ = new T(t); operate_ = &Operate ; return *this; } void Clear(){ if(object_) operate_(0,object_,DeleteTag); object_ = 0; } template T& As(){ return *static_cast (object_); } private: typedef void (*OperateFunc)(void*const&,void*&,Operation); void* object_; OperateFunc operate_; }; int main(){ Any_Virtual a = 6; std::cout () () () (); a2 = a3; a2.As () += " - again!"; std::cout () () ().As () += " - and yet again!!"; std::cout () a: " ().As ()
