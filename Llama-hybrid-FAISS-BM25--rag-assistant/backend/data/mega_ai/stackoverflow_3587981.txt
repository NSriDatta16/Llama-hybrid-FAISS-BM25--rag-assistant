[site]: stackoverflow
[post_id]: 3587981
[parent_id]: 3587704
[tags]: 
David Thonley's comment is right on, but I'm going to assume you want a blob with an 'organic' shape and smooth edges. For that you can use metaballs. Metaballs is a power function that works on a scalar field. Scalar fields can be rendered efficiently with the marching cubes algorithm. Different shapes can be made by changing the number of balls, their positions and their radius. See here for an introduction to 2D metaballs: https://web.archive.org/web/20161018194403/https://www.niksula.hut.fi/~hkankaan/Homepages/metaballs.html And here for an introduction to the marching cubes algorithm: https://web.archive.org/web/20120329000652/http://local.wasp.uwa.edu.au/~pbourke/geometry/polygonise/ Note that the 256 combinations for the intersections in 3D is only 16 combinations in 2D. It's very easy to implement. EDIT: I hacked together a quick example with a GLSL shader. Here is the result by using 50 blobs, with the energy function from hkankaan's homepage. Here is the actual GLSL code, though I evaluate this per-fragment. I'm not using the marching cubes algorithm. You need to render a full-screen quad for it to work (two triangles). The vec3 uniform array is simply the 2D positions and radiuses of the individual blobs passed with glUniform3fv . /* Trivial bare-bone vertex shader */ #version 150 in vec2 vertex; void main() { gl_Position = vec4(vertex.x, vertex.y, 0.0, 1.0); } /* Fragment shader */ #version 150 #define NUM_BALLS 50 out vec4 color_out; uniform vec3 balls[NUM_BALLS]; //.xy is position .z is radius bool energyField(in vec2 p, in float gooeyness, in float iso) { float en = 0.0; bool result = false; for(int i=0; i iso) result = true; return result; } void main() { bool outside; /* gl_FragCoord.xy is in screen space / fragment coordinates */ outside = energyField(gl_FragCoord.xy, 1.0, 40.0); if(outside == true) color_out = vec4(1.0, 0.0, 0.0, 1.0); else discard; }
