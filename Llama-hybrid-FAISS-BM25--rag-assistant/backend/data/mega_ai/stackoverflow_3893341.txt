[site]: stackoverflow
[post_id]: 3893341
[parent_id]: 3762306
[tags]: 
[NeverMind] The internal comments for LayerDrawable.getPadding claim that it takes the padding from the first drawable in the list. If this comment is telling the truth, you could get the behavior you want by putting an arbitrary (perhaps empty) image before your 9 patch in the list. A quick reading of the code, however, implies that it actually uses the sum of all the item's paddings, which means that there's no way to eliminate your problem using the default LayerDrawable . The statement implies the solution: implement a subclass of LayerDrawable which overrides "getPadding" to return {0, 0, 0, 0}. You may have to initialize your subclass in code rather than by loading an XML layout, but this isn't particularly difficult. [/NeverMind] Update: The solution above doesn't work, because the problem isn't the padding itself, it's the fact that the default implementation sets the bounds of each image to be the sum of the paddings of the preceding images. In other words, it enforces nesting, which is what most people will want. The proper solution is still to override LayerDrawable, but you replace "onBoundsChange" instead. A complete, tested demo follows: package com.beekeeper.ninepatchcover; import android.app.Activity; import android.graphics.*; import android.graphics.drawable.*; import android.os.Bundle; import android.view.Gravity; import android.widget.ImageButton; public class NinePatchCover extends Activity { private Drawable mCover0; private Drawable mCover1; /** Called when the activity is first created. */ @Override public void onCreate(final Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); final Drawable button = getResources().getDrawable(android.R.drawable.btn_default); final Bitmap iconBitmap = BitmapFactory.decodeResource(getResources(), android.R.drawable.ic_menu_mylocation); final BitmapDrawable icon = new BitmapDrawable(iconBitmap); icon.setGravity(Gravity.CENTER); mCover0 = getResources().getDrawable(android.R.drawable.title_bar); mCover1 = getResources().getDrawable(android.R.drawable.title_bar); final LayerDrawable unsolved = new LayerDrawable(new Drawable[]{button, icon, mCover0}); final LayerDrawable solved = new MyLayerDrawable(new Drawable[]{button, icon, mCover1,}, mCover1); ((ImageButton)findViewById(R.id.uncovered)).setBackgroundDrawable(unsolved); ((ImageButton)findViewById(R.id.covered)).setBackgroundDrawable(solved); } class MyLayerDrawable extends LayerDrawable { Drawable mCover; public MyLayerDrawable(final Drawable[] layers, final Drawable cover) { super(layers); mCover = cover; } @Override protected void onBoundsChange(final Rect bounds) { super.onBoundsChange(bounds); mCover.setBounds(bounds); } } } using the following layout/main.xml A sample screenshot follows: Update 2: As requested, here's how you can modify it to initialize a Selector within the code. Replace the initialization of "mCover1" with the following code: final StateListDrawable sld = new StateListDrawable(); sld.addState(new int[]{android.R.attr.state_pressed}, new ColorDrawable(0xffff0000)); sld.addState(new int[]{android.R.attr.state_window_focused}, new ColorDrawable(0xff00ff00)); sld.addState(new int[]{}, getResources().getDrawable(android.R.drawable.title_bar)); mCover1 = sld; This will show green in the normal case where the window is focused but the button isn't pressed, red when the button is pressed, and the default drawable (grey) when the window isn't focused. (Try dragging down the "windowshade" notification bar to see the window in it's unfocused state.)
