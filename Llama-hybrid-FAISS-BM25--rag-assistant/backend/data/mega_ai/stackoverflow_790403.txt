[site]: stackoverflow
[post_id]: 790403
[parent_id]: 786476
[tags]: 
You should be doing one presenter per one control because of: that would allow you to have focused unit tests tackling only that control increased maintainability due to the fact you won’t need to support gigantic presenter containing union of presentation logic of all controls that would prevent redundancy in cases of having same control on multiple pages Increases SRP by having controls focusing on their specific logic while the page performs container specific roles: There are two problems usually mentioned related to the decision “presenter per control”: Shared context is problem where due to the fact that all of the controls are just showing different pieces of the same page data context, that situation may look like a problematic use case leading to a lot of data retrieval redundant code in every of the controls. That is easily solvable through dependency injection where page (or controller) performs single data retrieval and then inject the data context object into every of the presenters\views (usually implementing some interface enabling that). In case of MV-VM pattern (Silverlight, WPF) same effect can be achieved through data bounding where the page would set its DataContext which would then be used from views itself Communication between views on the same page is second problem which is easily solvable using couple of approaches: Controls are publishing events to which page subscribes and then makes direct calls to appropriate methods in other controls (page is container to all controls meaning it is aware of all of their members) Observer design pattern Event aggregator pattern In each one of this approaches controls are communicating with each other without being aware of each other
