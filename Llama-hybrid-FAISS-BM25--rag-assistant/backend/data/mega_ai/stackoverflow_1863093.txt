[site]: stackoverflow
[post_id]: 1863093
[parent_id]: 1863069
[tags]: 
For types for which such cast is permitted (e.g. if T1 is a POD-type and T2 is unsigned char ), the approach with static_cast is well-defined by the Standard. On the other hand, reinterpret_cast is entirely implementation-defined - the only guarantee that you get for it is that you can cast a pointer type to any other pointer type and then back, and you'll get the original value; and also, you can cast a pointer type to an integral type large enough to hold a pointer value (which varies depending on implementation, and needs not exist at all), and then cast it back, and you'll get the original value. To be more specific, I'll just quote the relevant parts of the Standard, highlighting important parts: 5.2.10[expr.reinterpret.cast]: The mapping performed by reinterpret_cast is implementation-defined . [Note: it might, or might not, produce a representation different from the original value.] ... A pointer to an object can be explicitly converted to a pointer to an object of different type.) Except that converting an rvalue of type “pointer to T1” to the type “pointer to T2” (where T1 and T2 are object types and where the alignment requirements of T2 are no stricter than those of T1) and back to its original type yields the original pointer value, the result of such a pointer conversion is unspecified . So something like this: struct pod_t { int x; }; pod_t pod; char* p = reinterpret_cast (&pod); memset(p, 0, sizeof pod); is effectively unspecified. Explaining why static_cast works is a bit more tricky. Here's the above code rewritten to use static_cast which I believe is guaranteed to always work as intended by the Standard: struct pod_t { int x; }; pod_t pod; char* p = static_cast (static_cast (&pod)); memset(p, 0, sizeof pod); Again, let me quote the sections of the Standard that, together, lead me to conclude that the above should be portable: 3.9[basic.types]: For any object (other than a base-class subobject) of POD type T, whether or not the object holds a valid value of type T, the underlying bytes (1.7) making up the object can be copied into an array of char or unsigned char. If the content of the array of char or unsigned char is copied back into the object, the object shall subsequently hold its original value. The object representation of an object of type T is the sequence of N unsigned char objects taken up by the object of type T, where N equals sizeof(T). 3.9.2[basic.compound]: Objects of cv-qualified (3.9.3) or cv-unqualified type void* (pointer to void), can be used to point to objects of unknown type. A void* shall be able to hold any object pointer. A cv-qualified or cv-unqualified (3.9.3) void* shall have the same representation and alignment requirements as a cv-qualified or cv-unqualified char* . 3.10[basic.lval]: If a program attempts to access the stored value of an object through an lvalue of other than one of the following types the behavior is undefined): ... a char or unsigned char type . 4.10[conv.ptr]: An rvalue of type “pointer to cv T,” where T is an object type, can be converted to an rvalue of type “pointer to cv void.” The result of converting a “pointer to cv T” to a “pointer to cv void” points to the start of the storage location where the object of type T resides, as if the object is a most derived object (1.8) of type T (that is, not a base class subobject). 5.2.9[expr.static.cast]: The inverse of any standard conversion sequence (clause 4), other than the lvalue-to-rvalue (4.1), array-topointer (4.2), function-to-pointer (4.3), and boolean (4.12) conversions, can be performed explicitly using static_cast. [EDIT] On the other hand, we have this gem: 9.2[class.mem]/17: A pointer to a POD-struct object, suitably converted using a reinterpret_cast, points to its initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa. [Note: There might therefore be unnamed padding within a POD-struct object, but not at its beginning, as necessary to achieve appropriate alignment. ] which seems to imply that reinterpret_cast between pointers somehow implies "same address". Go figure.
