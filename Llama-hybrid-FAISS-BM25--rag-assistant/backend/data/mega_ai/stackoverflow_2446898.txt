[site]: stackoverflow
[post_id]: 2446898
[parent_id]: 2446841
[tags]: 
You can achieve O(1) if you pre-allocate N entries an array and hash the key to this N values. But then if you have more than N entries stored there are collision. So for each key in the array you have a list of value . So it's not exactly O(1) anymore. Scanning the list itself will be O(m) where m is the average number of collision. Example with hash = n mod 3 0 --> [0,a] [3,b] ... 1 --> [1,a] [4,b] [7,b] ... 2 --> [2,a] [5,b] ... At a point in time, it becomes some bad that you spend more time traversing the list of value for a potential key than using another structure with O(log n) lookup time, where n is the total number of entries. You could of course pick N so big that the array/hash would be faster than the B-Tree. But the array has a fixed pre-allocated size. So if N =1000 and you store 3 values, you've wasted 997 slots in the array. So it's essentially a performance-space trade-off. For small set of value, array and hashing is excellent. For large set of value, B-Tree are most efficient.
