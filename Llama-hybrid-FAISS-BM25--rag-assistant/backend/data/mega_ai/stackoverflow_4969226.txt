[site]: stackoverflow
[post_id]: 4969226
[parent_id]: 
[tags]: 
Android Homescreen

Hey folks, this is my first post so go easy on me! I want to develop an application where you can navigate through 7 or so screens like you can on the homescreen. I have seen a few posts on this but I can't seem to get them to work, I also can't seem to add comments to them (I'm sure thats me being a noob) So I need a working project so I can look at it and dissect it and use the bits relevant to me. This one was of interest but I just can't get it to work. I use Eclipse and the SDK is that what everyone else uses? Developing an Android Homescreen When I implement it I need to tell the app how to start because it installs it but says there is no activity. hope you can help T What I have in my Main.Java package com.matthieu.launcher; import android.app.Activity; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.view.View.OnClickListener; import android.widget.Button; import android.widget.ViewFlipper; public class main extends Activity { /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); Button onebutton = (Button)findViewById(R.id.soundsone); onebutton.setOnClickListener(new OnClickListener() { public void onClick(View v) { Intent i = new Intent(main.this, series1button.class); startActivity(i); overridePendingTransition(R.anim.push_up_in, R.anim.push_up_out); } }); Button twobutton = (Button)findViewById(R.id.soundstwo); twobutton.setOnClickListener(new OnClickListener() { public void onClick(View v) { Intent i = new Intent(main.this, series2button.class); startActivity(i); overridePendingTransition(R.anim.push_up_in, R.anim.push_up_out); } }); Button threebutton = (Button)findViewById(R.id.soundsthree); threebutton.setOnClickListener(new OnClickListener() { public void onClick(View v) { Intent i = new Intent(main.this, series3button.class); startActivity(i); overridePendingTransition(R.anim.push_up_in, R.anim.push_up_out); } }); Button fourbutton = (Button)findViewById(R.id.soundsfour); fourbutton.setOnClickListener(new OnClickListener() { public void onClick(View v) { Intent i = new Intent(main.this, series4button.class); startActivity(i); overridePendingTransition(R.anim.push_up_in, R.anim.push_up_out); } }); Button fivebutton = (Button)findViewById(R.id.soundsfive); fivebutton.setOnClickListener(new OnClickListener() { public void onClick(View v) { Intent i = new Intent(main.this, series5button.class); startActivity(i); overridePendingTransition(R.anim.push_up_in, R.anim.push_up_out); } }); Button sixbutton = (Button)findViewById(R.id.soundssix); sixbutton.setOnClickListener(new OnClickListener() { public void onClick(View v) { Intent i = new Intent(main.this, series6button.class); startActivity(i); overridePendingTransition(R.anim.push_up_in, R.anim.push_up_out); } }); Button sevenbutton = (Button)findViewById(R.id.soundsseven); sevenbutton.setOnClickListener(new OnClickListener() { public void onClick(View v) { Intent i = new Intent(main.this, series7button.class); startActivity(i); overridePendingTransition(R.anim.push_up_in, R.anim.push_up_out); } }); Button eightbutton = (Button)findViewById(R.id.soundseight); eightbutton.setOnClickListener(new OnClickListener() { public void onClick(View v) { Intent i = new Intent(main.this, series8button.class); startActivity(i); overridePendingTransition(R.anim.push_up_in, R.anim.push_up_out); } }); } } Then Dragablespace.java package com.matthieu.launcher; import android.content.Context; import android.app.Activity; import android.util.Log; import android.content.res.TypedArray; import android.util.AttributeSet; import android.view.MotionEvent; import android.view.VelocityTracker; import android.view.View; import android.view.ViewGroup; import android.view.ViewConfiguration; import android.widget.Scroller; public class DragableSpace extends ViewGroup { private Scroller mScroller; private VelocityTracker mVelocityTracker; private int mScrollX = 0; private int mCurrentScreen = 0; private float mLastMotionX; private static final String LOG_TAG = "DragableSpace"; private static final int SNAP_VELOCITY = 1000; private final static int TOUCH_STATE_REST = 0; private final static int TOUCH_STATE_SCROLLING = 1; private int mTouchState = TOUCH_STATE_REST; private int mTouchSlop = 0; public DragableSpace(Context context) { super(context); mScroller = new Scroller(context); mTouchSlop = ViewConfiguration.get(getContext()).getScaledTouchSlop(); this.setLayoutParams(new ViewGroup.LayoutParams( ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.FILL_PARENT)); } public DragableSpace(Context context, AttributeSet attrs) { super(context, attrs); mScroller = new Scroller(context); mTouchSlop = ViewConfiguration.get(getContext()).getScaledTouchSlop(); this.setLayoutParams(new ViewGroup.LayoutParams( ViewGroup.LayoutParams.WRAP_CONTENT , ViewGroup.LayoutParams.FILL_PARENT)); TypedArray a=getContext().obtainStyledAttributes(attrs,R.styleable.DragableSpace); mCurrentScreen = a.getInteger(R.styleable.DragableSpace_default_screen, 0); } @Override public boolean onInterceptTouchEvent(MotionEvent ev) { /* * This method JUST determines whether we want to intercept the motion. * If we return true, onTouchEvent will be called and we do the actual * scrolling there. */ /* * Shortcut the most recurring case: the user is in the dragging state * and he is moving his finger. We want to intercept this motion. */ final int action = ev.getAction(); if ((action == MotionEvent.ACTION_MOVE) && (mTouchState != TOUCH_STATE_REST)) { return true; } final float x = ev.getX(); switch (action) { case MotionEvent.ACTION_MOVE: /* * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check * whether the user has moved far enough from his original down touch. */ /* * Locally do absolute value. mLastMotionX is set to the y value * of the down event. */ final int xDiff = (int) Math.abs(x - mLastMotionX); boolean xMoved = xDiff > mTouchSlop; if (xMoved) { // Scroll if the user moved far enough along the X axis mTouchState = TOUCH_STATE_SCROLLING; } break; case MotionEvent.ACTION_DOWN: // Remember location of down touch mLastMotionX = x; /* * If being flinged and user touches the screen, initiate drag; * otherwise don't. mScroller.isFinished should be false when * being flinged. */ mTouchState = mScroller.isFinished() ? TOUCH_STATE_REST : TOUCH_STATE_SCROLLING; break; case MotionEvent.ACTION_CANCEL: case MotionEvent.ACTION_UP: // Release the drag mTouchState = TOUCH_STATE_REST; break; } /* * The only time we want to intercept motion events is if we are in the * drag mode. */ return mTouchState != TOUCH_STATE_REST; } @Override public boolean onTouchEvent(MotionEvent event) { if (mVelocityTracker == null) { mVelocityTracker = VelocityTracker.obtain(); } mVelocityTracker.addMovement(event); final int action = event.getAction(); final float x = event.getX(); switch (action) { case MotionEvent.ACTION_DOWN: Log.i(LOG_TAG, "event : down"); /* * If being flinged and user touches, stop the fling. isFinished * will be false if being flinged. */ if (!mScroller.isFinished()) { mScroller.abortAnimation(); } // Remember where the motion event started mLastMotionX = x; break; case MotionEvent.ACTION_MOVE: // Log.i(LOG_TAG,"event : move"); // if (mTouchState == TOUCH_STATE_SCROLLING) { // Scroll to follow the motion event final int deltaX = (int) (mLastMotionX - x); mLastMotionX = x; //Log.i(LOG_TAG, "event : move, deltaX " + deltaX + ", mScrollX " + mScrollX); if (deltaX 0) { scrollBy(Math.max(-mScrollX, deltaX), 0); } } else if (deltaX > 0) { final int availableToScroll = getChildAt(getChildCount() - 1) .getRight() - mScrollX - getWidth(); if (availableToScroll > 0) { scrollBy(Math.min(availableToScroll, deltaX), 0); } } // } break; case MotionEvent.ACTION_UP: Log.i(LOG_TAG, "event : up"); // if (mTouchState == TOUCH_STATE_SCROLLING) { final VelocityTracker velocityTracker = mVelocityTracker; velocityTracker.computeCurrentVelocity(1000); int velocityX = (int) velocityTracker.getXVelocity(); if (velocityX > SNAP_VELOCITY && mCurrentScreen > 0) { // Fling hard enough to move left snapToScreen(mCurrentScreen - 1); } else if (velocityX Then my main.xml layout I also have 3 other layout files called initial, left and right(_screen)
