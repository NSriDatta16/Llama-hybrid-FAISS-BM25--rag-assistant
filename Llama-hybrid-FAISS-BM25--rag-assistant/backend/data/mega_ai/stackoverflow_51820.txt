[site]: stackoverflow
[post_id]: 51820
[parent_id]: 51684
[tags]: 
What you want to get its the instant CPU usage (kind of)... Actually, the instant CPU usage for a process does not exists. Instead you have to make two measurements and calculate the average CPU usage, the formula is quite simple: AvgCpuUsed = [TotalCPUTime(process,time2) - TotalCPUTime(process,time1)] / [time2-time1] The lower Time2 and Time1 difference is, the more "instant" your measurement will be. Windows Task Manager calculate the CPU use with an interval of one second. I've found that is more than enough and you might even consider doing it in 5 seconds intervals cause the act of measuring itself takes up CPU cycles... So, first, to get the average CPU time using System.Diagnostics; float GetAverageCPULoad(int procID, DateTme from, DateTime, to) { // For the current process //Process proc = Process.GetCurrentProcess(); // Or for any other process given its id Process proc = Process.GetProcessById(procID); System.TimeSpan lifeInterval = (to - from); // Get the CPU use float CPULoad = (proc.TotalProcessorTime.TotalMilliseconds / lifeInterval.TotalMilliseconds) * 100; // You need to take the number of present cores into account return CPULoad / System.Environment.ProcessorCount; } now, for the "instant" CPU load you'll need an specialized class: class ProcLoad { // Last time you checked for a process public Dictionary lastCheckedDict = new Dictionary (); public float GetCPULoad(int procID) { if (lastCheckedDict.ContainsKey(procID)) { DateTime last = lastCheckedDict[procID]; lastCheckedDict[procID] = DateTime.Now; return GetAverageCPULoad(procID, last, lastCheckedDict[procID]); } else { lastCheckedDict.Add(procID, DateTime.Now); return 0; } } } You should call that class from a timer (or whatever interval method you like) for each process you want to monitor , if you want all the processes just use the Process.GetProcesses static method
