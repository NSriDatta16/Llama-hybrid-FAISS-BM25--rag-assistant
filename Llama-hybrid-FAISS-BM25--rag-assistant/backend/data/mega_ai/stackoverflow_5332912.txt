[site]: stackoverflow
[post_id]: 5332912
[parent_id]: 5332569
[tags]: 
I suspect that the reason that you are not seeing any speedup is that your application is only using 1 physical processor. If it is only using one processor, then the two threads won't be running in parallel. Instead, the processor will be "time-slicing" between the two threads. What can you do about this? Run on a dual-core etc processor. Or if you have a single processor machine with HT support, enable HT. Run the test over a longer time; e.g. a number of minutes. The reason I suggest the latter is that this could be a JVM warmup effect. When a JVM starts a new application, it needs to do a lot of class loading and JIT compilation behind the scenes. These tasks will be largely (if not totally) single-threaded. Running the tests over a longer period of time reduces the contribution of the "warm up" overheads to the average time per "game". There is a fix that you ought to make to make the program thread-safe. Change public static int gamesPlayed = 0; to private static final AtomicInteger gamesPlayed = new AtomicInteger(); and then use getAndIncrement() to increment the counter and intValue() to fetch its value. (This is simpler than having each thread maintain its own counter and summing them at the end.) However, I strongly suspect that this change (or @Erik's alternative) will make little difference to the results you are seeing. I'm now sure it is either: JVM warmup issue as described above, a consequence of high object creation rates and/or heap starvation, or some hidden synchronization issue between the instances of your game.
