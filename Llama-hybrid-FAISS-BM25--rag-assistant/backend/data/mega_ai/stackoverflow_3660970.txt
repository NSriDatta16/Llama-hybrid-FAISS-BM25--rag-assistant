[site]: stackoverflow
[post_id]: 3660970
[parent_id]: 3660923
[tags]: 
Is there a way round this using Interfaces or Inheritance? Yes. Interfaces: make an interface IEat or IPet or whatever concept you want to represent. Make the interface have an Eat method. Have Cat and Dog implement this interface. Have the Pet property be of that type. Inheritance: Make an abstract base class Animal or Pet or whatever concept you want to represent. Make an abstract method Eat on the base class. Have Cat and Dog inherit from this base class. Have the Pet property be of that type. What is the difference between these two? Use interfaces to model the idea "X knows how to do Y". IDisposable, for example, means "I know how to dispose of the important resource that I am holding onto". That is not a fact about what the object is , it is a fact about what the object does . Use inheritance to model the idea of "X is a kind of Y". A Dog is a kind of Animal. The thing about interfaces is you can have as many of them as you want. But you only get to inherit directly from one base class, so you have to make sure you get it right if you're going to use inheritance. The problem with inheritance is that people end up making base classes like "Vehicle" and then they say "a MilitaryVehicle is a kind of Vehicle" and "A Ship is a kind of Vehicle" and now you're stuck: what is the base class of Destroyer? It is both a Ship and a MilitaryVehicle and it can't be both . Choose your "inheritance pivot" extremely carefully . Is there a way I can set Pet to be of type Object but still access the properties of whichever animal class is assigned to it? Yes, in C# 4 there is, but do not do so . Use interfaces or inheritance. In C# 4 you can use "dynamic" to get dynamic dispatch at runtime to the Eat method on the object that is in Pet. The reason you don't want to do this is because this will crash and die horribly should someone put a Fruit or a Handsaw in the Pet property and then try to make it Eat. The point of compile-time checks is to decrease program fragility. If you have a way to make more compile-time checks, use it.
