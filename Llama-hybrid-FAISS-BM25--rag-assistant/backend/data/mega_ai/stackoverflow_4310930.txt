[site]: stackoverflow
[post_id]: 4310930
[parent_id]: 
[tags]: 
PHP: Standards of class constructors preventing instantiation

Just a question on standards. I've created a wrapper class for PHP session management, that helps automatically organize session data based on certain internal modules accessing it. It's designed as a singleton, using a getInstance() method to instantiate, since there will only be a single session at a given time. Also, this came as a benefit to me, as I am able to prevent instantiation of the session object in the (albeit probably limited) chance that session_start() fails. As for an example: public static function getInstance(){ if(!self::$_instance || !session_id()){ if(session_start()){ self::$_instance = new self(session_id()); }else{ return; } } return self::$_instance; } My question is; although the use of a gateway getInstance() method works naturally here for a few reasons, is it common/good practice to implement public static getInstance() or create() methods in classes to control object creation if the object is reliant on external conditions? I just find myself sticking to a convention of providing getInstance() in the case of singletons, and create() in the case of multiple instance objects. TL;DR: I keep using getInstance() and create() methods to control all object instantiation. Am I doing it wrong? EDIT: Refining my question a bit; Aside from using getInstance() for singletons, is my constructor wrapping with create() methods serving less purpose and more leaning towards bad convention? Should I be throwing Exceptions from the true constructor, or continue returning false from a create() ?
