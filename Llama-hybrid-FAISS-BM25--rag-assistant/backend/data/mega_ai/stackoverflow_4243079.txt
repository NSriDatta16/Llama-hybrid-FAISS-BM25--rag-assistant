[site]: stackoverflow
[post_id]: 4243079
[parent_id]: 4243042
[tags]: 
See this it's in c++ and can be done in c# in a same way. for convex polygon is too easy: If the polygon is convex then one can consider the polygon as a "path" from the first vertex. A point is on the interior of this polygons if it is always on the same side of all the line segments making up the path. Given a line segment between P0 (x0,y0) and P1 (x1,y1), another point P (x,y) has the following relationship to the line segment. Compute (y - y0) (x1 - x0) - (x - x0) (y1 - y0) if it is less than 0 then P is to the right of the line segment, if greater than 0 it is to the left, if equal to 0 then it lies on the line segment. Here is its code in c#, I didn't check edge cases. public static bool IsInPolygon(Point[] poly, Point point) { var coef = poly.Skip(1).Select((p, i) => (point.Y - poly[i].Y)*(p.X - poly[i].X) - (point.X - poly[i].X) * (p.Y - poly[i].Y)) .ToList(); if (coef.Any(p => p == 0)) return true; for (int i = 1; i I test it with simple rectangle works fine: Point[] pts = new Point[] { new Point { X = 1, Y = 1 }, new Point { X = 1, Y = 3 }, new Point { X = 3, Y = 3 }, new Point { X = 3, Y = 1 } }; IsInPolygon(pts, new Point { X = 2, Y = 2 }); ==> true IsInPolygon(pts, new Point { X = 1, Y = 2 }); ==> true IsInPolygon(pts, new Point { X = 0, Y = 2 }); ==> false Explanation on the linq query: poly.Skip(1) ==> creates a new list started from position 1 of the poly list and then by (point.Y - poly[i].Y)*(p.X - poly[i].X) - (point.X - poly[i].X) * (p.Y - poly[i].Y) we'll going to calculate the direction (which mentioned in referenced paragraph). similar example (with another operation): lst = 2,4,8,12,7,19 lst.Skip(1) ==> 4,8,12,7,19 lst.Skip(1).Select((p,i)=>p-lst[i]) ==> 2,4,4,-5,12
