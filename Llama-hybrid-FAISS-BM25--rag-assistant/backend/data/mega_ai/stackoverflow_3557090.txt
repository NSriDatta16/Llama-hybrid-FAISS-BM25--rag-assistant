[site]: stackoverflow
[post_id]: 3557090
[parent_id]: 661561
[tags]: 
Because of the triviality of the scenario I would actually have the UI thread poll for the status. I think you will find that it can be quite elegant. public class MyForm : Form { private volatile string m_Text = ""; private System.Timers.Timer m_Timer; private MyForm() { m_Timer = new System.Timers.Timer(); m_Timer.SynchronizingObject = this; m_Timer.Interval = 1000; m_Timer.Elapsed += (s, a) => { MyProgressLabel.Text = m_Text; }; m_Timer.Start(); var thread = new Thread(WorkerThread); thread.Start(); } private void WorkerThread() { while (...) { // Periodically publish progress information. m_Text = "Still working..."; } } } The approach avoids the marshaling operation required when using the ISynchronizeInvoke.Invoke and ISynchronizeInvoke.BeginInvoke methods. There is nothing wrong with using the marshaling technique, but there are a couple of caveats you need to be aware of. Make sure you do not call BeginInvoke too frequently or it could overrun the message pump. Calling Invoke on the worker thread is a blocking call. It will temporarily halt the work being done in that thread. The strategy I propose in this answer reverses the communication roles of the threads. Instead of the worker thread pushing the data the UI thread polls for it. This a common pattern used in many scenarios. Since all you are wanting to do is display progress information from the worker thread then I think you will find that this solution is a great alternative to the marshaling solution. It has the following advantages. The UI and worker threads remain loosely coupled as opposed to the Control.Invoke or Control.BeginInvoke approach which tightly couples them. The UI thread will not impede the progress of the worker thread. The worker thread cannot dominate the time the UI thread spends updating. The intervals at which the UI and worker threads perform operations can remain independent. The worker thread cannot overrun the UI thread's message pump. The UI thread gets to dictate when and how often the UI gets updated.
