[site]: stackoverflow
[post_id]: 4684501
[parent_id]: 4635334
[tags]: 
I found that there was a fairly nice tutorial written online about this topic. I don't quite remember where on google I found it but let me see if I can break the function down well enough myself as it is right in front of me... First the function, it can create a key length of any size. I took the liberty of commenting it fairly heavily... function pbkdf2($password,$salt,$iter_count = 1500,$key_length = 32,$algorithm = 'sha512') { /* @param string password -- password to be encrypted @param string salt -- salt to encrypt with @param int iter_count -- number of times to iterate blocks @param key_length -- length of key to return @param $algorithm -- algorithm to use in hashing @return string key */ //determine the length of the hahs $hash_length = strlen(hash($algorithm,NULL,TRUE)); //determine the number of key blocks to compute $key_blocks = ceil($key_length/$hash_length); //initialize key $key = ''; //create the key itself //create blocks for($block_count = 1;$block_count First thing it does is figure out the length of the hash. Next it determines how many key blocks are required for the key length specified Then it initializes the hash (key) to return sets up the for loop that will create each block takes the initial hash of the block with the block counter in binary appended to the salt begins the loop to iterate the block $iter_count times (create a hash of itself) XOR each iterate and append it to $iterated_block (xor previous hash to current) XOR loop finishes append $iterated_block to $key for each block block loop finishes return the key I feel this is probably the best way to do this. Maybe I am too paranoid?
