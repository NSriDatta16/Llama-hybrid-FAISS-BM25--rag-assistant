[site]: stackoverflow
[post_id]: 1949123
[parent_id]: 1948573
[tags]: 
Singletons are appropriate for this scenario, BUT you have to make sure you're doing the singleton right. So, for example, what Bozhno suggests is not a singleton, it's an ugly concoction of nasty statics that's not mockable, not easily testable, not injectable, and generally comes back to bite you in the ass. An acceptable singleton is just your average class with one notable exception that it is guaranteed either by itself or by some external factory/framework (e.g Spring IoC) to exist in only one instance. If you go with the first approach, you do something like private MyUberSingletonClass() { //..do your constructor stuff, note it's private } private static MyUberSingletonClass instance = null; public static synchronized MyUberSingletonClass instance() { if (instance == null) { instance = new MyUberSingletonClass(); } return instance; } public String getUberUsefulStuff(){ return "42"; } That's acceptable if you don't really feel the need for a factory otherwise, and aren't using any IoC container in your app (good idea to think about using one though). Note the difference from Bozhno's example: this is a good vanilla class where the only static is an instance var and a method to return it. Also note the synchronized keyword required for lazy-initialization. update: Pascal recommends this very cool post about a better way to lazy-init singletons in the comments below: http://crazybob.org/2007/01/lazy-loading-singletons.html
