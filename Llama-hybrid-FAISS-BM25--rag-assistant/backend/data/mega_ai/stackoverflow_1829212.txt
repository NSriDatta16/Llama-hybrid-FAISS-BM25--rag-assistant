[site]: stackoverflow
[post_id]: 1829212
[parent_id]: 3150
[tags]: 
Here is the approach I use to test the IIS URL Rewrite module at Microsoft (it is command-line based, but should work for VS too): Make sure your header files are consumable by moving source code to cpp files and using forward declaration if needed. Compile your code to test as library (.lib) Create your UnitTest project as C++ with CLR support. Include your header files. Include your .lib files. Add a reference to Microsoft.VisualStudio.QualityTools.UnitTestFramework.dll Use a really small class for declaring your unit test and jump from managed to C++/Native code like this (may have typos): Here is an example: // Example #include "stdafx.h" #include "mstest.h" // Following code is native code. #pragma unmanaged void AddTwoNumbersTest() { // Arrange Adder yourNativeObject; int expected = 3; int actual; // Act actual = yourNativeObject.Add(1, 2); // Assert Assert::AreEqual(expected, actual, L"1 + 2 != 3"); } // Following code is C++/CLI (Managed) #pragma managed using namespace Microsoft::VisualStudio::TestTools::UnitTesting; [TestClass] public ref class TestShim { public: [TestMethod] void AddTwoNumbersTest() { // Just jump to C++ native code (above) ::AddTwoNumbersTest(); } }; With this approach, people don't have to learn too much C++/CLI stuff, all the real test will be done in C++ native and the TestShim class will be used to 'publish' the test to MSTest.exe (or make it visible). For adding new tests you just declare a new [TestMethod] void NewTest(){::NewTest();} method and a new void NewTest() native function. No macros, no tricks, straighforward. Now, the heade file is optionally, but it can be used to expose the Assert class' methods with C++ native signatures (e.g. wchar_t* instead of Stirng^), so it can you can keep it close to C++ and far from C++/CLI: Here is an example: // Example #pragma once #pragma managed(push, on) using namespace System; class Assert { public: static void AreEqual(int expected, int actual) { Microsoft::VisualStudio::TestTools::UnitTesting::Assert::AreEqual(expected, actual); } static void AreEqual(int expected, int actual, PCWSTR pszMessage) { Microsoft::VisualStudio::TestTools::UnitTesting::Assert::AreEqual(expected, actual, gcnew String(pszMe ssage)); } template static void AreEqual(T expected, T actual) { Microsoft::VisualStudio::TestTools::UnitTesting::Assert::AreEqual(expected, actual); } // Etcetera, other overloads... } #pragma managed(pop) HTH
