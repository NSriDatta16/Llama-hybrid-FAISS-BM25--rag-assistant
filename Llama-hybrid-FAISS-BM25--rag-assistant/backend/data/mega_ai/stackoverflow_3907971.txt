[site]: stackoverflow
[post_id]: 3907971
[parent_id]: 
[tags]: 
Linq-to-SQL: Use a shared transaction between LinqDataSource and DataContext?

I have a page where I use two ASP DetailsView controls to render data from two different, but related, LinqDataSource objects. My primary table is represented in the first DetailsView/LinqDataSource set, and I use the LinqDataSource's built-in update functionality to persist changes when the DetailsView is in edit mode. The primary table here represents a "Contact" entity (i.e. a person or organization and their contact info). The second DetailsView renders data from a cross-reference table that associates a Contact with one or more "tags". The tag definitions come from another table, so the cross reference table just associates a Contact ID with a Tag ID; standard many-to-many type scenario. I have updates to the Tag Xref working properly; when tags are added or removed from a contact, the appropriate rows are inserted or deleted from the Xref table. This is accomplished not via the LinqDataSource, but by handling the ItemUpdating event for the tags DetailsView and using a DataContext to manually process the inserts and deletes. So the Contact and the Contact's tags can be updated individually. Trouble is, I need updates to Contact and to the Tags Xref to happen together in a single transaction. I have the two DetailsView controls linked so that when the user clicks "Update" for the first control, it triggers an update on the second. But the first DetailsView uses its bound LinqDataSource to do the update, which has its own DataContext. Attempts to "share" the DataContext between my manual update and the LinqDataSource result in ObjectDisposed exceptions. I feel I'm missing something obvious. Sharing DataContext objects seems like a slippery slope. Is there a way I can run a transaction on the page that would enclose both operations?
