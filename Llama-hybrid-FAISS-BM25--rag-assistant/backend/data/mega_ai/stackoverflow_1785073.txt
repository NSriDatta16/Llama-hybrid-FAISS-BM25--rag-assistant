[site]: stackoverflow
[post_id]: 1785073
[parent_id]: 1784966
[tags]: 
Here's another option: let foo = let rec helper sum ct getCt = function | x::xs -> helper (sum+x) (ct+1) (fun avg -> getCt(avg) + (if avg getCt(sum/ct) helper 0 0 (fun avg -> 0) To help clarify what's going on here, I'll describe the parameters for the helper function: sum: the sum of all items seen so far ct: the count of all items seen so far getCt: a function taking a single parameter and which returns the tally of the number of items seen so far which are at least as large as that parameter the final list parameter which is pattern matched if it's empty, then calculate the average of all items by dividing the total by the count, and then pass this to the getCt function to determine how many items were greater than it. otherwise, recurse into the tail of the list, passing in an updated total and count. The new getCt function should call the previous getCt function to see how many items prior to this one are greater than the average, and then increment that total if this item was also greater. It's also possible to create a modified version that uses only tail calls, so it won't cause a stack overflow even on lists of arbitrary size. To do this, our getCt function now needs an accumulator parameter representing the count so far: let foo = let rec helper sum ct getCt = function | x::xs -> helper (sum+x) (ct+1) (fun avg n -> getCt avg (if avg getCt (sum/ct) 0 helper 0 0 (fun avg n -> n)
