[site]: stackoverflow
[post_id]: 619893
[parent_id]: 619857
[tags]: 
You didn't specify if you're using .NET 2.0, but I'll make that assumption. C# 3.0 sample code is listed below: using (var tx = new TransactionScope()) { // Execute multiple DB statements inside here ts.Complete(); } If any of the DB statements fail, the ts.complete will never be reached and the transaction will be rolled back automatically at the end of the using statement. However, one caveat to this approach is that you'll end up leveraging the DTC if you use multiple connections, which means slower performance. Edited to change SqlTransaction to TransactionScope An example of forcing a single SQL connection to avoid using the DTC: using (var tx = new TransactionScope()) using (var db = new SqlConnection(connString)) { // Command 1 using (var cmd = db.CreateCommand()) { cmd.CommandText = "select..."; using (var reader = cmd.ExecuteReader()) { // Process results or store them somewhere for later } } // Command 2 using (var cmd = db.CreateCommand()) { cmd.CommandText = "select..."; using (var reader = cmd.ExecuteReader()) { // Process results or store them somewhere for later } } // Command 3 using (var cmd = db.CreateCommand()) { cmd.CommandText = "select..."; using (var reader = cmd.ExecuteReader()) { // Process results or store them somewhere for later } } tx.Complete(); }
