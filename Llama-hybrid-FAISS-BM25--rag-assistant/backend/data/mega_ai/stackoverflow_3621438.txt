[site]: stackoverflow
[post_id]: 3621438
[parent_id]: 3621390
[tags]: 
1) The constant expression for your byte is of type int , with an implicit conversion as specified in section 6.1.9 of the C# 4 spec: A constant-expression (ยง7.19) of type int can be converted to type sbyte, byte, short, ushort, uint, or ulong, provided the value of the constant-expression is within the range of the destination type. Clearly the constant expression isn't within the range of the destination type here. For the integer value, I believe it's not performing promotion to long and then trying to perform a narrowing conversion to int - it's performing the arithmetic with int overflow, as per section 7.19: The compile-time evaluation of constant expressions uses the same rules as run-time evaluation of non-constant expressions, except that where run-time evaluation would have thrown an exception, compile-time evaluation causes a compile-time error to occur. In other words, the constant expression is using +(int, int) as both operands are integers... that's not complaining in an unchecked context, because the overflow wouldn't happen at execution time either. 2) No, checked and unchecked make a difference at compile time too. From section 7.19: Unless a constant expression is explicitly placed in an unchecked context, overflows that occur in integral-type arithmetic operations and conversions during the compile-time evaluation of the expression always cause compile-time errors (ยง7.19). (For the sake of interest, I'd like to point out that the Microsoft C# compiler doesn't quite comply with the rules of the middle quoted paragraph anyway... there are some decimal operations where the results of performing the arithmetic at compile-time are different than the same operations performed at execution time, IIRC. Just a bit of trivia. It'll be interesting to see whether the compiler-as-a-service version (i.e. managed code) behaves the same way here.)
