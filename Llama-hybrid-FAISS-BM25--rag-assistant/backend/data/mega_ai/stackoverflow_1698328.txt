[site]: stackoverflow
[post_id]: 1698328
[parent_id]: 1698010
[tags]: 
Asking the proper question is at least half of the way to getting a good answer. You should really state what you want to achieve rather than the particular problem you are facing. It seems to me as if you have more problems with the language than you actually realize. The first part is that it seems as if you have a component hierarchy that derives from Component, probably providing a common interface. An entity holds many components internally, that can be of any derived type from Component. If that is the case, you should rework your containers as you are storing Component objects directly, and that will produce slicing in your objects (no matter what derived type you enter into the container, the container will only keep the common Component part of the object). Working on a couple of vectors and hoping that both of them will be synchronized at all times is feasible but fragile. If the name and the component go together, then you want to store pairs of name/component. If you want to search by name, you should use a map as it will provide O(log N) search directly. Now, going back to the question. If what you want to achieve is plain syntactic sugar (avoid the caller from explicitly dynamic casting if needed) then you can get it with a template (more later on). But you should really think on your design. Does Component define the real interface into any component? If users need to downcast to particular types before using a Component, either the abstraction is bad (Component does not provide a real interface) or the objects do not really fit together. If at the end of it you still want to do it, you can hide the dynamic cast from the caller by doing it within a template method (or free function). class Entity { typedef std::map > component_map_t; public: boost::shared_ptr getComponent( std::string const & name ) { component_map_t::iterator it = components_.find(name); if ( it == components_.end() ) { // not found, handle error // ... } return it->second; } template // syntactic sugar boost::shared_ptr getComponent( std::string const & name ) { return boost::dynamic_pointer_cast ( getComponent(name) ); } private: component_map_t components_; }; template // syntactic sugar also available as free function boost::shared_ptr getComponent( Entity & entity, std::string const & name ) { return boost::dynamic_pointer_cast ( entity.getComponent(name) ); } int main() { // usage Entity e; // ... work with it add components... boost::shared_ptr c1 = e.getComponent( "one" ); // non-templated method returns Component boost::shared_ptr c2 = e.getComponent ( "two" ); boost::shared_ptr c3 = getComponent ( e, "two" ); } You could play with the interface so that instead of boost::shared_ptr you return real references (with what it entails: lifetime must be carefully controlled so that user code does not try to use a dangling reference if the component is removed from the entity).
