[site]: stackoverflow
[post_id]: 3802660
[parent_id]: 3802482
[tags]: 
I've thought about somehow caching the result of someExpensiveMethod , but that seems wasteful, given that objects tend to come in, be processed and then discarded. I don't see how that is wasteful. This is basically how caches work. You compare the objects that come in against the ones that you've recently processed, and when you get a "hit" you avoid the expense of calling someExpensiveMethod . Whether caching actually works for your application will depend on a number of factors like: the number of object / result pairs that you can keep in your cache, the probability of a "hit", the average cost of performing a cache probe (in the "hit" and "miss" cases), the average cost of calling someExpensiveMethod the direct costs of maintaining the cache; e.g. if you use LRU or some other strategy to get rid of cache entries that not helping, and the indirect cost of maintaining the cache. (The last point is hard to predict / measure, but it includes the extra memory needed to represent the cache structures, work that the GC has to do to deal with the fact that the cache and its contents are "reachable", and the GC overheads associated with weak references ... assuming that you use them.) Ultimately, the success (or otherwise) of a caching solution is judged in terms of the system's average behavior for realistic workloads. The fact that some cached results are never used again is not really relevant. It also seems clunky - methods need to know about a cache, or I need to cache results in someExpensiveMethod . Again, IMO it not "clunky" either way. This is the way that you implement caching. Even short term cache could be bad news, since literally millions of objects get processed every day. Again, I don't see the logic of your argument. If millions of objects are processed a day and you keep (say) the last 5 minutes worth, that just tens of thousands of objects to cache. That is hardly "bad news". If you really are processing "literally millions" of objects a day, then: someExpensiveMethod cannot be be that expensive ... unless you have either a highly effective caching and lots of memory, or a large number of processors, or both , your concerns about elegance (unclunkiness) and avoiding coupling must be secondary to the issue of designing the application so that it can keep up, and you'll probably need to run on a multiprocessor, and you will therefore need to deal with the fact that a cache can be a concurrency bottleneck.
