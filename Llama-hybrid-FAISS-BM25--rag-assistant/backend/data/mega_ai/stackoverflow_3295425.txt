[site]: stackoverflow
[post_id]: 3295425
[parent_id]: 3295283
[tags]: 
The following fails for my in Dev Studio: #include "stdafx.h" #include #include template std::vector > transform(std::vector > const &vec, std::vector > > > const &m, T z = T(0), T w = T(1)); template std::vector > transform(std::vector > const &vec, std::vector > > > const &m, T z, T w) { std::cout > xi; std::vector > > > mi; transform(xi,mi); std::vector > xf; std::vector > > > mf; transform(xf,mf); std::vector > xd; std::vector > > > md; transform(xd,md); } Output: Z0 W1 Z0 W1.4013e-045 Z2.122e-314 W3.60689e-305 So I suppose it does not work as expected!!! If you remove the pre-declaration and put the default arguments in the template function then it works as expected. #include "stdafx.h" #include #include template std::vector > transform(std::vector > const &vec, std::vector > > > const &m T z = T(0), T w = T(1)) { std::cout > xi; std::vector > > > mi; transform(xi,mi); std::vector > xf; std::vector > > > mf; transform(xf,mf); std::vector > xd; std::vector > > > md; transform(xd,md); } This works as expected. This has something to do with the template pre-declaration not actually being a function pre-declaration and thus it does not actually have default parameters and as such you are getting random values in the parameter list. OK. Not from my reading of the standard this should work as expected: Using n2521 Section 14.7.1 Implicit instantiation Paragraph 9 An implementation shall not implicitly instantiate a function template, a member template, a non-virtual member func- tion, a member class or a static data member of a class template that does not require instantiation. It is unspecified whether or not an implementation implicitly instantiates a virtual member function of a class template if the virtual member function would not otherwise be instantiated. The use of a template specialization in a default argument shall not cause the template to be implicitly instantiated except that a class template may be instantiated where its complete type is needed to determine the correctness of the default argument. The use of a default argument in a function call causes specializations in the default argument to be implicitly instantiated. The bold part of the paragraph seems (to me) to indicate that each specialization created because of default arguments will be implicitly instantiated into the translation unit when used. Paragraph 11: If a function template f is called in a way that requires a default argument expression to be used, the dependent names are looked up, the semantics constraints are checked, and the instantiation of any template used in the default argument expression is done as if the default argument expression had been an expression used in a function template specialization with the same scope, the same template parameters and the same access as that of the function template f used at that point. This analysis is called default argument instantiation. The instantiated default argument is then used as the argument of f. Indicates that even if the default arguments are template parameters they will be correctly instantiated. Well I hope I interpreted that correctly. :-)
