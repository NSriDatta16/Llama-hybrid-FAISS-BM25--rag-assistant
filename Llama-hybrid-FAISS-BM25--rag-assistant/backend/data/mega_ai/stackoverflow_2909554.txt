[site]: stackoverflow
[post_id]: 2909554
[parent_id]: 2909106
[tags]: 
I can try to answer the second part of your question. The collisions will probably result not from the hash code itself, but from mapping the hash code to an index in a collection. So for example your hash function could return random values from 1 to 10000, but if your hash table only has 32 entries you'll get collisions on insertion. In addition, I would think that collisions would be resolved by the collection internally, and there are many methods to resolve collisions. The simplest (and worst) is, given an entry to insert at index i, add 1 to i until you find an empty spot and insert there. Retrieval then works the same way. This results in inefficient retrievals for some entries, as you could have an entry that requires traversing the entire collection to find! Other collision resolution methods reduce the retrieval time by moving entries in the hash table when an item is inserted to spread things out. This increases the insertion time but assumes you read more than you insert. There are also methods that try and branch different colliding entries out so that entries to cluster in one particular spot. Also, if you need to resize the collection you will need to rehash everything or use a dynamic hashing method. In short, depending on what you're using the hash code for you may have to implement your own collision resolution method. If you're not storing them in a collection, you can probably get away with a hash function that just generates hash codes in a very large range. If so, you can make sure your container is bigger than it needs to be (the bigger the better of course) depending on your memory concerns. Here are some links if you're interested more: coalesced hashing on wikipedia Wikipedia also has a summary of various collision resolution methods: Also, " File Organization And Processing " by Tharp covers alot of collision resolution methods extensively. IMO it's a great reference for hashing algorithms.
