[site]: stackoverflow
[post_id]: 4445576
[parent_id]: 4417545
[tags]: 
Imagine that the overlay is cloud cover - or in our case, cellular signal coverage. It might not "look good" while zoomed in deep, but the overlay is still conveying essential information to the user. I've worked around the problem by adding an OverZoom mode to enhance Apple's TileMap sample code. Here is the new tilesInMapRect function in TileOverlay.m: - (NSArray *)tilesInMapRect:(MKMapRect)rect zoomScale:(MKZoomScale)scale { NSInteger z = zoomScaleToZoomLevel(scale); // OverZoom Mode - Detect when we are zoomed beyond the tile set. NSInteger overZoom = 1; NSInteger zoomCap = MAX_ZOOM; // A constant set to the max tile set depth. if (z > zoomCap) { // overZoom progression: 1, 2, 4, 8, etc... overZoom = pow(2, (z - zoomCap)); z = zoomCap; } // When we are zoomed in beyond the tile set, use the tiles // from the maximum z-depth, but render them larger. NSInteger adjustedTileSize = overZoom * TILE_SIZE; // Number of tiles wide or high (but not wide * high) NSInteger tilesAtZ = pow(2, z); NSInteger minX = floor((MKMapRectGetMinX(rect) * scale) / adjustedTileSize); NSInteger maxX = floor((MKMapRectGetMaxX(rect) * scale) / adjustedTileSize); NSInteger minY = floor((MKMapRectGetMinY(rect) * scale) / adjustedTileSize); NSInteger maxY = floor((MKMapRectGetMaxY(rect) * scale) / adjustedTileSize); NSMutableArray *tiles = nil; for (NSInteger x = minX; x And here is the new drawMapRect in TileOverlayView.m: - (void)drawMapRect:(MKMapRect)mapRect zoomScale:(MKZoomScale)zoomScale inContext:(CGContextRef)context { // OverZoom Mode - Detect when we are zoomed beyond the tile set. NSInteger z = zoomScaleToZoomLevel(zoomScale); NSInteger overZoom = 1; NSInteger zoomCap = MAX_ZOOM; if (z > zoomCap) { // overZoom progression: 1, 2, 4, 8, etc... overZoom = pow(2, (z - zoomCap)); } TileOverlay *tileOverlay = (TileOverlay *)self.overlay; // Get the list of tile images from the model object for this mapRect. The // list may be 1 or more images (but not 0 because canDrawMapRect would have // returned NO in that case). NSArray *tilesInRect = [tileOverlay tilesInMapRect:mapRect zoomScale:zoomScale]; CGContextSetAlpha(context, tileAlpha); for (ImageTile *tile in tilesInRect) { // For each image tile, draw it in its corresponding MKMapRect frame CGRect rect = [self rectForMapRect:tile.frame]; UIImage *image = [[UIImage alloc] initWithContentsOfFile:tile.imagePath]; CGContextSaveGState(context); CGContextTranslateCTM(context, CGRectGetMinX(rect), CGRectGetMinY(rect)); // OverZoom mode - 1 when using tiles as is, 2, 4, 8 etc when overzoomed. CGContextScaleCTM(context, overZoom/zoomScale, overZoom/zoomScale); CGContextTranslateCTM(context, 0, image.size.height); CGContextScaleCTM(context, 1, -1); CGContextDrawImage(context, CGRectMake(0, 0, image.size.width, image.size.height), [image CGImage]); CGContextRestoreGState(context); // Added release here because "Analyze" was reporting a potential leak. Bug in Apple's sample code? [image release]; } } Seems to be working great now. BTW - I think the TileMap sample code is missing an [image release] and was leaking memory. Note where I added it in the code above. I hope that this helps some others with the same problem. Cheers, Chris
