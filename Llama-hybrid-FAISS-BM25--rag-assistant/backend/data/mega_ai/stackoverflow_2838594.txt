[site]: stackoverflow
[post_id]: 2838594
[parent_id]: 2831571
[tags]: 
Since in another question by the OP I proposed a different data structure for the playing grid -- namely a vector of vectors -- I'm tempted to show how I'd go about solving this problem with that representation. For the purposes of this problem, it seems easiest to me to use 0 and 1 to represent grid cell states. Adapting the code for the case of a more complex grid cell structure (possibly a map holding the number or a Boolean somewhere inside) would present no problem. This is the function being discussed: (defn check-position-valid [field-grid block] (let [grid-rect (subgrid field-grid @(block :x) (-> block :grid :width) @(block :y) (-> block :grid :height)) block-rect (-> block :grid :data)] (and grid-rect (not-any? pos? (mapcat #(map (comp dec +) %1 %2) grid-rect block-rect))))) I removed the grid struct map; instead, all grids are simple vectors of vectors. Note that holding explicit :width and :height keys may not necessarily be much help performance-wise, as Clojure vectors keep a count of their members (as do many other Clojure collections). There's no particular reason not to have them, though, I just found it simpler to do without. This affects my terminology below: the word 'grid' always refers to a vector of vectors. The following creates the grid on which the other functions operate; also enjoy the bonus printout function: (defn create-grid ([w h] (create-grid w h 0)) ([w h initial-value] (let [data (vec (map vec (repeat h (repeat w initial-value))))] data))) (defn print-grid [g] (doseq [row g] (apply println row))) The key to the above version of check-position-valid is this function, which gives as a subgrid of the given grid: (defn subgrid "x & y are top left coords, x+ & y+ are spans" [g x x+ y y+] (if (and ( subvec is advertised by its docstring as an O(1) (constant time) operation which is very fast, so this should be pretty fast too. In the above, it's used to extract a window into the given grid, which is itself a grid (and can be printed with print-grid ). check-position-valid takes such a window into the grid and examines it side-by-side with the block's grid to determine whether the block is in a valid position. It is assumed that completely nonsensical argument values (negative x , x+ , y , y+ ) will not occur, however in case the window would "stick out" of the grid on the right or at the bottom, nil is returned instead of subvec 's index out of bounds exception. Finally, a definition of current-block usable with the above: (def current-block {:grid [[0 1 0] [0 1 0] [0 1 1]]) :x (ref 0) :y (ref 0)}) And some utility functions (which all return grids): (defn get-grid [g x y] (get-in g [y x])) (defn set-grid [g x y v] (assoc-in g [y x] v)) (defn swap-grid [g x y f & args] (apply update-in g [y x] f args)) (defn get-grid-row [g y] (get g y)) (defn set-grid-row [g y v] (assoc g y (vec (repeat (count (g 0)) v)))) (defn get-grid-col [g x] (vec (map #(% x) g))) (defn set-grid-col [g x v] (vec (map #(assoc-in % [x] v) g))) The latter four can be used to build up a test grid quickly like so (the 2 s and 3 s make no sense in connection with the code above as it is presently written, but they serve to illustrate what happens): user> (print-grid (set-grid-row (set-grid-col (create-grid 6 10) 1 2) 0 3)) 3 3 3 3 3 3 0 2 0 0 0 0 0 2 0 0 0 0 0 2 0 0 0 0 0 2 0 0 0 0 0 2 0 0 0 0 0 2 0 0 0 0 0 2 0 0 0 0 0 2 0 0 0 0 0 2 0 0 0 0 nil
