[site]: stackoverflow
[post_id]: 4359903
[parent_id]: 4089385
[tags]: 
Modifying the outline solution Have four makefiles: makefile app1.1.mak app1.2.mak appdummy.mak The app.dummy.mak makefile can be empty - a symlink to /dev/null if you like. Both app.1.1.mak and app.1.2.mak are unchanged from their current content. The main makefile changes a little: MAK_VER = dummy include makefile$(MAK_VER).mak dummy: ${MAKE} MAK_VER=$$(echo $(APP_VER) | sed -e 's/^\([0-9]*\.[0-9]*\).*$$/\1/') all all: PROD ...as now... If you type make , it will read the (empty) dummy makefile, and then try to build the dummy target because it appears first. To build the dummy target, it will run make again, with APP_VER=1.1 or APP_VER=1.2 on the command line: make APP_VER=1.1 all Macros set on the command line cannot be changed within the makefile, so this overrides the line in the makefile. The second invocation of make , therefore, will read the correct version-specific makefile, and then build all . This technique has limitations, most noticeably that it is fiddly to arrange for each and every target to be treated like this. There are ways around it, but usually not worth it. Project organization More seriously, I think you need to review what you're doing altogether. You are, presumably, using a version control system (VCS) to manage the source code. Also, presumably, there are some (significant) differences between the version 1.1 and 1.2 source code. So, to be able to do a build for version 1.1, you have to switch from the version 1.1 maintenance branch to the version 1.2 development branch, or something along those lines. So, why isn't the makefile just versioned for 1.1 or 1.2? If you switch between versions, you need to clean out all the derived files (object files, libraries, executables, etc) that may have been built with the wrong source. You have to change the source code over. So why not change the makefile too? A build script to invoke make I also observe that since you have the environment variable APP_VER driving your process, that you can finesse the problem by requiring a standardized 'make invoker' that sorts out the APP_VER value and invokes make correctly. Imagine that the script is called build : #!/bin/sh : ${APP_VER:=1.2.0.1} # Latest version is default case $APP_VER in [0-9].[0-9].*) MAK_VER=`echo $APP_VER | sed -e 's/^\(...\).*/\1/'` ;; *) echo "`basename $0 .sh`: APP_VER ($APP_VER) should start with two digits followed by dots" 1>&2; exit 1;; esac exec make MAK_VER=$MAK_VER "$@" This script validates that APP_VER is set, giving an appropriate default if it is not. It then processes that value to derive the MAK_VER (or errors out if it is incorrect). You'd need to modify that test after you reach version 10, of course, since you are planning to be so successful that you will reach double-digit version numbers in due course. Given the correct version information, you can now invoke your makefile with any command line arguments. The makefile can be quite simple: MAK_VER = dummy include app$(MAK_VER).mak all: PROD ...as now... The appdummy.mak file now contains a rule: error: echo "You must invoke this makefile via the build script" 1>&2 exit 1 It simply points out the correct way to do the build. Note that you can avoid the APP_VER environment variable if you keep the product version number under the VCS in a file, and the script then reads the version number from the file. And there could be all sorts of other work done by the script, ensuring that correct tools are installed, other environment variables are set, and so on.
