[site]: stackoverflow
[post_id]: 2366085
[parent_id]: 2366067
[tags]: 
The line, in itself, doesn't demonstrate the difference. However, assume Bird declares a method Fly that doesn't exist on Animal . You wouldn't be able to do: Animal* a = new Bird; a->Fly(); on the other hand, this is legal: Bird* b = new Bird; b->Fly(); The distinction here is a result of the fact that C++ is a statically typed language. The static type of the variable is what the compiler cares about when it's verifying things like method calls. Since the static type of the variable a is Animal which doesn't have a Fly method, the compiler will not allow you to call Fly on it (not all animals are able to fly, so you'll have to explicitly cast to Bird : dynamic_cast (a)->Fly() is legal). The expression new Bird will have the type Bird* . If you assign a value of a derived type to a variable of a based type, the compiler will not complain (all Bird s are Animal s, so it should always work). Basically, the compiler upcasts Bird* to Animal* . The reverse is not true. Not all Animal s are Bird s, so you'll have to take the responsibility and do the cast explicitly and tell the compiler that I know that object is really a Bird* . Only in that case the compiler will let you to use Bird -specific features. So, in general, if you need to use a Bird -specific member, you'd better use Bird* b = new Bird; .
