[site]: stackoverflow
[post_id]: 4172600
[parent_id]: 4172580
[tags]: 
There are some faster solutions, averaging O(log n) or in some cases O(log log n) instead of O(n). Have a google for "binary search" and "interpolation search" , you're likely to find very good explanations. If the array is unsorted, then yes, the element is anywhere and you can't get under O(n), but that's not the case with sorted arrays. -- Some explanation on interpolation search as requested: While the binary search only concerns with comparing two elements in terms of "greater / not greater", the interpolation search tries to also make use of numerical values . The point is: You have a sorted range of values from 0 to, say, 20000. You look for 300 - binary search would start at the half of range, at 10000. The interpolation search guesses that 300 would probably be somewhere closer to 0 than 20000, so it would check the element 6000 first instead of 10000. Then again - if it's too high, recurse into lower subrange, and it's too low - recurse into upper subrange. For a big array with +- uniform distribution of values, interpolation search should behave much faster than binary search - code it and see for yourself. Also, works best if first you use one interpolation search step, then one binary search step, and so on. Note that it's the thing a human does intuitively when looking up something in a dictionary.
