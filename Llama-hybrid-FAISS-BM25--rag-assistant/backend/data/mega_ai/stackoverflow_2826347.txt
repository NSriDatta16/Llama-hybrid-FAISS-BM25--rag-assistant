[site]: stackoverflow
[post_id]: 2826347
[parent_id]: 2824508
[tags]: 
What is so great about the STL ? The STL is great in that it was conceived very early and yet succeeded in using C++ generic programming paradigm quite efficiently. It separated efficiently the data structures: vector , map , ... and the algorithms to operate on them copy , transform , ... taking advantage of templates to do so. It neatly decoupled concerns and provided generic containers with hooks of customization ( Comparator and Allocator template parameters). The result is very elegant (DRY principle) and very efficient thanks to compiler optimizations so that hand-generated algorithms for a given container are unlikely to do better. It also means that it is easily extensible: you can create your own container with the interface you wish, as long as it exposes STL-compliant iterators you'll be able to use the STL algorithms with it! And thanks to the use of traits, you can even apply the algorithms on C-array through plain pointers! Talk about backward compatibility! However, it could (perhaps) have been better... What is not so great about the STL ? It really pisses me off that one always have to use the iterators, I'd really stand for being able to write: std::foreach(myVector, [](int x) { return x+1;}); because face it, most of the times you want to iterate over the whole of the container... But what's worse is that because of that: set mySet = /**/; set ::const_iterator it = std::find(mySet.begin(), mySet.end(), 1005); // [1] set ::const_iterator it = mySet.find(1005); // [2] [1] and [2] are carried out completely differently, resulting in [1] having O(n) complexity while [2] has O(log n) complexity! Here the problem is that the iterators abstract too much. I don't mean that iterators are not worthy, I just mean that providing an interface exclusively in terms of iterators was a poor choice. I much prefer myself the idea of views over containers, for example check out what has been done with Boost.MPL . With a view you manipulate your container with a (lazy) layer of transformation. It makes for very efficient structures that allows you to filter out some elements, transform others etc... Combining views and concept checking ideas would, I think, produce a much better interface for STL algorithms (and solve this find , lower_bound , upper_bound , equal_range issue). It would also avoid common mistakes of using ill-defined ranges of iterators and the undefined behavior that result of it...
