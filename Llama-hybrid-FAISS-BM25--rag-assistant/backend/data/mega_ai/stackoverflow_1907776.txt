[site]: stackoverflow
[post_id]: 1907776
[parent_id]: 1820098
[tags]: 
Good news. I had to work on something else for a while, but this allowed me to come back with a fresh pair of eyes. I quickly realized that I could just combine what I knew was working. I doubt this solution will win any awards, but it works. I know that I can wrap a FlowDocument up as text using the XamlReader, keeping the image elements but losing image data. I also knew that I can turn a FlowDocument into binary using XamlFormat. So I had the idea of taking the FlowDocument, and using a function I already wrote to iterate through it to find the images, I take each image, basically clone it and put the clone into a new FlowDocument. I take that new FlowDocument that now contains the single image, turn it into binary, and then take the resulting binary, turn it into base64 string and stick it into the tag property of the image in the original FlowDocument. This keeps image data in the original FlowDocument as text. This way I can pass the FlowDocument with image data (which I call SUBString Format) into the XamlReader to get searchable text. When it comes out of the database, I pull the FlowDocument out of the Xaml as normal, but then iterate through each image, extracting the data from the tag property using XamlFormat, and then creating another clone image to provide the Source property for my actual image. I have provided the steps to get to SUBString format below. /// /// Returns a FlowDocument in SearchableText UI Binary (SUB)String format. /// /// The FlowDocument containing images/UI formats to be converted /// Returns a string representation of the FlowDocument with images in base64 string in image tag property private string ConvertFlowDocumentToSUBStringFormat(FlowDocument flowDocument) { //take the flow document and change all of its images into a base64 string FlowDocument fd = TransformImagesTo64(flowDocument); //apply the XamlWriter to the newly transformed flowdocument using (StringWriter stringwriter = new StringWriter()) { using (System.Xml.XmlWriter writer = System.Xml.XmlWriter.Create(stringwriter)) { XamlWriter.Save(flowDocument, writer); } return stringwriter.ToString(); } } /// /// Returns a FlowDocument with images in base64 stored in their own tag property /// /// The FlowDocument containing images/UI formats to be converted /// Returns a FlowDocument with images in base 64 string in image tag property private FlowDocument TransformImagesTo64(FlowDocument flowDocument) { FlowDocument img_flowDocument; Paragraph img_paragraph; InlineUIContainer img_inline; System.Windows.Controls.Image newImage; Type inlineType; InlineUIContainer uic; System.Windows.Controls.Image replacementImage; //loop through replacing images in the flowdoc with the base64 versions foreach (Block b in flowDocument.Blocks) { //loop through inlines looking for images foreach (Inline i in ((Paragraph)b).Inlines) { inlineType = i.GetType(); /*if (inlineType == typeof(Run)) { //The inline is TEXT!!! $$$$$ Kept in case needed $$$$$ } else */if (inlineType == typeof(InlineUIContainer)) { //The inline has an object, likely an IMAGE!!! uic = ((InlineUIContainer)i); //if it is an image if (uic.Child.GetType() == typeof(System.Windows.Controls.Image)) { //grab the image replacementImage = (System.Windows.Controls.Image)uic.Child; //create a new image to be used to get base64 newImage = new System.Windows.Controls.Image(); //clone the image from the image in the flowdocument newImage.Source = replacementImage.Source; //create necessary objects to obtain a flowdocument in XamlFormat to get base 64 from img_inline = new InlineUIContainer(newImage); img_paragraph = new Paragraph(img_inline); img_flowDocument = new FlowDocument(img_paragraph); //Get the base 64 version of the XamlFormat binary replacementImage.Tag = TransformImageTo64String(img_flowDocument); } } } } return flowDocument; } /// /// Takes a FlowDocument containing a SINGLE Image, and converts to base 64 using XamlFormat /// /// The FlowDocument containing a SINGLE Image /// Returns base 64 representation of image private string TransformImageTo64String(FlowDocument flowDocument) { TextRange documentTextRange = new TextRange(flowDocument.ContentStart, flowDocument.ContentEnd); using (MemoryStream ms = new MemoryStream()) { documentTextRange.Save(ms, DataFormats.XamlPackage); ms.Position = 0; return Convert.ToBase64String(ms.ToArray()); } }
