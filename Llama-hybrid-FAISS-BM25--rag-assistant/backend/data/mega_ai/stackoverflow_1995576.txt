[site]: stackoverflow
[post_id]: 1995576
[parent_id]: 138144
[tags]: 
I often find myself needing needing some basic agregates to count/sum some things., I've defined these functions and use them often, they work really nicely at the end of a pipeline : # # useful agregate # function count { BEGIN { $x = 0 } PROCESS { $x += 1 } END { $x } } function product { BEGIN { $x = 1 } PROCESS { $x *= $_ } END { $x } } function sum { BEGIN { $x = 0 } PROCESS { $x += $_ } END { $x } } function average { BEGIN { $max = 0; $curr = 0 } PROCESS { $max += $_; $curr += 1 } END { $max / $curr } } To be able to get time and path with colors in my prompt : function Get-Time { return $(get-date | foreach { $_.ToLongTimeString() } ) } function prompt { # Write the time write-host "[" -noNewLine write-host $(Get-Time) -foreground yellow -noNewLine write-host "] " -noNewLine # Write the path write-host $($(Get-Location).Path.replace($home,"~").replace("\","/")) -foreground green -noNewLine write-host $(if ($nestedpromptlevel -ge 1) { '>>' }) -noNewLine return "> " } The following functions are stolen from a blog and modified to fit my taste, but ls with colors is very nice : # LS.MSH # Colorized LS function replacement # /\/\o\/\/ 2006 # http://mow001.blogspot.com function LL { param ($dir = ".", $all = $false) $origFg = $host.ui.rawui.foregroundColor if ( $all ) { $toList = ls -force $dir } else { $toList = ls $dir } foreach ($Item in $toList) { Switch ($Item.Extension) { ".Exe" {$host.ui.rawui.foregroundColor = "Yellow"} ".cmd" {$host.ui.rawui.foregroundColor = "Red"} ".msh" {$host.ui.rawui.foregroundColor = "Red"} ".vbs" {$host.ui.rawui.foregroundColor = "Red"} Default {$host.ui.rawui.foregroundColor = $origFg} } if ($item.Mode.StartsWith("d")) {$host.ui.rawui.foregroundColor = "Green"} $item } $host.ui.rawui.foregroundColor = $origFg } function lla { param ( $dir=".") ll $dir $true } function la { ls -force } And some shortcuts to avoid really repetitive filtering tasks : # behave like a grep command # but work on objects, used # to be still be allowed to use grep filter match( $reg ) { if ($_.tostring() -match $reg) { $_ } } # behave like a grep -v command # but work on objects filter exclude( $reg ) { if (-not ($_.tostring() -match $reg)) { $_ } } # behave like match but use only -like filter like( $glob ) { if ($_.toString() -like $glob) { $_ } } filter unlike( $glob ) { if (-not ($_.tostring() -like $glob)) { $_ } }
