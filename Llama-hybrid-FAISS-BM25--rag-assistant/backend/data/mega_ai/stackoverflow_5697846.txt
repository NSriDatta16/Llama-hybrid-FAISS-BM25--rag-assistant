[site]: stackoverflow
[post_id]: 5697846
[parent_id]: 5506498
[tags]: 
Two features that are already implemented in YARV, and which will most likely end up in Ruby 2.0, are traits ( mix ) and Module#prepend . The mix method, unlike the current include method, takes a list of modules, and mixes all of them in at the same time, making sure that they have no conflicting methods. It also gives you a way to easily resolve conflicts, if e.g. two modules you want to mix in define the same method. So, basically, while the include method allows you to treat a module as a mixin, the mix method allows you to treat a module as a trait. Module#prepend mixes a module into a class or module, again just like include does, but instead of inserting it into the inheritance chain just above the class, it inserts is just below the class. This means that methods in the module can override methods in the class, and they can delegate to the overriden methods with super , both of which is not possible when using include . This basically makes alias_method_chain obsolete. One feature that has been discussed for a couple of months (or 10 years, depending on how you count), are Refinements. There has been discussion for over 10 years now to add a way to do scoped, safe monkey patching in Ruby. I.e. a way where I can monkey patch a core class, but only my code sees that monkey patch, other code doesn't. For many years, the frontrunner for that kind of safe monkey patching were Selector Namespaces, however more recently, Classboxes have been getting a lot of attention, and even more recently, a prototype implementation and specification of Refinements, a variant of Classboxes, was put forward. Generally speaking, the big theme of Ruby 2.0 is scalability: scaling up to bigger teams, bigger codebases, bigger problem sizes, bigger machines, more cores. But also scaling down to smaller machines like embedded devices. The three features I mentioned above are for scaling to bigger teams and bigger codebases. Some proposed features for scaling to bigger problem sizes and more cores are parallel collections and parallel implementations of Enumerable methods such as map , as well as better concurrency abstractions such as futures, promises, agents, actors, channels, join patterns or something like that.
