[site]: crossvalidated
[post_id]: 506979
[parent_id]: 
[tags]: 
Normality of a ratio of random variables

For the context, I am measuring the execution time of a piece of code. I run it $N$ times with different problem sizes, its duration is proportional to the problem size. I am interested in the performance, in terms of operations per second, and in particular the "average" performance. Here are my variables: $F_i$ is the number of operations performed by the run $i$ . No assumption is made on these. $T_i \sim \alpha F_i + \beta + \epsilon$ is the duration of run $i$ , which depends on the number of operations. No assumption is made on $\epsilon$ (it could be normally distributed, or uniformly, or whatever). $P_i = F_i/T_i$ is the performance of run $i$ , in operations per second. I have two alternative definitions for the "average" performance. These definitions are not equivalent, the second one makes more sense in my context. $M_1 = \frac{1}{N}\sum_i P_i$ , the arithmetic mean of the individual performance values. $M_2 = \sum F_i / \sum T_i$ , the ratio of the total number of operations by the total duration. Now I am interested in the distribution of $M_1$ and $M_2$ if I were to repeat this experiment several times. I think we can expect $M_1$ to be normally distributed, with the central limit theorem. My question is about $M_2$ , do we know something about its distribution? I tried to simulate this scenario with some dummy data. I got this plot. The red plots are the theoretical densities of the normal distribution with the sample mean and standard deviation, the black plots are the real density plots. To me it seems pretty clear that both variables ( $M_1$ and $M_2$ ) follow a normal distribution, but I cannot convince myself why it is the case for $M_2$ . The code: library(dplyr) library(ggplot2) library(patchwork) N = 1000 # number of calls in an experiment nb_exp = 10000 # number of experiments max_flop = 1e10 # maximal number of operations in a call mean_rate = 7e-11 # inverse of the flop rate intercept = 1e-2 # minimum duration of a call small_calls = rep(c(1, 4, 16), 50) # each experiment also has these small calls set.seed(42) df = data.frame() for(i in (1:nb_exp)) { exp = data.frame(F=c(runif(N, 1, max_flop), small_calls)) %>% mutate(T=rnorm(n(), F*mean_rate, F*mean_rate/20) + intercept) %>% mutate(P=F/T) mean1 = exp %>% pull(P) %>% mean() mean2 = exp %>% summarise(F=sum(F), T=sum(T)) %>% mutate(P=F/T) %>% pull(P) df = rbind(df, data.frame(mean1=mean1, mean2=mean2)) } plot_density
