[site]: stackoverflow
[post_id]: 604724
[parent_id]: 604104
[tags]: 
I'm going to pretend I'm the computer here, reading this code... typedef struct Cell { struct Cell* subcells; } This tells me: We have a struct type called Cell It contains a pointer called subcells The pointer should be to something of type struct Cell It doesn't tell me whether the pointer goes to one Cell or an array of Cell. When a new Cell is made, the value of that pointer is undefined until a value is assigned to it. It's Bad News to use pointers before defining them. Cell makeCell(int dim) { Cell newCell; New Cell struct, with an undefined subcells pointer. All this does is reserve a little chunk of memory to be called newCell that is the size of a Cell struct. It doesn't change the values that were in that memory - they could be anything. for(int i = 0; i In order to get newCell.subcells[i], a calculation is made to offset from subcells by i, then that is dereferenced . Specifically, this means the value is pulled from that memory address. Take, for instance, i==0... Then we would be dereferencing the subcells pointer itself (no offset). Since subcells is undefined, it could be anything. Literally anything! So, this would ask for a value from somewhere completely random in memory. There's no guarantee of anything with the result. It may print something, it may crash. It definitely should not be done. } return newCell; } Any time you work with a pointer, it's important to make sure it's set to a value before you dereference it. Encourage your compiler to give you any warnings it can, many modern compilers can catch this sort of thing. You can also give pointers cutesy default values like 0xdeadbeef (yup! that's a number in hexadecimal, it's just also a word, so it looks funny) so that they stand out. (The %p option for printf is helpful for displaying pointers, as a crude form of debugging. Debugger programs also can show them quite well.)
