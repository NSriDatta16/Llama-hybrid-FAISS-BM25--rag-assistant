[site]: stackoverflow
[post_id]: 3791904
[parent_id]: 3791014
[tags]: 
Walking a hash (tree, whatever) is a technique that any programmer should know. rafl uses a visitor module , but in some cases I think the cure is almost worse than the disease. Is your expected output what you intended? It seems different that what you said in the text, as FM says . I use his hash in my example. It's pretty easy if you use a queue. You start with the top-level hash. Every time you run into a hash ref, you add it to the queue. When you run into an array ref, you check that it has values and delete that key if it doesn't. Everything else you leave alone: #!perl use strict; use warnings; use 5.010; my %hash = ( # From FM 'A' => { 'B' => ['C', 'D', 'E'], 'F' => { 'G' => [], 'H' => [], 'Z' => ['FOO', 'BAR'], # Not in the OP's original. }, 'I' => [], }, ); my @queue = ( \%hash ); while( my $ref = shift @queue ) { next unless ref $ref eq ref {}; KEY: foreach my $key ( keys %$ref ) { if( ref $ref->{$key} eq ref {} ) { push @queue, $ref->{$key}; next KEY; } elsif( ref $ref->{$key} eq ref [] ) { delete $ref->{$key} if @{$ref->{$key}} == 0; } } } use Data::Dumper; print Dumper( \%hash ); My output is: $VAR1 = { 'A' => { 'F' => { 'Z' => [ 'FOO', 'BAR' ] }, 'B' => [ 'C', 'D', 'E' ] } }; That output sounds more like what you are asking for, rather than the reorganization that you specify. Can you clarify the output?
