[site]: stackoverflow
[post_id]: 1220528
[parent_id]: 1213959
[tags]: 
Since storage is cheap, you could create your own ListProperty based indexfiles with key_names that reflect the sort criteria. class album_pubyear_List(db.Model): words = db.StringListProperty() class album_length_List(db.Model): words = db.StringListProperty() class album_artist_List(db.Model): words = db.StringListProperty() class Album(db.Model): blah... def save(self): super(Album, self).save() # you could do this at save time or batch it and do # it with a cronjob or taskqueue words = [] for field in ["title", "artist", "label", "genre", ...]: words.append("%s:%s" %(field, getattr(self, field))) word_records = [] now = repr(time.time()) word_records.append(album_pubyear_List(parent=self, key_name="%s_%s" %(self.pubyear, now)), words=words) word_records.append(album_length_List(parent=self, key_name="%s_%s" %(self.album_length, now)), words=words) word_records.append(album_artist_List(parent=self, key_name="%s_%s" %(self.artist_name, now)), words=words) db.put(word_records) Now when it's time to search you create an appropriate WHERE clause and call the appropriate model where = "WHERE words = " + "%s:%s" %(field-a, value-a) + " AND " + "%s:%s" %(field-b, value-b) etc. aModel = "album_pubyear_List" # or anyone of the other key_name sorted wordlist models indexes = db.GqlQuery("""SELECT __key__ from %s %s""" %(aModel, where)) keys = [k.parent() for k in indexes[offset:numresults+1]] # +1 for pagination object_list = db.get(keys) # returns a sorted by key_name list of Albums
