[site]: stackoverflow
[post_id]: 2803436
[parent_id]: 2791126
[tags]: 
Your problem is clear. In the current implementation you have only impersonation of users and no delegation. I don't want to repeat information already written by Stephen Martin. I only want to add at least three solutions. The classical way of delegation which Stephen Martin suggests is only one way. You can read some more ways here: http://msdn.microsoft.com/en-us/library/ff647404.aspx#paght000023_delegation . I see three practical ways of you solving your problem: Convert the impersonation token of the user to a token with delegation level of impersonation or to a new primary token. You can do this with respect of DuplicateToken or DuplicateTokenEx . Use S4U2Self (see http://msdn.microsoft.com/en-us/magazine/cc188757.aspx and http://msdn.microsoft.com/en-us/library/ms998355.aspx ) to receive a new token from the old one with respect of one simple .NET statement WindowsIdentity wi = new WindowsIdentity(identity); You can access another server with respect of one fixed account. It can be a computer account on an account of the application pool of the IIS. It can be another fixed defined account which one will only use for access to the file system. It is important to know which version of Windows Server you have on the server where IIS is running and which Domain Function Level you have in Active Directory for your Domain (you see this in "Active Directory Domain and Trusts" tool if you select your domain and choose "Raise Domain Functional Level"). It is also interesting to know under which account the application pool of the IIS runs. The first and the third way will always work. The third way can be bad for your environment and for the current permission in the file system. The second one is very elegant. It allows control of which servers (file server) are accessed from IIS. This way has some restrictions and it needs some work to be done in Active Directory. Because you use classic ASP, a small scriptable software component must be created to support your implementation. Which way do you prefer? UPDATED based on the question from comment: Because you use classic ASP you can not use a Win32 API directly, but you can write a small COM component in VB6 or in .NET which use APIs which you need. As an example you can use code from http://support.microsoft.com/kb/248187/en . But you should do some other things inside. So I explain now which Win32 API can help you to do everything what you need with tokens and impersonation. First of all a small explanation about impersonation. Everything works very easy. There are always one primary token under which the process runs. To any thread another token (thread token) can be assigned. To do this one needs to have a token of a user hUserToken and call API ImpersonateLoggedOnUser(hUserToken); . To go back to the original process token (for the current thread only) you can call RevertToSelf() function. The token of user will be received and already impersonated for you by IIS, because you so configured your Web Site. To go back to the original process token you should implement calling of the function RevertToSelf() in your custom COM component. Probably, if you need to do nothing more in the ASP page, it will be enough, but I recommend you be more careful and save current users token in a variable before operation with files. Then you make all operations with file system and at the end reassign users token back to the current thread. You can assign an impersonation token to a thread with respect of SetThreadToken(NULL,hUserToken); . To give (save) current thread token (user token in your case) you can use OpenThreadToken API. It must work. UPDATED 2: Probably the usage of RevertToSelf() function at the end of one ASP page would be already OK for you. The corresponding C# code can be so: Create a new Project in C# of the type "Class Library" with the name LoginAdmin . Paste the following code inside using System; using System.Runtime.InteropServices; namespace LoginAdmin { [InterfaceTypeAttribute (ComInterfaceType.InterfaceIsDual)] public interface IUserImpersonate { [DispId(1)] bool RevertToSelf (); } internal static class NativeMethods { [DllImport ("advapi32.dll", SetLastError = true)] internal static extern bool RevertToSelf (); } [ClassInterface (ClassInterfaceType.AutoDual)] public class UserImpersonate : IUserImpersonate { public UserImpersonate () { } public bool RevertToSelf () { return NativeMethods.RevertToSelf(); } } } Check in project properties in "Build" part "Register for COM interop". In "Signing" part of the project check Sign the assembly and in "Choose a strong name key file" choose , then type any filename and password (or check off "protect my key..."). At the end you should modify a line from AssemblyInfo.cs in Properties part of the project: [assembly: ComVisible (true)] After compiling this project you get two files, LoginAdmin.dll and LoginAdmin.tlb. The DLL is already registered on the current computer. To register if on the other computer use RegAsm.exe . To test this COM DLL on a ASP page you can do following "); Response.Write("Current user's domain: ");Response.Write(objNet.UserDomain);Response.Write(" "); var objLoginAdmin = Server.CreateObject("LoginAdmin.UserImpersonate"); var isOK = objLoginAdmin.RevertToSelf(); if (isOK) Response.Write("RevertToSelf return true "); else Response.Write("RevertToSelf return false "); Response.Write("One more time after RevertToSelf() "); Response.Write("Current user: ");Response.Write(objNet.UserName);Response.Write(" "); Response.Write("Current user's domain: ");Response.Write(objNet.UserDomain);Response.Write(" "); var fso = Server.CreateObject("Scripting.FileSystemObject"); var path = "\\\\mk01\\C\\Oleg"; if (fso.FolderExists(path)) { Response.Write("Yes"); } else { Response.Write("No"); }%> If the account used to run the IIS application pool has access to the corresponding network share, the output will be look like following Current user: Oleg Current user's domain: WORKGROUP RevertToSelf return true One more time after RevertToSelf() Current user: DefaultAppPool Current user's domain: WORKGROUP Yes
