[site]: stackoverflow
[post_id]: 1768483
[parent_id]: 1767864
[tags]: 
EDIT: As alexdej correctly points out, Image will serialize/deserialize with DCS correctly, but you have to either change the DataContract type to Bitmap or use config to specify a KnownType of Bitmap for System.Drawing.Image at runtime (you can't attribute it because you don't own the Image class). The Image class isn't suitable for serialization by DataContractSerializer- it's got all sorts of ties to GDI buffers and stuff under the covers. DCS is intended to represent data objects where you control the entire structure of the class. The confusion comes because in 3.5SP1 they added the ability for DCS to serialize objects that aren't tagged with DataContractAttribute (mostly as a convenience for people too lazy to attribute their wire classes). The unfortunate side effect is that the serializer will happily TRY to serialize any old object, but will fail to produce a useful result in many cases (like yours). One way or another, you'll need to turn it into a byte[] or a Stream to get it over the wire, and rehydrate it as an image. If you're using WCF and the same DataContract types on both sides (eg, not a generated type), you can leave Graphic as a property, but don't mark it with DataMember. Make the set on Graphic populate storage for another proprty ImageBytes (that IS tagged DataMember) by calling Image.Save to a MemoryStream, then dump the byte[]. Make the set on ImageBytes load the graphic property's internal Image storage from the byte[] passed in in the same manner. When the object is deserialized on the other end (eg, the deserializer calls the ImageBytes setter), poof- your Graphic property's storage is populated, and it all just works. Full automatic serialization/deserialization behavior- the ImageBytes property is just an implementation detail.
