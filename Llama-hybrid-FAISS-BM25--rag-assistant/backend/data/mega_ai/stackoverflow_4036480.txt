[site]: stackoverflow
[post_id]: 4036480
[parent_id]: 4036394
[tags]: 
Only in very specific circumstances you need to call the destructor directly. By default the destructor will be called by the system when you create a variable of automatic storage and it falls out of scope or when a an object dynamically allocated with new is destroyed with delete . struct test { test( int value ) : value( value ) {} ~test() { std::cout For completeness, (this should not be used in general) the syntax to call the destructor is similar to a method. After the destructor is run, the memory is no longer an object of that type (should be handled as raw memory): int main() { test t( 1 ); t.~test(); // prints: ~test: 1 // after this instruction 't' is no longer a 'test' object new (&t) test(2); // recreate a new test object in place } // test falls out of scope, prints: ~test: 2 Note: after calling the destructor on t , that memory location is no longer a test , that is the reason for recreation of the object by means of the placement new .
