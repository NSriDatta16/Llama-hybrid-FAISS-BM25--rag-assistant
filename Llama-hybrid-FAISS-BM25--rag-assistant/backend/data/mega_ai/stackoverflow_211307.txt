[site]: stackoverflow
[post_id]: 211307
[parent_id]: 211237
[tags]: 
As you say the order is undefined across different compilation units. Within the same compilation unit the order is well defined: The same order as definition. This is because this is not resolved at the language level but at the linker level. So you really need to check out the linker documentation. Though I really doubt this will help in any useful way. For gcc: Check out ld I have found that even changing the order of objects files being linked can change the initialization order. So it is not just your linker that you need to worry about, but how the linker is invoked by your build system. Even try to solve the problem is practically a non starter. This is generally only a problem when initializing globals that reference each other during their own initialization (so only affects objects with constructors). There are techniques to get around the problem. Lazy initialization. Schwarz Counter Put all complex global variables inside the same compilation unit. Note 1: globals: Used loosely to refer to static storage duration variables that are potentially initialized before main() . Note 2: Potentially In the general case we expect static storage duration variables to be initialized before main, but the compiler is allowed to defer initialization in some situations (the rules are complex see standard for details).
