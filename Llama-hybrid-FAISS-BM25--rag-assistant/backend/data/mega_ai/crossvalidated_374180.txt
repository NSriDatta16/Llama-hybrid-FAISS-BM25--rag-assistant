[site]: crossvalidated
[post_id]: 374180
[parent_id]: 373819
[tags]: 
Since growth is your outcome, then you have two outcomes at some time points, but only one in others. According to you, one is of higher quality than the other. If you have a quantitative way of communicating model quality, then you could apply those as case weights. It does not seem like you do so here's what I recommend. For cases where you have both measurements, transform those cases into two cases. Each case should retain a case ID so you know where the data come from. Also, have an identifier for each type of outcome. Now you have data with dependence between rows. So you can take a mixed effects regression approach, clustering the data by original case. For your model, create two dummies, one for each original outcome. You can begin by entering both dummies into the model (remove the standard intercept) from your software so you can use both dummies. Also, depending on your software, you can enter both dummies as random slopes, also calculating a correlation between them. It is probably simpler to enter a single random intercept, and permit heteroskedastic variances by each type of outcome. The second approach is possible using the nlme package in R. Finally, you have two options for entering your remaining predictors into the model. If you believe each predictor influences each outcome uniquely, you can enter them as interactions-only with the two dummies for each type of outcome. Otherwise, enter them into the model as standard predictors. I have an example of data stacking and predictor entry here - MLE with unbalanced system of regressions . In that example, the corresponding nlme model would be: library(nlme) # baseline model # outcome1 and outcome2 are outcome type identifiers # Random intercept by plant, permit heteroskedasticity by outcome type # Obtain average value for each outcome type using dummies lme( y ~ 0 + outcome1 + outcome2, random = ~ 1 | plant_id, dat, weights = varIdent(form = ~ 1 | outcome1)) # Standard model lme( y ~ 0 + outcome1 + outcome2 + sunlight + water_per_min, random = ~ 1 | plant_id, dat, weights = varIdent(form = ~ 1 | outcome1)) The more flexible specification where we permit each predictor to have a different coefficient depending on the outcome type is below. But since both outcomes are the same, there is probably no need to do this unless the measures really are different. lme( y ~ 0 + outcome1 + outcome2 + outcome1:sunlight + outcome1:water_per_min + outcome2:sunlight + outcome2:water_per_min, random = ~ 1 | plant_id, dat, weights = varIdent(form = ~ 1 | outcome_type)) I think this is one approach. Obviously, it ignores the differences in quality between the different outcome types. But it allows you to use both outcome types in a single model. You can also use the different correlation structures your package ( nlme in my case) offers to account for the time-series nature of the data. I would also run a quality measure only model, hoping that the results do not differ much. If the growth from earlier periods affects future growth, then you need to account for growth using some special correlation structure (corClasses in nlme). Otherwise, if you just want to model growth simply overall, time simply enter the model as a predictor. You can specify it as linear, quadratic, exponential, ... Given discussion in comments, a model that would average over both outcome types would then be: model.disc where f() is some function on time, power, log, spline, ... The fitted values ( fitted(model.disc) ) from such a model would return the predicted outcome at each time point for each plant averaging over the two measures.
