[site]: stackoverflow
[post_id]: 5040389
[parent_id]: 5040380
[tags]: 
It's easy - use PreparedStatement and let it escape the Strings properly for you. While it doesn't explain your problem, I don't like your code very much. It's getting too big. I'd refactor by creating a separate DAO interface with three methods, one for each of the queries you're executing. I'd make those query Strings static final constants in the DAO implementation class. I'd test this separately. When it was working perfectly I'd give the object that's checking the experience level a reference to a DAO and have it call its methods rather than embedding all that database logic in one class. It's called "decomposition". It'll help you manage your problem as it gets larger. Something like this: package persistance; public interface FooDao { List find(String name); } public class FooDaoImpl implements FooDao { public static final String FIND_BY_NAME_SQL = "SELECT * FROM Foo WHERE name = ?"; private DataSource dataSource; public Foo(DataSource dataSource) { this.dataSource = dataSource; } public List find(String name) { List result = new ArrayList (); PreparedStatement ps = null; ResultSet rs = null; try { ps = this.dataSource.getConnection().prepareStatement(FIND_BY_NAME_SQL); ps.setString(1, name); rs = ps.executeQuery(); while (rs.hasNext()) { // Map row into Foo and add it to the List result.add(foo); } } catch (SQLException e) { throw new RuntimeException(e); } finally { close(rs); close(ps); } } }
