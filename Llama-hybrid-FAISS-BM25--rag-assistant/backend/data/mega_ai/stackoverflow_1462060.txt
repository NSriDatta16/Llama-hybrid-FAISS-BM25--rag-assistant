[site]: stackoverflow
[post_id]: 1462060
[parent_id]: 1461381
[tags]: 
Since I don't particularly like any of the answers given so far, I went to the C++ standard: 4.7 Integral conversions [conv.integral] 1 An rvalue of an integer type can be converted to an rvalue of another integer type. An rvalue of an enumeration type can be converted to an rvalue of an integer type. This says it is allowed to implicitly convert one integer to another, so the two types (as they are the same size), are interchangeable as rvalues. 4.10 Pointer conversions [conv.ptr] 1 An integral constant expression ( expr.const ) rvalue of integer type that evaluates to zero (called a null pointer constant) can be converted to a pointer type. The result is a value (called the null pointer value of that type) distinguishable from every pointer to an object or function. Two null pointer values of the same type shall compare equal. The conversion of a null pointer constant to a pointer to cv-qualified type is a single conversion, and not the sequence of a pointer conversion followed by a qualification conversion ( conv.qual ). 2 An rvalue of type "pointer to cv T," where T is an object type, can be converted to an rvalue of type "pointer to cv void." The result of converting a "pointer to cv T" to a "pointer to cv void" points to the start of the storage location where the object of type T resides, as if the object is a most derived object ( intro.object ) of type T (that is, not a base class subobject). 3 An rvalue of type "pointer to cv D," where D is a class type, can be converted to an rvalue of type "pointer to cv B," where B is a base class ( class.derived ) of D. If B is an inaccessible ( class.access ) or ambiguous ( class.member.lookup ) base class of D, a program that necessitates this conversion is ill-formed. The result of the conversion is a pointer to the base class sub-object of the derived class object. The null pointer value is converted to the null pointer value of the destination type. It is only allowed to implicitly convert: 0 to any pointer type (making it a null pointer) any pointer type to void* (properly cv-qualified) derived pointer to a base pointer (properly cv-qualified) So even though the underlying machine type is the same, it is not allowed to implicitly convert between the two types.
