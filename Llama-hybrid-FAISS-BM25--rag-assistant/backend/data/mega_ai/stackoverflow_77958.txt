[site]: stackoverflow
[post_id]: 77958
[parent_id]: 52702
[tags]: 
Ok, I resolved the problem, several factors at play here. Firstly this support Microsoft article was beneficial: Internet Explorer is unable to open Office documents from an SSL Web site . In order for Internet Explorer to open documents in Office (or any out-of-process, ActiveX document server), Internet Explorer must save the file to the local cache directory and ask the associated application to load the file by using IPersistFile::Load. If the file is not stored to disk, this operation fails. When Internet Explorer communicates with a secure Web site through SSL, Internet Explorer enforces any no-cache request. If the header or headers are present, Internet Explorer does not cache the file. Consequently, Office cannot open the file. Secondly, something earlier in the page processing was causing the "no-cache" header to get written. So Response.ClearHeaders needed to be added, this cleared out the no-cache header, and the output of the page needs to allow caching. Thirdly for good measure, also added on Response.End, so that no other processing futher on in the request lifetime attempts to clear the headers I've set and re-add the no-cache header. Fourthly, discovered that content expiration had been enabled in IIS. I've left it enabled at the web site level, but since this one aspx page will serve as a gateway for downloading the files, I disabled it at the download page level. So here is the code snippet that works (there are a couple other minor changes which I believe are inconsequential): System.IO.FileStream fs = new System.IO.FileStream(Server.MapPath(".") + "\\" + "TestMe.doc", System.IO.FileMode.Open); long byteNum = fs.Length; byte[] fileBytes = new byte[byteNum]; fs.Read(fileBytes, 0, (int)byteNum); Response.ClearContent(); Response.ClearHeaders(); Response.AppendHeader("Content-disposition", "attachment; filename=Testme.doc"); Response.Cache.SetCacheability(HttpCacheability.Public); Response.ContentType = "application/octet-stream"; Response.OutputStream.Write(fileBytes, 0, fileBytes.Length); Response.Flush(); Response.Close(); fs.Close(); Response.End(); Keep in mind too, this is just for illustration. The real production code will include exception handling and likely read the file a chunk at a time (perhaps 10K). Mauro, thanks for catching a detail that was missing from the code as well.
