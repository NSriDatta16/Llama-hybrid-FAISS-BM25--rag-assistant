[site]: stackoverflow
[post_id]: 860916
[parent_id]: 860877
[tags]: 
Not only for portability across operating systems, but also across architectures, for example between 32- and 64-bit machines. Imagine you wrote some network code on a 32-bit machine that used two unsigned ints to store 64 consecutive bit flags. Compile that same code on a 64-bit machine and it would virtually be guaranteed to not work, given that most 64-bit machines allocate 8 bytes for an int, so you would end up with 128 bits allocated and 32 bits of gap between your two sets of 32 bit flags. That's obviously really bad for portability. On *nix machines a lot of times you'll see typedefs that specifically refer the size of memory allocated for that variable, for example uint16_t and uint32_t. These are then typedef'd to whatever type gets you that much unsigned storage on a particular architecture, so your code can remain consistent across operating systems and architectures.
