[site]: stackoverflow
[post_id]: 1275135
[parent_id]: 1268173
[tags]: 
I'd like to explore smarter ways, like making sortOrder floating point except I don't have that option If you find it easier to think of it in terms of floating point, why not imagine the number as fixed point. e.g. for the purposes of your algorithm interpret 1000000 as 100.0000. You'll need to choose the point position so that there as many decimal (or binary) places as you can fit given (max number of items in your array+2) vs the integer size. So let's say the max number of entries is 998, you'd need 3 digits before the point, the rest would be available for 'gaps'. A move operation then can be as simple as setting its new sortnumber to half the sum of the sortnumber of the items either side, i.e. slotting the moved item between its new neighbors. Use 0 and size(array)+1 as the end cases. Again I'm assuming that your UI can record the moves done by the user - regardless I think it should be fairly straightforward to work them out, and a standard sort algorithm could probably be used, just redefine 'swap'. So for example moving last to first in this array (with imaginary decimal point): 1.0000 2.0000 3.0000 4.0000 5.0000 becomes 1.0000 2.0000 3.0000 4.0000 0.5000 = (0.0000 + 1.0000)/2 giving a sort order of 0.5000 1.0000 2.0000 3.0000 4.0000 Which changes just one record, the last one in the array Moving last to second would do this: 1.0000 2.0000 3.0000 4.0000 5.0000 Becomes 1.0000 2.0000 3.0000 4.0000 1.5000 = (1.0000+2.0000)/2 resulting in a sort order of 1.0000 1.5000 2.0000 3.0000 4.0000 Again, just one record changed. You will still need to cater for the case where you you run out of room 'between' two numbers, which you will eventually. I think this is true regardless of algorithm. This will require 'swap' to renumber more entries to make more room. Again regardless of algorithm I don't think you can rule out the case where everything has to be renumbered, it will just be very unlikely. I also suspect that extensive renumbers become more likely over time, again no matter what you do - the available space will fragment. However by choosing the position of the point to give as much room as possible, it should be optimal, i.e. you postpone that as long as possible. To avoid having to do a more extensive renumber at an inconvenient time, it would probably be advisable to regularly do some kind of batch renumber during quiet periods - basically stretching the gaps again to make room for further user driven sorts. Again, I think you probably need this no matter what method you use. This is just a sketch and I think it is probably equivalent to any other way of doing it, though perhaps a more intuitive/maintainable way of thinking about it and a way of maximising the room for expansion. Also if you're really worried about poor performance of degenerate cases - and from your description it sounds like you should be - I'd suggest to run whatever algorithm you go with in a test harness with a lot of random data (no database) over a long period, to see how many renumbers it really performs in practice and especially to see if it degrades with use over a long period. I suspect any algorithm for this will.
