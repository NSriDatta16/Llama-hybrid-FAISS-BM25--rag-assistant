[site]: stackoverflow
[post_id]: 3033125
[parent_id]: 3032202
[tags]: 
The simplest way is to create a NSView subclass that handles both the mouse management and the drawing. There is a sample code that can help you to start named "TLayer". It is part of the Examples of the XCode 3.1.4. It contains a circular custom view that controls the offset and the radius of the shadow drawn for layers. It is easy to understand and easy to extend. Note: as it does not seems to be available on the Apple website, so I have pasted the sources below. ShadowOffsetView.h #import extern NSString *ShadowOffsetChanged; @interface ShadowOffsetView : NSView { CGSize _offset; float _scale; } - (float)scale; - (void)setScale:(float)scale; - (CGSize)offset; - (void)setOffset:(CGSize)offset; @end ShadowOffsetView.m #import "ShadowOffsetView.h" NSString *ShadowOffsetChanged = @"ShadowOffsetChanged"; @interface ShadowOffsetView (Internal) - (NSCell *)cell; @end @implementation ShadowOffsetView - (id)initWithFrame:(NSRect)frame { self = [super initWithFrame:frame]; if (self == nil) return nil; _offset = CGSizeZero; return self; } - (void)dealloc { [super dealloc]; } - (float)scale { return _scale; } - (void)setScale:(float)scale { _scale = scale; } - (CGSize)offset { return CGSizeMake(_offset.width * _scale, _offset.height * _scale); } - (void)setOffset:(CGSize)offset { offset = CGSizeMake(offset.width / _scale, offset.height / _scale); if (!CGSizeEqualToSize(_offset, offset)) { _offset = offset; [self setNeedsDisplay:YES]; } } - (BOOL)isOpaque { return NO; } - (void)setOffsetFromPoint:(NSPoint)point { float radius; CGSize offset; NSRect bounds; bounds = [self bounds]; offset.width = (point.x - NSMidX(bounds)) / (NSWidth(bounds) / 2); offset.height = (point.y - NSMidY(bounds)) / (NSHeight(bounds) / 2); radius = sqrt(offset.width * offset.width + offset.height * offset.height); if (radius > 1) { offset.width /= radius; offset.height /= radius; } if (!CGSizeEqualToSize(_offset, offset)) { _offset = offset; [self setNeedsDisplay:YES]; [(NSNotificationCenter *)[NSNotificationCenter defaultCenter] postNotificationName:ShadowOffsetChanged object:self]; } } - (void)mouseDown:(NSEvent *)event { NSPoint point; point = [self convertPoint:[event locationInWindow] fromView:nil]; [self setOffsetFromPoint:point]; } - (void)mouseDragged:(NSEvent *)event { NSPoint point; point = [self convertPoint:[event locationInWindow] fromView:nil]; [self setOffsetFromPoint:point]; } - (void)drawRect:(NSRect)rect { NSRect bounds; CGContextRef context; float x, y, w, h, r; bounds = [self bounds]; x = NSMinX(bounds); y = NSMinY(bounds); w = NSWidth(bounds); h = NSHeight(bounds); r = MIN(w / 2, h / 2); context = [[NSGraphicsContext currentContext] graphicsPort]; CGContextTranslateCTM(context, x + w/2, y + h/2); CGContextAddArc(context, 0, 0, r, 0, 2*M_PI, true); CGContextClip(context); CGContextSetGrayFillColor(context, 0.910, 1); CGContextFillRect(context, CGRectMake(-w/2, -h/2, w, h)); CGContextAddArc(context, 0, 0, r, 0, 2*M_PI, true); CGContextSetGrayStrokeColor(context, 0.616, 1); CGContextStrokePath(context); CGContextAddArc(context, 0, -2, r, 0, 2*M_PI, true); CGContextSetGrayStrokeColor(context, 0.784, 1); CGContextStrokePath(context); CGContextMoveToPoint(context, 0, 0); CGContextAddLineToPoint(context, r * _offset.width, r * _offset.height); CGContextSetLineWidth(context, 2); CGContextSetGrayStrokeColor(context, 0.33, 1); CGContextStrokePath(context); } @end
