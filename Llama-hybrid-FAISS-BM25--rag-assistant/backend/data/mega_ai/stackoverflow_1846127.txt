[site]: stackoverflow
[post_id]: 1846127
[parent_id]: 1844162
[tags]: 
I think your question is totally valid. If you have implemented your own error handling you may want to: Always trigger asserts even in release builds. Implement better error reporting in case an assert triggers. You may want to send error reports or write to log files. That being said, I don't see any solution that always works. If you are lucky, the third-party libraries use ASSERT macros that you can redefine yourself as long as the file defining this macro has some sort of #pragma once or #ifndef __HEADERFILE_H__ #define __HEADERFILE_H__ provision against multiple inclusion. Include the header file separately, redefine ASSERT and you're good. If they directly include assert.h or cassert you can only patch the code I guess. Make minimal code changes, save the changes as patch files and when you update the library hope that the patches still work. Add the patches to version control. If this doesn't work, rethink the question if you really need internal asserts in third-party libraries. Ship release builds only, this gets rid of the asserts, and add your ASSERTs to check for correctness inside your code. Check for validity of return values. If such an ASSERT is triggered, you can still dive into the third-party code to see what caused the problem.
