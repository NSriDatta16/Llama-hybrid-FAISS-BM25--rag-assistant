[site]: stackoverflow
[post_id]: 2768968
[parent_id]: 2768917
[tags]: 
The module hasn't been updated since 2007 but you can always send a message to the author (Matthijs van Duin: xmath@cpan.org) or file a bug report as Robert mentioned in his answer. Here are some alternatives: As far as additional CPAN modules for aliasing that work in 5.12+: Variable::Alias - clean syntax Tie::Alias - a pure perl solution Lexical::Alias - clean syntax Devel::LexAlias - a bit lower level And searching for 'alias' on CPAN turns up a few more, none seem to provide the "do everything with aliases in this statement" feature of Data::Alias though. So until Data::Alias is fixed, you can use one of the above, or the following pure Perl methods: Perl has built in support for aliasing any variable to variables that exist in the symbol table. This is done as follows: my $x = 1; our $y; # declare $y in the symbol table for the current package { local *y = \$x; # make $y an alias of $x in the current scope $y++; } print $x; # prints 2 But as always, be aware of what dynamic scope / local actually does before using it. A lexical scalar can be used as an alias within the scope of a for loop: my $x = 1; for my $y ($x) { $y++; } print $x; # prints 2 this type of lexical alias can even be passed out of the loop in a closure if needed You can create array aliases using Perl's aliasing magic for subroutine argument lists: my $x = 1; my $alias = sub{\@_}->($x); # return a reference to its argument list, # which maintains its aliases $$alias[0]++; print $x; # prints 2 but that doesn't really give you any more functionality than references, just with a different syntax. And an example using Perl's references: my $x = 1; my $y = \$x; # take a reference to $x $$y++; # dereference $y print $x; # prints 2
