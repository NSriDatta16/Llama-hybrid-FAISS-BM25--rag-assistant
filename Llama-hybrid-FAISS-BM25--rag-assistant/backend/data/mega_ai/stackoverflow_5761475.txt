[site]: stackoverflow
[post_id]: 5761475
[parent_id]: 
[tags]: 
Message passing from destructor during garbage collection

The following gives me an Access Violation on windows 32-bit, dmd.2.052, no flags. When the destructor is run by the garbage collector, the message box seems to be corrupted in the process. import std.stdio; import core.thread; import core.memory; import std.concurrency; class C { string m_str; Tid m_receiverTid; this(string s, Tid rt) { this.m_str = s; this.m_receiverTid = rt; } ~this() { writeln("Destructor : ",this.m_str); m_receiverTid.send(this.m_str); } } void receiver() { try { while(true) { receive((string s){writeln("Received: ",s);}); } } catch (Throwable th) { writeln("Caught throwable: ",th.toString()); } } void main() { Tid receiverTid = spawn(&receiver); receiverTid.send("Basic test"); Thread.sleep( 5_000_000 ); C c1 = new C("c1 Manually deleted",receiverTid); delete c1; Thread.sleep( 5_000_000 ); { C c2 = new C("c2 Garbage collected",receiverTid); } writeln("Running garbage collector..."); // This line needed to flush out the c2 root pointer. GC.collect(); Thread.sleep( 5_000_000 ); writeln("Exiting main thread..."); } The above produces: Received: Basic test Destructor : c1 Manually deleted Received: c1 Manually deleted Running garbage collector... Destructor : c2 Garbage collected Received: c2 Garbage collected Caught throwable: object.Error: Access Violation Exiting main thread... Are there any workarounds for this? Is there a way for destructor code to know if it is being invoked by the GC or not? Is message passing from a destructor intrinsically unsafe, e.g. if non-GC threads are frozen by the GC whilst they have a mutex lock on a shared message box then the GC might deadlock if it sends to a locked message box? Or does destructor code only take place in a sweep cycle after all threads are thawed? Is it safe for a destructor to reference thread local storage, e.g. could the GC sweep cycle be in a different thread?
