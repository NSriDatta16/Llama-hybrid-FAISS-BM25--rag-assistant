[site]: stackoverflow
[post_id]: 4374125
[parent_id]: 4373905
[tags]: 
This is the expected behavior and is by design. You can see this for yourself if you right-click on an item in Windows Explorer and open its Properties window. All of the dynamic text fields on the "General" tab are selectable, though not modifiable. If this is not the behavior you desire, you should strongly consider using a Label control instead. This is the exact situation for which it was intendedâ€”static text that is not selectable by the user. In case, for whatever reason, you're not sold on why you should use a Label control instead, I'll proceed onward in answering the question you asked. The major problem with trying to override this behavior (like overriding the default behavior of any control) is that there are a lot of ways for the user to accomplish it: clicking and dragging with the mouse, double-clicking the mouse button, using the arrow keys on the keyboard in combination with the Shift key, tabbing into the textbox, right-clicking and choosing "Select All" from the context menu, etc... Your first instinct might be to override the potentially relevant events exposed by the .NET Framework (such as OnMouseDown , OnKeyDown , etc.) and reset the selected length to 0 so that the text is immediately unselected after it is automatically selected. However, this causes a little bit of a flicker effect in the process, which may or may not be acceptable to you. Alternatively, you could do the same thing by overriding the control's WndProc method, watching for the relevant window messages, and preventing the messages from being passed on to the control's base class altogether. This will prevent the flicker effect because the base TextBox control never actually receives a message causing it to automatically select its text, but it does have the obvious side effect of preventing the control from taking any action as a result of these common events. It seems like that probably doesn't matter to you in this case, but realize that this is still a pretty drastic hack. I definitely cannot recommend it as being good practice. That being said, if you're still interested, you could use the following custom UnselectableTextBox class. It prevents the processing of every window message that I could think of which would possibly allow the user to select text. It does indeed work, but fair warning: there may be yet others I haven't thought of. public class UnselectableTextBox : TextBox { public UnselectableTextBox() : base() { //Set it to read only by default this.ReadOnly = true; } protected override void OnGotFocus(System.EventArgs e) { base.OnGotFocus(e); //Prevent contents from being selected initally on focus this.DeselectAll(); } protected override void WndProc(ref System.Windows.Forms.Message m) { const int WM_KEYDOWN = 0x100; const int WM_LBUTTONDOWN = 0x201; const int WM_LBUTTONDBLCLK = 0x203; const int WM_RBUTTONDOWN = 0x204; if ((m.Msg == WM_KEYDOWN) || (m.Msg == WM_LBUTTONDOWN) || (m.Msg == WM_LBUTTONDBLCLK) || (m.Msg == WM_RBUTTONDOWN)) { this.DeselectAll(); return; } base.WndProc(ref m); } }
