[site]: stackoverflow
[post_id]: 4763552
[parent_id]: 3706258
[tags]: 
I re-engaged on this project over the last few weeks and finally came up with a solution. Given the comments and thoughts people posted above, I'm not sure anyone but me understands what I'm trying to do, but I figured it might be worthwhile posting how I solved this. At the minimum, writing it up will ensure I understand it :-). Summarizing the question again: I have a home control server that exposes objects in my home via a SOAP interface. Home.LivingRoom.Fireplace , for example is exposed as: http://server/Home/LivingRoom/Fireplace?property=DisplayName http://server/Home/LivingRoom/Fireplace?property=PowerState Doing an HTTP GET against these will result in the HTTP reply containing the property value (e.g. "Living Room Fireplace" and "Off" respectively). A garage door (e.g. Home.Garage.EastGarageDoor ) is exposed as: http://server/Home/Upstairs/EastGarageDoor?property=DisplayName http://server/Home/Upstairs/EastGarageDoor?property=GarageDoorOpened http://server/Home/Upstairs/EastGarageDoor?property=Trigger Here we have a property that if set causes an action ( Trigger ). Doing a POST against this with a HTTP body of "True" will cause the door to open/close. I am building a WP7 app as a front end to this. I have decided to follow the Mvvm model and am using Mvvm-Light. WP7 does not have a built in way of supporting notifications from REST interfaces, and I am not yet ready to build my own (although it is on my radar). So for the UI to show up-to-date state I need to poll. The # of entities & amount of data is relatively small and I have now proven that I can make it work well with polling, but there are some optimizations I can do to improve it (including adding smarts to the server to enable a notifcation like system). In my solution I've blurred the lines between my model & my viewmodel. If you really wanted to be pendantic about it my "Model" is just the low level classes I have for wrapping my Http requests (e.g GetPropertyAsync(objectLocation, propertyName, completionMethod) ). What I ended up doing is defining a generic class for properties. It looks like this: namespace Premise.Model { //where T : string, bool, int, float public class PremiseProperty { private T _Value; public PremiseProperty(String propertyName) { PropertyName = propertyName; UpdatedFromServer = false; } public T Value { get { return _Value; } set { _Value = value; } } public String PropertyName { get; set; } public bool UpdatedFromServer { get; set; } } } I then created a ViewModelBase (from Mvvm-Light) derived base class PremiseObject which represents the base class each object in the control system is based on (e.g. which is literally called `Object'). The most important method on PremiseObject is it's override of RaisePropertyChanged : /// protected override void RaisePropertyChanged (string propertyName, T oldValue, T newValue, bool sendToServer) { if (sendToServer) SendPropertyChangeToServer(propertyName, newValue); // Check if we are on the UI thread or not if (App.Current.RootVisual == null || App.Current.RootVisual.CheckAccess()) { // broadcast == false because I don't know why it would ever be true base.RaisePropertyChanged(propertyName, oldValue, newValue, false); } else { // Invoke on the UI thread // Update bindings // broadcast == false because I don't know why it would ever be true GalaSoft.MvvmLight.Threading.DispatcherHelper.CheckBeginInvokeOnUI(() => base.RaisePropertyChanged(propertyName, oldValue, newValue, false)); } } Note a few things: 1) I am over-riding/re-purposing the broadcast parameter. If it is True then a the property change is "sent to the server" (I do an HTTP POST). I don't use broadcast property changes anywhere else (and I'm not actually even sure what I would use it for). 2) I always pass broadcast to False when calling base. . PremiseObject has a set of standard PremiseProperty properties on it: Location (the URL to the object), Name, DisplayName, Value (the value property). DisplayName looks like this: protected PremiseProperty _DisplayName = new PremiseProperty ("DisplayName"); public string DisplayName { get { return _DisplayName.Value; } set { if (_DisplayName.Value == value) { return; } var oldValue = _DisplayName; _DisplayName.Value = value; // Update bindings and sendToServer change using GalaSoft.MvvmLight.Messenging RaisePropertyChanged(_DisplayName.PropertyName, oldValue, _DisplayName, _DisplayName.UpdatedFromServer); } } So this means anytime .DisplayName changes within my program it gets relayed to all UI and IF AND ONLY IF _DisplayName.UpdatedFromServer is True does it also get sent back to the server. So how does .UpdatedFromServer get set? When we get our callback from an async Http request: protected void DisplayName_Get(PremiseServer server) { String propertyName = _DisplayName.PropertyName; _DisplayName.UpdatedFromServer = false; server.GetPropertyAsync(Location, propertyName, (HttpResponseArgs) => { if (HttpResponseArgs.Succeeded) { //Debug.WriteLine("Received {0}: {1} = {2}", DisplayName, propertyName, HttpResponseArgs.Response); DispatcherHelper.CheckBeginInvokeOnUI(() => { DisplayName = (String)HttpResponseArgs.Response; // Whenever the UI wants fresh data these XXX_Get functions get called (e.g. on a polling timer, when a view changes, app start, etc...) I have to duplicate the code above for each property I define which is pretty painful, but I have not yet found a way to genericize it (trust me, I've tried, but my knowledge of C# is just not strong enough and I just keep moving the problem). But this works, and works well. To cover all bases, here's an example of the Trigger property on the GarageDoor class: protected PremiseProperty _Trigger = new PremiseProperty ("Trigger"); public bool Trigger { set { if (value == true) RaisePropertyChanged(_Trigger.PropertyName, false, value, true); } } Note how I force the broadcast parameter to RaisePropertyChanged to true and how this is a "Write only" property? This generates an HTTP POST against the 'GarageDoor.Location' URL + ?propertyName= + value.ToString() . I'm pretty happy with this turned out. It's a bit of a hack, but I've now implemented several sophisticated views and it works well. The separation I've created will allow me to change the underling protocol (e.g. batching up requests and having the server only send changed data) and my ViewModels will not have to change. Thoughts, comments, suggestions?
