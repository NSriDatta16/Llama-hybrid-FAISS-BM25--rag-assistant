[site]: stackoverflow
[post_id]: 4352308
[parent_id]: 4352226
[tags]: 
well, lets just test it all out. I can compile, with full optimizations, a more complete example like so: void use(int &); class classWithInt { public: classWithInt() : someInt(){} int someInt; }; class podWithInt { public: int someInt; }; int main() { int foo; classWithInt bar; podWithInt baz; use(foo); use(bar.someInt); use(baz.someInt); return 5; } And this is the output I get from gcc-llvm ; ModuleID = '/tmp/webcompile/_21792_0.bc' target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64" target triple = "x86_64-linux-gnu" %struct.classWithInt = type { i32 } define i32 @main() { entry: %foo = alloca i32, align 4 ; [#uses=1] %bar = alloca %struct.classWithInt, align 8 ; [#uses=1] %baz = alloca %struct.classWithInt, align 8 ; [#uses=1] %0 = getelementptr inbounds %struct.classWithInt* %bar, i64 0, i32 0 ; [#uses=2] store i32 0, i32* %0, align 8 call void @_Z3useRi(i32* %foo) call void @_Z3useRi(i32* %0) %1 = getelementptr inbounds %struct.classWithInt* %baz, i64 0, i32 0 ; [#uses=1] call void @_Z3useRi(i32* %1) ret i32 5 } declare void @_Z3useRi(i32*) There are some differences in each case. In the simplest case, the POD type differs from the plain int in only one way, it requires a different alignment, it's 8 byte aligned instead of just 4 byte. The other noticeable thing is that the POD and bare int do not get initialized. Their storage is used right as is in from the wilderness of the stack. The non-pod type, which has a non-trivial constructor, causes a zero to be stored before the instance can be used for anything else.
