[site]: stackoverflow
[post_id]: 3220940
[parent_id]: 3217596
[tags]: 
Actually, the correct fix in your case is either to change your call to glOrthof to: glOrthof(Left-0.5f, Right-0.5f, Up-0.5f, Down-0.5f, -1.0f, 1.0f); or leave your call to glOrthof in its original form and add a translation when you’re setting up your modelview matrix: glTranslatef(0.5f, 0.5f, 0.0f); The reason for this comes from the OpenGL ES rules for point rasterization, as described in section 3.3.1 of the specification , which states: In the default state, a point is rasterized by truncating its x w and y w coordinates (recall that the subscripts indicate that these are x and y window coordinates) to integers. This ( x , y ) address, along with data derived from the data associated with the vertex corresponding to the point, is sent as a single fragment to the per-fragment stage of the GL. The important thing to note is that the window coordinate of a point is the result of applying the modelview and projection matrices to the point’s position, then scaling by your viewport. In your case, this winds up multiplying your points’ x and y coordinates by the reciprocal of backingWidth and backingHeight , then by backingWidth and backingHeight again, which isn’t guaranteed to leave them exactly integral, because of floating-point rounding at various stages in the calculations. To minimize any occurrences of rounding/truncation putting your points where you don’t expect, you want your point’s final window coordinates to land right on the center of a pixel. Remember that the pixel ( x , y ) in the framebuffer actually corresponds to a rectangle spanning ( x , y ) to ( x +1, y +1), so you want to shift them by 0.5 in both x and y . Both snippets I posted do that, but in different ways. (You need only do one of them.)
