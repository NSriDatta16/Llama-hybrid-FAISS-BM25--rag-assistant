[site]: stackoverflow
[post_id]: 3026886
[parent_id]: 3026724
[tags]: 
Use the first (repetitive) form. The reasons for this are: It's less work. Asserts are debug-only, so the repetition doesn't add any inefficiency to the release build. Don't waste time trying to make code "pretty" or "elegant" when it is already perfectly readable and functional. I'd argue it's actually shorter, more readable, and more easily maintained than your alternatives. When you hit an Assert in your debugger, it's very useful to have the full message in the code so you can see what the assert means. A lot of programmers use Assert(kosherBaconList.SelectedIndex != -1); with no explanation at all, which is fine if you wrote the code, but when you hit someone else's Assert you have no idea what it means . i.e. I know I called your method "wrong", but what the heck do I have to fix to call it "right"? The assert message should therefore indicate what the problem is, and what the person staring at the Assert() call needs to do to fix it. And you want it right there in front of you when your debugger stops in the middle of your test run. Sometimes you'll find it is useful to add additonal information relating to the context in which the assert fired, so you don't have to actually debug the code to work out which of your 3 "identical" asserts failed. I often use assert text like "BaconManager.Cook: You must select..." and "BaconManager.Wrap: You must select..." for this reason. If you include the text in the Assert call, it will not be compiled into your release build. But as soon as you make it a static variable, you will include the (unused) string in your release build, clogging it up with debugging junk. A subroutine could be used if you want to check more than one condition to test the validity of your object, i.e. [Conditional("DEBUG")] private void AssertValidity() { Debug.Assert(kosherBaconList.SelectedIndex != -1, "Nothing selected in kosher bacon list"); Debug.Assert(kosherBaconList.COunt > 0, "kosher bacon list is empty!"); }
