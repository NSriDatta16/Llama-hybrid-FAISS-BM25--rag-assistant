[site]: stackoverflow
[post_id]: 854692
[parent_id]: 852334
[tags]: 
I've done this innumerable times before: it's a very common scenario. There's a number of things which I virtually always do. Don't worry too much about making it the most efficient thing available. If we do wind up spending a lot of time packing and unpacking packets, then we can always change it to be more efficient. Whilst I've not encountered a case where I've had to as yet, I've not been implementing network routers! Whilst using structs/unions is the most efficient approach in term of runtime, it comes with a number of complications: convincing your compiler to pack the structs/unions to match the octet structure of the packets you need, work to avoid alignment and endianness issues, and a lack of safety since there is no or little opportunity to do sanity checks on debug builds. I often wind up with an architecture including the following kinds of things: A packet base class. Any common data fields are accessible (but not modifiable). If the data isn't stored in a packed format, then there's a virtual function which will produce a packed packet. A number of presentation classes for specific packet types, derived from common packet type. If we're using a packing function, then each presentation class must implement it. Anything which can be inferred from the specific type of the presentation class (i.e. a packet type id from a common data field), is dealt with as part of initialisation and is otherwise unmodifiable. Each presentation class can be constructed from an unpacked packet, or will gracefully fail if the packet data is invalid for the that type. This can then be wrapped up in a factory for convenience. If we don't have RTTI available, we can get "poor-man's RTTI" using the packet id to determine which specific presentation class an object really is. In all of this, it's possible (even if just for debug builds) to verify that each field which is modifiable is being set to a sane value. Whilst it might seem like a lot of work, it makes it very difficult to have an invalidly formatted packet, a pre-packed packets contents can be easilly checked by eye using a debugger (since it's all in normal platform-native format variables). If we do have to implement a more efficient storage scheme, that too can be wrapped in this abstraction with little additional performance cost.
