[site]: stackoverflow
[post_id]: 2217699
[parent_id]: 2217413
[tags]: 
Of the technologies you mentioned, JMX isn't relevant to the problem, and while JMS would probably work, it is likely to be overkill (the amount of effort in setting it up can be considerable, depending on your platform). Quartz is also an option, although Quartz's strengths lie in cron-type scheduling and clustered scheduling, neither of which seems to be a requirement for you. Your requirement seems to be to submit a task to a queue, execute those queued tasks one at a time, and if one of them fails for a specific reason, then hold up further processing for a certain amount of time, and then try again with the previous task. The simplest approach I can think of is pretty similar to the other question you mentioned, which is to use the Spring TaskExecutor abstraction , but with a twist. If your requirement is just that the queue should be "held up" for a fixed period of time if a web service failure is detected, then you can handle that entirely within the executing task, e.g. public class MyTask implements Runnable { public void run() { while (true) { try { performWork(); return; } catch (WebServiceFailure f) { sleepForFixedPeriod(); } } } } The configure a ThreadPoolTaskExecutor is Spring, with a maxPoolSize set to 1 . Your client code then submits worker task objects (like the one above) to the executor. If you were to increase the corePoolSize of the executor to a value higher than 1 , then you could take advantage of multiple cores to improve throughput by allowing the executor use multiple threads, but the "catch-and-retry" logic would only apply on a per-thread basis. It's not the most elegant of solutions, but it's very simple, easy to understand and setup.
