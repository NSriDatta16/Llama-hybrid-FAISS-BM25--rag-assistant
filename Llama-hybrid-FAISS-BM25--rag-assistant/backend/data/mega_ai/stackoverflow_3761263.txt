[site]: stackoverflow
[post_id]: 3761263
[parent_id]: 3760933
[tags]: 
All enums must use one of the following types in their declaration: byte , sbyte , short , ushort , int , uint , long or ulong . This is how you specify a type: enum MyEnum3 : long { Value1 = 5L, Value2 = 9L, Value3 = long.MaxValue } If you don't specify a type, the default is int . Unfortunately you can't specify char as an underlying type. You could create that "extension" as a custom attribute: [AttributeUsage(AttributeTargets.Enum)] public class CharAttribute : Attribute { } [Char] enum MyEnum2 { Value1 = 'a', Value2 = 'b', Value3 = 'c' } And then have a class like this: public static class EnumEx { public static Type GetUnderlyingType(Type enumType) { if (!enumType.IsEnum) throw new ArgumentException(); if (enumType.GetCustomAttributes(typeof(CharAttribute), false).Length > 0) { return typeof(char); } return Enum.GetUnderlyingType(enumType); } public static object ConvertToUnderlyingType(object enumValue) { return Convert.ChangeType(enumValue, GetUnderlyingType(enumValue.GetType())); } } (Incidently, the method Enum.GetUnderlyingType seems to be the one you were looking for, but it never returns char because you can't have char enums in the language.) This will allow you to get to your extended notion of char enums: var value3 = EnumEx.ConvertToUnderlyingType(MyEnum2.Value3); Console.WriteLine(value3); This will print c to the console. Pay attention to the underlying type and the values of your char enums, they should ideally fit into a char to avoid conversion failures (overflows). The safe types are 16-bit wide (just like char ) or less: byte , sbyte , short or ushort . Other types are OK if the values in the enum can be converted to 16-bit chars without loss of precision (just like in the example above). Using the default ( int ) underlying type and char literals as the enum values (which are implicitly convertible to int ) is good enough. UPDATE: You can declare a char enum in F#: namespace Drawing type Color = | Red = 'r' | Green = 'g' | Blue = 'b' In C#, you can use it like this: Console.WriteLine(Enum.GetUnderlyingType(typeof(Color))); And it will print System.Char . But ... C# will complain if you try to use its values. This: Console.WriteLine(Color.Red.ToString()); Gives a compiler error: error CS0570: 'Drawing.Color.Red' is not supported by the language In VB.NET there's no compilation error, but there's a runtime error from Enum.GetName . It seems that the runtime is not prepared to deal with char enums. This is an excerpt from that method (from Reflector): if (((!type.IsEnum && (type != intType)) && ((type != typeof(short)) && (type != typeof(ushort)))) && (((type != typeof(byte)) && (type != typeof(sbyte))) && (((type != typeof(uint)) && (type != typeof(long))) && (type != typeof(ulong))))) { throw new ArgumentException(Environment.GetResourceString("Arg_MustBeEnumBaseTypeOrEnum"), "value"); } It checks not only that the type is an enum, but that it also is one of the aforementioned underlying types (for which char is not an option). So you really shouldn't create char enums in F#. You could use the "extension" approach I've described.
