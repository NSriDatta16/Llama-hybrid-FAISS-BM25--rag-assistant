[site]: stackoverflow
[post_id]: 5354960
[parent_id]: 5353877
[tags]: 
Any ideas why this deadlock is occuring? InnoDB has a number of locking modes . We're seeing a row-level lock here, but it's failing. Transaction #1 is waiting for an exclusive lock: RECORD LOCKS ... page no 232059 ... lock_mode X locks rec but not gap waiting Transaction #2 already has a shared lock on the same row: RECORD LOCKS ... page no 232059 ... lock mode S locks rec but not gap While #2 has the shared lock, it also wants an exclusive lock: RECORD LOCKS ... page no 232059 ... lock_mode X locks rec but not gap waiting Both #1 and #2 need the same exclusive lock, but neither lock can be granted until #2 releases the shared lock , but #2 can't release the shared lock until it's upgraded to exclusive, but that will never happen. This causes a deadlock, and InnoDB will kill one of the two transactions and perform a rollback. A similar situation is described on the documentation page I linked. You have two ways to handle this. The first and worst way would be to perform table locking instead of using a transaction. This will prevent multiple writers (or optionally readers) from modifying the table at once. This will probably impact performance, and opens up even worse deadlock situations. Further, you can't mix table locks and transactions. The second and better way is to modify your application to deal with deadlocks elegantly. This means making sure that the rollback happened and either trying again or presenting an appropriate error to the user.
