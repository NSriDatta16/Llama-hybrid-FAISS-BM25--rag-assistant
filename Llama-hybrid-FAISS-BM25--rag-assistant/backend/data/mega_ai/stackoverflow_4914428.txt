[site]: stackoverflow
[post_id]: 4914428
[parent_id]: 4914184
[tags]: 
Raw pointers are only one potential cause of memory leaks. Even if you use smart pointers, like shared_ptr, you can get a leak if you have a cycle - the cure for this is to use a weak_ptr somewhere to break the cycle. Using smart pointers is not a cure-all for memory leaks. You can also forget a virtual destructor in a base class, and get leaks that way. Even if there are no problems with new-ed objects not being deleted, a long-running process can grow (and appear to leak) because of address space fragmentation. Tools like valgrind are very, very useful for finding leaks, but they won't always tell you where the fix should be (e.g. in the case of cycles or objects holding onto smart pointers)
