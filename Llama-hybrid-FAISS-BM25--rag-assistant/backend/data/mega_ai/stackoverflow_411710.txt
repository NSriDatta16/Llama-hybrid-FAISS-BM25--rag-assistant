[site]: stackoverflow
[post_id]: 411710
[parent_id]: 411254
[tags]: 
Java is strongly-typed. PHP isn't; PHP does a lot of implicit type conversion, which can actually be problematic and is why PHP5 has operators like === and !== . Java's implicit type conversion is primarily limited to auto-boxing of primitive types (PHP has no primitive types). This often comes up. Consider: $val = 'a'; if (strpos('abcdefghij', $val)) { // do stuff } which is incorrect and will have the block not executed because the return index of 0 is converted to false . The correct version is: $val = 'a'; if (strpos('abcdefghij', $val) !== false) { // do stuff } Java conditional statements require an explicit boolean ; PHP variables and arrays are all prepended by $ and otherwise indistinguishable; The equivalent of PHP associative arrays is PHP Maps (eg HashMap ). Associative arrays are ordered on insertion order and can be used like ordinary arrays (on the values). Theres one Map implementation that maintains insertion order in Java but this is the exception rather than the norm; $arr['foo'] = 'bar' insert or update an element in an associative array. Java must use Map.put() and Map.get() ; PHP5 has the equivalent of function pointers and anonymous functions (using create_function() ); 5.3 introduces closures at the language level. Java must use inner classes for both, which is somewhat more verbose. Moreover, inner classes are limited in how they can access variables from the outer scope (read Java Closures on JavaPapers), making them not as powerful as true closures. Variable declaration is optional in PHP; Use of global variables within functions requires explicit use of the global keyword in PHP; POST/GET parameters are, unless configured otherwise ( register_globals() ) automatically result in global variables of the same name. They can alternatively be accessed via the $_POST global variable (and $_SESSION for session variables) whereas support for these things comes from a JEE add-on called the servlets API via objects like HttpServletRequest and HttpSession ; Function declaration in PHP uses the function keyword whereas in Java you declare return types and parameter types; PHP function names can't normally clash whereas Java allows method overloading as long as the different method signatures aren't ambiguous; PHP has default values for function arguments. Java doesn't. In Java this is implemented using method overloading. PHP supports the missing-method pattern, which is confusingly called " overloading " in the PHP docs. Compare: function do_stuff($name = 'Foo') { // ... } to void doStuff() { doStuff("Foo"); } void doStuff(String what) { // ... } String constants in PHP are declared using single or double quotes, much like Perl. Double quotes will evaluate variables embedded in the text. All Java String constants use double quotes and have no such variable evaluation; PHP object method calls use the -> operator. Java uses the . operator; Constructors in Java are named after the class name. In PHP they are called __construct() ; In Java objects, this is implicit and only used to be explicit about scope and in certain cases with inner classes. In PHP5, $this is explicit; Static methods in Java can be called with either the . operator on an instance (although this is discouraged it is syntactically valid) but generally the class name is used instead. These two are equivalent: float f = 9.35f; String s1 = String.valueOf(f); String s2 = "My name is Earl".valueOf(f); but the former is preferred. PHP uses the :: scope resolution operator for statics; Method overriding and overloading is quite natural in Java but a bit of a kludge in PHP; PHP code is embedded in what is otherwise largely an HTML document, much like how JSPs work; PHP uses the . operator to append strings. Java uses + ; Java 5+ methods must use the ellipsis ( ... ) to declare variable length argument lists explicitly. All PHP functions are variable length; Variable length argument lists are treated as arrays inside method bodies. In PHP you have to use func_get_args() , func_get_arg() and/or func_num_args() ; and no doubt more but thats all that springs to mind for now.
