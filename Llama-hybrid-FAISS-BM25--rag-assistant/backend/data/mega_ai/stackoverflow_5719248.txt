[site]: stackoverflow
[post_id]: 5719248
[parent_id]: 
[tags]: 
Help with moving CGPoint (cocos2d)

I don't know how the best way is to explain what I am trying to do, but I will give it a shot. So I have a football on the screen and when I touch the screen I can drag my finger across the screen which by using a CCProgressTimer gives me a representation of the power of the throw. In other words it is like having a volume bar on the screen and when I touch the screen and drag away from the volume bar it starts to increase and dragging towards the volume bar decreases it. So my question is I am recording my touch when I touch the screen and that touch is what all the calculations are based off of, but I want to some how be able to no matter where I am on the screen be able to decrease or increase. The way it works right now is, I can't start to decrease the power of the throw until I reach that recorded touch. Is it possible to have it work, where when the power is at %100 no matter where I am on the screen if I drag back towards the football to have it decrease before I reach that original touch on the screen. Here is my code. footballPath = [CCProgressTimer progressWithFile:@"footballPath.png"]; footballPath.visible = NO; footballPath.percentage = 0; footballPath.type = kCCProgressTimerTypeHorizontalBarLR; footballPath.anchorPoint = ccp(0, 0.5); [self addChild:footballPath]; -(BOOL)ccTouchBegan:(UITouch*)touch withEvent:(UIEvent *)event { cachedTouchPt = [self convertTouchToNodeSpace:touch]; if (!self.currentFootball.footballHasEmbarked) { footballPath.percentage = 0; [self updateArrowWithTouch:touch]; arrow.visible = YES; footballPath.visible = YES; return YES; } else { return NO; } } -(void) ccTouchMoved:(UITouch *)touch withEvent:(UIEvent *)event { [self updateArrowWithTouch:touch]; } -(void) ccTouchEnded:(UITouch*)touch withEvent:(UIEvent *)event { const float max = 100; CGPoint touchPt = [self convertTouchToNodeSpace:touch]; if (touchPt.x > self.currentFootball.position.x) { touchPt = ccp(self.currentFootball.position.x, touchPt.y); } arrow.visible = NO; footballPath.visible = NO; self.currentFootball.footballHasEmbarked = YES; self.currentFootball.spiraling = YES; if (self.currentFootball) { [smgr morphShapeToActive:self.currentFootball.shape mass:25]; } diff = ccpSub(touchPt, self.currentFootball.position); if (diff.x == 0 && diff.y == 0) { diff = ccp(1, 1); } float len = footballPath.percentage; CGPoint norm = ccpNormalize(diff); if (len > max){ len = max; } [self.currentFootball applyImpulse:ccpMult(norm, (len * 245))]; pos = self.currentFootball.position.y; [self schedule:@selector(newFootball)]; } - (void) updateArrowWithTouch: (UITouch*) touch { const float distFromFb = 100; CGPoint touchPt = [self convertTouchToNodeSpace:touch]; if (touchPt.x > self.currentFootball.position.x) { touchPt = ccp(self.currentFootball.position.x, touchPt.y); } CGPoint fpt = self.currentFootball.position; CGPoint vect = ccpSub(touchPt, fpt); float dist = ccpLength(vect); CGPoint vect2 = ccpSub(touchPt, cachedTouchPt); float dist2 = ccpLength(vect2); float degrees = -CC_RADIANS_TO_DEGREES(ccpToAngle(vect)); float factor = dist2; CGPoint normalVect = ccpMult(vect, 1/dist); factor = distFromFb; CGPoint newPoint = ccpAdd(fpt, ccpMult(normalVect, factor)); if (newPoint.x The cachedTouchPt = [self convertTouchToNodeSpace:touch]; is the original point that I am talking about. So when I touch the screen it makes a new point and stores it in cachedTouchPt, and so I can't decrease the the power/CCProgressTimer until I reach the X and Y of the cachedTouchPt. If I didn't make sense of what I was trying to say. I need to be able to decrease the power/CCProgressTimer without needing to be at the original point. Is there a way reset the point so that no matter where I am on the screen I can drag towards the football and have it decrease, same with the increasing.
