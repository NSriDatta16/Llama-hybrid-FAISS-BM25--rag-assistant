[site]: stackoverflow
[post_id]: 3927399
[parent_id]: 3924733
[tags]: 
This solution demonstrates the usage of custom attributes, as Robert suggested. First, the custom attribute class definition: // match the properties to the xml dynamically using this attribute... [AttributeUsage(AttributeTargets.Property)] public class DBSPropAttribute : Attribute { public string MappingField { get; set; } public DBSPropAttribute(string fieldName) { MappingField = fieldName; } } The custom attribute is then applied to the SessionProperties class like this: [DBSProp("archiveDays")] public int ArchiveDays { get; set; } In the SessionProperties class, I'm also going to define this converter dictionary, a very elegant idea of Robert's: // map CLR types to convert methods; you'll need one entry in // this map for every CLR type private static readonly Dictionary > TypeConverterMap = new Dictionary > { { typeof(bool), x => Convert.ToBoolean(x)}, { typeof(int), x => Convert.ToInt32(x)}, { typeof(string), x => x}, { typeof(double), x => Convert.ToDouble(x)} }; Finally the class will implement the following method to bind the XML to the object properties: public void SetPropertyValues(IEnumerable elements) { var propList = typeof(SessionProperties).GetProperties(); foreach (var elm in elements) { var nm = elm.Element("name").Value; var val = elm.Element("value").Value; // MUST throw an exception if there are no matches... var pi = propList.First(c => c.GetCustomAttributes(true) .OfType () .First() .MappingField == nm); pi.SetValue(this, TypeConverterMap[pi.PropertyType](val), null); } } Thanks again to Robert for illustrating the key concepts which led to this answer. I think it's a nice alternative to his equally valid approach.
