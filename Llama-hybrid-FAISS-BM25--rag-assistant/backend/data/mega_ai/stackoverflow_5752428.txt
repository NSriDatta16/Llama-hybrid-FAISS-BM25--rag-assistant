[site]: stackoverflow
[post_id]: 5752428
[parent_id]: 5738207
[tags]: 
I tried several things to work this out, but in every case, the event for editableCellDidEndEditing:cell: always would be handled after the changes were committed. I tried changing the order of my code to see if I could get the event to be handled sooner. I tried replacing the method doneSave with two methods, where the first method, willSaveOnExit , queues an event to call the second method, didSaveOnExit . The idea was to put the commit operation into didSaveOnExit and have the event queued after the editableCellDidEndEditing . Unfortunately, I discovered that the event calling editableCellDidEndEditing:cell was never generated until the view controller was popped and the previous view had appeared. So trying to rearrange the event queue was pointless. I lost patience trying to figure out a way around that, because I couldn't think of a way to communicate to the detailed view controller that the previous view had appeared. (I could probably figure it out, but, at the time, I wasn't feeling too creative in that direction.) None of the above was necessary, after all. Here is what I ended up doing: (which is very much like what I suggested in my question) I created an ivar in the tableviewcontroller called currentCell, which I set in the method editableCellDidBeginEditing:cell: pointing to the cell where editing is being done. currentCell is initialized to nil in viewDidAppear I changed this code (see my question for the original), wrapping the code in the conditional - (void)editableCellDidEndEditing:(EditableCell *)cell { if (currentCell){ [clientMO setValue:currentCell.textField.text forKey:currentCell.keyName]; // update the value } } I changed the Save button handler method to this - (void) doneSave { [self editableCellDidEndEditing:currentCell]; currentCell = nil; [dataInterface commitChangesAndNotify:@"clientUpdate"]; [self.navigationController popViewControllerAnimated:YES]; } (adding the first two lines to the version in my question) Now, I know that if the save button has been pressed, then the user is done editing, so I want to call editableCellDidEndEditing:cell: one last time before I commit the changes . But since my code is calling (rather than the event handler) I have to provide the cell pointer, which I obtained when the cell edit began, and had put in currentCell. I then set currentCell to nil, indicating that there is no longer a current cell. Now, remember that I said there is still going to be an event queued up for editableCellDidEndEditing:cell: by the time the previous view appears. When that method executes, the conditional test for currentCell (!=nil) drops through, and the code is bypassed. So in the end, it appears that everything is working in the right order, even though the superfluous call to editableCellDidEndEditing:cell: still is occurring. I'm happy for now.
