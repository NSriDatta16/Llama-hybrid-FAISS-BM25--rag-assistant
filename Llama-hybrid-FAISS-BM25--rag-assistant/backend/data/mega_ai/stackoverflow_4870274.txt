[site]: stackoverflow
[post_id]: 4870274
[parent_id]: 4870188
[tags]: 
The size of a Java array is fixed when you allocate it, and cannot be changed. If you want to "grow" or "shrink" an existing array, you have to allocate a new array of the appropriate size and copy the array elements; e.g. using System.arraycopy(...) or Arrays.copyOf(...) . A copy loop works as well, though it looks a bit clunky ... IMO. If you want to "delete" an item or items from an array (in the true sense ... not just replacing them with null ), you need to allocate a new smaller array and copy across the elements you want to retain. Finally, you can "erase" an element in an array of a reference type by assigning null to it. But this introduces new problems: If you were using null elements to mean something, you can't do this. All of the code that uses the array now has to deal with the possibility of a null element in the appropriate fashion. More complexity and potential for bugs 1 . There are alternatives in the form of 3rd-party libraries (e.g. Apache Commons ArrayUtils ), but you may want to consider whether it is worth adding a library dependency just for the sake of a method that you could implement yourself with 5-10 lines of code. It is better (i.e. simpler ... and in many cases, more efficient 2 ) to use a List class instead of an array. This will take care of (at least) growing the backing storage. And there are operations that take care of inserting and deleting elements anywhere in the list. For instance, the ArrayList class uses an array as backing, and automatically grows the array as required. It does not automatically reduce the size of the backing array, but you can tell it to do this using the trimToSize() method; e.g. ArrayList l = ... l.remove(21); l.trimToSize(); // Only do this if you really have to. 1 - But note that the explicit if (a[e] == null) checks themselves are likely to be "free", since they can be combined with the implicit null check that happens when you dereference the value of a[e] . 2 - I say it is "more efficient in many cases" because ArrayList uses a simple "double the size" strategy when it needs to grow the backing array. This means that if grow the list by repeatedly appending to it, each element will be copied on average one extra time. By contrast, if you did this with an array you would end up copying each array element close to N/2 times on average.
