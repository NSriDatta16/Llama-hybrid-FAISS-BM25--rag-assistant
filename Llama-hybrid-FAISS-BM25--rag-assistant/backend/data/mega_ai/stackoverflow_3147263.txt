[site]: stackoverflow
[post_id]: 3147263
[parent_id]: 3147014
[tags]: 
For practical purposes, the answer to your question is yes. Modern operating systems will generally release memory allocated by a process when that process is shut down. However, to depend on this behavior is a very shoddy practice. Even if we can be assured that operating systems will always function this way, the code is fragile. If some function that fails to free memory suddenly gets reused for another purpose, it might translate to an application-level memory leak. Nevertheless, the nature of this question and the example posted requires, ethically, for me to point you and your team to look at RAII. int *pIntPtr = new int; ... delete pIntPtr; This code reeks of memory leaks. If anything in [...] throws, you have a memory leak. There are several solutions: int *pIntPtr = 0; try { pIntPtr = new int; ... } catch (...) { delete pIntPtr; throw; } delete pIntPtr; Second solution using nothrow (not necessarily much better than first, but allows sensible initialization of pIntPtr at the time it is defined): int *pIntPtr = new(nothrow) int; if (pIntPtr) { try { ... } catch (...) { delete pIntPtr; throw; } delete pIntPtr; } And the easy way: scoped_ptr pIntPtr(new int); ... In this last and finest example, there is no need to call delete on pIntPtr as this is done automatically regardless of how we exit this block (hurray for RAII and smart pointers).
