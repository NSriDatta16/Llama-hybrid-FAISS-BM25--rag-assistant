[site]: stackoverflow
[post_id]: 3277522
[parent_id]: 3277449
[tags]: 
This may or may not be of interest, but here's a regex I wrote that mostly conforms to RFC3986 (it's actually slightly stricter, as it disallows some of the more unusual URI syntaxes): ~^(?:(?:(?P [a-z][0-9a-z.+-]*?)://)?(?P (?:(?P (?P (?:[\w.\~-]|(?:%[\da-f]{2})|[!$&'()*+,;=])*)?:(?P (?:[\w.\~-]|(?:%[\da-f]{2})|[!$&'()*+,;=])*)?|(?:[\w.\~-]|(?:%[\da-f]{2})|[!$&'()*+,;=]|:)*?)@)?(?P (?P (?:[a-z](?:[0-9a-z-]*(?:[0-9a-z]))?\.)+(?:[a-z](?:[0-9a-z-]*(?:[0-9a-z]))?))|(?P (?:25[0-5]|2[0-4]\d|[01]\d\d|\d?\d).(?:25[0-5]|2[0-4]\d|[01]\d\d|\d?\d).(?:25[0-5]|2[0-4]\d|[01]\d\d|\d?\d).(?:25[0-5]|2[0-4]\d|[01]\d\d|\d?\d)))(?::(?P \d+))?(?=/|$)))?(?P /?(?:(?:[\w.\~-]|(?:%[\da-f]{2})|[!$&'()*+,;=]|:|@)+/)*(?:(?:[\w.\~-]|(?:%[\da-f]{2})|[!$&'()*+,;=]|:|@)+/?)?)(?:\?(?P (?:(?:[\w.\~-]|(?:%[\da-f]{2})|[!$&'()*+,;=]|:|@)|/|\?)*?))?(?:#(?P (?:(?:[\w.\~-]|(?:%[\da-f]{2})|[!$&'()*+,;=]|:|@)|/|\?)*))?$~i The named components are: scheme authority userinfo username password domain ip path query fragment And here's the code that generates it (along with variants defined by some options): public static function validateUri($uri, &$components = false, $flags = 0) { if (func_num_args() > 3) { $flags = array_slice(func_get_args(), 2); } if (is_array($flags)) { $flagsArray = $flags; $flags = array(); foreach ($flagsArray as $flag) { if (is_int($flag)) { $flags |= $flag; } } } // Set options. $requireScheme = !($flags & self::URI_ALLOW_NO_SCHEME); $requireAuthority = !($flags & self::URI_ALLOW_NO_AUTHORITY); $isRelative = (bool)($flags & self::URI_IS_RELATIVE); $requireMultiPartDomain = (bool)($flags & self::URI_REQUIRE_MULTI_PART_DOMAIN); // And we're awayâ€¦ // Some character types (taken from RFC 3986: https://www.rfc-editor.org/rfc/rfc3986). $hex = '[\da-f]'; // Hexadecimal digit. $pct = "(?:%$hex{2})"; // "Percent-encoded" value. $gen = '[\[\]:/?#@]'; // Generic delimiters. $sub = '[!$&\'()*+,;=]'; // Sub-delimiters. $reserved = "(?:$gen|$sub)"; // Reserved characters. $unreserved = '[\w.\~-]'; // Unreserved characters. $pChar = "(?:$unreserved|$pct|$sub|:|@)"; // Path characters. $qfChar = "(?:$pChar|/|\?)"; // Query/fragment characters. // Other entities. $octet = '(?:25[0-5]|2[0-4]\d|[01]\d\d|\d?\d)'; $label = '[a-z](?:[0-9a-z-]*(?:[0-9a-z]))?'; $scheme = '(?:(?P [a-z][0-9a-z.+-]*?)://)'; // Authority components. $userInfo = "(?:(?P (?P (?:$unreserved|$pct|$sub)*)?:(?P (?:$unreserved|$pct|$sub)*)?|(?:$unreserved|$pct|$sub|:)*?)@)?"; $ip = "(?P $octet.$octet.$octet.$octet)"; if ($requireMultiPartDomain) { $domain = "(?P (?:$label\.)+(?:$label))"; } else { $domain = "(?P (?:$label\.)*(?:$label))"; } $host = "(?P $domain|$ip)"; $port = '(?::(?P \d+))?'; // Primary hierarchical URI components. $authority = "(?P $userInfo$host$port(?=/|$))"; $path = "(?P /?(?:$pChar+/)*(?:$pChar+/?)?)"; // Final bits. $query = "(?:\?(?P $qfChar*?))?"; $fragment = "(?:#(?P $qfChar*))?"; // Construct the final pattern. $pattern = '~^'; // Only include scheme and authority if the path is not relative. if (!$isRelative) { if ($requireScheme) { // If the scheme is required, then the authority must also be there. $pattern .= $scheme . $authority; } else if ($requireAuthority) { $pattern .= "$scheme?$authority"; } else { $pattern .= "(?:$scheme?$authority)?"; } } else { // Disallow that optional slash we put in $path. $pattern .= '(?!/)'; } // Now add standard elements and terminate the pattern. $pattern .= $path . $query . $fragment . '$~i'; // Finally, validate that sucker! $components = array(); $result = (bool)preg_match($pattern, $uri, $matches); if ($result) { // Filter out all of the useless numerical matches. foreach ($matches as $key => $value) { if (!is_int($key)) { $components[$key] = $value; } } return true; } else { return false; } }
