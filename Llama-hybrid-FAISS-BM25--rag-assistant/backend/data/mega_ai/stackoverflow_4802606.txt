[site]: stackoverflow
[post_id]: 4802606
[parent_id]: 4397883
[tags]: 
Typically data-driven code is easier to read and maintain. I know I've seen cases where data-driven has been taken to the extreme and winds up very unusable (I'm thinking of some SAP deployments I've used), but coding your own "Domain Specific Languages" to help you build your software is typically a huge time saver. The pragmatic programmers remain in my mind the most vivid advocates of writing little languages that I have read. Little state machines that run little input languages can get a lot accomplished with very little space, and make it easy to make modifications. A specific example: consider a progressive income tax system, with tax brackets at $1,000, $10,000, and $100,000 USD. Income below $1,000 is untaxed. Income between $1,000 and $9,999 is taxed at 10%. Income between $10,000 and $99,999 is taxed at 20%. And income above $100,000 is taxed at 30%. If you were write this all out in code, it'd look about as you suspect: total_tax_burden(income) { if (income Adding new tax brackets, changing the existing brackets, or changing the tax burden in the brackets, would all require modifying the code and recompiling. But if it were data-driven, you could store this table in a configuration file: 1000:0 10000:10 100000:20 inf:30 Write a little tool to parse this table and do the lookups (not very difficult, right?) and now anyone can easily maintain the tax rate tables. If congress decides that 1000 brackets would be better, anyone could make the tables line up with the IRS tables, and be done with it, no code recompiling necessary. The same generic code could be used for one bracket or hundreds of brackets. And now for something that is a little less obvious: testing. The AppArmor project has hundreds of tests for what system calls should do when various profiles are loaded. One sample test looks like this: #! /bin/bash # $Id$ # Copyright (C) 2002-2007 Novell/SUSE # # This program is free software; you can redistribute it and/or # modify it under the terms of the GNU General Public License as # published by the Free Software Foundation, version 2 of the # License. #=NAME open #=DESCRIPTION # Verify that the open syscall is correctly managed for confined profiles. #=END pwd=`dirname $0` pwd=`cd $pwd ; /bin/pwd` bin=$pwd . $bin/prologue.inc file=$tmpdir/file okperm=rw badperm1=r badperm2=w # PASS UNCONFINED runchecktest "OPEN unconfined RW (create) " pass $file # PASS TEST (the file shouldn't exist, so open should create it rm -f ${file} genprofile $file:$okperm runchecktest "OPEN RW (create) " pass $file # PASS TEST genprofile $file:$okperm runchecktest "OPEN RW" pass $file # FAILURE TEST (1) genprofile $file:$badperm1 runchecktest "OPEN R" fail $file # FAILURE TEST (2) genprofile $file:$badperm2 runchecktest "OPEN W" fail $file # FAILURE TEST (3) genprofile $file:$badperm1 cap:dac_override runchecktest "OPEN R+dac_override" fail $file # FAILURE TEST (4) # This is testing for bug: https://bugs.wirex.com/show_bug.cgi?id=2885 # When we open O_CREAT|O_RDWR, we are (were?) allowing only write access # to be required. rm -f ${file} genprofile $file:$badperm2 runchecktest "OPEN W (create)" fail $file It relies on some helper functions to generate and load profiles, test the results of the functions, and report back to users. It is far easier to extend these little test scripts than it is to write this sort of functionality without a little language. Yes, these are shell scripts, but they are so far removed from actual shell scripts ;) that they are practically data. I hope this helps motivate data-driven programming; I'm afraid I'm not as eloquent as others who have written about it, and I certainly haven't gotten good at it, but I try.
