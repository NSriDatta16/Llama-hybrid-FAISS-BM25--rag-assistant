[site]: stackoverflow
[post_id]: 4661669
[parent_id]: 4661619
[tags]: 
I have to admit that I haven’t yet delved deeply into C++0x but as far as I see it “merely” offers some primitives for generic parallelization. OpenMP on the other hand is a relatively high-level abstraction to parallelize code with a single purpose: to improve performance by distributing work across multiple CPU cores (rather than, say, improve UI responsiveness, or communicate with an asynchronous channel). OpenMP makes this very easy because it offers a compact syntax and does a lot automatically, e.g. the managing of a thread pool and the scheduling of threads to distribute the work evenly. In the best case, this means that parallelizing an existing algorithm is as easy as putting the following into your code (at the appropriate position): #pragma omp parallel for (Of course it’s usually a bit more complicated.) However, this comes at a cost that is twofold: OpenMP is implemented by means of pragmas and integrates poorly with C++ syntax. For example, the following straightforward-looking code is illegal: void f() { #pragma omp critical { return; } } That’s because you cannot prematurely leave OpenMP “blocks”. Quite the bummer. OpenMP strives to be as platform-independent as possible. As a consequence, it lacks a few interesting primitives. For example, there’s no yield command in OpenMP, and no fetch_and_add primitive, nor a compare_and_swap or LL/CS.
