[site]: stackoverflow
[post_id]: 2616634
[parent_id]: 2616577
[tags]: 
Usually, it is hard to find a good exception handling strategy. Every approach has its drawbacks. In particular, Yours is good in some sense (a centralized location for handling failures) but suffers from this flaw: The exception handler you're describing will have special handling for each possible exception. Over time it will become a focal point of your application: every time you add new functionality you will also need to add exception-processing logic to your handler. This means that: The handler is highly dependents on other parts, a change in impl. of some functionality is likely to trigger corresponding changes in the handler. You will need to be careful in keeping these two in sync. The handler has poor coherency (has many reasons to change) - it contains the intersection of all features of your app. Another problem is error recovery. After an exception is thrown (and a some notification is presented to the user), the user want to continue using the application. This means that if your code started modifying the internal data structures and then stopped due to exception, you will need to undo these modifications (or at least get the data structure back to a workable condition) before you allow additional interaction of the user. Achieving this requires a new thinking about the way your data is organized. One possible solution is to DB transactions. On the other hand, this kind of representation is more complicated than plain-old data structures so you need to weigh it against the needs of your app (is it a toy/prototype?)
