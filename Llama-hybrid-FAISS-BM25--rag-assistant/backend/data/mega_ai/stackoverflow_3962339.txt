[site]: stackoverflow
[post_id]: 3962339
[parent_id]: 
[tags]: 
NSStream Released while reading in, "EXC_BAD_ACCESS" iPhone SDK

I have a view controller that is an NSStreamDelegate, I have a problem when the view is popped from the navigation controller while something is being streamed I get a "EXC_BAD_ACCESS" error. I have tried closing the stream, but it doesn't seem to stop it if there is a stream in progress. What is the proper way to handle this, can you delay the view from popping if something is being streamed? #import "CameraViewer.h" @implementation CameraViewer @synthesize camService; @synthesize currentDownload; // The designated initializer. Override if you create the controller programmatically and want to perform customization that is not appropriate for viewDidLoad. - (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil theService:(NSNetService *)cameraService { if ((self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil])) { // Custom initialization [self setCamService:cameraService]; } return self; } // Implement viewDidLoad to do additional setup after loading the view, typically from a nib. - (void)viewDidLoad { [super viewDidLoad]; [self downloadAgain]; } - (void)viewWillDisappear:(BOOL)animated{ NSLog(@"view is going away"); NSInputStream *istream; [camService getInputStream:&istream outputStream:nil]; [istream close]; NSLog(@"view is gone"); [super viewWillDisappear:animated]; } - (void)downloadAgain{ NSInputStream *istream; [camService getInputStream:&istream outputStream:nil]; [istream retain]; [istream setDelegate:self]; [istream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode]; [istream open]; } #pragma mark NSStream delegate method - (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)event { switch(event) { case NSStreamEventHasBytesAvailable: NSLog(@"Reading Stream"); if (![self currentDownload]) { [self setCurrentDownload:[[NSMutableData alloc] initWithCapacity:409600]]; } uint8_t readBuffer[4096]; int amountRead = 0; NSInputStream * is = (NSInputStream *)aStream; amountRead = [is read:readBuffer maxLength:4096]; [[self currentDownload] appendBytes:readBuffer length:amountRead]; //NSLog(@"case 1"); break; case NSStreamEventEndEncountered: [(NSInputStream *)aStream close]; UIImage *newImage = [[UIImage alloc] initWithData:[self currentDownload]]; [self setCurrentDownload:nil]; if(newImage != nil){ [imageView setImage:newImage]; } [newImage release]; [self performSelector:@selector(downloadAgain) withObject:nil afterDelay:0.25]; break; default: break; } } // Override to allow orientations other than the default portrait orientation. - (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation { return YES; } - (void)didReceiveMemoryWarning { // Releases the view if it doesn't have a superview. [super didReceiveMemoryWarning]; // Release any cached data, images, etc that aren't in use. } - (void)viewDidUnload { [super viewDidUnload]; // Release any retained subviews of the main view. // e.g. self.myOutlet = nil; } - (void)dealloc { [[self camService] release]; [[self currentDownload] release]; [super dealloc]; } @end
