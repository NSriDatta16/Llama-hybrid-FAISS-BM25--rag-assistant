[site]: crossvalidated
[post_id]: 485968
[parent_id]: 485533
[tags]: 
The strategy is to simulate the coefficients from the joint normal distribution of all parameters, including the $\phi$ parameter. The reason is that the coefficients for $\mu$ and $\phi$ are not orthogonal, i.e., depend on each other. After having obtained the full simulated parameter vector, you can than compute any quanity you want from the relevant subset of parameters. I would recommend though to use a log-link for the $\phi$ in this case because the normal approximation will typically be much better on the log-scale because the parameters are unbounded. The easiest way to achieve that is to specify a two-part formula: perc_degr ~ time | 1 in your case, declaring that $\mu$ depends on time but $\phi$ is constant. Moreover, I would encourage you to consider a model with varying $\phi$ though: perc_degr ~ time | time where both parameters are allowed to change over time . As a worked example, consider the following illustration based on a (too) simple model for the ReadingSkills data available in the package: library("betareg") data("ReadingSkills", package = "betareg") m Then we can simulate 10,000 draws from the full parameter vector (using mvtnorm rather than MASS ): library("mvtnorm") set.seed(1) cf And then we can compute any quantity we want. For example, we can compute the negative ratio of coefficients for $\mu$ and compare it with the quantity at the estimated coefficients: hist(-cf[,1]/cf[,2], main = "") abline(v = -coef(m)[1]/coef(m)[2], col = 2, lwd = 2) In this particular model this plot looks rather bad because we have to extrapolate quite a bit. Hence I'm also showing another quantity which looks a bit more reasonable on this data set. Let's also compute the predicted $\mu$ at regressor iq set to -1, 0, and 1. So we set up a suitable 10,000 x 3 matrix and compute the predicted $\mu$ with the inverse link from the fitted model object: x $link$ mean$linkinv(cf[,1] + cf[,2] * x) mu0 The fitted quantity from the original model is also added for comparison: for(i in 1:3) { hist(mu[, i], main = "", xlab = paste("x =", x[1,i]), xlim = c(0.5, 1)) abline(v = mu0[i], col = 2, lwd = 2) }
