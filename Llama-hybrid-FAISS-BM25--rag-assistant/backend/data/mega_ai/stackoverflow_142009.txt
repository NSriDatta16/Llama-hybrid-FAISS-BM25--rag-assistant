[site]: stackoverflow
[post_id]: 142009
[parent_id]: 141875
[tags]: 
The problem is that you seem to want to perform both syntactical and semantical checking in your lexer and/or your parser. It's a common mistake, and something that is only possible in very simple languages. What you really need to do is accept more broadly in the lexer and parser, and then perform semantic checks. How strict you are in your lexing is up to you, but you have two basic options, depending on whether or not you need to accept zeroes preceding your days of the month: 1) Be really accepting for your INTs, 2) define DATENUM to only accept those tokens that are valid days, yet not valid INTs. I recommend the second because there will be less semantic checks necessary later in the code (since INTs will then be verifiable at the syntax level and you'll only need to perform semantic checks on your dates. The first approach: INT: '0'..'9'+; The second approach: DATENUM: '0' '1'..'9'; INT: '0' | SIGN? '1'..'9' '0'..'9'*; After accepting using these rules in the lexer, your date field would be either: date: INT '/' INT ( '/' INT )? or: date: (INT | DATENUM) '/' (INT | DATENUM) ('/' (INT | DATENUM) )? After that, you would perform a semantic run over your AST to make sure that your dates are valid. If you're dead set on performing semantic checks in your grammar, however, ANTLR allows semantic predicates in the parser, so you could make a date field that checks the values like this: date: month=INT '/' day=INT ( year='/' INT )? { year==null ? (/* First check /*) : (/* Second check */)} When you do this, however, you are embedding language specific code in your grammar, and it won't be portable across targets.
