[site]: stackoverflow
[post_id]: 4684911
[parent_id]: 4684636
[tags]: 
Unless you're planning on instantiating your Foo-object through some Data Repository Retrieval method, this would require dynamic compilation to inject the necessary into your getter and setters. I would instead recommend you to look at a pattern like this var foo = DataRepository.GetObject (some_id); the method signature of GetObject would be public static T GetObject (object id) where T: new() In the GetObject method you will reflect over the type finding all its Field-attributes and mapping them to a actual database call. This is very simple and common approach and can be achieved like this public static IEnumerable > GetFieldAttributes () { var properties = typeof(T).GetProperties(); foreach (var prop in properties) { var attribute = prop.GetCustomAttributes(typeof(FieldAttribute), true).FirstOrDefault(); if (attribute != null) { yield return new Tuple (prop, attribute); } } } Now with a list og attributes you can construct a sql-string like this var columns = GetFieldAttributes ().Select(t => t.Item2.FieldName); var sql = "SELECT "+ String.Join("," columns) +" FROM table WHERE id = "+ id; var result = ... execute the query and return ie a datareader With the result you can instantiate a Foo-instance, fill out its properties and return the instance var instance = new T(); result.Read() var dictionary = new Dictionary (); // get the columns returned from database for (int i = 0; i
