[site]: stackoverflow
[post_id]: 583041
[parent_id]: 582115
[tags]: 
Thanks for all your answers. I think we can forget about the problem. I created a new service application and performed quick post message tests. The messages were delivered correctly, so I hope I can now state that normally everything works fine and something is wrong only with this one service I described. I know it is stupid, but I will just try to copy one fragment of code after another from the 'bad' service to a new one. Maybe this will help me find the reason of the problem. I hope I can now consider the message-waiting loop unnecessary as long as everything works fine without it, can't I? If it comes to the privileges, Microsoft says: "UAC uses WIM to block Windows messages from being sent between processes of different privilege levels.". My Vista's UAC is off and I did not set any privileges for those services I described. Apart from that I do not send messages between different processes. Messages are sent within one process. To give you the idea of what I am doing, I'll show you a code snippet from a test service application. uses ...; type TMyThread = class; TMyClass = class private FThread: TMyThread; procedure ReadMessage(var Msg: TMessage); public FHandle: HWND; constructor Create; destructor Destroy; override; end; TMyThread = class(TThread) private FMyClass: TMyClass; protected procedure Execute; override; constructor Create(MyClass: TMyClass); reintroduce; end; implementation { TMyClass } constructor TMyClass.Create; begin inherited Create; FHandle := AllocateHWnd(ReadMessage); FThread := TMyThread.Create(Self); end; destructor TMyClass.Destroy; begin FThread.Terminate; FThread.WaitFor; FThread.Free; DeallocateHWnd(FHandle); inherited Destroy; end; procedure TMyClass.ReadMessage(var Msg: TMessage); begin Log.Log('message read: ' + IntToStr(Msg.Msg)); end; { TMyThread } constructor TMyThread.Create(MyClass: TMyClass); begin inherited Create(True); FMyClass := MyClass; Resume; end; procedure TMyThread.Execute; begin while not Terminated do begin //do some work and //send a message when finished if PostMessage(FMyClass.FHandle, WM_USER, 0, 0) then Log.Log('message sent') else Log.Log('message not sent: ' + SysErrorMessage(GetLastError)); //do something else... Sleep(1000); end; end; This is only an example, but functioning of my real code bases on the same idea. When you create an object of this class, it will create a thread that will start sending messages to that class. Log.Log() saves data into a text file. When I use this code in a new service application, everything works fine. When i put it into the 'broken' service, it does not. Please note that I do not use any message-waiting loop to receive messages. I created a new service and just put the code above into it, then created an object of the class. That's all. If I get to know why this does not work in the 'broken' service, I'll write about it. Thanks for the time you devoted me. Mariusz.
