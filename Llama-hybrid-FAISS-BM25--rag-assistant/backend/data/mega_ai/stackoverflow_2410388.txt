[site]: stackoverflow
[post_id]: 2410388
[parent_id]: 
[tags]: 
TCP, HTTP and the Multi-Threading Sweet Spot

I'm trying to understand the performance numbers I'm getting and how to determine the optimal number of threads. See the bottom of this post for my results I wrote an experimental multi-threaded web client in perl which downloads a page, grabs the source for each image tag and downloads the image - discarding the data. It uses a non-blocking connect with an initial per file timeout of 10 seconds which doubles after each timeout and retry. It also caches IP addresses so each thread only has to do a DNS lookup once. The total amount of data downloaded is 2271122 bytes in 1316 files via 2.5Mbit connection from http://hubblesite.org/gallery/album/entire/npp/all/hires/true/ . The thumbnail images are hosted by a company which claims to specialize in low latency for high bandwidth applications. Wall times are: 1 Thread takes 4:48 -- 0 timeouts 2 Threads takes 2:38 -- 0 timeouts 5 Threads takes 2:22 -- 20 timeouts 10 Threads take 2:27 -- 40 timeouts 50 Threads take 2:27 -- 170 timeouts In the worst case ( 50 threads ) less than 2 seconds of CPU time are consumed by the client. avg file size 1.7k avg rtt 100 ms ( as measured by ping ) avg cli cpu/img 1 ms The fastest average download speed is 5 threads at about 15 KB / sec overall. The server actually does seem to have pretty low latency as it takes only 218 ms to get each image meaning it takes only 18 ms on average for the server to process each request: 0 cli sends syn 50 srv rcvs syn 50 srv sends syn + ack 100 cli conn established / cli sends get 150 srv recv's get 168 srv reads file, sends data , calls close 218 cli recv HTTP headers + complete file in 2 segments MSS == 1448 I can see that the per file average download speed is low because of the small file sizes and the relatively high cost per file of the connection setup. What I don't understand is why I see virtually no improvement in performance beyond 2 threads. The server seems to be sufficiently fast, but already starts timing out connections at 5 threads. The timeouts seem to start after about 900 - 1000 successful connections whether it's 5 or 50 threads, which I assume is probably some kind of throttling threshold on the server, but I would expect 10 threads to still be significantly faster than 2. Am I missing something here? EDIT-1 Just for comparisons sake I installed the DownThemAll Firefox extension and downloaded the images using it. I set it to 4 simultaneous connections with a 10 second timeout. DTM took about 3 minutes to download all the files + write them to disk, and it also started experiencing timeouts after about 900 connections. I'm going to run tcpdump to try and get a better picture what's going on at the tcp protocol level. I also cleared Firefox's cache and hit reload. 40 Seconds to reload the page and all the images. That seemed way too fast - maybe Firefox kept them in a memory cache which wasn't cleared? So I opened Opera and it also took about 40 seconds. I assume they're so much faster because they must be using HTTP/1.1 pipelining? And the Answer Is!?? So after a little more testing and writing code to reuse the sockets via pipelining I found out some interesting info. When running at 5 threads the non-pipelined version retrieves the first 1026 images in 77 seconds but takes a further 65 seconds to retrieve the remaining 290 images. This pretty much confirms MattH's theory about my client getting hit by a SYN FLOOD event causing the server to stop responding to my connection attempts for a short period of time. However, that is only part of the problem since 77 seconds is still very slow for 5 threads to get 1026 images; if you remove the SYN FLOOD issue it would still take about 99 seconds to retrieve all the files. So based on a little research and some tcpdump 's it seems like the other part of the issue is latency and the connection setup overhead. Here's where we get back to the issue of finding the "Sweet Spot" or the optimal number of threads. I modified the client to implement HTTP/1.1 Pipelining and found that the optimal number of threads in this case is between 15 and 20. For example: 1 Thread takes 2:37 -- 0 timeouts 2 Threads takes 1:22 -- 0 timeouts 5 Threads takes 0:34 -- 0 timeouts 10 Threads take 0:20 -- 0 timeouts 11 Threads take 0:19 -- 0 timeouts 15 Threads take 0:16 -- 0 timeouts There are four factors which affect this; latency / rtt , maximum end-to-end bandwidth, recv buffer size and the size of the image files being downloaded. See this site for a discussion on how receive buffer size and RTT latency affect available bandwidth . In addition to the above, average file size affects the maximum per connection transfer rate. Every time you issue a GET request you create an empty gap in your transfer pipe which is the size of the connection RTT. For example, if you're Maximum Possible Transfer Rate ( recv buff size / RTT ) is 2.5Mbit and your RTT is 100ms, then every GET request incurs a minimum 32kB gap in your pipe. For a large average image size of 320kB that amounts to a 10% overhead per file, effectively reducing your available bandwidth to 2.25Mbit. However, for a small average file size of 3.2kB the overhead jumps to 1000% and available bandwidth is reduced to 232 kbit / second - about 29kB. So to find the optimal number of threads: Gap Size = MPTR * RTT MPTR / (MPTR / Gap Size + AVG file size) * AVG file size) For my above scenario this gives me an optimum thread count of 11 threads, which is extremely close to my real world results. If the actual connection speed is slower than the theoretical MPTR then it should be used in the calculation instead.
