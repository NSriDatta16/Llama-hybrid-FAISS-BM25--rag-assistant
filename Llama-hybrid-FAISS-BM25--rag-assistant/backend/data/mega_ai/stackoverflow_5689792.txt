[site]: stackoverflow
[post_id]: 5689792
[parent_id]: 5689432
[tags]: 
Since I'm not sure every answer completely answers it, here's a linked list implementation (written without testig: // your (correct) structure struct Node { float item; // storage for the node's item Node* next; // pointer to the next node }; Now we need two pointers somewhere to look after the list: /* some pointers */ struct List { Node* head; Node* tail; }; Now we need to create some elements. As others have said, you can do that with new: /* create some elements we want to link in */ Node* elem1 = new Node(); Node* elem2 = new Node(); Node* elem3 = new Node(); /* maybe even set their properties! */ elem1->item = 3.14; elem2->item = 3.14; elem3->item = 3.14; Notice how I didn't try to add these elements to a list yet? That's because I've got a function in mind which looks like this: void addtolist(List &list, Node* node) { /* if no head, initialise the list */ if ( list->head == NULL ) { list->head = node; list->tail = node; } else if ( list->head != NULL && list->tail != NULL ) { /* access the tail element and set its next to this ptr. Move tail to this node */ list->tail->next = node; list->tail = node; } else { /* probably raise an exception! */ } } You can call this by doing this: List l; addtolist(l, elem1); /* etc */ Deleting elements is somewhat more tricky, since you have to go to that element, remember its previous element, grab it's next element, join them up and delete the Node* you're on. Now for traversing lists... your terminology HEAD|TAIL reminds me of Erlang and tail recursion, where the current element is referred to as the head and the remainder the tail. If I write: Node* cur = l.head; while ( cur != NULL ) { // do something with cur.item ? cur = cur->next; } You can see this happening. Replacing cur with head here would be harmless thanks to the List struct. Finally, I've used a very C-like approach here, but there's scope for templates: template struct node { T item; // storage for the node's item Node * next; // pointer to the next node }; and encapsulating the List struct as a class: template class List { protected: Node * head; Node * tail; public: void addtolist(Node * node); Node * gethead(); Node * gettail(); } Which brings you a little bit closer to std::list .
