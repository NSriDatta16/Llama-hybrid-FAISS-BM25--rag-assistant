[site]: stackoverflow
[post_id]: 5410978
[parent_id]: 
[tags]: 
How to enforce the use of a method's return value in C#?

I have a piece of software written with fluent syntax. The method chain has a definitive "ending", before which nothing useful is actually done in the code (think NBuilder, or Linq-to-SQL's query generation not actually hitting the database until we iterate over our objects with, say, ToList()). The problem I am having is there is confusion among other developers about proper usage of the code. They are neglecting to call the "ending" method (thus never actually "doing anything")! I am interested in enforcing the usage of the return value of some of my methods so that we can never "end the chain" without calling that "Finalize()" or "Save()" method that actually does the work. Consider the following code: //The "factory" class the user will be dealing with public class FluentClass { //The entry point for this software public IntermediateClass Init () { return new IntermediateClass (); } } //The class that actually does the work public class IntermediateClass { private List _values; //The user cannot call this constructor internal IntermediateClass () { _values = new List (); } //Once generated, they can call "setup" methods such as this public IntermediateClass With(T value) { var instance = new IntermediateClass () { _values = _values }; instance._values.Add(value); return instance; } //Picture "lazy loading" - you have to call this method to //actually do anything worthwhile public void Save() { var itemCount = _values.Count(); . . . //save to database, write a log, do some real work } } As you can see, proper usage of this code would be something like: new FluentClass().Init ().With(-1).With(300).With(42).Save(); The problem is that people are using it this way (thinking it achieves the same as the above): new FluentClass().Init ().With(-1).With(300).With(42); So pervasive is this problem that, with entirely good intentions, another developer once actually changed the name of the "Init" method to indicate that THAT method was doing the "real work" of the software. Logic errors like these are very difficult to spot, and, of course, it compiles, because it is perfectly acceptable to call a method with a return value and just "pretend" it returns void. Visual Studio doesn't care if you do this; your software will still compile and run (although in some cases I believe it throws a warning). This is a great feature to have, of course. Imagine a simple "InsertToDatabase" method that returns the ID of the new row as an integer - it is easy to see that there are some cases where we need that ID, and some cases where we could do without it. In the case of this piece of software, there is definitively never any reason to eschew that "Save" function at the end of the method chain. It is a very specialized utility, and the only gain comes from the final step. I want somebody's software to fail at the compiler level if they call "With()" and not "Save()". It seems like an impossible task by traditional means - but that's why I come to you guys. Is there an Attribute I can use to prevent a method from being "cast to void" or some such? Note: The alternate way of achieving this goal that has already been suggested to me is writing a suite of unit tests to enforce this rule, and using something like http://www.testdriven.net to bind them to the compiler. This is an acceptable solution, but I am hoping for something more elegant.
