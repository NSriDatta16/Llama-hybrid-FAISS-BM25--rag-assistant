[site]: stackoverflow
[post_id]: 235048
[parent_id]: 109825
[tags]: 
This is a good question, which follows the sames lines as two questions I have asked myself: Large, Complex Objects as a Web Service Result . ASP.NET Web Service Results, Proxy Classes and Type Conversion . Both of these may be a worthwhile read for you. Heres my two bits: Try to keep the return types of your Web Services to primitives where possible. This not only helps reduce the size of the messages, but also reduces complexity at the receiving end. If you do need to return complex objects, return them as a raw xml string (I'll explain below). What I then do is create a seperate class which represents the object and handles it's xml. I ensure the class can be instantiated from and serialized to xml easily. Then both projects (the web service and the client) can reference the DLL with the concrete object in, but there is none of the annoying coupling with the proxy class. This coupling causes issues if you have shared code. For example (using your Car class): Web Service ( CarFactory ) method BuyCar(string make, string model) is a factory method that returns a car. You also write a Mechanic class that works on Car objects to repair them, this is developed without knowledge of the Web Service. You then right a Garage class for your application. You add a web reference to the CarFactory service to get your cars, and then add some Mechanic 's to your garage and then crack your knuckles and get ready to get some cars from the factory to get them working on. Then it all falls over, when you get the result of CarFactory.BuyCar("Audi", "R8") and then tell your Mechanic.Inspect(myAudi) the compiler moans, because the Car is actually of type CarFactory.Car not the original Car type, yes? So, using the method I suggested: Create your Car class in its own DLL. Add methods to instantiate it and serialize it from/to XML respectively. Create your CarFactory web service, add a reference to the DLL, build your cars as before, but instead of returning the object, return the XML . Create your Garage adding a reference to the Mechanic , Car DLL and the CarFactory web service. Call your BuyCar method and now it returns a string, you then pass this string to the Car class, which re-builds its object model. The Mechanic 's can happily work on these Car's too because everything is singing from the same hymn sheet (or DLL?) :) One major benefit is that if the object changes in its design, all you need to do is update the DLL and the web service and client apps are completely decoupled from the process. Note: Often it can be useful to then create a Facade layer two work with the web services and auto-generate objects from the XML results. I hope that makes sense, if not, then please shout and I will clarify .
