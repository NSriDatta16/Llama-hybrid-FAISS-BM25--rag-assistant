[site]: stackoverflow
[post_id]: 4446156
[parent_id]: 4446112
[tags]: 
Just a quick thought 'off the cuff' so to speak. Could you organize them into 2 lists, one for start of intervals and the other for end of intervals. This way, you can compare y to the items in the start of interval list (say by binary search) to cut down the candidates based on that. You can then compare x to the items in the end of interval list. EDIT Case: Once Off If you are comparing only single interval to the list of intervals in a once-off situation, I don't believe sorting will help you out since ideal sorting is O(n) . By doing a linear search through all x's to trim out any impossible intervals then doing another linear search through the remaining y's you can reduce your total work. While this is still O(n), without this you would be doing 2n comparisons, whereas on average, you would only do (3n-1)/2 comparisons this way. I believe this is the best you can do for an unsorted list. Case: Pre-sorting doesn't count In the case where you will be repeatedly comparing single intervals to this list of intervals and your pre-sort your list, you can achieve better results. The process above still applies, but by doing a binary search on the first list then the second you can get O(m log n) as opposed to O(mn), where m is the number of single intervals being compared. Note, still still gives you the advantage of reducing total comparisons. [2m log n compared to m(3(log n) - 1)/2]
