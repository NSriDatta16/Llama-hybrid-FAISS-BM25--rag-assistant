[site]: stackoverflow
[post_id]: 4678854
[parent_id]: 4678507
[tags]: 
I don't program iphone for know, so I image std::vector, it's quite easy, simple and elegant enough: #include using std::cout; #include using std::vector; #include //no need for using, assert is macro template void eraseCircularVector(vector & vec, size_t position, size_t count) { assert(count 0) { position %= vec.size(); //normalize position size_t positionEnd = (position + count) % vec.size(); if (positionEnd values; for (int i = 0; i ::const_iterator cit = values.begin(); cit != values.end(); cit++) cout ::const_iterator cit = values.begin(); cit != values.end(); cit++) cout However, you might consider: creating new loop_vector class, if you use this kind of functionality enough using list if you perform many deletions (or few deletions (not from end, that's simple pop_back) but large array) If your container (NSMutableArray or whatever) is not list, but vector (i.e. resizable array), you most definitely don't want to delete items one by one, but whole range (e.g. std::vector's erase(begin, end)! Edit : reacting to comment, to fully realize what must be done by vector, if you erase element other than the last one: it must copy all values after that element (e.g. 1000 items in array, you erase first, 999x copying (moving) of item, that is very costly). Example: #include #include #include using namespace std; int main() { clock_t start, end; vector vec; const int items = 64 * 1024; cout Produces output: using 65536 items in vector Inefficient method took: 1.705 ms Efficient method took: 0 ms Note it's very easy to get inefficient, look e.g. have at http://www.cplusplus.com/reference/stl/vector/erase/
