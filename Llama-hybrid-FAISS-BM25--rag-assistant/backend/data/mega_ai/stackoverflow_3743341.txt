[site]: stackoverflow
[post_id]: 3743341
[parent_id]: 3742656
[tags]: 
When you move the items between collections you also need to set some of their properties to signify changes. ObservableCollection exposes the NotifyCollectionChanged event which you can use for that purpose. So the answer would be to set the User property of a Task to the current user when the Task enters the ListBox that signifies the current user's tasks, and remove it when it enters the collection of tasks. Edit: Another technique I used, if the collection usually contains a moderate amount of items (what the limit is I don't know, you must test with appropriate test data), was to have all the items in the same collection (usually ObservableCollection to be able to add/remove items dynamically without having to worry about updating the user interface), and create two views (ICollectionView interface, usually created with CollectionViewSource in Silverlight I think) each having a filtering predicate. The view uses the predicate to determine if an item belongs to the view or not; so one view can have the predicate condition 'user must be equal to the current user' and the other one 'user must be null'. Simply setting the user property of an entity in your collection (if the entity implements INotifyPropertyChanged) will automagically move the entity in the appropriate view. Granted, this will require changes to the drag and drop part of the problem: when dropping an item into a list, you need to set its user property to either the current user or null depending on the drop target, and then everything else is taken care of by the views. The changes still need to be saved to the database - simply call SubmitChanges (at least that's what it's called in RIA services, I think... working with too many technologies at the moment) when the user clicks the 'ok' or 'save' button or whatever. The modified entities will be saved, and they will be detected as modified because their user property has been modified.
