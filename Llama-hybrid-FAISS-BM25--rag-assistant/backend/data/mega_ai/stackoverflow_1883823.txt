[site]: stackoverflow
[post_id]: 1883823
[parent_id]: 1883786
[tags]: 
First, you should really consider whether you can't bend the rules of not using instances of Wizards to discover their available spells. I find that the prototype pattern can actually be quite useful for this sort of thing. However, if you really can't do that, you can use nested classes and reflection to discover the available spells that a particular concrete AbsWizard-derivative can cast. Here's an example: public abstract class AbsWizard { public abstract Magic GetMagic(String magicword); public abstract string[] GetAvalibleSpells(); } public class WhiteWizard : AbsWizard { // organizes all the spells available to the wizard... public sealed class Spells { // NOTE: Spells may be better off as a specific class, rather than as strings. // Then you could decorate them with a lot of other information (cost, category, etc). public const string Abracadabra = "Abracadabra"; public const string AlaPeanutButterSandwiches = "APBS"; } } public static void CastMagic() { Type[] types = System.Reflection.Assembly.GetExecutingAssembly().GetTypes(); List wizardTypes = new List (); List avalibleSpells = new List (); Type selectedWizardType; string selectedSpell; foreach (Type t in types) { if (typeof(AbsWizard).IsAssignableFrom(t)) { // find a nested class named Spells and search it for public spell definitions // better yet, use an attribute to decorate which class is the spell lexicon var spellLexicon = Type.FromName( t.FullName + "+" + "Spells" ); foreach( var spellField in spellLexicon.GetFields() ) // whatever you do with the spells... } } } There are many ways to improve the above code. First, you can define your own custom attribute that you can tag on the nested classes of each wizard to identify the spell lexicon. Second, using strings to define the available spells may end up being a bit limiting. You may find it easier to define a global static list of all available spells (as some kind of class, let's call it Spell ). You could then define the available spells of the wizard based off this list, rather than strings. Third, consider creating an external configuration for this thing rather than embedded, nested classes. It's more flexible and possibly easier to maintain. However, it can be nice to write code like: WhiteWizard.Spells.Abracadabra.Cast(); Finally, consider creating a static dictionary for each Wizard-derivative that manages the list of available spells so that you can avoid performing reflection (which is expensive) more than once.
