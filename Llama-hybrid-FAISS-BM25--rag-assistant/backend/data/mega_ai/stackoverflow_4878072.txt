[site]: stackoverflow
[post_id]: 4878072
[parent_id]: 4827870
[tags]: 
The issue with multiple assignments is easy enought to handle in a grammar. Just allow multiple assignements: assign_stmt = 'assign' assignments '.' ; assignements = ; assignments = assignments target '=' expression ; One method you can use is to augment the grammar to allow preprocessor token sequences wherever a nonterminal can be allowed, and simply not do preprocessor expansion. For your example, you have some grammar rule: expression = ... ; just add the rule: expression = '{' include_reference '}' ; This works to the extent that the preprocessor isn't used abusively to generate several lanaguage elements that span nonterminal boundaries. What kind of code anlaysis do you intend to do? Pretty much to do anything, you'll need to name and type resolution, which will require to expand the preprocessor directives. In that case, you'll need a more sophisticated scheme, because you need the expanded tree to do the name resolution, and need the include information associated off to the side. Our DMS Software Reengineering Toolkit has an OpenEdge parser, in which we present do the previous "keep the include file references" trick. DMS's C parser adds a "macro node" to the tree where the macro (OpenEdge "include" is just a funny way to write a macro definition) child nodes contains the tree as you expect it, and the reference information that refers back to the macro defintion. This requires some careful organization, and lots of special handliing of macro nodes where they occur.
