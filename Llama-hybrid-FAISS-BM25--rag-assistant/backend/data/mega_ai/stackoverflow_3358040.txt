[site]: stackoverflow
[post_id]: 3358040
[parent_id]: 360307
[tags]: 
I have been looking for some answers on thread scheduling on Windows, and have some empirical information that I'll post here for anyone who may stumble across this post in the future. I wrote a simple C# program that launches two threads. On my quad core Windows 7 box, I saw some surprising results. When I did not force affinity, Windows spread the workload of the two threads across all four cores. There are two lines of code that are commented out - one that binds a thread to a CPU, and one that suggests an ideal CPU. The suggestion seemed to have no effect, but setting thread affinity did cause Windows to run each thread on their own core. To see the results best, compile this code using the freely available compiler csc.exe that comes with the .NET Framework 4.0 client, and run it on a machine with multiple cores. With the processor affinity line commented out, Task Manager showed the threads spread across all four cores, each running at about 50%. With affinity set, the two threads maxed out two cores at 100%, with the other two cores idling (which is what I expected to see before I ran this test). EDIT: I initially found some differences in performance with these two configurations. However, I haven't been able to reproduce them, so I edited this post to reflect that. I still found the thread affinity interesting since it wasn't what I expected. using System; using System.Collections.Generic; using System.Linq; using System.Diagnostics; using System.Runtime.InteropServices; using System.Threading.Tasks; class Program { [DllImport("kernel32")] static extern int GetCurrentThreadId(); static void Main(string[] args) { Task task1 = Task.Factory.StartNew(() => ThreadFunc(1)); Task task2 = Task.Factory.StartNew(() => ThreadFunc(2)); Stopwatch time = Stopwatch.StartNew(); Task.WaitAll(task1, task2); Console.WriteLine(time.Elapsed); } static void ThreadFunc(int cpu) { int cur = GetCurrentThreadId(); var me = Process.GetCurrentProcess().Threads.Cast ().Where(t => t.Id == cur).Single(); //me.ProcessorAffinity = (IntPtr)cpu; //using this line of code binds a thread to each core //me.IdealProcessor = cpu; //seems to have no effect //do some CPU / memory bound work List ls = new List (); ls.Add(10); for (int j = 1; j != 30000; ++j) { ls.Add((int)ls.Average()); } } }
