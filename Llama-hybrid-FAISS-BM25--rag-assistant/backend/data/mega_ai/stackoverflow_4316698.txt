[site]: stackoverflow
[post_id]: 4316698
[parent_id]: 3520458
[tags]: 
if ([_infoMedia.description length] > 270) { NSRange labelLimit = [_infoMedia.description rangeOfString:@" " options:NSCaseInsensitiveSearch range:NSMakeRange(270, (_infoMedia.description.length - 270))]; _descTop.text = [_infoMedia.description substringToIndex:labelLimit.location]; _descBottom.text = [_infoMedia.description substringFromIndex:(labelLimit.location+1)]; } else { _descTop.text = _infoMedia.description; _descBottom.text = @""; } Okay that's a late answer but maybe it could help someone. The code above is approximatively the solution I used in my app. _descTop is my first label and _descBottom is the second label. 270 is a constant equivalent to a little less than the average maximum number of characters displayed in my first label, _descTop. I calculated it by hand, trying with many different strings, maybe there's a better way to do that but this worked not bad. If the string I want to display (_infoMedia.description) is larger than 270 characters, I isolate the first 270 characters plus the end of the next word in the string (by searching the next space), in the case where the 270 characters limit would cut the string in the middle of a word. Then I put the first part of the string in my first label, and the second part in the second label. If not, I only put the globality of the string in the first label. I know that's a crappy solution, but it worked and I didn't found any better way to do that.
