[site]: stackoverflow
[post_id]: 4874815
[parent_id]: 4874589
[tags]: 
I don't know how well the designers play with user controls that are generic classes. If that is a problem (which I would guess), one way to get away from that is to expose the collections IList but still use List that are constructed in runtime to have type safety in the storage (code sample reduced to include only list object creation and properties for exposing them; add code for DependencyProperty and so on as needed): public class YourControl : UserControl { // this method will set up the internal lists for accepting // objects of the specified type only public void SetListType(Type containedType) { var listType = typeof(List<>).MakeGenericType(new[] { containedType }); SetCollection = (IList)Activator.CreateInstance(listType); SubsetCollection = (IList)Activator.CreateInstance(listType); } public IList SetCollection { get; private set; } public IList SubsetCollection { get; private set; } } // usage example: theControl.SetListType(typeof(string)); theControl.SetCollection.Add("some string"); // works ok theControl.SetCollection.Add(42); // fails, 42 is not a string The obvious downside is that SetCollection and SubsetCollection expose "untyped" object lists.
