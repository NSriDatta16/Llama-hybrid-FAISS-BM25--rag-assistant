[site]: stackoverflow
[post_id]: 3580367
[parent_id]: 3577610
[tags]: 
Here's another way to distinguish between a string literal and a pointer, based on the fact that string literals have array type, not pointer type: #include void foo(char *msg) { std::cout void foo(const char (&msg)[N]) { std::cout But note that all of them (including your original function) can be "fooled" by passing something that isn't a string literal: const char *soap = 0; foo(soap); char *b = 0; foo(b); const char a[4] = {}; foo(a); There is no type in C++ which is unique to string literals. So, you can use the type to tell the difference between an array and a pointer, but not to tell the difference between a string literal and another array. RTTI is no use, because RTTI exists only for classes with at least one virtual member function. Anything else is implementation-dependent: there is no guarantee in the standard that string literals will occupy any particular region of memory, or that the same string literal used twice in a program (or even in a compilation unit) will have the same address. In terms of storage location, anything that an implementation can do with string literals, it is permitted also to do with my array a .
