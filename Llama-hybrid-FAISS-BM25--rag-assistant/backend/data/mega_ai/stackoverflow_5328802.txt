[site]: stackoverflow
[post_id]: 5328802
[parent_id]: 4567659
[tags]: 
Here is what I ended up doing: #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include "mac.h" int main() { printf("en1: %s\n", lookupDeviceMac("vnic0")); } unsigned char *lookupDeviceMac(char *dev){ pcap_if_t *alldevs; pcap_if_t *d; pcap_addr_t *alladdrs; pcap_addr_t *a; struct sockaddr_dl* link; char eb[PCAP_ERRBUF_SIZE]; char *ret = malloc(6); if (pcap_findalldevs(&alldevs, eb) == -1) { printf("%s\n", eb); return(ret); } for (d = alldevs; d != NULL; d = d->next) { if(strcmp(d->name, dev) == 0){ printf("Device: %s\n", d->name); alladdrs = d->addresses; for (a = alladdrs; a != NULL; a = a->next) { if(a->addr->sa_family == AF_LINK && a->addr->sa_data != NULL){ // MAC ADDRESS //struct sockaddr_dl *sdl = (struct sockaddr_dl *) a->addr->sa_data; link = (struct sockaddr_dl*)a->addr->sa_data; char mac[link->sdl_alen]; caddr_t macaddr = LLADDR(link); memcpy(mac, LLADDR(link), link->sdl_alen); if(link->sdl_alen == 6){ // Seen in some sample code sprintf(ret, "%02x:%02x:%02x:%02x:%02x:%02x",(unsigned char)mac[0], (unsigned char)mac[1], (unsigned char)mac[2], (unsigned char)mac[3], (unsigned char)mac[4], (unsigned char)mac[5]); } else if(link->sdl_alen > 6) { // This is what happens in OSX 10.6.5 sprintf(ret, "%02x:%02x:%02x:%02x:%02x:%02x",(unsigned char)mac[1], (unsigned char)mac[2], (unsigned char)mac[3], (unsigned char)mac[4], (unsigned char)mac[5], (unsigned char)mac[6]); } return(ret); } } } } }
