[site]: stackoverflow
[post_id]: 3544857
[parent_id]: 3544795
[tags]: 
Disclaimer This kind of thing is no good except for debugging. There aren't many legitimate reasons to continue your program after a memory access exception, because usually it indicates data corruption. That said, I think it's better to answer the question than to pass judgment, censure, or censor it. The C++ classes derived from exception are simply conveniences to encourage good practice among programmers. They have no special semantics, and aren't differentiated in anything but name. Worse, C++ exceptions cannot pass outside a signal handler (what in other languages would be called the "exception handler," the function which is called upon the illegal access). The standard has a specific warning about this, A [plain old function] that could be used as a signal handler in a conforming C program does not produce undefined behavior when used as a signal handler in a C++ program. The behavior of any other function used as a signal handler in a C++ pro- gram is implementation defined.213) 213) In particular, a signal handler using exception handling is very likely to have problems That said, if you want to catch this, use the UNIX signal facility to install a function that does not use C++ features. #include #include #include void catch_memory( int ) { std::printf( "caught!\n" ); std::abort(); } int main() { std::signal( SIGSEGV, catch_memory ); int *i = 0; *i = 6; }
