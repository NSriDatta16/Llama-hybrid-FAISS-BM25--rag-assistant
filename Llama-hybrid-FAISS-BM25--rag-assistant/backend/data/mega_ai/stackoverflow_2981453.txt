[site]: stackoverflow
[post_id]: 2981453
[parent_id]: 2981269
[tags]: 
I use the following template all the time and find it very useful. The loading and saving of the singleton's state is encapsulated and all you have to do is to ask for the shared instance. You might want to make persistToStorage public and call it from the app delegate's applicationWillTerminate: method. (You might want to make this more thread safe.) static Actor* SharedActor; +(Actor*)sharedActor { if (SharedActor) return SharedActor; SharedActor = [[NSKeyedUnarchiver unarchiveObjectWithFile:[self actorDataFileName]]retain]; if (!SharedActor) SharedActor = [[Actor alloc]init]; return SharedActor; } +(NSString*)actorDataFileName { NSString* path = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0]; return [path stringByAppendingPathComponent:@"actor.dat"]; } -(BOOL)persistToStorage { return [NSKeyedArchiver archiveRootObject:self toFile:[Actor userDataFileName]]; } -(void) encodeWithCoder:(NSCoder *)encoder { [encoder encodeInteger:strength forKey:@"strength"]; . . . } -(id)initWithCoder:(NSCoder *)decoder { if (self = [super init]) { strength = [decoder decodeIntegerForKey:@"strength"]; . . . } } A couple of things: Don't do this: [self retain]; There is nothing strange about archiving a singleton...
