[site]: crossvalidated
[post_id]: 417237
[parent_id]: 417222
[tags]: 
I will illustrate how this 'discretization' of a continuous-time Markov process can be done, using a process that is a little simpler than your queue. Continuous-time Markov process. Consider a continuous time Markov process roughly modeling decay of performance of a machine and rate of its repair. States are $S = \{1,2,3\},$ where 1 = poor, 2 = fair, 3 = good performance. Instantaneous transition intensities are as follows: If in state 1, the machine is repaired at rate $\lambda = 3,$ moving to state 3. If in state 2, it decays to state 1 at rate $\mu = 2.$ If in state 3, it decays at rate $2\mu$ , moving to state 1 or 2 with equal probabilities. The $Q$ -matrix can be expressed in R as Q = matrix(c(-3, 0, 3, 2, -2, 0, 2, 2, -4), byrow=T, nrow=3) One can solve balance equations to show that the long run probabilities in being in the states are given by $P = (.4, .3, .3).$ Similar discrete Markov Chain. Now we 'discretize' the chain by viewing it at one minute intervals (elapsed time $s).$ . The rate of not moving out of state 1 is $$e^{-\lambda s} = e^{-1/20} \approx 19/20 = 57/60.$$ Similarly, the probability of not moving from state 2 is $e^{-10} \approx 58/60,$ and the probability of nor moving from state 3 is about $56/60.$ Thus the transition matrix of the discrete-time chain can be written as P = (1/60)*matrix(c(57, 0, 3, 2, 58, 0, 2, 2, 56), byrow=T, nrow=3) It is easy to show that the steady state distribution of this Markov Chain is $(.4, .3, .3).$ Consider transitions from state 1 to state 3 ("repairs"): The original continuous-time process makes such transitions according to an exponential distribution at the rate $\lambda = 3$ per hour---on average 20 minutes apart. In contrast, the approximating discrete-time chain takes a geometrically distributed length of time to make this transition. It has probability $3/60 = 1/20$ of moving at each (one minute) stepâ€”on average one transition in 20 steps. Observing only at one minute intervals, we would seldom see a difference between the two models. One relatively rare exception is that the continuous-time process could conceivably move from state 1 to state 3 to state 2 within one minute, whereas the discrete-time chain cannot move from state 1 to state 2 in a one-minute step. Simulating the chain. The discrete-time chain can be simulated using the program below. We use an unusually large number of iterations here because the P-matrix specifies a chain that rarely moves. The result is consistent with the stationary distribution above. P = matrix((1/60)*c(57, 0, 3, 2, 58, 0, 2, 2, 56), byrow=T, nrow=3) set.seed(2014) m = 10^6; y = numeric(m); y[1] = 2 for (i in 2:m) y[i] = sample(1:3, 1, prob=P[y[i-1],]) round(summary(as.factor(y))/m, 4) 1 2 3 0.4023 0.2970 0.3006 Addendum. Simulating the process in continuous time. Somewhat more intricately, the original continuous-time process can also be simulated in R. (Particularly, for complex queues, many authors prefer the simplicity of simulation the discrete-time analogue.) set.seed(1492) lam = 3; mu = 2 # repair and decay rates kap = c(lam, mu, 2*mu) # rates for leaving states (1, 2, 3) m = 50000; x = t = numeric(m) x[1] = 2 # start in state 2 for (i in 2:m) { t[i-1] = rexp(1, kap[x[i-1]]) if (x[i-1] == 1) x[i] = 3 # moving from 1 to 3 if (x[i-1] == 2) x[i] = 1 # moving from 2 to 1 if (x[i-1] == 3) x[i] = sample(1:2, 1) # moving from 3 to 1 or 2 } # with prob 1/2 each plot(c(0,cumsum(t)[1:50]), c(x[1],x[1:50]), type="S", ylab = "State", xlab="Elapsed time", main="") d = 2*(lam + mu); p = c(2*mu, lam, lam)/d # exact p t.avg = numeric(3) # simulated p for (j in 1:3) {t.avg[j] = sum(t[x==j])/sum(t)} round(cbind(states=1:3, p, t.avg), 3) ## states p t.avg ## 1 0.4 0.400 ## 2 0.3 0.301 ## 3 0.3 0.299
