[site]: stackoverflow
[post_id]: 3161560
[parent_id]: 
[tags]: 
How can I inherit an inner class using an abstract base class?

I'm trying to create a test class which organizes its test methods using inner classes. I would like for this class to be abstract with the ability to set a static property so this property can be injected. Here's an example of what I'm talking about: [TestClass] public abstract class BaseUnitTest { public static string InjectedProperty; public static string GetInjectedString() { return InjectedProperty; } [TestClass] public class WhenFoo { [TestMethod] public void TestFoo() { string str = GetInjectedString(); } } } [TestClass] public class DeriverdUnitTest : BaseUnitTest { [ClassInitialize] public void SetUp() { InjectedProperty = "Injected Property"; } } However, I don't see a DerivedUnitTest+WhenFoo+TestFoo() class show up in my unit test view. I'm using Visual Studio 2010. I'm guessing when I override BaseUnitTest, I don't override its inner classes as well. I suppose I could make its inner classes abstract and override them later, but as the complexity of my test class increases this will get really annoying. Could somebody please explain why this is occuring and how I can fix it? Thanks. Edit: I feel like I need to better explain my reasons for wanting to do this. We'd like to implement a testing standard which is very verbose in its naming. Therefore a test class would look something like this: [TestClass] public abstract class BaseUnitTest { public static string InjectedProperty; public static string GetInjectedString() { return InjectedProperty; } [TestClass] public class WhenFooIsCalled { [TestClass] public class AndTheArgumentIsNull { [TestMethod] public void AnArgumentNullExceptionShouldBeThrown() { string str = GetInjectedString(); } } } } The advantage of this is when you open up the test view in Visual Studio and display the method name and class name columns you get something that looks like this: BaseUnitTest+WhenFooIsCalled+AndTheArgumentIsNull AnArgumentNullExceptionShouldBeThrown() This makes it a lot easier to glance to tell what a failing test among a few hundred pass tests is supposed to do. The main reason I want to be able to override the abstract BaseUnitTest is because when I do all of the tests which were contained in the BaseUnitTest are all added to the DerivedUnitTest and show up in the Test View in Visual Studio. Thanks again.
