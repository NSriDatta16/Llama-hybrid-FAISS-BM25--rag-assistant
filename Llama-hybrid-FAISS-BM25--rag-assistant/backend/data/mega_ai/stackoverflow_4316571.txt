[site]: stackoverflow
[post_id]: 4316571
[parent_id]: 642229
[tags]: 
It should be noted that the value/type kinding issue is not the fundamental problem. The primary issue is parsing . Consider template void f() { (T::x)(1); } There is no way to tell if this is a cast or a function call unless the typename keyword is mandatory. In that case, the above code contains a function call. In general the choice cannot be delayed without forgoing parsing altogether, just consider fragment (a)(b)(c) In case you didn't remember, cast has a higher precedence than function call in C, one reason Bjarne wanted function style casts. It is therefore not possible to tell if the above means (a)(b) (c) // a is a typename or (a) (b)(c) // a is not a typename , b is or (a)(b) (c) // neither a nor b is a typename where I inserted space to indicate grouping. Note also "templatename" keyword is required for the same reason as "typename", you can't parse things without knowing their kind in C/C++.
