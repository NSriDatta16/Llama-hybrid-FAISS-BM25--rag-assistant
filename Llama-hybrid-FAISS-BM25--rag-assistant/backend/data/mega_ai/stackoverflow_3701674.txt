[site]: stackoverflow
[post_id]: 3701674
[parent_id]: 3693447
[tags]: 
It is possible to write apply in a statically-typed language, as long as functions are typed a particular way. In most languages, functions have individual parameters terminated either by a rejection (i.e. no variadic invocation), or a typed accept (i.e. variadic invocation possible, but only when all further parameters are of type T). Here's how you might model this in Scala: trait TypeList[T] case object Reject extends TypeList[Reject] case class Accept[T](xs: List[T]) extends TypeList[Accept[T]] case class Cons[T, U](head: T, tail: U) extends TypeList[Cons[T, U]] Note that this doesn't enforce well-formedness (though type bounds do exist for that, I believe), but you get the idea. Then you have apply defined like this: apply[T, U]: (TypeList[T], (T => U)) => U Your functions, then, are defined in terms of type list things: def f (x: Int, y: Int): Int = x + y becomes: def f (t: TypeList[Cons[Int, Cons[Int, Reject]]]): Int = t.head + t.tail.head And variadic functions like this: def sum (xs: Int*): Int = xs.foldLeft(0)(_ + _) become this: def sum (t: TypeList[Accept[Int]]): Int = t.xs.foldLeft(0)(_ + _) The only problem with all of this is that in Scala (and in most other static languages), types aren't first-class enough to define the isomorphisms between any cons-style structure and a fixed-length tuple. Because most static languages don't represent functions in terms of recursive types, you don't have the flexibility to do things like this transparently. (Macros would change this, of course, as well as encouraging a reasonable representation of function types in the first place. However, using apply negatively impacts performance for obvious reasons.)
