[site]: stackoverflow
[post_id]: 5269900
[parent_id]: 273450
[tags]: 
I have a variation of the idle timer solution which doesn't require subclassing UIApplication. It works on a specific UIViewController subclass, so is useful if you only have one view controller (like an interactive app or game may have) or only want to handle idle timeout in a specific view controller. It also does not re-create the NSTimer object every time the idle timer is reset. It only creates a new one if the timer fires. Your code can call resetIdleTimer for any other events that may need to invalidate the idle timer (such as significant accelerometer input). @interface MainViewController : UIViewController { NSTimer *idleTimer; } @end #define kMaxIdleTimeSeconds 60.0 @implementation MainViewController #pragma mark - #pragma mark Handling idle timeout - (void)resetIdleTimer { if (!idleTimer) { idleTimer = [[NSTimer scheduledTimerWithTimeInterval:kMaxIdleTimeSeconds target:self selector:@selector(idleTimerExceeded) userInfo:nil repeats:NO] retain]; } else { if (fabs([idleTimer.fireDate timeIntervalSinceNow]) (memory cleanup code excluded for brevity.)
