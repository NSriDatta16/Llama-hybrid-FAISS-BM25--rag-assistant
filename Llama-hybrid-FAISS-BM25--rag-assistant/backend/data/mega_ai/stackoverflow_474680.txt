[site]: stackoverflow
[post_id]: 474680
[parent_id]: 474613
[tags]: 
Regarding your inflated constructor call problem, you could introduce parameter classes or factory methods to leverage this problem for you. A parameter class moves some of the parameter data to it's own class, e.g. like this: var parameterClass1 = new MenuParameter(menuBar, editor); var parameterClass2 = new StuffParameters(sasquatch, ...); var ctrl = new MyControllerClass(managedStore, parameterClass1, parameterClass2); It sort of just moves the problem elsewhere though. You might want to housekeep your constructor instead. Only keep parameters that are important when constructing/initiating the class in question and do the rest with getter/setter methods (or properties if you're doing .NET). A factory method is a method that creates all instances you need of a class and have the benefit of encapsulating creation of the said objects. They are also quite easy to refactor towards from Singleton, because they're similar to getInstance methods that you see in Singleton patterns. Say we have the following non-threadsafe simple singleton example: // The Rather Unfortunate Singleton Class public class SingletonStore { private static SingletonStore _singleton = new MyUnfortunateSingleton(); private SingletonStore() { // Do some privatised constructing in here... } public static SingletonStore getInstance() { return _singleton; } // Some methods and stuff to be down here } // Usage: // var singleInstanceOfStore = SingletonStore.getInstance(); It is easy to refactor this towards a factory method. The solution is to remove the static reference: public class StoreWithFactory { public StoreWithFactory() { // If the constructor is private or public doesn't matter // unless you do TDD, in which you need to have a public // constructor to create the object so you can test it. } // The method returning an instance of Singleton is now a // factory method. public static StoreWithFactory getInstance() { return new StoreWithFactory(); } } // Usage: // var myStore = StoreWithFactory.getInstance(); Usage is still the same, but you're not bogged down with having a single instance. Naturally you would move this factory method to it's own class as the Store class shouldn't concern itself with creation of itself (and coincidentally follow the Single Responsibility Principle as an effect of moving the factory method out). From here you have many choices, but I'll leave that as an exercise for yourself. It is easy to over-engineer (or overheat) on patterns here. My tip is to only apply a pattern when there is a need for it .
