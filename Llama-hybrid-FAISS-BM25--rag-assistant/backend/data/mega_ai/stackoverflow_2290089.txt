[site]: stackoverflow
[post_id]: 2290089
[parent_id]: 2290057
[tags]: 
Use a loop: BigInteger randomNumber; do { randomNumber = new BigInteger(upperLimit.bitLength(), randomSource); } while (randomNumber.compareTo(upperLimit) >= 0); on average, this will require less than two iterations, and the selection will be uniform. Edit: If your RNG is expensive, you can limit the number of iterations the following way: int nlen = upperLimit.bitLength(); BigInteger nm1 = upperLimit.subtract(BigInteger.ONE); BigInteger randomNumber, temp; do { temp = new BigInteger(nlen + 100, randomSource); randomNumber = temp.mod(upperLimit); } while (s.subtract(randomNumber).add(nm1).bitLength() >= nlen + 100); // result is in 'randomNumber' With this version, it is highly improbable that the loop is taken more than once (less than one chance in 2^100 , i.e. much less than the probability that the host machine spontaneously catches fire in the next following second). On the other hand, the mod() operation is computationally expensive, so this version is probably slower than the previous, unless the randomSource instance is exceptionally slow.
