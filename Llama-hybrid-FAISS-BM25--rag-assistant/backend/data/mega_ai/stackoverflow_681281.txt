[site]: stackoverflow
[post_id]: 681281
[parent_id]: 681192
[tags]: 
I understand your question that you want to combine a vector of real parts with a vector of imaginary parts into a vector of complex numbers. std::complex has one template parameter which lets you chose the numerical represenation of the parts of the complex (i.e. if you want complex values based on double or float or even some custom number type...). The complex type then defines basic complex algebra in terms of the underlying type. In your code you are trying to construct a complex type based on a vector of floats (i.e. a single complex value having a real and imaginary part being a vector), which is obviously wrong. Instead you want a vector of complex numbers of type float You'd have to do something like: // ... typedef std::vector > floatComplexVector; floatComplexVector vA_Complex; // No need to 'new' !? for (CVFLoat::const_iterator itA = vA.begin(), itB = vB.begin(); itA != vA.end() && itB != vB.end(); ++itA,++itB) vA_Complex.push_back(std::complex (*itA, *itB)); Remarks: In most cases it isn't necessary to create containers such as vectors on the heap (i.e. using new ) Try to avoid this. Unfortunately the C++ standard library doesnt contain a combining iterator (i.e. one that "automatically" combines two sequences) which would allow a more elegant solution (see Boost Zip iterator for a general idea).
