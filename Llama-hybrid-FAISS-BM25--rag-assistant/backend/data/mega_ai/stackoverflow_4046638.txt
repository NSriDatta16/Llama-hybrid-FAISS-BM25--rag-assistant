[site]: stackoverflow
[post_id]: 4046638
[parent_id]: 3517438
[tags]: 
I solved this by subclassing a common superview and intercepting the touch events before sending them forward. In interface builder, I also added a button where the selector area is, attached an action to the touch up event, and sent the button to "the back" (that's very important so it doesn't return itself in hitTest). The most relevant code is below. It could be improved for more complicated, like multitouch, cases. @implementation InterceptorView -(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { UITouch *t=[touches anyObject]; CGPoint p=[t locationInView:button]; if ([button hitTest:p withEvent:event]) started_in_button=YES; [hitView touchesBegan:touches withEvent:event]; } - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event { [hitView touchesMoved:touches withEvent:event]; } - (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event { UITouch *t=[touches anyObject]; CGPoint p=[t locationInView:button]; if ([button hitTest:p withEvent:event] && started_in_button) { started_in_button=NO; [button sendActionsForControlEvents:UIControlEventTouchUpInside]; } [hitView touchesEnded:touches withEvent:event]; } - (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event { [hitView touchesCancelled:touches withEvent:event]; } - (UIView*)hitTest:(CGPoint)point withEvent:(UIEvent *)event { hitView = [super hitTest:point withEvent:event]; return self; }
