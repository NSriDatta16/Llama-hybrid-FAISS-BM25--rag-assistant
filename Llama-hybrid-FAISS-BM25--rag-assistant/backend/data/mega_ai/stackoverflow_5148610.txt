[site]: stackoverflow
[post_id]: 5148610
[parent_id]: 782087
[tags]: 
Here. Try this Unicode-savvy version of the wc program. It skips non-file arguments (pipes, directories, sockets, etc). It assumes UTF-8 text. It counts any Unicode whitespace as a word separator. It also accepts alternate encodings if there is a .ENCODING at the end of the filename, like foo.cp1252 , foo.latin1 , foo.utf16 , etc. It also work with files that have been compressed in a variety of formats. It gives counts of Paragraphs, Lines, Words, Graphemes, Characters , and Bytes. It understands all Unicode linebreak sequences. It warns about corrupted textfiles with linebreak errors. Hereâ€™s an example of running it: Paras Lines Words Graphs Chars Bytes File 2 2270 82249 504169 504333 528663 /tmp/ap 1 2404 11163 63164 63164 66336 /tmp/b3 uwc: missing linebreak at end of corrupted textfiile /tmp/bad 1* 2* 4 19 19 19 /tmp/bad 1 14 52 273 273 293 /tmp/es 57 383 1369 11997 11997 12001 /tmp/funny 1 657068 3175429 31205970 31209138 32633834 /tmp/lw 1 1 4 27 27 27 /tmp/nf.cp1252 1 1 4 27 27 34 /tmp/nf.euc-jp 1 1 4 27 27 27 /tmp/nf.latin1 1 1 4 27 27 27 /tmp/nf.macroman 1 1 4 27 27 54 /tmp/nf.ucs2 1 1 4 27 27 56 /tmp/nf.utf16 1 1 4 27 27 54 /tmp/nf.utf16be 1 1 4 27 27 54 /tmp/nf.utf16le 1 1 4 27 27 112 /tmp/nf.utf32 1 1 4 27 27 108 /tmp/nf.utf32be 1 1 4 27 27 108 /tmp/nf.utf32le 1 1 4 27 27 39 /tmp/nf.utf7 1 1 4 27 27 31 /tmp/nf.utf8 1 26906 101528 635841 636026 661202 /tmp/o2 131 346 1370 9590 9590 4486 /tmp/perl5122delta.pod.gz 291 814 3941 25318 25318 9878 /tmp/perl51310delta.pod.bz2 1 2551 5345 132655 132655 133178 /tmp/tailsort-pl.utf8 1 89 334 1784 1784 2094 /tmp/til 1 4 18 88 88 106 /tmp/w 276 1736 5773 53782 53782 53804 /tmp/www Here ya go: #!/usr/bin/env perl ######################################################################### # uniwc - improved version of wc that works correctly with Unicode # # Tom Christiansen # Mon Feb 28 15:59:01 MST 2011 ######################################################################### use 5.10.0; use strict; use warnings FATAL => "all"; use sigtrap qw[ die untrapped normal-signals ]; use Carp; $SIG{__WARN__} = sub { confess("FATALIZED WARNING: @_") unless $^S; }; $SIG{__DIE__} = sub { confess("UNCAUGHT EXCEPTION: @_") unless $^S; }; $| = 1; my $Errors = 0; my $Headers = 0; sub yuck($) { my $errmsg = $_[0]; $errmsg =~ s/(? qw{ Paras Lines Words Graphs Chars Bytes File } unless $Headers++; printf $mask => map( { show_undef($_) } $paracount, $linecount, $wordcount, $grafcount, $charcount, $bytecount, ), $file; } sub show_undef { my $value = shift; return defined($value) ? $value : "undef"; } END { close(STDOUT) || die "$0: can't close STDOUT: $!"; exit($Errors != 0); } sub process_input { my $function = shift(); my $enc; if (@ARGV == 0 && -t) { warn "$0: reading from stdin, type ^D to end or ^C to kill.\n"; } unshift(@ARGV, "-") if @ARGV == 0; FILE: for my $file (@ARGV) { # don't let magic open make an output handle next if -e $file && ! -f _; my $quasi_filename = fix_extension($file); $file = "standard input" if $file eq q(-); $quasi_filename =~ s/^(?=\s*[>|])/ "all"; local $/; scalar ; }; if ($@) { $@ =~ s/ at \K.*? line \d+.*/$file line $./; yuck($@); next FILE; } $function->($whole_file, $file); unless (close $fh) { yuck("couldn't close $quasi_filename at line $.: $!"); next FILE; } } # foreach file } sub set_encoding(*$) { my ($handle, $path) = @_; my $enc_name = "utf8"; if ($path && $path =~ m{ \. ([^\s.]+) \z }x) { my $ext = $1; die unless defined $ext; require Encode; if (my $enc_obj = Encode::find_encoding($ext)) { my $name = $enc_obj->name || $ext; $enc_name = "encoding($name)"; } } return 1 if eval { use warnings FATAL => "all"; no strict "refs"; binmode($handle, ":$enc_name"); 1; }; for ($@) { s/ at .* line \d+\.//; s/$/ for $path/; } yuck("set_encoding: $@"); return undef; } sub fix_extension { my $path = shift(); my %Compress = ( Z => "zcat", z => "gzcat", # for uncompressing gz => "gzcat", bz => "bzcat", bz2 => "bzcat", bzip => "bzcat", bzip2 => "bzcat", lzma => "lzcat", ); if ($path =~ m{ \. ( [^.\s] +) \z }x) { if (my $prog = $Compress{$1}) { return "$prog $path |"; } } return $path; }
