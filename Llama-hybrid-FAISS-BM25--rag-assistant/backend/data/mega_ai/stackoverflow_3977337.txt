[site]: stackoverflow
[post_id]: 3977337
[parent_id]: 3974746
[tags]: 
I don't know any database access layer that permits this. The reason is that each thread has its own " thread local storage " (The threadvar keyword in Delphi, other languages have equivalents, it is used in a lot of frameworks). When you start things on one thread, and continue it on another, then you get these local storages mixed up causing all sorts of havoc. The best you can do is this: pass the query and parameters to the thread that will handle this (use the standard Delphi thread synchronization mechanisms for this) have the actual query thread perform the query return the results to the main thread (use the standard Delphi thread synchronization mechanisms for this) The answers to this question explains thread synchronization in more detail. Edit: (on presumed slowness of starting something in an other thread) "Right away" is a relative term: it depends in how you do your thread synchronization and can be very very fast (i.e. less than a millisecond). Creating a new thread might take some time. The solution is to have a threadpool of worker threads that is big enough to service a reasonable amount of requests in an efficient manner. That way, if the system is not yet too busy, you will have a worker thread ready to start servicing your request almost immediately. I have done this (even cross process) in a big audio application that required low latency response, and it works like a charm. The audio server process runs at high priority waiting for requests. When it is idle, it doesn't consume CPU, but when it receives a request it responds really fast. The answers to this question on changes with big improvements and this question on cross thread communication provide some interesting tips on how to get this asynchronous behaviour working. Look for the words AsyncCalls , OmniThread and thread . --jeroen
