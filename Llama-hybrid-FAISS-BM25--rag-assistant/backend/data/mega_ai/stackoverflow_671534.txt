[site]: stackoverflow
[post_id]: 671534
[parent_id]: 671520
[tags]: 
First of all, here's the documentation for grep Let me clean up your code and explain it piece by piece # 1 cars = [:Ford, :Toyota, :Audi, :Honda] # 2 ucased_cars = cars.collect do |c| c.to_s end.grep(/^Ford/) do |car| # 3 puts car.upcase # 4 car.upcase # 5 end # 6 # 7 puts "ucased:" + ucased_cars.to_s Declare array of symbols Convert symbols to strings by using collect. You get ["Ford", "Toyota", "Audi", "Honda"] Feed this array of strings into grep. Any of the items which match the regexp /^Ford/ will get fed to the block The block prints out the upcased string that it got fed The block returns the upcased string, which grep then takes as the "match value" the return value from grep (which is an array of all the "match values") gets assigned to ucased_cars , it is ["FORD"] , because that was the only thing that matched the regex. It then gets printed. doing a to_s on an array just prints all the elements jammedtogetherlikethis. This isn't very useful, you're better off printing ucased_cars.inspect To answer your question about how grep works behind the scenes... The above documentation page shows the C source for grep itself. It basically does this: allocate a new ruby array (dynamically sized) call rb_iterate to walk over each element in the source, passing some grep-specific code in. rb_iterate is also used by collect , each_with_index and a bunch of other stuff. As we know how collect/each/etc all work, we don't need to do any more spelunking in the source code, we have our answer, and it's your [B]. To explain in more detail, it does this: Make a new array to hold return values. Get the next item from the source If it matches the regex: If a block was given, call the block, and whatever the block returns, put it in the return values. If a block was not given, put the item in the return values Goto 2, repeat until no more items in the source. As to your comment of "A seems to make a lot more sense" - I don't agree. The idea is that the block does something with each element. If it scanned the source first, and then passed the array of matches to the block, your block would then have to call each itself, which would be cumbersome. Secondly, it would be less efficient. What happens for example, if your block calls return or raises an error? In it's current incarnation, you avoid having to scan the rest of the source. If it had already scanned the entire source list up-front, you'd have wasted all this effort.
