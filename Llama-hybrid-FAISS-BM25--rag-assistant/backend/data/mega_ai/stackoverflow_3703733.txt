[site]: stackoverflow
[post_id]: 3703733
[parent_id]: 3703658
[tags]: 
It really depends what you're trying to implement, exactly. Usually enum indicates runtime subtypes of a particular class, or a discriminated union (boost::variant). But in this case, you want to pass the enum directly. Moreover, you have a limited set of possible values, and each function call forms a subset. Really what you are representing is one subset, not several parameters at all. The best way to represent a subset of a finite set is a bitset. Large sets should use std::bitset ; small sets can just use unsigned long . enum Maiden_set { Eunice = 1, , Beatrice = 2 , Una_Brow = 4 , Helga = 8 , Aida = 16 }; dragon_list_t make_dragon_list(Maiden_set) { //here be dragons } make_dragon_list( Eunice + Beatrice + Helga ); or, since you appear to want to handle variation at compile time, template // parameter is not a Maiden_set because enum+enum=int dragon_list_t make_dragon_list() { //here be dragons } make_dragon_list (); // + promotes each enum to int It should be possible to generate the powers of 2 automatically using an operator+ overloaded on the enum type. But I'm not sure I'm on the right track at all.
