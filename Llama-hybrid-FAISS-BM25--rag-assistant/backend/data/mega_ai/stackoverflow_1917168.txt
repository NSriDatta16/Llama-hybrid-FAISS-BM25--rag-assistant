[site]: stackoverflow
[post_id]: 1917168
[parent_id]: 1906670
[tags]: 
To answer your second question, I think you are doing a reasonable job trying to clean up your thread pool. With respect to your first question, I think the method that you want to use is submit rather than execute . Rather than try to explain it all in text, here's an edited fragment from a unit test that I wrote that makes many tasks, has each of them do a fragment of the total work and then meets back at the starting point to add the results: final AtomicInteger messagesReceived = new AtomicInteger(0); // ThreadedListenerAdapter is the class that I'm testing // It's not germane to the question other than as a target for a thread pool. final ThreadedListenerAdapter adapter = new ThreadedListenerAdapter (listener); int taskCount = 10; List > taskList = new ArrayList >(); for (int whichTask = 0; whichTask futureTask = new FutureTask (new Callable () { @Override public Integer call() throws Exception { // Does useful work that affects messagesSent return messagesSent; } }); taskList.add(futureTask); } for (FutureTask task : taskList) { LocalExecutorService.getExecutorService().submit(task); } for (FutureTask task : taskList) { int result = 0; try { result = task.get(); } catch (InterruptedException ex) { Thread.currentThread().interrupt(); } catch (ExecutionException ex) { throw new RuntimeException("ExecutionException in task " + task, ex); } assertEquals(maxMessages, result); } int messagesSent = taskCount * maxMessages; assertEquals(messagesSent, messagesReceived.intValue()); I think this fragment is similar to what you're trying to do. The key components were the submit and get methods.
