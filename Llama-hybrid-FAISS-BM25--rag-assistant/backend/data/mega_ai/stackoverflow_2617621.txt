[site]: stackoverflow
[post_id]: 2617621
[parent_id]: 2617476
[tags]: 
This seems like a problem that can be solved with a PID controller . I use them in my work to control a heater output to set a temperature. For the 'P' component, you apply a torque that is proportional to the difference between the turret angle and the target angle i.e. P = P0 * differenceAngle If this still oscillates too much (it will a bit) then add an 'I' component, integAngle = integAngle + differenceAngle * dt I = I0 * integAngle If this overshoots too much then add a 'D' term derivAngle = (prevDifferenceAngle - differenceAngle) / dt prevDifferenceAngle = differenceAngle D = D0 * derivAngle P0 , I0 and D0 are constants that you can tune to get the behaviour that you want (i.e. how fast the turrets respond etc.) Just as a tip, normally P0 > I0 > D0 Use these terms to determine how much torque is applied i.e. magnitudeAngMomentum = P + I + D EDIT: Here is an application written using Processing that uses PID. It actually works fine without I or D. See it working here // Demonstration of the use of PID algorithm to // simulate a turret finding a target. The mouse pointer is the target float dt = 1e-2; float turretAngle = 0.0; float turretMass = 1; // Tune these to get different turret behaviour float P0 = 5.0; float I0 = 0.0; float D0 = 0.0; float maxAngMomentum = 1.0; void setup() { size(500, 500); frameRate(1/dt); } void draw() { background(0); translate(width/2, height/2); float angVel, angMomentum, P, I, D, diffAngle, derivDiffAngle; float prevDiffAngle = 0.0; float integDiffAngle = 0.0; // Find the target float targetX = mouseX; float targetY = mouseY; float targetAngle = atan2(targetY - 250, targetX - 250); diffAngle = targetAngle - turretAngle; integDiffAngle = integDiffAngle + diffAngle * dt; derivDiffAngle = (prevDiffAngle - diffAngle) / dt; P = P0 * diffAngle; I = I0 * integDiffAngle; D = D0 * derivDiffAngle; angMomentum = P + I + D; // This is the 'maxTorque' equivelant angMomentum = constrain(angMomentum, -maxAngMomentum, maxAngMomentum); // Ang. Momentum = mass * ang. velocity // ang. velocity = ang. momentum / mass angVel = angMomentum / turretMass; turretAngle = turretAngle + angVel * dt; // Draw the 'turret' rotate(turretAngle); triangle(-20, 10, -20, -10, 20, 0); prevDiffAngle = diffAngle; }
