[site]: stackoverflow
[post_id]: 1815850
[parent_id]: 1815497
[tags]: 
You seem to be on the right track and the answers above have some good ideas. But I note that all these recursive solutions have some deep flaws. Let's suppose the tree in question has a total of n nodes with a max tree depth of d First off, they consume system stack space in the depth of the tree. If the tree structure is very deep, then this can blow the stack and crash the program. Tree depth d is O(lg n), depending on the branching factor of the tree. Worse case is no branching at all -- just a linked list -- in which case a tree with only a few hundred nodes will blow the stack. Second, what you're doing here is building an iterator that calls an iterator that calls an iterator ... so that every MoveNext() on the top iterator actually does a chain of calls that is again O(d) in cost. If you do this on every node, then the total cost in calls is O(nd) which is worst case O(n^2) and best case O(n lg n). You can do better than both; there's no reason why this cannot be linear in time. The trick is to stop using the small, fragile system stack to keep track of what to do next, and to start using a heap-allocated stack to explicitly keep track. You should add to your reading list Wes Dyer's article on this: https://blogs.msdn.microsoft.com/wesdyer/2007/03/23/all-about-iterators/ He gives some good techniques at the end for writing recursive iterators.
