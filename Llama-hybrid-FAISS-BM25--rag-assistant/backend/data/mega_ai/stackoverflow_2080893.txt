[site]: stackoverflow
[post_id]: 2080893
[parent_id]: 2078978
[tags]: 
Object Oriented Programming offers: Encapsulation, to control mutation of internal state limit coupling to internal representation Subtyping, allowing: substitution of compatible types (polymorphism) a crude means of sharing implementation between classes (implementation inheritance) Functional Programming, in Haskell or even in Scala, can allow substitution through more general mechanism of type classes. Mutable internal state is either discouraged or forbidden. Encapsulation of internal representation can also be achieved. See Haskell vs OOP for a good comparison. Norman's assertion that "Adding a new kind of thing to a functional program may require editing many function definitions to add a new case." depends on how well the functional code has employed type classes. If Pattern Matching on a particular Abstract Data Type is spread throughout a codebase, you will indeed suffer from this problem, but it is perhaps a poor design to start with. EDITED Removed reference to implicit conversions when discussing type classes. In Scala, type classes are encoded with implicit parameters, not conversions, although implicit conversions are another means to acheiving substitution of compatible types.
