[site]: stackoverflow
[post_id]: 791645
[parent_id]: 
[tags]: 
Styling UITextField

I've been playing around with different methods of determining at runtime the width of a "label" so that I can resize the "label" because I don't want it to truncate. I've finally found an easy solution through UITextField which allows me to set the .autoSize which is great! However, now I'm trying to "style" (simply adjust font and font size) of the UITextField but it seems that I have to do it manually with ' .htmlText ' (which I'll gladly accept if that is the ONLY way). I'm using the .text to set the value of the label. My test case involves a HBox (I'm actually using a Grid but they should be the same and I've done testing on both): I style the HBox and the style carries through to the UITextField . I don't believe this will work for me because I have other components inside that I need to style differently. I've tried: UITextFormat and TextFormat (I see that the .htmlText being updated accordingly but the output doesn't update. Then I noticed that whenever I called hbox.addChild(myUITextField) it would override the .htmlText I've tried setting the style with myUITextField.setStyle("fontSize", 20) before and/or after the call to addChild neither of which made an impact on the display as per what I noted above. Changes are being made but they seem to be overrided when I add it to the display. So what do I need to do in order to style the UITextField aside from manually setting it along with my contents in .htmlText ? Solutions not using UITextField is fine as long as there is some easy way of not truncating the text. EDIT: I want to just do textField.setStyle('fontSize', 20) and expect that every time I change the text, I wouldn't need to use HTML to go with it (so I can just do textField.text = 'something else' and expect that it will still have a font size of 20). This is what I meant by not using .htmlText (sorry if I wasn't clear before). 2nd EDIT : I guess I should present the whole issue and maybe that'll clarify what I did wrong or couldn't achieve. My intent is to have a Grid and add text into it. I do not want it to wrap or scroll so I add it to the next row in the Grid when the current row's children total width exceeds some number. In order to add it to the next row, I need to be able to calculate the width of the text. I would like to be able to style that text individually based on cases and there might be other components (like a TextInput ). Essentially what I'm trying to accomplish is "Fill in the Blank". I've included code to show what I'm currently doing and it works somewhat. It might be un-related to the original issue of styling but I can't figure out how to adjust the distance between each UITextField but aside from that this fits what I would like to accomplish. Relevant to the question is: I would like to change the way I style each UITextField (currently setting .htmlText ) into something a bit straightforward though like I previously mentioned I'll gladly accept using .htmlText if that's the only solution. So I have a Grid with x Rows in it and in each row, I have exactly one GridItem. Based on the input, I add UITextField and TextInput into the GridItem going on to the next GridItem when necessary. If you have a better way of doing so then that would be better but I guess what I really want is to find a different way of styling. Also another problem , I'm not sure of the exact way to add a TextField into the display. I tried: var t : TextField = new TextField(); t.text = "I'm a TextField"; hBox.addChild(t); // doesn't work //this.addChild(t); // doesn't work either But I get the following error: TypeError: Error #1034: Type Coercion failed: cannot convert flash.text::TextField@172c8f9 to mx.core.IUIComponent. Here's what I have that's working. private function styleQuestionString(str : String) : String { return ' ' + str + ' '; } private function loadQuestion(str : String) : void { /* Split the string */ var tmp : Array = str.split("_"); /* Track the current width of the GridItem */ var curWidth : int = 0; /* Display components that we will add */ var txtField : UITextField = null; var txtInput : TextInput = null; /* Track the current GridItem */ var curGridItem : GridItem = null; /* Track the GridItem we can use */ var gridItemAC : ArrayCollection = new ArrayCollection(); var i : int = 0; /* Grab the first GridItem from each GridRow of Grid */ var tmpChildArray : Array = questionGrid.getChildren(); for (i = 0; i = 670) { curGridItem = gridItemAC[0]; curGridItem.setStyle("leading", "1"); if (gridItemAC.length != 1) { gridItemAC.removeItemAt(0); } // TODO Configure the proper gap distance curWidth = txtLineMetrics.width + 2; } displayObj = curGridItem.addChild(txtField); } } //txtField.setColor(0xFF0000); // WORKS if (curItem != tmp.length - 1) { txtInput = new TextInput(); txtInput.tabIndex = txtInputCounter; txtInput.setStyle("fontSize", 12); txtInputCounter++; txtInput.setStyle("textAlign", "center"); txtInput.width = TEXT_INPUT_WIDTH; curWidth += TEXT_INPUT_WIDTH; if (curWidth >= 670) { curGridItem = gridItemAC[0]; if (gridItemAC.length != 1) { gridItemAC.removeItemAt(0); } // TODO Decide if we need to add a buffer curWidth = TEXT_INPUT_WIDTH + 2; } curGridItem.addChild(txtInput); txtInputAC.addItem(txtInput); /* Adds event listener so that we can perform dragging into the TextInput */ txtInput.addEventListener(DragEvent.DRAG_ENTER, dragEnterHandler); txtInput.addEventListener(DragEvent.DRAG_DROP, dragDropHandler); txtInput.addEventListener(DragEvent.DRAG_EXIT, dragExitHandler); } /* Add event so that this label can be dragged */ //txtField.addEventListener(MouseEvent.MOUSE_MOVE, dragThisLabel(event, txtField.text)); } }
