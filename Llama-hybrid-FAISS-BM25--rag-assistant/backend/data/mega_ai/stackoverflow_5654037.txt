[site]: stackoverflow
[post_id]: 5654037
[parent_id]: 5653562
[tags]: 
As the other answers indicate, there's more than one way to do it. Here's an especially peculiar one for your information: although it's not portable C so perhaps is better suited to assembly: struct Node { Node *next; Node *prev; }; struct List { Node *a; Node *b; Node *c; List : a(tail()), b(0), c(head()) Node *head() { return (Node *)&a; } Node *tail() { return (Node *)&b; } }; So, a struct contains a dummy head node (whose prev pointer of course is always 0) and a dummy tail node (whose next pointer is always 0), and to save a massive sizeof(Node*) bytes storage per list, they overlap (which is what makes it non-portable). The overlap isn't essential, you could put two Node in the List instead of three Node* . This is a useful structure in that it gives you both a "before-the-beginning" and an "after-the-end" node in the list, which means you can perform all of remove , insert_after and insert_before on nodes without reference to the list head at all. In that respect it's like James's circular list, but unlike his you can also check for the ends by looking for the null pointer - also without reference to the head. File under, "tricks I don't need to play".
