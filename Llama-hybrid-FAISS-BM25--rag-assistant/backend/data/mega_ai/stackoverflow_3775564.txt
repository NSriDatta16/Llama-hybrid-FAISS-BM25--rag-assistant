[site]: stackoverflow
[post_id]: 3775564
[parent_id]: 3774315
[tags]: 
For a generalized, threadsafe higher-level function, you could use something like the following in combination with the Queue.Queue class and some other bits: from Queue import Empty def Accumulator(f, q, storage): """Yields successive values of `f` over the accumulation of `q`. `f` should take a single iterable as its parameter. `q` is a Queue.Queue or derivative. `storage` is a persistent sequence that provides an `append` method. `collections.deque` may be particularly useful, but a `list` is quite acceptable. >>> from Queue import Queue >>> from collections import deque >>> from threading import Thread >>> def mean(it): ... vals = tuple(it) ... return sum(it) / len(it) >>> value_queue = Queue() >>> LastThreeAverage = Accumulator(mean, value_queue, deque((), 3)) >>> def add_to_queue(it, queue): ... for value in it: ... value_queue.put(value) >>> putting_thread = Thread(target=add_to_queue, ... args=(range(0, 12, 2), value_queue)) >>> putting_thread.start() >>> list(LastThreeAverage) [0, 1, 2, 4, 6, 8] """ try: while True: storage.append(q.get(timeout=0.1)) q.task_done() yield f(storage) except Empty: pass This generator function evades most of its purported responsibility by delegating it to other entities: It relies on Queue.Queue to supply its source elements in a thread-safe manner A collections.deque object can be passed in as the value of the storage parameter; this provides, among other things, a convenient way to only use the last n (in this case 3) values The function itself (in this case mean ) is passed as a parameter. This will result in less-than-optimally efficient code in some cases, but is readily applied to all sorts of situations. Note that there is a possibility of the accumulator timing out if your producer thread takes longer than 0.1 seconds per value. This is easily remedied by passing a longer timeout or by removing the timeout parameter entirely. In the latter case the function will block indefinitely at the end of the queue; this usage makes more sense in a case where it's being used in a sub thread (usually a daemon thread). Of course you can also parametrize the arguments that are passed to q.get as a fourth argument to Accumulator . If you want to communicate end of queue, i.e. that there are no more values to come, from the producer thread (here putting_thread ), you can pass and check for a sentinel value or use some other method. There is more info in this thread ; I opted to write a subclass of Queue.Queue called CloseableQueue that provides a close method. There are various other ways you could customize the behaviour of such a function, for example by limiting the queue size; this is just an example of usage. edit As mentioned above, this loses some efficiency because of the necessity of recalculation and also, I think, doesn't really answer your question. A generator function can also accept values through its send method. So you can write a mean generator function like def meangen(): """Yields the accumulated mean of sent values. >>> g = meangen() >>> g.send(None) # Initialize the generator >>> g.send(4) 4.0 >>> g.send(10) 7.0 >>> g.send(-2) 4.0 """ sum = yield(None) count = 1 while True: sum += yield(sum / float(count)) count += 1 Here the yield expression is both bringing values —the arguments to send — into the function, while simultaneously passing the calculated values out as the return value of send . You can pass the generator returned by a call to that function to a more optimizable accumulator generator function like this one: def EfficientAccumulator(g, q): """Similar to Accumulator but sends values to a generator `g`. >>> from Queue import Queue >>> from threading import Thread >>> value_queue = Queue() >>> g = meangen() >>> g.send(None) >>> mean_accumulator = EfficientAccumulator(g, value_queue) >>> def add_to_queue(it, queue): ... for value in it: ... value_queue.put(value) >>> putting_thread = Thread(target=add_to_queue, ... args=(range(0, 12, 2), value_queue)) >>> putting_thread.start() >>> list(mean_accumulator) [0.0, 1.0, 2.0, 3.0, 4.0, 5.0] """ try: while True: yield(g.send(q.get(timeout=0.1))) q.task_done() except Empty: pass
