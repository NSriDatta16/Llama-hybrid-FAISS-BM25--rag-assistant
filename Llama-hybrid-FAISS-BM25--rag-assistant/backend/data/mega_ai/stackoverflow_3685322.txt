[site]: stackoverflow
[post_id]: 3685322
[parent_id]: 3685129
[tags]: 
You class C will require an override keyword on val foo to compile, rendering it identical to D . It will store its own copy of foo. You class B does not add storage unless someplace outside its constructor body there is a reference to foo . That would force a hidden field to be created to hold the constructor parameter. The constructor body is all the code within the class definition and outside any method body . Addendum: package storage class A(val foo: String) class B( foo: String) extends A(foo) // class C( val foo: String) extends A(foo) class D(override val foo: String) extends A(foo) class E( bar: String) extends A(bar) class F( bar: String) extends A(bar) { def barbar: String = bar } I am perplexed by this: % javap -private storage.F Compiled from "Storage.scala" public class storage.F extends storage.A implements scala.ScalaObject{ public java.lang.String barbar(); public storage.F(java.lang.String); } What is method barbar using to get its return value?
