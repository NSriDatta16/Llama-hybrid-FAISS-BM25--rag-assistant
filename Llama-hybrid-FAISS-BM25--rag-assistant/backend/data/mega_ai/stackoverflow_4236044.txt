[site]: stackoverflow
[post_id]: 4236044
[parent_id]: 2900691
[tags]: 
I think it is a matter of preference but I like to have the sprite detect if it was touched by subclassing CCSprite. I make a getter method in my CCSprite subclass that retrieves the state variable from the subclass and then the main program can act accordingly. Here is an example header file for my CCSprite subclass "spuButton": #import "cocos2d.h" typedef enum tagButtonState { kButtonStatePressed, kButtonStateNotPressed } ButtonState; typedef enum tagButtonStatus { kButtonStatusEnabled, kButtonStatusDisabled } ButtonStatus; @interface spuButton : CCSprite { @private ButtonState state; CCTexture2D *buttonNormal; CCTexture2D *buttonLit; ButtonStatus buttonStatus; } @property(nonatomic, readonly) CGRect rect; + (id)spuButtonWithTexture:(CCTexture2D *)normalTexture; - (void)setNormalTexture:(CCTexture2D *)normalTexture; - (void)setLitTexture:(CCTexture2D *)litTexture; - (BOOL)isPressed; - (BOOL)isNotPressed; @end and here is an example of the .m file: #import "spuButton.h" #import "cocos2d.h" @implementation spuButton - (CGRect)rect { CGSize s = [self.texture contentSize]; return CGRectMake(-s.width / 2, -s.height / 2, s.width, s.height); } + (id)spuButtonWithTexture:(CCTexture2D *)normalTexture { return [[[self alloc] initWithTexture:normalTexture] autorelease]; } - (void)setNormalTexture:(CCTexture2D *)normalTexture { buttonNormal = normalTexture; } - (void)setLitTexture:(CCTexture2D *)litTexture { buttonLit = litTexture; } - (BOOL)isPressed { if (state == kButtonStateNotPressed) return NO; if (state == kButtonStatePressed) return YES; return NO; } - (BOOL)isNotPressed { if (state == kButtonStateNotPressed) return YES; if (state == kButtonStatePressed) return NO; return YES; } - (id)initWithTexture:(CCTexture2D *)aTexture { if ((self = [super initWithTexture:aTexture]) ) { state = kButtonStateNotPressed; } return self; } - (void)onEnter { [[CCTouchDispatcher sharedDispatcher] addTargetedDelegate:self priority:0 swallowsTouches:YES]; [super onEnter]; } - (void)onExit { [[CCTouchDispatcher sharedDispatcher] removeDelegate:self]; [super onExit]; } - (BOOL)containsTouchLocation:(UITouch *)touch { return CGRectContainsPoint(self.rect, [self convertTouchToNodeSpaceAR:touch]); } - (BOOL)ccTouchBegan:(UITouch *)touch withEvent:(UIEvent *)event { if (state == kButtonStatePressed) return NO; if ( ![self containsTouchLocation:touch] ) return NO; if (buttonStatus == kButtonStatusDisabled) return NO; state = kButtonStatePressed; [self setTexture:buttonLit]; return YES; } - (void)ccTouchMoved:(UITouch *)touch withEvent:(UIEvent *)event { // If it weren't for the TouchDispatcher, you would need to keep a reference // to the touch from touchBegan and check that the current touch is the same // as that one. // Actually, it would be even more complicated since in the Cocos dispatcher // you get NSSets instead of 1 UITouch, so you'd need to loop through the set // in each touchXXX method. if ([self containsTouchLocation:touch]) return; //if (buttonStatus == kButtonStatusDisabled) return NO; state = kButtonStateNotPressed; [self setTexture:buttonNormal]; } - (void)ccTouchEnded:(UITouch *)touch withEvent:(UIEvent *)event { state = kButtonStateNotPressed; [self setTexture:buttonNormal]; } @end Hope this helps and Happy coding! ADDITION of tick method and explanation (for Stephan's question below): To check the status of the buttons I have a tick: method that basically fires every frame and checks the status of all my buttons. -(void)tick:(ccTime)dt { do my button checks here.... } I check the status of my buttons by calling a isPressed or isNotPressed function that is part of my spuButton class. for (spuButton *aButton in _fourButtonsArray) { if ([aButton isNotPressed]) continue; //this button is not pressed .....otherwise record that it is pressed..... } Then I do the same kind of check to see if it has been released and respond accordingly. I do it this way because I want to be able to react to multiple button press combos plus I want to do something when it gets pressed down and then something else when it gets released. I use the ccTouchBegan and ccTouchEnded to change the textures(the sprite image) and to change the state variable accordingly.
