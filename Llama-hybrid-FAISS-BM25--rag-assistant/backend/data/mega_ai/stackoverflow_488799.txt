[site]: stackoverflow
[post_id]: 488799
[parent_id]: 488684
[tags]: 
I'm working on a project that does lots of different, horribly complex things, in a framework that is supposed to be easily extensible by others. At first, classes were large and did multiple things. In order to change those behaviors, you had to extend those classes. The methods were all virtual and didn't change the object's state, so it was pretty easy to do this. But as the system grew, it became more clear that the framework was going to end up with a series of monolithic objects, each with looooong inheritance chains. This also resulted in unexpected dependencies--an abstract method taking a collection of class X to produce object Y defined in a base class dictated that EVERYBODY had to do it this way, even when it made no sense for half of the inheritance tree. This also resulted in massive classes that required tens of unit tests to get the code coverage over 80%, and the complexity was such that you weren't sure if you covered everything correctly. It was obvious this design would cause the framework to be very rigid and inflexible. So we redesigned everything along SRP lines. You'd have your interface, a base class and, possibly, one or more implementation classes. Each one was composed of different objects which performed key functions of the overall process. If you wanted to change one part, you didn't override a method, you would produce another object that extended the requisite interface/base class and performed its job differently. SRP was even taken down into the arguments and return values of the class methods. For those parts of the system that needed to be flexible, rather than pass collections of X class that are used to produce Y objects, a class was created to encapsulate the process of production of Y objects. Components in the system would then pass these producers around, combine them with others (the responsibility of the producers), and eventually use them to produce Y. This allowed for different types of producers to be created, all of which could be treated exactly the same, even though they did vastly different things. The move also drastically reduced each class' code base and made them MUCH easier to test. I would say that, as a new developer, it is VERY HARD to break everything down to this level. You almost have to write a big ball of mud, understand how it works, then redesign it as several different components, each taking responsibility for a part of the whole.
