[site]: stackoverflow
[post_id]: 277786
[parent_id]: 12516
[tags]: 
Hm... I don't think you can write a top-down parser for this without backtracking, so it has to be some sort of a shift-reduce parser. LR(1) or even LALR will of course work just fine with the following (ad-hoc) language definition: Start -> E1 E1 -> E1+E1 | E1-E1 E1 -> E2*E2 | E2/E2 | E2 E2 -> number | (E1) Separating it out into E1 and E2 is necessary to maintain the precedence of * and / over + and -. But this is how I would do it if I had to write the parser by hand: Two stacks, one storing nodes of the tree as operands and one storing operators Read the input left to right, make leaf nodes of the numbers and push them into the operand stack. If you have >= 2 operands on the stack, pop 2, combine them with the topmost operator in the operator stack and push this structure back to the operand tree, unless The next operator has higher precedence that the one currently on top of the stack. This leaves us the problem of handling brackets. One elegant (I thought) solution is to store the precedence of each operator as a number in a variable. So initially, int plus, minus = 1; int mul, div = 2; Now every time you see a a left bracket increment all these variables by 2, and every time you see a right bracket, decrement all the variables by 2. This will ensure that the + in 3*(4+5) has higher precedence than the *, and 3*4 will not be pushed onto the stack. Instead it will wait for 5, push 4+5, then push 3*(4+5).
