[site]: stackoverflow
[post_id]: 61319
[parent_id]: 58431
[tags]: 
@Mendelt Siebenga Strings are corner-stone objects in programming languages. Different languages implement strings differently. An implementation of join() strongly depends on underlying implementation of strings. Pseudocode doesn't reflect underlying implementation. Consider join() in Python. It can be easily used: print ", ".join(["Alpha", "Beta", "Gamma"]) # Alpha, Beta, Gamma It could be easily implemented as follow: def join(seq, sep=" "): if not seq: return "" elif len(seq) == 1: return seq[0] return reduce(lambda x, y: x + sep + y, seq) print join(["Alpha", "Beta", "Gamma"], ", ") # Alpha, Beta, Gamma And here how join() method is implemented in C (taken from trunk ): PyDoc_STRVAR(join__doc__, "S.join(sequence) -> string\n\ \n\ Return a string which is the concatenation of the strings in the\n\ sequence. The separator between elements is S."); static PyObject * string_join(PyStringObject *self, PyObject *orig) { char *sep = PyString_AS_STRING(self); const Py_ssize_t seplen = PyString_GET_SIZE(self); PyObject *res = NULL; char *p; Py_ssize_t seqlen = 0; size_t sz = 0; Py_ssize_t i; PyObject *seq, *item; seq = PySequence_Fast(orig, ""); if (seq == NULL) { return NULL; } seqlen = PySequence_Size(seq); if (seqlen == 0) { Py_DECREF(seq); return PyString_FromString(""); } if (seqlen == 1) { item = PySequence_Fast_GET_ITEM(seq, 0); if (PyString_CheckExact(item) || PyUnicode_CheckExact(item)) { Py_INCREF(item); Py_DECREF(seq); return item; } } /* There are at least two things to join, or else we have a subclass * of the builtin types in the sequence. * Do a pre-pass to figure out the total amount of space we'll * need (sz), see whether any argument is absurd, and defer to * the Unicode join if appropriate. */ for (i = 0; i tp_name); Py_DECREF(seq); return NULL; } sz += PyString_GET_SIZE(item); if (i != 0) sz += seplen; if (sz PY_SSIZE_T_MAX) { PyErr_SetString(PyExc_OverflowError, "join() result is too long for a Python string"); Py_DECREF(seq); return NULL; } } /* Allocate result space. */ res = PyString_FromStringAndSize((char*)NULL, sz); if (res == NULL) { Py_DECREF(seq); return NULL; } /* Catenate everything. */ p = PyString_AS_STRING(res); for (i = 0; i Note that the above Catenate everything. code is a small part of the whole function. In pseudocode: /* Catenate everything. */ for each item in sequence copy-assign item if not last item copy-assign separator
