[site]: stackoverflow
[post_id]: 4124900
[parent_id]: 
[tags]: 
Is there a way to use two '...' statements in a function in R?

I want to write a function that calls both plot() and legend() and it would be ideal if the user could specify a number of additional arguments that are then passed through to either plot() or legend() . I know I can achieve this for one of the two functions using ... : foo.plot This passes xaxt = "n" to plot. But is there a way for example to pass e.g. title = "legend" to the legend() call without prespecifying the arguments in the function header? Update from the accepted answer: I thought that VitoshKa's way was the most elegant to accomplish what I wanted. However, there were some minor issues that I had to get around with until it worked as I wanted. At first, I checked which of the parameters I want to pass to legend and which to plot . First step to this end was to see which arguments of legend are unique to legend and not part of plot and/or par: legend.args I use dput() here, because the line plot.args always calls a new empty plot which I did not want. So, I used the output of dput in the following function. Next, I had to deal with the overlapping arguments (get them via dput(largs.all[(largs.all %in% pargs.all)]) ). For some this was trivial (e.g., x , y ) others get passed to both functions (e.g., pch ). But, in my real application I even use other strategies (e.g., different variable names for adj , but not implemented in this example). Finally, the do.call function had to be changed in two ways. First, the what part (i.e., called functions) needs to be a character (i.e., 'plot' instead of plot ). And the argument list must be constructed slightly different. foo.plot In this example, pch is passed to both plot and legend , title is only passed to legend , and ylim only to plot . Update 2 based on a comment by Gavin Simpson (see also the comments at Vitoshka's answer): (i) That's correct. (ii) It can always be a character. But if you have a variable with the same name as the function, then you need to quote the function name in do.call : min.plot (iii) You can use c(x = 1, y = 1, list()) and it works fine. However, what I really did (not in the example I gave but in my real function) is the following: c(x = 1, y = 1, xlim = c(0, 2), list(bla='foo')) Please compare this with: c(list(x = 1, y = 1, xlim = c(0, 2)), list(bla='foo')) In the first case, the list contains two elements xlim , xlim1 and xlim2 (each a scalar), in the latter case the list has only xlim (which is vector of length 2, which is what I wanted). So, you are right in all your points for my example. But, for my real function (with a lot more variables), I encountered these problems and wanted to document them here. Sorry for being imprecise.
