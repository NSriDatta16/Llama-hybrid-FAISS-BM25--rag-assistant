[site]: crossvalidated
[post_id]: 504806
[parent_id]: 504690
[tags]: 
The Bayesian framework is apt for including prior information and giving you prediction intervals. The mcp package can model AR(N) time series and the docs has a section on forecasting with future change points . In your case, it sounds like you may have an AR(1) stable intercept-only trend which shifts 20% down. I briefly present how I would approach it and refer to the article above for more details why this works. Here, I model a change to 80% of the current intercept, 30 days after the last observed data point (with an uncertainty of SD = 10 days). Say x is your date in days and y is your volume: # Model current status model_now = list(y ~ 1 + ar(1)) fit_now = mcp(model, data = my_data, sample = FALSE, par_x = "x") # Extend it to include the unobserved future segment model_forecast = list( y ~ 1 + ar(1), # current segment ~ 1 # future segment ) prior_forecast = c(fit_now$prior, list( int_2 = "int_1 * 0.8", # 20% lower intercept cp_1 = "dnorm(MAXX + 30, 10)[MAXX, ]" # Prior knowledge about when the change happens )) fit_forecast = mcp(model_forecast, my_data, prior = prior_forecast) Now you can make predictions about the future, e.g., newdata = data.frame(x = max(my_data$x) + c(10, 20, 30, 40)) predict(fit_forecast, newdata) Options for further refinement: If your volume is counts, you may consider using another response family, e.g., mcp(..., family = poison()) or mcp(..., family = binomial()) . You can do e.g., int_2 = "dnorm(int_1 * 0.8, 2)" if you want to model uncertainty about the magnitude of the change too. This is a very simple intercept-only model. Check the mcp docs for many more modeling options. The default priors in fit_now$prior are quite vague. You can update them to better fit your problem. Disclosure: I am the developer of mcp . The code here is for illustration only since you did not provide data.
