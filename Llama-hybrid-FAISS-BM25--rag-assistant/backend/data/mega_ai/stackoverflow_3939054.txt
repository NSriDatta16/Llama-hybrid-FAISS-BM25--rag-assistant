[site]: stackoverflow
[post_id]: 3939054
[parent_id]: 
[tags]: 
Dynamic casting in Java

Before I get chided for not doing my homework, I've been unable to find any clues on the multitude of questions on Java generics and dynamic casting. The type Scalar is defined as follows: public class Scalar { public final String name; T value; ... public T getValue() { return value; } public void setValue(T val) { this.value = val; } } I would like to have a method that looks like this: public void evilSetter(V val) { this.value = (T) val; } Sure, this is generally discouraged. The reason I want such a method is because I have a collection of Scalars whose values I'd like to change later. However, once they go in the collection, their generic type parameters are no longer accessible. So even if I want make an assignment that's perfectly valid at runtime, there's no way of knowing that it'll be valid at compile time, with or without generics. Map > scalars = ...; Scalar scalar = scalars.get("someId"); // None of this can work scalar.value = ... scalar.setValue(...) So how do I implement a checked cast and set method? public void castAndSet(V val) { // One possibility if (this.value.getClass().isAssignableFrom(val.getClass()) { // Some cast code here } // Another if (this.value.getClass().isInstanceOf(val) { // Some cast code here } // What should the cast line be? // It can't be: this.value = this.value.getClass().cast(val); // Because this.value.getClass() is of type Class , not Class } So I'm left with using this.value = (T) val; and catching a ClassCastException?
