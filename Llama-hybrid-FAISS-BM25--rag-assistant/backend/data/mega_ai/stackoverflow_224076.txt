[site]: stackoverflow
[post_id]: 224076
[parent_id]: 223215
[tags]: 
I think in this day and age, in C++, the C-style cast to char* disqualifies you from any "brilliant design idea" awards without getting much of a hearing. I might go for: #include #include class Header { private: uint32_t type; uint32_t payloadlength; public: uint32_t getType() { return ntohl(type); } uint32_t getPayloadLength() { return ntohl(payloadlength); } }; class Message { private: Header head; char payload[1]; /* or maybe std::vector : see below */ public: uint32_t getType() { return head.getType(); } uint32_t getPayloadLength() { return head.getPayloadLength(); } const char *getPayload() { return payload; } }; This assumes C99-ish POSIX, of course: to port to non-POSIX platforms you'd have to define one or both of uint32_t and ntohl yourself, in terms of whatever the platform does offer. It's usually not hard. In theory you might need layout pragmas in both classes. In practice I'd be surprised given the actual fields in this case. The issue can be avoided by reading/writing the data from/to iostreams one field at a time, rather than trying to construct the bytes of the message in memory and then write it in one go. It also means you can represent the payload with something more helpful than a char[], which in turn means you won't need to have a maximum message size, or mess about with malloc and/or placement new, or whatever. Of course it introduces a bit of overhead.
