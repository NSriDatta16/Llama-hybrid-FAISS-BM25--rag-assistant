[site]: stackoverflow
[post_id]: 5033576
[parent_id]: 5032916
[tags]: 
From your question I assume you have some huge middleware, and have only access to shaders, am I right ? In this case, create in your vertex shader a varying called, for instance, vertexID : varying float vertexID; # in GLSL and assign it the built-in gl_VertexID : vertexID = (float)gl_VertexID; This way, you'll get access to gl_VertexID from the fragment shader, but interpolated ! This is great because it will be, for instance, 2 at one vertex, 3 at the neighbour, and 2.5 inbetween. So you just have to check if vertexID is close to 2 (resp. 3) : if so, you're close to an edge. That should be good enough for visualisation & debug. in float vertexID; # or varying float vertexID; // blabla if (fract(vertexID) Note that you'll get only 2 edges of each triangle this way. And maybe some will be ver thin ( if one vertexID is 2 and the other 1000, the 0.1 zone is little ).
