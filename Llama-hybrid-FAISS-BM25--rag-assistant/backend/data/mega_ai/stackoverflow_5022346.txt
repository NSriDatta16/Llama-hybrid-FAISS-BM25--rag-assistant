[site]: stackoverflow
[post_id]: 5022346
[parent_id]: 5022031
[tags]: 
You can spend half a semester talking about either of the containers, but here are a few points: std::vector is a contiguous container, which means every element follows right after the previous element in memory. It can grow at runtime, which means it allocates its storage in dynamic memory. std::list is a bidirectional linked list. This means that the elements are scattered in memory in arbitrary layout, and that each element knows where the next and previous elements in sequence are. std::vector , std::list and the other containers don't take ownership of the elements they hold, but they do cleanup after themselves. So, if the elements are pointers to dynamic memory then the user must free the pointers before the container destructs. But if the container contains automatic data then the data's destructors will call automatically upon the container's cleanup. So far, very simple and roughly equivalent to any other language or toolset. What's unique about the STL is that the containers are generic and decoupled from the means of iterating over them and (for the most part) from the operations you can perform over them. Some operations can be done particularly efficiently with some containers, so the containers will provide member functions in these cases. For example, std::list has a sort() member function. The STL doesn't provide container classes (for the most part), but rather container templates . In other words, when the library talks about a container it only refers to the data type anonymously, say, as T , never by its true name. Never int or double or Car ; always T , for any type. There are exceptions, like std::vector , but this is the general case. Then, when the user instantiates a container template, they specify a type, and the compiler creates a container class from the template for that type. The STL also offers algorithms as free template functions. These algorithms work on iterators , themselves templates. Often iterators come in pairs that denote the beginning and end of a sequence, on which the algorithm operates. std::vector , std::list and other containers then expose their own iterators that can traverse and manipulate their data. So the same free algorithm can work on a std::vector and a std::list and other containers, provided the iterators conform with specific assumptions about the iterators' abilities. All this abstraction is done at compile-time, and that is the biggest difference when compared to other languages. This translates to outstanding performance with relatively short and concise code. The same performance that in C you'd only get with lots of copy-pasting or hardcoding.
