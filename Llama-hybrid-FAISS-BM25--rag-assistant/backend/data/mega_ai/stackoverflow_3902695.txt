[site]: stackoverflow
[post_id]: 3902695
[parent_id]: 3902456
[tags]: 
From the last code snippet: vector > pixelsVector (WIDTH, vector (HEIGHT)); Using uppercase names for variables you risk name collisions with macros. In C++ all uppercase names are conventionally reserved for macros. ... vector > > pixelsArray; Presumably this vector is the same as is called pixels below? If so, then the standard advice is that it helps to post real code. Anyway, in order to output those bytes in one efficient operation you need the bytes to be contiguously stored in memory. So a vector of vectors of vectors is out. Use a single vector (C++ guarantees contiguous storage for the buffer of a std::vector ). for (int i = 0; i >()); for (int j = 0; j ()); At this point you have an inner vector but it's empty, size 0. vector pixelColors; pixelColors = pixelArray[i][j].getColor(); Presumably pixelArray is an instance of a class you have defined? for (int k = 0; k Here you're trying to assign to non-existent elements of the empty innermost vector. You can either size it properly in advance, or use the push_back method for each value. In addition, are you sure that the float values are integers in range 0 through 255 (or more generally, 0 through UCHAR_MAX) and not, say, in the range 0 through 1? Perhaps you need to scale those values. } } // Error fwrite(pixelsArray, 1, 500*500*3, file); If pixelsArray had been a (non-empty) vector of bytes, then you could use &pixelsArray[0] to obtain a pointer to the first byte. Now, I know, the above only dissects some of what's wrong, and doesn't tell you directly what's right. :-) But some more information would be needed to give example code for doing this, like (1) what are your float values, and (2) what do you want in your file? Anyway, hope this helps, â€“ Alf
