[site]: stackoverflow
[post_id]: 1345252
[parent_id]: 1338001
[tags]: 
The Photo Scenario is Impossible to Achieve: Your scheme is impossible for the reasons that you name. Consider a function f, which takes two sets of photos, s1 and s2. f(s1, s2) returns true if s1=s2 and false if s1!=s2. That is, this function implements the scheme you want. Bob can always supply a subset of photo's he has, and learn which photo's charlie doesn't have. There is no way around this, any function which has the property you want can not have the security you want. The Spy Scenario is Even More Impossible: As Kent Fredric pointed out the spy scenario has even greater inherent weaknesses. It has all problems of the photo scenario, plus the additional weakness of having only four secrets. In the photo scenario it would be highly unlikely that Bob would randomly guess one of Charlies photographs. It is trivial in the spy scenario for Bob to guess Alices choice (1/4). The spys only have four countries they can belong to, as they are both quadruple agents they both know all the secret code words for each country. Thus, Bob could pretend to be working for the Chinese to test Alice. A Different Type of Solution: Some posters have noted, the security can be increased if you weaken the accuracy of f. Of course if it is not accurate what is the point. I propose a different type of solution. Do not let them compare the same photographs more than one time. The party which wishes to initiate the comparison must first show that this is a new comparison and does not use any of the pictures from before. EDIT: Problems with Double Hash I am making some assumptions about the doublhash protocol, but... For the photograph scheme, the doublehash protocol is no better than f, because the 62 bit secret must be constructed from a set of photographs for the comparison to be meaningfull. The subset attack mentioned in the original question still applies here. Try all subsets of photographs to brute force the secrets you can generate, thus Bob can see if he can generate the same secret as Alice. Using the doublehash property Bob can still brute force the secret. doubleHash(s1+doubleHash(b)) != doubleHash(aliceSecret+doubleHash(a)) doubleHash(s2+doubleHash(b)) != doubleHash(aliceSecret+doubleHash(a)) doubleHash(s3+doubleHash(b)) == doubleHash(aliceSecret+doubleHash(a)) Bingo, aliceSecret == s3. DoubleHash is only as strong as it is hard to bruteforce either a or b Implementating DoubleHash Instead doubleHash(a + doubleHash(b)), try doubleHash(a, md5(b)). DoubleHash(a + doubleHash(b)) is bad because Bob could generate colliding hashes like so: doubleHash((12 + doubleHash(34)) + doubleHash(5678)) = doubleHash((34 + doubleHash(12)) + doubleHash(5678)) = doubleHash(5678 + doubleHash(12 + doubleHash(34)) = doubleHash(5678 + doubleHash(34 + doubleHash(12)) Here is an implementation of doubleHash using the new formulation, Doublehash(a, hashOfB){ hashOfA = md5(a) combinedHash = hashOfA xor hashOfB return md5(combinedHash) } One could also use the math behind blind signatures to impliment version of doubleHash.
