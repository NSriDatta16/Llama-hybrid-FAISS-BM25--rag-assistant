[site]: stackoverflow
[post_id]: 4853672
[parent_id]: 4853131
[tags]: 
Formal protocols are primarily a compile time conceit, to help you be more clear about your intentions. They're a relatively recent invention, before which all protocols were informal â€” they were part of the class documentation but not declared in the code. They have a runtime effect in that you can use some of the Objective-C runtime methods to query whether a particular class responds to a particular protocol (just as you can query whether a particular class responds to a particular selector), but no such testing will occur at runtime when you pass objects about. Protocols are just a contract defining communications and don't specify behaviour. So there's no concept of inheritance. And there's no runtime list of the selectors included in a protocol, so the idea isn't particularly helpful. Your best shot is to define an additional protocol that includes the extra functionality you want. Write your new objects to implement both protocols. Extend classes you don't want or have access to using category methods. If you need additional storage to handle the new fields, then it's safest to subclass. You can actually add instance variables at runtime nowadays, but you'd need to drop down to the C interface to the Objective-C runtime and finding an opportunity to do so would require some hoop jumping.
