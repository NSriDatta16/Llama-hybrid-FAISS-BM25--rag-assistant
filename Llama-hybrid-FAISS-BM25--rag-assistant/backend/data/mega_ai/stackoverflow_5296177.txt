[site]: stackoverflow
[post_id]: 5296177
[parent_id]: 4988448
[tags]: 
You start from the beginning: you first need to calculate the time it takes tu run an average case MMultiply: The first thing you can see in MMultiply is a loop from 0 to n - 1, that gives you: T(MMultiply) = n*(T(what_is_inside_the_first_loop)) Now you need T(what_is_inside_the_first_loop). As you only have another loop inside the first loop, T(what_is_inside_the_first_loop) = n*T(what_is_inside_the_second_loop) Inside the second loop is only a single call to "DotProduct" so, disregarding the "=" assignment, T(what_is_inside_the_second_loop) = T(DotProduct). To calculate T(DotProduct), you take the function line-by-line: 1 for the initial assignement n for the loop 3 for each iteration of the loop (1 for the "+=" operation and 1 for each call to I - which only does one operation) so T(DotProduct) = 1 + n*3 replacing T(DotProduct) in the initial ecuation gives you: T(MMultiply) = n * n * (1 + n*3) = 3*n^3 + n^2 so T(MMultiply) = 3*n^3 + n^2 the big O notation basically just assigns this time to a specific class (it's an approximation). The class which approximates "3*n^3 + n^2" best is n^3 (since n^3 is the most significant member). So T(MMultiply) = O(n^3). Your calculations were almost right, but you had a "+ 1" surplus on the first two lines of MMultiply and, if you commented on each line the time it takes to process that line, "t += A[ I(i,k,n) ] * B[ I(k,j,n) ]; " does not take n, it only takes 2. Same goes for "return t", it takes only 1.
