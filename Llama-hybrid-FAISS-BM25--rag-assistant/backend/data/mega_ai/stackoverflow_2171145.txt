[site]: stackoverflow
[post_id]: 2171145
[parent_id]: 2167518
[tags]: 
You should think of your communication protocol as being layered. Treat | |1byte checksum|LF as fragments to be reassembled into larger packets of contiguous data. Once the larger packet is reconstituted, it is easier to parse its data contiguously (you don't have to deal with measurements being split up across fragments). Many existing network protocols (such as UDP/IP) does this sort of reassembly of fragments into packets. It's possible to read the fragments directly into their proper "slot" in the packet buffer. Since your fragments have footers instead of headers, and there is no out-of-order arrival of your fragments, this should be fairly easy to code (compared to copyless IP reassembly algorithms). Once you receive an "empty" fragment (the duplicate LF), this marks the end of the packet. Here is some sample code to illustrate the idea: #include #include class Reassembler { public: // Constructs reassembler with given packet buffer capacity Reassembler(int capacity) : buf_(capacity) {reset();} // Returns bytes remaining in packet buffer int remaining() const {return buf_.end() - pos_;} // Returns a pointer to where the next fragment should be read char* back() {return &*pos_;} // Advances the packet's position cursor for the next fragment void push(int size) {pos_ += size; if (size == 0) complete_ = true;} // Returns true if an empty fragment was pushed to indicate end of packet bool isComplete() const {return complete_;} // Resets the reassembler so it can process a new packet void reset() {pos_ = buf_.begin(); complete_ = false;} // Returns a pointer to the accumulated packet data char* data() {return &buf_[0];} // Returns the size in bytes of the accumulated packet data int size() const {return pos_ - buf_.begin();} private: std::vector buf_; std::vector ::iterator pos_; bool complete_; }; int readFragment(char* dest, int maxBytes, char delimiter) { // Read next fragment from source and save to dest pointer // Return number of bytes in fragment, except delimiter character } bool verifyChecksum(char* fragPtr, int size) { // Returns true if fragment checksum is valid } void processPacket(char* data, int size) { // Extract measurements which are now stored contiguously in packet } int main() { const int kChecksumSize = 1; Reassembler reasm(1000); // Use realistic capacity here while (true) { while (!reasm.isComplete()) { char* fragDest = reasm.back(); int fragSize = readFragment(fragDest, reasm.remaining(), '\n'); if (fragSize > 1) assert(verifyChecksum(fragDest, fragSize)); reasm.push(fragSize - kChecksumSize); } processPacket(reasm.data(), reasm.size()); reasm.reset(); } } The trick will be making an efficient readFragment function that stops at every newline delimiter and stores the incoming data into the given destination buffer pointer. If you tell me how you acquire your sensor data, then I can perhaps give you more ideas.
