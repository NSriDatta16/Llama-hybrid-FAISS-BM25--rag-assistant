[site]: stackoverflow
[post_id]: 5263881
[parent_id]: 5263257
[tags]: 
What you describe is not a problem per se. It is in fact a good example of application design and pattern usage. What it lacks that makes it seem problematic, is that it doesn't leverage newer technologies / techniques which aid in maintainability. For example, from your description, it's apparent the architecture clearly separates functional responsibilities into layers. You have a Presentation (UI) which communicates with a Domain (BLL) which in turn uses a Repository pattern to communicate with its Infrastructure (DAL). Your BLL seems to already implement cross-cutting concerns such as Validation and Security. What you can do to improve upon this design would be to incorporate a stronger Domain by including a Model. Drop the old ADO.NET DataTable techniques and design a strongly-typed model which reflects your database. Incorporating an ORM can aid in this tremendously as it has the power to generate the model from the database and maintain changes easily. I won't get into further ORM advantages as you desire. Your DAL should return POCOs and Enumerables. Let your BLL return response objects (I like to call them service response objects or presentation transfer objects) which may contain things like: POCO data, Error Handling Results, Validation Results. Another possible solution is to change your implementation of Repository pattern to a Generic Repository, though this now bleeds your infrastructure logic into the BLL. For instance, instead of: public class UserRepository { public User GetUserById(Int32 userId){...} } You can create (using generics) a repository which implements IQueryable. Look at nCommon for a nice approach to this. This will allow you to do something like: var userRepository = new EF4Repository (OrmContextFactory.CreateContext(...)); User u = userRepository.Where(user => user.Id == 1).SingleOrDefault(); The pros to this is that you only need to create domain business logic. If you need to modify your database tables, you only need to change your business logic once. However, that query now exists in the business logic and simply uses a "Repository" as a medium to communicate to your database which some deem improper. UPDATE You can use generics for creating a simple response object. Example: [DataContract(Name = "ServiceResponseOf{0}")] public class ServiceResponse : ResponseTransferObjectBase where TDto : IDto { #region Constructors /// /// Initializes a new instance of the class. /// /// The error. /// public ServiceResponse(ServiceErrorBase error) : this(ResponseStatus.Failure, null, new List {error}, null) { } /// /// Initializes a new instance of the class. /// /// The errors. /// public ServiceResponse(IEnumerable errors) : this(ResponseStatus.Failure, null, errors, null) { } /// /// Initializes a new instance of the class with a status of . /// /// The validation results. public ServiceResponse(MSValidation.ValidationResults validationResults) : this(ResponseStatus.Failure, null, null, validationResults) { } /// /// Initializes a new instance of the class with a status of . /// /// The response data. public ServiceResponse(TDto data) : this(ResponseStatus.Success, new List { data }, null, null) { } /// /// Initializes a new instance of the class with a status of . /// /// The response data. public ServiceResponse(IEnumerable data) : this(ResponseStatus.Success, data, null, null) { } /// /// Initializes a new instance of the class. /// /// The response status. /// The data. /// The errors. /// The validation results. /// private ServiceResponse(ResponseStatus responseStatus, IEnumerable data, IEnumerable errors, MSValidation.ValidationResults validationResults) { Status = responseStatus; Data = (data != null) ? new List (data) : new List (); Errors = Mapper.Map , List >(errors) ?? new List (); ValidationResults = Mapper.Map >(validationResults) ?? new List (); } #endregion #region Properties /// /// Gets the data. /// [DataMember(Order = 0)] public List Data { get; private set; } [DataMember(Order = 1)] public List Errors { get; private set; } /// /// Gets the validation results. /// [DataMember(Order = 2)] public List ValidationResults { get; private set; } /// /// Gets the indicating whether the request failed or succeeded. /// [DataMember(Order = 3)] public ResponseStatus Status { get; private set; } #endregion } This class is a basic response object which I use to return results from my domain to my service layer or to my presentation. It can be serialized and supports MS Enterprise Library Validation Block. To support validation, it uses AutoMapper to translate Microsoft's validation results to my own ValidationResult object. I don't recommend trying to serialize MS's classes as it proved error prone when using in services. The overloaded constructors allow you to provide a single poco or enumerable of pocos. POCOs vs DataTables ... anytime you can use strongly typed objects, it's always better. With T4 templating your POCO can automatically be generated from an ORM model. POCOs can also be easily mapped into DTOs for service operations and vice-versa. There's also no real need for DataTables anymore. Instead of List, you can use BindingList for CRUD support with databinding. Returning a POCO without all its properties filled is perfectly fine. In Entity Framework this is referred to as projection. Usually I'll create custom DTOs for this instead of my domain entities. UPDATE Example ValidationResult class: /// /// Represents results returned from Microsoft Enterprise Library Validation. See . /// [DataContract] public sealed class ValidationResult : IValidationResult { [DataMember(Order = 0)] public String Key { get; private set; } [DataMember(Order = 1)] public String Message { get; private set; } [DataMember(Order = 3)] public List NestedValidationResults { get; private set; } [DataMember(Order = 2)] public Type TargetType { get; private set; } public ValidationResult(String key, String message, Type targetType, List nestedValidationResults) { Key = key; Message = message; NestedValidationResults = new List (nestedValidationResults); TargetType = targetType; } } Example AutoMapper code for translating Microsoft Validation Results to a ValidationResult DTO: Mapper.CreateMap ().ConstructUsing( dest => new ValidationResult( dest.Key, dest.Message, dest.Target.GetType(), dest.NestedValidationResults.Select(mappingManager.Map ).ToList()));
