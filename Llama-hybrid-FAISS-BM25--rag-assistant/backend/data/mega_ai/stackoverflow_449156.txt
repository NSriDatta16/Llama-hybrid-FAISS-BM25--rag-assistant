[site]: stackoverflow
[post_id]: 449156
[parent_id]: 449014
[tags]: 
'Turing Completeness' describes the property of being able to express any arbitrary algorithmic computation, which was the point of Turing's Machine in the first place. A language or logical system can be described as 'Turing Complete' if it has this property. From a practical perspective all general purpose programming languages - and a surprisingly large number of special purpose ones - can do this for a suitably loose definition (see below). However, a strict definition of Turing Completeness implies infinite storage capacity, which is of course not physically possible. Given this, no physical machine can possibly be Turing Complete, but this constraint is usually relaxed (at least informally) when ascribing Turing Completeness to a programming language. One trivial test of Turing Completeness for a language is whether the language can be used to implement a Turing Machine simulator. An example of a widespread system that is not Turing Complete is Relational Algebra, the theoretical basis behind SQL as described in Codd's paper A relational model for large shared data banks. Relational Algebra has the property of Godel Completeness , which means that it can express any computation that can be defined in terms of first-order predicate calculus (i.e. ordinary logical expressions). However, it is not Turing-Complete as it cannot express an arbitrary algorithmic computation. Note that most if not all all practical SQL dialects extend the pure relational model with procedural constructs to the extent that they are Turing Complete by the definition as normally applied to programming languages. However, an individual SQL query by and large is not. Some more egregious examples of Turing Complete domain-specific languages are TeX and sendmail.cf, . In the latter case there is actually a famous-ish example of someone using sendmail.cf to implement a universal Turing Machine simulator.
