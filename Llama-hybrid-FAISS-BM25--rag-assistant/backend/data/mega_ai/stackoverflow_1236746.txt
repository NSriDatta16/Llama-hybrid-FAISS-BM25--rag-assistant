[site]: stackoverflow
[post_id]: 1236746
[parent_id]: 1236133
[tags]: 
I think reference counting is overkill for this problem. But your interface needs to specify more precisely who owns *b and not just b->d . It's not at all clear to me how the library knows when it is "necessary" (as you put it) to free b->d . I'd extend the interface as follows: Every pointer of type bs * is either externally managed or internally managed . Function new_bs returns an externally managed pointer; function add returns an internally managed one. Every function that returns a pointer of type bs * should say whether the management of the result is internal or external. You probably should provide functions void bs_free_ext(bs **); // free *bs and set *bs = NULL (external mgmt) void bs_free_int(bs **); // free *bs and set *bs = NULL (internal mgmt) bs_free_ext frees only *bs ; bs_free_int frees both *bs and (*bs)->d . For safety's sake I would also add the field that records the storage management of each struct, and I would have assertions on any function that allocates or frees. (Reason: assertion checking is cheap compared to the cost of allocating or freeing.) If you can run your app on Linux then memory checking with valgrind is a plus. P.S. The fact that details of memory management leak into almost every interface is one of the costs we pay to get the benefits of programming in C.
