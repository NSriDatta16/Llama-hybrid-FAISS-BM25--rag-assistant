[site]: stackoverflow
[post_id]: 2704733
[parent_id]: 2703802
[tags]: 
The answer from Kha shows how to optimize the code manually by using closures directly. If this is a frequent pattern that you need to use often, it is also possible to define a higher-order function that constructs the efficient code from two functions - the first one that does pre-processing of some arguments and a second one which does the actual processing once it gets the remaining arguments. The code would look like this: let preProcess finit frun preInput = let preRes = finit preInput fun input -> frun preRes input let f : string list -> ((string -> string) * string) -> bool = preProcess Set.ofList // Pre-processing of the first argument (fun elemsSet (normalize, p) -> // Implements the actual work to be normalize p |> elemsSet.Contains) // .. done once we get the last argument It is a question whether this is more elegant though... Another (crazy) idea is that you could use computation expressions for this. The definition of computation builder that allows you to do this is very non-standard (it is not something that people usually do with them and it isn't in any way related to monads or any other theory). However, it should be possible to write this: type CurryBuilder() = member x.Bind((), f:'a -> 'b) = f member x.Return(a) = a let curry = new CurryBuilder() In the curry computation, you can use let! to denote that you want to take the next argument of the function (after evaluating the preceeding code): let f : string list -> (string -> string) -> string -> bool = curry { let! elems = () let elemsSet = Set.ofList elems printf "elements converted" let! normalize = () let! p = () printf "calling" return normalize p |> elemsSet.Contains } let ff = f [ "a"; "b"; "c" ] (fun s -> s.ToLower()) // Prints 'elements converted' here ff "C" ff "D" // Prints 'calling' two times Here are some resources with more information about computation expressions: The usual way of using computation expressions is described in free sample chapter of my book: Chapter 12: Sequence Expressions and Alternative Workflows (PDF) The example above uses some specifics of the translation which is in full detailes described in the F# specification (PDF)
