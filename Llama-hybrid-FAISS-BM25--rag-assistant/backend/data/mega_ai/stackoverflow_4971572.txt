[site]: stackoverflow
[post_id]: 4971572
[parent_id]: 4971460
[tags]: 
Closures were introduced into the language to solve this very problem. By capturing the appropriate variable, you can give it storage that 'outlives' the containing method: // Note that the 'input' variable is captured by the lambda. pd.PrintPage += (sender, e) => Print(e.Graphics, input); ... static void Print(Graphics g, string input) { ... } Do note that this very much a convenience feature; the way the compiler solves this problem on your behalf is suspiciously similar to your own, existing solution. (There are certain differences, e.g. the captured variable ends up as a field of a newly created object of some other (generated) class. Your existing solution does not do this: you have one 'temporary' storage location per instance of your class rather than per call to PrintIt , which is not good - it isn't thread-safe, for example)
