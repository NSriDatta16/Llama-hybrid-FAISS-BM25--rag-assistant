[site]: stackoverflow
[post_id]: 4516108
[parent_id]: 4512383
[tags]: 
You're better off not worrying about forcing your packet structure to be stored as a byte array. The CPU cost of converting to and from a byte array, and the memory costs of the temporary duplicate storage are most likely insignificant. Create a class or set of classes to represent your data structure, and then use BinaryWriter to convert it to a byte array in the format required by your protocol. If you really want to use a structure, look into the Marshal.StructureToPtr method, and the [LayoutKind] and [MarshalAs] attributes. But be warned, if your data structure contains an variable length fields (strings or arrays), you won't be able to convert it to a byte array using this method. And I don't see any reason why you should go this route. It's really intended for Win32 interop. EDIT: Another thought, if you were stuck with a big byte array, and you really wanted to access chunks of it by name, I would create an implementation of IList that took a T[] an offset and a length, and just used the array as its storage. Then you could create a class like so: public class Packet { public byte[] PacketData; public SubArray Header; public SubArray MessageBody; // Add more SubArrays for each of the remainder of your 8 packet pieces //modify this constructor as needed public Packet(byte[] data) { // replace the offsets and lengths here with appropriate data Header = new SubArray (data, 0, 10); MessageBody = new SubArray (data, 10, 100); } } public class SubArray : IList { private T[] data; private int offset; private int length; public SubArray(T[] data, int offset, int length) { this.data = data; this.offset = offset; this.length = length; } public T this[int i] { get { if (i = length) throw new ArgumentOutOfRangeException(); return data[i + offset]; } set { if (i = length) throw new ArgumentOutOfRangeException(); data[i + offset] = value; } } // TODO: Implement the rest of IList accordingly }
