[site]: stackoverflow
[post_id]: 5738131
[parent_id]: 5737344
[tags]: 
As said in comments, don't get a thread-safe memory allocator, allocate memory per-thread. As you implied in your update, you need to manage free/in-use effectively. That is a pretty straightforward problem, given a constant type and no concurrency. For example (off the top of my head, untested): template class ThreadStorage { std::vector m_objs; std::vector m_avail; public: explicit ThreadStorage(size_t count) : m_objs(count, T()) { m_avail.reserve(count); for (size_t i = 0; i Then, for each thread, have a ThreadStorage instance, and call alloc() and free() as required. You can add smart pointers to manage calling free() for you, and you can optimise constructor/destructor calling if that's expensive. You can also look at boost::pool. Update: The new requirement for keeping track of things that have been used so that they can be processed in a second pass seems a bit unclear to me. I think you mean that when the primary processing is finished on an object, you need to not release it, but keep a reference to it for second stage processing. Some objects you will just be released back to the pool and not used for second stage processing. I assume you want to do this in the same thread. As a first pass, you could add a method like this to ThreadStorage, and call it when you want to do processing on all unreleased instances of T. No extra book keeping required. void do_processing(boost::function const& f) { std::sort(m_avail.begin(), m_avail.end()); size_t o = 0; for (size_t i = 0; i != m_avail.size(); ++i) { if (o Assumes no other thread is using the ThreadStorage instance, which is reasonable because it is thread-local by design. Again, off the top of my head, untested.
