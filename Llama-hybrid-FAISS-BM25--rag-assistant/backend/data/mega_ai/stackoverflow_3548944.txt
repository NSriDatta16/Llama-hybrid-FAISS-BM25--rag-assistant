[site]: stackoverflow
[post_id]: 3548944
[parent_id]: 3315097
[tags]: 
Add start and end handlers to your parser, and have them record the ancestry of the current element. When the ancestry contains or , disable rewriting. Keep your front matter #! /usr/bin/perl use warnings; use strict; use HTML::Parser 3.05; sub edit_print { local $_ = shift; tr/a-z/n-za-m/; print } and use the following sub to create a new parser: sub create_parser { my @tags; my $start = sub { my($text,$tagname) = @_; push @tags => $tagname; print $text; }; my $end = sub { my($text,$tagname) = @_; die "$0: expected , got " unless $tagname eq $tags[-1]; pop @tags; print $text; }; my $edit_print = sub { if (grep /^(head|script)$/, @tags) { print @_ } else { edit_print @_ } }; HTML::Parser->new( unbroken_text => 1, default_h => [ sub { print @_ }, "text" ], text_h => [ $edit_print, "text" ], start_h => [ $start, "text,tagname" ], end_h => [ $end, "text,tagname" ], ); } The reason for creating it inside a sub is the handler callbacks are closures that share private state in @tags . This implementation allows you to instantiate multiple parsers without worrying about them stomping on each other's data. my $p = create_parser; $p->parse_file(\*DATA); __DATA__ foo My Title /* don't change me */ // or me My Document Yo. Output: sbb My Title /* don't change me */ // or me Ml Dbphzrag Yb.
