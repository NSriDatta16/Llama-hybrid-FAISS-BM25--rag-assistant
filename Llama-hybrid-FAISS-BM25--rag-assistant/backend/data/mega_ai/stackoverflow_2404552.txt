[site]: stackoverflow
[post_id]: 2404552
[parent_id]: 2401981
[tags]: 
How to look up a value/How to update a value First you have to look up the record (row) that you want to update. This is typically done by searching the table for a given key value. COBOL provides a couple of ways to do this. I recommend that you start by reviewing the COBOL SEARCH statement. If STRUCT-1 records are sorted, you could use SEARCH ALL , otherwise you must use SEARCH or just code your own search loop. In order to use any of these techniques you will need to declare another variable somewhere in your program to use as an index (offset) into the STRUCT-1 table. COBOL provides the INDEXED BY phrase on the OCCURS clause to declare an index specific to the given table (see OCCURS ) Once you have set the index into STRUCT-1 to point to the row to be updated you just MOVE the value to the appropriate variables within that row, for example MOVE 123.456 TO VALUE-2 (IDX-1) where IDX-1 is the index referred to above. Note that you can use either an integer or index variable to specify the row number to be updated, you are not limited to using an INDEX type variable. However, it is generally more efficient to use INDEX variables over other types of variables, particularily when working with multi-dimensional tables where the program makes lots of references to the table. How to add a new row First recognize that STRUCT-1 contains exactly 25 rows. COBOL does not have a mechanism to dynamically increase or decrease this number (I've heard this will possible in the next ISO COBOL standard - but don't hold your breath waiting for it). Technically all 25 rows are available at any time. However a common convention is to 'grow' a table from being empty to full sequentially, one row at a time. To use this convention you need to assign a variable to keep track of the last used row number (don't forget to initialize this variable to zero at program startup). In your example it looks like the variable NUMBER-OF-OCCURS does this job (I didn't mention it but, you need this variable to bound the SEARCH discussed above). To 'add' a row, just increment NUMBER-OF-OCCURS by 1. Be careful not to exceed the table size. Example code might be: IF NUMBER-OF-OCCURS The above code avoids the explicit use of the number of occurs in TABLE-1 which in turn can save a number of maintenance problems when/if the number of OCCURS is ever changed. See the NOTE at the bottom: There is a really big Woops here - did you catch it! Now back to the search problem. The following code example illustrates how you might proceed: WORKING-STORAGE Declaration: 01 FOUND-IND PIC X(1). 88 FOUND-YES VALUE 'Y'. 88 FOUND-NO VALUE 'N'. 77 MAX-IDX USAGE IS INDEX. 01 TABLE-1. 05 STRUCT-1 OCCURS 25 TIMES INDEXED BY IDX-1. 10 VALUE-1 PIC AAA. 10 VALUE-2 PIC 9(5)V999. 05 NUMBER-OF-OCCURS PIC 99. What was added: FOUND-IND is used to indicate whether the row you are looking for has been found. The 88 levels give specific values to set/test MAX-IDX is used to set an upper bound limit on the search. You could use NUMBER-OF-OCCURS in the upper bounds test but this would force a data type converson on every test which isn't very efficient IDX-1 is used as the index (offset) into the STRUCT-1 table. Personally, I would declare NUMBER-OF-OCCURS as PIC S9(4) BINARY but what you have will work. Assuming that STRUCT-1 is not sorted and NUMBER-OF-OCCURS represents the current number of active rows in STRUCT-1 this is an example of how you might code the SEARCH when looking for the value 'ABC': SET FOUND-NO TO TRUE IF NUMBER-OF-OCCURS > ZERO SET IDX-1 TO 1 SET MAX-IDX TO NUMBER-OF-OCCURS SEARCH STRUCT-1 WHEN IDX-1 > MAX-IDX CONTINUE WHEN VALUE-1 (IDX-1) = 'ABC' SET FOUND-YES TO TRUE END-SEARCH END-IF IF FOUND-YES row found, use IDX-1 to reference the row containing 'ABC' ELSE row not found, IDX-1 does not contain a valid index END-IF How it works: Start by assuming the row is not in the table by setting FOUND-NO to true. The first IF ensures that there is at least 1 active row in STRUCT-1 before beginning the search (it is an error to set an INDEX to zero - so you need to guard against that). The SEARCH terminates when the first SEARCH WHEN clause is satisified. That is why the 'do nothing' verb CONTINUE can be used when we run out of rows to search. The other terminating condition (finding the value you are looking for) is the only place where FOUND-YES can be set. When the SEARCH completes, test for success or failure then act accordingly. Some exercises for you to research: Why did I not have to code an AT END clause in the SEARCH statement? Why did I not have to code a VARYING clause in the SEARCH statement? Why did I code the WHERE clauses in the order that I did? Hope this gets you started down the right path. Edit In response to your question in the comments: Could we use NUMBER-OF-OCCURS as index for the search . The answer is yes, but you need to implement some different rules. When using NUMBER-OF-OCCURS as an index you can no longer use it to keep track of how many rows currently contain valid data. This means you need another mechanism to identify unused rows in STRUCT-1 . This might be accomplished by initializing un-used rows with a sentinal value (eg. LOW-VALUE ) that you will never actually want to put into the table. The SEARCH becomes: SET FOUND-NO TO TRUE MOVE 1 TO NUMBER-OF-OCCURS SEARCH STRUCT-1 VARYING NUMBER-OF-OCCURS WHEN VALUE-1 (NUMBER-OF-OCCURS) = 'ABC' SET FOUND-YES TO TRUE END-SEARCH The above will search every row in STRUCT-1 in the event that the value you are searching for (ie. ABC ) is not in the table. As an optimization you can add a second WHEN clause to terminate the search upon finding a sentinal value: WHEN VALUE-1 (NUMBER-OF-OCCURS) = LOW-VALUE CONTINUE The above assumes LOW-VALUE was used to identify unused rows. You can also drop IDX-1 and MAX-IDX from your working storage since this solution doesn't need them. Using NUMBER-OF-OCCURS as an index also means you must change the way you search for an empty row to insert a new value. The easiest way to do this is to search the table using the above code for LOW-VALUE instead of 'ABC' . If FOUND-YES has been set at the end of the search, then NUMBER-OF-OCCURS is the index of the first unused row. If FOUND-NO has been set, then the table is already full. The above code is a lot simpler than what I initially suggested. So why did I give you the more complicated solution? The more complicated solution is more efficient because it makes many fewer internal offset calculations and data type conversions when running through the table. It also avoids doing an additional SEARCH to find the next unused row. These efficiencies may not be of concern in your application, but if the tables are large and accessed frequently you should be aware of the performance aspect of searching tables and forced data type conversions (for example the cost of converting a PIC 99 field into an index reference). Note: My original example to calculate whether the table was full using the LENGTH OF special register would work in this example but has a really bad built in assumption! The LENGTH OF TABLE-1 includes not only the STRUCT-1 table but the NUMBER-OF-OCCURS too. The length of NUMBER-OF-OCCURS is less than one occurance of STRUCT-1 so it all works out ok due to truncation of the result into an integer value. This is a very good example of code working correctly for the wrong reason! To make the proper calculation you would have to adjust your working storage to something like: 01 TABLE-1. 05 STRUCT-TABLE. 10 STRUCT-1 OCCURS 25 TIMES. 20 VALUE-1 PIC AAA. 20 VALUE-2 PIC 9(5)V999. 05 NUMBER-OF-OCCURS PIC 99. and the bounds calculation would become: IF NUMBER-OF-OCCURS Or you could just move NUMBER-OF-OCCURS out of the TABLE-1 record definition.
