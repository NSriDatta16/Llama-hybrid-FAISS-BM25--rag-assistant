[site]: stackoverflow
[post_id]: 4451129
[parent_id]: 
[tags]: 
Scala singleton factories and class constants

OK, in the question about 'Class Variables as constants' , I get the fact that the constants are not available until after the 'official' constructor has been run (i.e. until you have an instance). BUT, what if I need the companion singleton to make calls on the class: object thing { val someConst = 42 def apply(x: Int) = new thing(x) } class thing(x: Int) { import thing.someConst val field = x * someConst override def toString = "val: " + field } If I create companion object first, the 'new thing(x)' (in the companion) causes an error. However, if I define the class first, the 'x * someConst' (in the class definition) causes an error. I also tried placing the class definition inside the singleton. object thing { var someConst = 42 def apply(x: Int) = new thing(x) class thing(x: Int) { val field = x * someConst override def toString = "val: " + field } } However, doing this gives me a 'thing.thing' type object val t = thing(2) results in t: thing.thing = val: 84 The only useful solution I've come up with is to create an abstract class, a companion and an inner class (which extends the abstract class): abstract class thing object thing { val someConst = 42 def apply(x: Int) = new privThing(x) class privThing(x: Int) extends thing { val field = x * someConst override def toString = "val: " + field } } val t1 = thing(2) val tArr: Array[thing] = Array(t1) OK, 't1' still has type of 'thing.privThing', but it can now be treated as a 'thing'. However, it's still not an elegant solution, can anyone tell me a better way to do this? PS. I should mention, I'm using Scala 2.8.1 on Windows 7
