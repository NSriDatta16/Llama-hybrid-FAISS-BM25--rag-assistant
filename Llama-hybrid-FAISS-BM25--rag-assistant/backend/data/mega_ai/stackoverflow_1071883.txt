[site]: stackoverflow
[post_id]: 1071883
[parent_id]: 369678
[tags]: 
It took me a while to realize what the best way of handling this kind of typical task; it turns out the clue is in the design of many of Cocoa and CocoaTouch's own APIs: delegation . The reason so many of Cocoa's APIs use delegation is because it fits very well with the asynchronous nature of many GUI apps. It seems perfectly normal to want do do something along the lines of: users = [MyDataFactory getUsers]; Except, as you point out, you have no idea when the getUsers method will finish. Now, there are some light-weight solutions to this; amrox mentioned a few in his post above (personally I'd say notifications aren't such a good fit but the object:selector: pattern is reasonable), but if you are doing this kind of thing a lot the delegation pattern tends to yield a more elegant solution. I'll try to explain by way of an example of how I do things in my application. Let's say we have a domain class, Recipe . Recipes are fetched from a web service. I typically have a series of repository classes, one for each entity in my model. A repository class' responsibility is to fetch the data required for the entity (or a collection of them), use that data to construct the objects, and then pass those objects onto something else to make use of them (typically a controller or data source). My RecipeRepository interface might look something like this: @interface RecipeRepository {} - (void)initWithDelegate:(id)aDelegate; - (void)findAllRecipes; - (void)findRecipeById:(NSUInteger)anId; @end I'd then define a protocol for my delegate; now, this can be done as an informal or formal protocol, there are pros and cons of each approach that aren't relevant to this answer. I'll go with a formal approach: @protocol RepositoryDelegateProtocol - (void)repository:(id)repository didRetrieveEntityCollection:(NSArray *)collection; - (void)repository:(id)repository didRetrieveEntity:(id)entity; @end You'll notice I've gone for a generic approach; you will likely have multiple XXXRepository classes in your app and each will use the same protocol (you may also choose to extract a base EntityRepository class that encapsulates some common logic). Now, to use this in a controller, for example, where you previous would have done something such as: - (void)viewDidLoad { self.users = [MySingleton getUsers]; [self.view setNeedsDisplay]; } You would do something like this: - (void)viewDidLoad { if(self.repository == nil) { // just some simple lazy loading, we only need one repository instance self.repository = [[[RecipeRepository alloc] initWithDelegate:self] autorelease]; } [self.repository findAllRecipes]; } - (void)repository:(id)repository didRetrieveEntityCollection:(NSArray *)collection; { self.users = collection; [self.view setNeedsDisplay]; } You could even extend this further to display some kind of "loading" notice with an additional delegate method: @protocol RepositoryDelegateProtocol - (void)repositoryWillLoadEntities:(id)repository; @end // in your controller - (void)repositoryWillLoadEntities:(id)repository; { [self showLoadingView]; // etc. } Another thing about this design is that your repository classes really don't need to be singletons - they can be instantiated wherever you need them. They may deal with some kind of singleton connection manager but at this layer of abstraction a singleton is unnecessary (and its always good to avoid singletons where possible). There is a downside to this approach; you may find you need layers of delegation at each level. For instance, your repositories may interact with some kind of connection object which does the actual asynchronous data loading; the repository might interact with the connection object using it's own delegation protocol. As a result you might find you have to "bubble up" these delegation events throughout the different layers of your application using delegates that get more and more coarse-grained as they get closer to your application-level code. This can create a layer of indirection that can make your code harder to follow. Anyway, this is my first answer on SO, I hope its been helpful.
