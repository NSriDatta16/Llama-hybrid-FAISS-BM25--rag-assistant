[site]: stackoverflow
[post_id]: 2180419
[parent_id]: 
[tags]: 
Wrapping an asynchronous computation into a synchronous (blocking) computation

similar questions: Pattern for wrapping an Asynchronous JavaScript function to make it synchronous Wrapping an asynchronous method synchronously in C# I have an object with a method I would like to expose to library clients (especially scripting clients) as something like: interface MyNiceInterface { public Baz doSomethingAndBlock(Foo fooArg, Bar barArg); public Future doSomething(Foo fooArg, Bar barArg); // doSomethingAndBlock is the straightforward way; // doSomething has more control but deals with // a Future and that might be too much hassle for // scripting clients } but the primitive "stuff" I have available is a set of event-driven classes: interface BazComputationSink { public void onBazResult(Baz result); } class ImplementingThing { public void doSomethingAsync(Foo fooArg, Bar barArg, BazComputationSink sink); } where ImplementingThing takes inputs, does some arcane stuff like enqueueing things on a task queue, and then later when a result occurs, sink.onBazResult() gets called on a thread that may or may not be the same thread as ImplementingThing.doSomethingAsync() was called. Is there a way I can use the event-driven functions I have, along with concurrency primitives, to implement MyNiceInterface so scripting clients can happily wait on a blocking thread? edit: can I use FutureTask for this?
