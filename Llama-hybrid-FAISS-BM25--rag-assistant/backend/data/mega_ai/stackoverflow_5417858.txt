[site]: stackoverflow
[post_id]: 5417858
[parent_id]: 5417754
[tags]: 
There are value types and reference types in C# . A dictionary is a reference type so whenever assigning a variable that holds a reference type to another, the reference is copied, which means that both variables will be holding the same data. So, if you change the data , you should expect it to change on both variables: List list1 = new List () { 1, 2, 3 }; List list2 = list1; list2.Add(10); list1.ForEach(x => Console.WriteLine(x)); // should print 1, 2, 3 and 10. However, if you reassign the variable, then you are not changing the data: List list1 = new List () { 1, 2, 3 }; List list2 = list1; list2 = new List () { 10, 11, 12 }; list1.ForEach(x => Console.WriteLine(x)); // should print 1, 2, 3 only One thing that caught my attention in your code though was that the constructor is expecting a ref . This means that you are passing the reference itself by reference, which in C++ would be something like a double pointer ( type** ). You'd do this if, in the snippet above, you want to have this effect: void MethodA(ref List list) { list = new List () { 10, 11, 12 }; } // ... List list1 = new List () { 1, 2, 3 }; MethodA(ref list1); list1.ForEach(x => Console.WriteLine(x)); // should print 10, 11, 12 One more thing -- AFAIK C# doesn't implement deep copies in any of it classes. You have to do it yourself.
