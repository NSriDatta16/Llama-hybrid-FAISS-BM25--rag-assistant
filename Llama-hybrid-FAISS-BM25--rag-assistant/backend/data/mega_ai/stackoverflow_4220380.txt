[site]: stackoverflow
[post_id]: 4220380
[parent_id]: 4219107
[tags]: 
If I've understood correctly, you're stuck at the point where you actually have a need to do 64-bit arithmetic, right? If you're doing a typical shift-and-add binary long multiplication, you could build some 64-bit shift and addition primitives from 32-bit operations, then use the same method. Here are some examples as C fragments (should be trivial to translate to MIPS, if that's what you're actually using). I'm assuming that you're working with unsigned 32-bit numbers and want unsigned 64-bit results. Logical shift left 1 bit: tmp = lo >> 31; /* top bit of lo to bottom bit of tmp, rest of tmp is 0 */ lo Logical shift right 1 bit: tmp = hi >= 1; lo >>= 1; lo |= tmp; (in fact you can replace the 1 and 31 with n and (32 - n) to shift by some other number of bits) 64-bit addition: result_lo = a_lo + b_lo; result_hi = a_hi + b_hi; if (result_lo (see here for more detail about that, with specific reference to MIPS). An alternative approach is to treat each of your 32-bit inputs as a pair of 16-bit "digits"; multiplying two 16-bit numbers gives at most a 32-bit result. So the basic idea is like this: 0x12345678 * 0x23456789 = 0x5678 * 0x6789 + ((0x1234 * 0x6789) (you'll still need some 64-bit additions).
