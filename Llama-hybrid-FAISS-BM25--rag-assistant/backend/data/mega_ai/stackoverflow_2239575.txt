[site]: stackoverflow
[post_id]: 2239575
[parent_id]: 2236359
[tags]: 
in general you are programming in a too "imperative" fashion; a more elegant expmod would be (define (expmod b e m) (define (emod b e) (case ((= e 1) (remainder b m)) ((= (remainder e 2) 1) (remainder (* b (emod b (- e 1))) m) (else (emod (remainder (* b b) m) (/ e 2))))))) (emod b e)) which avoids the use of set! and just implements recursively the rules b^1 == b (mod m) b^k == b b^(k-1) (mod m) [k odd] b^(2k) == (b^2)^k (mod m) Similarly the rab_mil thing is programmed in a very non-scheme fashion. Here's an alternative implementation. Note that there is no 'breaking' of the loops and no call/cc; instead the breaking out is implemented as a tail-recursive call which really corresponds to 'goto' in Scheme: (define (rab_mil n k) ;; calculate the number 2 appears as factor of 'n' (define (twos-powers n) (if (= (remainder n 2) 0) (+ 1 (twos-powers (/ n 2))) 0)) ;; factor n to 2^s * d where d is odd: (let* ((s (twos-powers n 0)) (d (/ n (expt 2 s)))) ;; outer loop (define (loop k) (define (next) (loop (- k 1))) (if (= k 0) 'probably-prime (let* ((a (+ 2 (random (- n 2)))) (x (expmod a d n))) (if (or (= x 1) (= x (- n 1))) (next) (inner x next)))))) ;; inner loop (define (inner x next) (define (i r x) (if (= r s) (next) (let ((x (expmod x 2 n))) (case ((= x 1) 'composite) ((= x (- n 1)) (next)) (else (i (+ 1 r) x)))) (i 1 x)) ;; run the algorithm (loop k)))
