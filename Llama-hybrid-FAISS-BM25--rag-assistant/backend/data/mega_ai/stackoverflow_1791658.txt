[site]: stackoverflow
[post_id]: 1791658
[parent_id]: 1789519
[tags]: 
This sample code from apple (edit: link moved) : https://developer.apple.com/library/content/samplecode/LocateMe/ You have to ask user permission, adding this property in you plist : NSLocationWhenInUseUsageDescription then, here is basically how apple does in a viewController (copied from link above) : /* Copyright (C) 2014 Apple Inc. All Rights Reserved. See LICENSE.txt for this sampleâ€™s licensing information */ #import "GetLocationViewController.h" #import "LocationDetailViewController.h" #import "SetupViewController.h" #import "CLLocation+Strings.h" @interface GetLocationViewController () @property (nonatomic, weak) IBOutlet UIButton *startButton; @property (nonatomic, weak) IBOutlet UILabel *descriptionLabel; @property (nonatomic, weak) IBOutlet UITableView *tableView; @property (nonatomic, strong) SetupViewController* setupViewController; @property (nonatomic, copy) NSString *stateString; @property (nonatomic, strong) CLLocationManager *locationManager; @property (nonatomic, strong) NSDateFormatter *dateFormatter; @property (nonatomic, strong) NSMutableArray *locationMeasurements; @property (nonatomic, strong) CLLocation *bestEffortAtLocation; @end #pragma mark - @implementation GetLocationViewController - (void)viewDidLoad { [super viewDidLoad]; _locationMeasurements = [NSMutableArray array]; } - (NSDateFormatter *)dateFormatter { if (_dateFormatter == nil) { _dateFormatter = [[NSDateFormatter alloc] init]; [_dateFormatter setDateStyle:NSDateFormatterMediumStyle]; [_dateFormatter setTimeStyle:NSDateFormatterLongStyle]; } return _dateFormatter; } - (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender { UINavigationController *nv = segue.destinationViewController; _setupViewController = nv.viewControllers[0]; self.setupViewController.delegate = self; } #pragma mark - Actions // The reset method allows the user to repeatedly test the location functionality. // In addition to discarding all of the location measurements from the previous "run", // it animates a transition in the user interface between the table which displays location // data and the start button and description label presented at launch. // - (void)reset { _bestEffortAtLocation = nil; [self.locationMeasurements removeAllObjects]; // fade in the rest of the UI and fade out the table view [UIView animateWithDuration:0.6f animations:^(void) { self.startButton.alpha = 1.0; self.descriptionLabel.alpha = 1.0; self.tableView.alpha = 0.0; [self.navigationItem setLeftBarButtonItem:nil animated:YES]; } completion:^(BOOL finished) { if (finished) { //.. } }]; } #pragma mark - Location Manager Interactions // This method is invoked when the user hits "Done" in the setup view controller. // The options chosen by the user are passed in as a dictionary. The keys for this dictionary // are declared in SetupViewController.h. // - (void)setupViewController:(SetupViewController *)controller didFinishSetupWithInfo:(NSDictionary *)setupInfo { self.startButton.alpha = 0.0; self.descriptionLabel.alpha = 0.0; self.tableView.alpha = 1.0; // Create the core location manager object _locationManager = [[CLLocationManager alloc] init]; self.locationManager.delegate = self; // This is the most important property to set for the manager. It ultimately determines how the manager will // attempt to acquire location and thus, the amount of power that will be consumed. self.locationManager.desiredAccuracy = [setupInfo[kSetupInfoKeyAccuracy] doubleValue]; // Once configured, the location manager must be "started" // // for iOS 8, specific user level permission is required, // "when-in-use" authorization grants access to the user's location // // important: be sure to include NSLocationWhenInUseUsageDescription along with its // explanation string in your Info.plist or startUpdatingLocation will not work. // if ([self.locationManager respondsToSelector:@selector(requestWhenInUseAuthorization)]) { [self.locationManager requestWhenInUseAuthorization]; } [self.locationManager startUpdatingLocation]; [self performSelector:@selector(stopUpdatingLocationWithMessage:) withObject:@"Timed Out" afterDelay:[setupInfo[kSetupInfoKeyTimeout] doubleValue]]; self.stateString = NSLocalizedString(@"Updating", @"Updating"); [self.tableView reloadData]; } // We want to get and store a location measurement that meets the desired accuracy. // For this example, we are going to use horizontal accuracy as the deciding factor. // In other cases, you may wish to use vertical accuracy, or both together. // - (void)locationManager:(CLLocationManager *)manager didUpdateToLocation:(CLLocation *)newLocation fromLocation:(CLLocation *)oldLocation { // store all of the measurements, just so we can see what kind of data we might receive [self.locationMeasurements addObject:newLocation]; // test the age of the location measurement to determine if the measurement is cached // in most cases you will not want to rely on cached measurements // NSTimeInterval locationAge = -[newLocation.timestamp timeIntervalSinceNow]; if (locationAge > 5.0) { return; } // test that the horizontal accuracy does not indicate an invalid measurement if (newLocation.horizontalAccuracy newLocation.horizontalAccuracy) { // store the location as the "best effort" _bestEffortAtLocation = newLocation; // test the measurement to see if it meets the desired accuracy // // IMPORTANT!!! kCLLocationAccuracyBest should not be used for comparison with location coordinate or altitidue // accuracy because it is a negative value. Instead, compare against some predetermined "real" measure of // acceptable accuracy, or depend on the timeout to stop updating. This sample depends on the timeout. // if (newLocation.horizontalAccuracy
