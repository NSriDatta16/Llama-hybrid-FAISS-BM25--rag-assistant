[site]: stackoverflow
[post_id]: 1939344
[parent_id]: 1878087
[tags]: 
As far as I can tell, this is not supported in ASP.NET MVC 2 Beta, nor is it supported in ASP.NET MVC 2 RC. I dug through the MVC source code and it looks like Dictionaries are supported but not Models that are IEnumerable<> (or that contain nested IEnumerable objects) and it's inheritors like IList<>. The issue is in the ViewDataDictionary class. Particularly, the GetPropertyValue method only provides a way to retrieve property values from dictionary properties (by calling GetIndexedPropertyValue) or simple properties by using the PropertyDescriptor.GetValue method to pull out the value. To fix this, I created a GetCollectionPropertyValue method that handles Models that are collections (and even Models that contain nested collections). I am pasting the code here for reference. Note: I don't make any claims about elegance - in fact all the string parsing is pretty ugly, but it seems to be working. Here is the method: // Can be used to pull out values from Models with collections and nested collections. // E.g. Persons[0].Phones[3].AreaCode private static ViewDataInfo GetCollectionPropertyValue(object indexableObject, string key) { Type enumerableType = TypeHelpers.ExtractGenericInterface(indexableObject.GetType(), typeof(IEnumerable<>)); if (enumerableType != null) { IList listOfModelElements = (IList)indexableObject; int firstOpenBracketPosition = key.IndexOf('['); int firstCloseBracketPosition = key.IndexOf(']'); string firstIndexString = key.Substring(firstOpenBracketPosition + 1, firstCloseBracketPosition - firstOpenBracketPosition - 1); int firstIndex = 0; bool canParse = int.TryParse(firstIndexString, out firstIndex); object element = null; // if the index was numeric we should be able to grab the element from the list if (canParse) element = listOfModelElements[firstIndex]; if (element != null) { int firstDotPosition = key.IndexOf('.'); int nextOpenBracketPosition = key.IndexOf('[', firstCloseBracketPosition); PropertyDescriptor descriptor = TypeDescriptor.GetProperties(element).Find(key.Substring(firstDotPosition + 1), true); // If the Model has nested collections, we need to keep digging recursively if (nextOpenBracketPosition >= 0) { string nextObjectName = key.Substring(firstDotPosition+1, nextOpenBracketPosition-firstDotPosition-1); string nextKey = key.Substring(firstDotPosition + 1); PropertyInfo property = element.GetType().GetProperty(nextObjectName); object nestedCollection = property.GetValue(element,null); // Recursively pull out the nested value return GetCollectionPropertyValue(nestedCollection, nextKey); } else { return new ViewDataInfo(() => descriptor.GetValue(element)) { Container = indexableObject, PropertyDescriptor = descriptor }; } } } return null; } And here is the modified GetPropertyValue method which calls the new method: private static ViewDataInfo GetPropertyValue(object container, string propertyName) { // This method handles one "segment" of a complex property expression // First, we try to evaluate the property based on its indexer ViewDataInfo value = GetIndexedPropertyValue(container, propertyName); if (value != null) { return value; } // If the indexer didn't return anything useful, continue... // If the container is a ViewDataDictionary then treat its Model property // as the container instead of the ViewDataDictionary itself. ViewDataDictionary vdd = container as ViewDataDictionary; if (vdd != null) { container = vdd.Model; } // Second, we try to evaluate the property based on the assumption // that it is a collection of some sort (e.g. IList<>, IEnumerable<>) value = GetCollectionPropertyValue(container, propertyName); if (value != null) { return value; } // If the container is null, we're out of options if (container == null) { return null; } // Third, we try to use PropertyDescriptors and treat the expression as a property name PropertyDescriptor descriptor = TypeDescriptor.GetProperties(container).Find(propertyName, true); if (descriptor == null) { return null; } return new ViewDataInfo(() => descriptor.GetValue(container)) { Container = container, PropertyDescriptor = descriptor }; } Again, this is in the ViewDataDictionary.cs file in ASP.NET MVC 2 RC. Should I create a new issue to track this on the MVC codeplex site?
