[site]: stackoverflow
[post_id]: 3384344
[parent_id]: 
[tags]: 
Static linking GLU?

I'm using GLUTess to tesselate polygons. After several tests, I realized glu32.lib which links to glu32.dll, crashes every once in a while. Whereas GLU which I got from the opengl sdk, is solid as a rock. Unfortunately though, by not linking to the windows dll, this means I need to drag around GLU.dll with my app instead of relying on Windows's GLU32.dll. Is there a version of GLU which is static linkable? I really do not want to have any dll dependencies for his small project. Thanks My tesselator code: #include "StdAfx.h" #include "CGlTesselator.h" std::vector gluptrvec; std::vector tempvct; std::vector tempvcttex; POINTFLOAT CurrentDimensions; POINTFLOAT CurrentMinima; void CALLBACK combineCallback(GLdouble coords[3], GLdouble *vertex_data[4], GLdouble weight[4], GLdouble **dataOut) { GLdouble *vertex; vertex = (GLdouble *) malloc(6 * sizeof(GLdouble)); if(vertex == NULL) { MessageBox(0,0,0,0); } vertex[0] = coords[0]; vertex[1] = coords[1]; //vertex[2] = coords[2]; *dataOut = vertex; gluptrvec.push_back(vertex); } void CALLBACK vertexCallback(GLvoid *vertex) { GLdouble *ptr; ptr = (GLdouble *) vertex; if(ptr == NULL) { MessageBox(0,0,0,0); } double x = ptr[0]; double y = ptr[1]; double s = (x - CurrentMinima.x) / CurrentDimensions.x; double t = (y - CurrentMinima.y) / CurrentDimensions.y; tempvct.push_back((GLfloat)x); tempvct.push_back((GLfloat)y); tempvcttex.push_back((GLfloat)s); tempvcttex.push_back((GLfloat)t); //glTexCoord2d(s,t); //glVertex2dv((GLdouble *) ptr); } void CALLBACK edgeflags(int flag) { } CGlTesselator::CGlTesselator(void) { Init(); } int CGlTesselator::Init(GLvoid) { // Create a new tessellation object tobj = gluNewTess(); // Set callback functions gluTessCallback(tobj, GLU_TESS_VERTEX, (GLvoid (_stdcall *)(void) ) &vertexCallback); gluTessCallback(tobj, GLU_TESS_BEGIN, (GLvoid (_stdcall *)(void) ) &glBegin); gluTessCallback(tobj, GLU_TESS_END, (GLvoid (_stdcall *)(void) ) &glEnd); gluTessCallback(tobj, GLU_TESS_COMBINE, (GLvoid (_stdcall *)(void) )&combineCallback); gluTessCallback(tobj, GLU_EDGE_FLAG, (GLvoid (_stdcall *)(void) )&edgeflags); return(1); } int CGlTesselator::Set_Winding_Rule(GLenum winding_rule) { // Set the winding rule gluTessProperty(tobj, GLU_TESS_WINDING_RULE, winding_rule); return(1); } int CGlTesselator::Render_Contour(GLdouble obj_data[][6], int num_vertices) { for (int x = 0; x 0) { for(unsigned int i = 0; i 0) { glBindBufferARB(GL_ARRAY_BUFFER_ARB,polyvbo); glBufferDataARB(GL_ARRAY_BUFFER_ARB,sizeof(GLfloat) * tempvct.size(),&tempvct[0],GL_STATIC_COPY); glBindBufferARB(GL_ARRAY_BUFFER_ARB,texvbo); glBufferDataARB(GL_ARRAY_BUFFER_ARB,sizeof(GLfloat) * tempvcttex.size(),&tempvcttex[0],GL_STATIC_COPY); } vbocount = tempvct.size(); texcount = tempvcttex.size(); tempvct.clear(); tempvcttex.clear(); } Is there something wrong here?
