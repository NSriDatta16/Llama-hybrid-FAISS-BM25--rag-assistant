[site]: stackoverflow
[post_id]: 3763191
[parent_id]: 3762332
[tags]: 
You must set the single-line option to get the effect you're describing; you can do that in two ways, both using the RegexOptions.SingleLine option, which does exactly that: allows . to also match newlines in addition to 'any character'. in the Regex constructor using RegexOptions.SingleLine; however that can mess up the entire regex. inline, using the syntax (?s) to turn it on and (?-s) to turn it off. You can use this to turn it on just before the expression you want to be able to match multiple lines and back off afterwards. That takes care of spanning multiple lines. Now for double quotes embedded in the string... I'm assuming they'll be escaped somehow? Is it plain backslash escaping? Double-quoting? You'll have to see which is the case, there's a solution for every case. However... in the words of some very wise man (can't remember who he was so obviously wiser than me), 'if you have a problem and say - I know, I'll use regex -- now you have two problems'. That can certainly be the case when you keep discovering corner cases. Edit: Note that you can actually ignore escaped characters... somewhat... for example you can match quotes only when not preceded by backslash, with negative look-behind assertions (I think that's what they're called at least): ? , but going that way is a bit more complex. I'm not even sure exactly how it works myself. In the case of CDATA it's considerably easier to write a regex; all you need to do is turn on single line as I said, and: match the start, which is \"\ ; you need to escape the characters because most of them have specific meanings in the regex syntax. To be on the safe side (if you don't feel like looking for documentation on what exactly you need to escape), you can escape with a backslash pretty much any non-standard character. match any characters, for the maximum length possible before encountering the next match: (.+)? - note the question mark, which makes the match non-greedy. match the CDATA end tag: \]\]\>\"; . So the complete expression would be... (without testing it a great deal, mind you): ( {{ (? \w*) | (? (? \w*)="\ .*)?\]\]\>";*) }} )+ (I've spread it across multiple lines with IgnoreWhitespace to be more readable). However it might make for some awkward code when going over the results so I've taken the liberty of improving it slightly: ( {{ (? .*?) \| ((? \w*) | (? (? \w*) ="\ .+)? \]\]\>"; )+ ) }} )+ (Note that when pasting in Visual Studio you'll need to escape the quotes again!) What this does, when going through multiple matches with the option ExplicitCapture on (to only capture named groups), is this: the match will contain a title group. This is the first part of the regex. the match will have some data in either the single or pair groups; you can check with string.IsNullOrEmpty which one has matched. if the single contains something, then that's the match you're looking for. if the pair contains something, you can look further at the key and cdatavalue groups for the key-value-pair broken up according to what you requested. Example: sample text: {{asp:sample|test}} {{asp:codesample|Text=" this is text on the second line]]>";}} Results: Also, can't believe I didn't mention this earlier: Expresso is an awesome tool for testing and developing .net regexes, and it's free (the registration required is a minor nuisance). Holy cow, that was long. Sorry for the long-windedness.
