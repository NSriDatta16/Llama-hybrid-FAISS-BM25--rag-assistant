[site]: stackoverflow
[post_id]: 2729316
[parent_id]: 2318005
[tags]: 
It's strange to me that you've now received two answers that seem to confirm you can't do this. I just tested it myself and it worked fine without throwing any exception. Below is the code I used to test the behavior, followed by an excerpt of the output (around when I pressed 'C' to clear the dictionary in a foreach and S immediately afterwards to stop the background threads). Notice that I put a pretty substantial amount of stress on this ConcurrentDictionary : 16 threading timers each attempting to add an item roughly every 15 milliseconds. It seems to me this class is quite robust, and worth your attention if you're working in a multithreaded scenario. Code using System; using System.Collections.Concurrent; using System.Collections.Generic; using System.Threading; namespace ConcurrencySandbox { class Program { private const int NumConcurrentThreads = 16; private const int TimerInterval = 15; private static ConcurrentDictionary _dictionary; private static WaitHandle[] _timerReadyEvents; private static Timer[] _timers; private static volatile bool _timersRunning; [ThreadStatic()] private static Random _random; private static Random GetRandom() { return _random ?? (_random = new Random()); } static Program() { _dictionary = new ConcurrentDictionary (); _timerReadyEvents = new WaitHandle[NumConcurrentThreads]; _timers = new Timer[NumConcurrentThreads]; for (int i = 0; i (r.Next(), r.Next()); if (_dictionary.TryAdd(entry.Key, entry.Value)) Console.WriteLine("Added entry: {0} - {1}", entry.Key, entry.Value); else Console.WriteLine("Unable to add entry: {0}", entry.Key); } finally { readyEvent.Set(); } } } } Output (excerpt) cAdded entry: 108011126 - 154069760 // Also note that, based on the console output, it looks like the foreach loop locked out the other threads that were trying to add values to the dictionary. (I could be wrong, but otherwise I would've guessed you would've seen a bunch of "Added entry" lines between the "COUNT" lines.)
