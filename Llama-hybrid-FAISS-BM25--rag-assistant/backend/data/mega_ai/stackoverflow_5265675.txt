[site]: stackoverflow
[post_id]: 5265675
[parent_id]: 5265568
[tags]: 
One possible workaround is not to make the method virtual, but replace it using the new keyword: class Program { static void Main(string[] args) { List list = new List { new B(), new B(), new B(), new B() }; foreach (A a in list) { a.Foo(); } foreach (B b in list) { b.Foo(); } Console.ReadLine(); } } public class A { public void Foo() { Console.WriteLine("Base"); } } public class B : A { public new void Foo() { Console.WriteLine("Derived"); } } This will only call the B.Foo() implementation if the reference you use is of type B . I wouldn't encourage you to do this, since I've never came accross a situation where the new keyword made sense.
