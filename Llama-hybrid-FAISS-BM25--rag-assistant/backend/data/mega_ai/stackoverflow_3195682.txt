[site]: stackoverflow
[post_id]: 3195682
[parent_id]: 1945085
[tags]: 
Honestly, I don't quite see the point of it. As this.__curious_geek points out in his answer , a sealed class cannot be inherited and so using one as a constraint might seem nonsensical. But there's no guarantee that a sealed class will never be "unsealed" -- i.e., that the developer might rearrange its implementation to make it more amenable to inheritance and then remove the sealed modifier from the class definition (or just flat-out remove the sealed keyword for no reason at all). I know a lot of developers actually encourage this practice: not removing the sealed keyword per se, but rather adding the sealed keyword liberally and only supporting inheritance when the decision to do so is made explicitly (and at this point, yes, removing the sealed keyword). So I'm not sure why you couldn't use the type of a sealed class as a generic constraint. After all, you could always use the type of a class that just happens to not have any derived classes, even though it's not sealed. The two scenarios don't seem all that different to me. I'm probably missing something, though. I'm sure Eric Lippert could give a pretty killer explanation.
