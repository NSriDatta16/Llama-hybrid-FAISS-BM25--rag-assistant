[site]: stackoverflow
[post_id]: 5394294
[parent_id]: 5385500
[tags]: 
How Strange. Okay, when I tried to use the auto-correct "include org.eclipse.core.databinding_1.3..." nothing happened. I ass-u-me'd that it was correctly included as a plugin dependency and didn't fix the error. During this time, that plugin's jar appeared in my plugin project's "Plug-in Dependencies" folder, and I was able to view its source. One would think at that point that the plugin was correctly included in the plugin.xml One would be wrong. I manually added ...core.databinding_1.3... to my plugin dependencies and the errors Went Away. So it seems this is a bug in the autocorrect rather than in the API restriction code. AH! I had org.eclipse.core.databinding in my Imported Packages list. That must have thrown things off. So now you know. And knowing's have the battle. GO CODE! And speaking of code. Here's what I'm doing (more or less): enum MapValueDirection { VALUE_TO_KEY, KEY_TO_VALUE }; private class MappingConverter extends Converter { Map map = null; public MappingConverter( Map map_, MapValueDirection dir) { super(String.class, String.class); if (dir == MapValueDirection.VALUE_TO_KEY) { map = reverseMap(map_); } else { map = map_; } } private Map reverseMap(Map map_) { Map reversedMap = new TreeMap (); Set > entries = map_.entrySet(); for (Entry curEnt : entries) { reversedMap.put(curEnt.getValue(), curEnt.getKey()); } return reversedMap; } /* (non-Javadoc) * @see org.eclipse.core.databinding.conversion.IConverter#convert(java.lang.Object) */ public Object convert(Object fromObject) { if (map != null && fromObject != null && String.class.equals(fromObject.getClass())) { Object newVal = map.get(fromObject); if (newVal == null) { newVal = fromObject; } return newVal; } return fromObject; } } /** * And this is were the actual work gets done. */ public void bindBean(Object bean, PropertyDescriptor prop) { Control curControl = getControl(prop.getPropertyType()); IObservableValue uiElement = getObserver(prop, curControl); IOvservableValue modelElement = BeanObservables.observValue(bean, prop.getName()); // "display" = key, "storage" = value Map profileFlds = getProfileFields(); UpdateValueStrategy toStorage = new UpdateValueStrategy(); toStorage.setConverter( new MappingConverter( profileFlds, MapValueDirection.KEY_TO_VALUE)); UpdateValueStrategy toDisplay = new UpdateValueStrategy(); toDisplay .setConverter( new MappingConverter( profileFlds, MapValueDirection.VALUE_TO_KEY)); m_bindingContext.bindValue( uiElement, modelElement, toDisplay , toStorage); } My actual code is a bit more complex than that, but you get the idea. I suspect it's not terribly efficient, but it works well within the whole data binding framework, conceptually speaking (based on my admittedly limited experience). It should be fairly trivial to make a Generic version of MappingConverter, but I'll leave that as an Exercise For the Reader.
