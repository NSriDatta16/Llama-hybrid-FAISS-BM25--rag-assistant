[site]: stackoverflow
[post_id]: 830538
[parent_id]: 
[tags]: 
Dynamic class creation

we have a data-layer which contains classes generated by outputs (tables/views/procs/functions) from database. The tables in database are normalized and are designed similar to OOP design ( table for "invoice" has 1:1 relation to table for "document", table for "invoice-item" has 1:1 relation to table for "document-item", etc...". All access to/from databaes is by stored procedures (for simple tables too). Typical clas looks like (shortly): public class DocumentItem { public Guid? ItemID { get; set; } public Guid? IDDocument { get; set; } public DateTime? LastChange { get; set; } } public class InvoiceItem : DocumentItem { public Guid? IDProduct { get; set; } public decimal? Price { get; set; } } The problem is, the database tables has relations similar to multiple inheritance in OOP. Now we do a new class for every database output. But every database outputs are combination of "pure" tables in database. The ideal solution would be (IMHO) tranform classes to interface, use the multiple implementation of interfaces, and then automaticly implement the members (this "table-classes" has only properties, and body of properties are always same). For example: public interface IItem { Guid? ItemID { get; set; } DateTime? LastChange { get; set; } } public interface IDocumentItem : IItem { Guid? IDDocument { get; set; } } public interface IItemWithProduct : IItem { Guid? IDProduct { get; set; } } public interface IItemWithRank : IItem { string Rank { get; set; } } public interface IItemWithPrice : IItem { decimal? Price { get; set; } } // example of "final" item interface public interface IStorageItem : IDocumentItem, IItemWithProduct, IItemWithRank { } // example of "final" item interface public interface IInvoiceItem : IDocumentItem, IItemWithProduct, IItemWithPrice { } // the result should be a object of class which implements "IInvoiceItem" object myInvoiceItem = SomeMagicClass.CreateClassFromInterface( typeof( IInvoiceItem ) ); The database contains hunderts of tables and the whole solution is composed from dynamicly loaded modules (100+ modules). What do you think, is the best way, how to deal with it? EDIT: Using partial classes is good tip, bud in our solution can not be used, because "IDocumentItem" and "IItemWithPrice" (for example) are in different assemblies. Now, if we make change in "DocumentItem" table, we must go and re-generate source code in all dependent assemblies. There is almost no reuse (because can not use multiple inheritance). Its quite time consuming, if there are dozens of dependent assemblies.
