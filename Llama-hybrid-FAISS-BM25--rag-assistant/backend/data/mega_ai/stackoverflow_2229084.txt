[site]: stackoverflow
[post_id]: 2229084
[parent_id]: 
[tags]: 
C# generic interface specialization

I wonder if it is in any way possible to specialize generic interface methods somehow in C#? I have found similar questions, but nothing exactly like this. Now I suspect that the answer is "No, you can't" but I would like to have it confirmed. What I have is something like the following. public interface IStorage { void Store (T data); } public class Storage : IStorage { public void Store (T data) { Console.WriteLine("Generic"); } public void Store(int data) { Console.WriteLine("Specific"); } } class Program { static void Main(string[] args) { IStorage i = new Storage(); i.Store("somestring"); // Prints Generic i.Store(1); // Prints Generic Storage s = (Storage)i; s.Store("somestring"); // Prints Generic s.Store(1); // Prints Specific } } Is there any way to make it use the specialized version of Store when called through the interface? And if not, does anyone know the exact reason why C# treats Generic arguments this way? Edit: The issue could be worked around if it wasn't so that C# cannot resolve template arguments in more than one step. void Foo (T t) { SubFoo(t); } void SubFoo (T t) { Console.WriteLine("Generic"); } void SubFoo(int t) { Console.WriteLine("Specific"); } A call to Foo(1) here will print "Generic" as well, shouldn't the compiler be able to resolve this? Or does the JIT prevent this?
