[site]: stackoverflow
[post_id]: 409215
[parent_id]: 409198
[tags]: 
I remember someone saying if you create a class through a lib you should destroy it through the lib. That means if you call a function in a lib to create an object for you, you should read the documentation of that function, which must say how you free that object again. Often the function for free something is named similar to the allocation function. For example, the library pcre has two functions called pcre_malloc and pcre_free . The reason is, because the library allocates in a way opaque to you (which is the reason you use the function in the first place). It could get memory from the data-section of the program, while you would (wrongly) assume it got the memory possibly from the heap when using delete . If you are that library writer, the same rules apply. Make sure that when one of your functions return a object allocated dynamically, you say how the caller has to handle it Is the object encapsulated into a smart pointer? Then the smart pointer will take care of calling the appropriate deleter you designated. Do you return a raw pointer? You should avoid that, because the caller has to keep track of the pointer, and the caller will have to pass the pointer into a function you document in your interface. That's just another level of dependency you put on the burden of the user of your library, which smart pointers can elegantly rationalize away. Do you return an object by value, which by itself wraps an allocated resource? If that is the case, overload the copy constructor, copy assignment operator and destructor of that object's class, which then manages the resource by either copying it properly or sharing it among all other instances of its object (see this answer ). You should almost never overload the delete operator for your class unless you have also overloaded the new operator. Overloading the delete operator is not to be taking literally: It means you merely overload deallocation of the associated memory of an object. It only makes sense if you are housing your own memory pool or want to log every allocation/deallocation of memory for your objects.
