[site]: stackoverflow
[post_id]: 5066676
[parent_id]: 5066508
[tags]: 
You need to pass in the additional operations and the UserInfo object as a callback to the asynchronous method. The easiest way to do this is to create a class containing them and pass that as the asynchronous state of the method. private class ImageCallbackState { public UserInfo Friend { get; set; } public Action Callback { get; set; } } private void GetProfilePhotosFromServer(IEnumerable friends) { Parallel.ForEach(friends, f => { //get defualt if (f.ProfilePhoto == null) f.ProfilePhotoAsBitmap = CreateDefaultAvatar(f.Sex); Action action = (u,i) => { i.Freeze(); u.ProfilePhotoAsBitMap = i; }; var state = new ImageCallbackState { Friend = f, Callback = action }; StartDownloadingImage(f.MediumProfilePhoto,state); }); } private void StartDownloadingImage(Uri imageUri, ImageCallbackState state) { _webRequest = WebRequest.Create(imageUri); _webRequest.BeginGetResponse(this.ProcessImage, state); // pass callback state } private void ProcessImage(IAsyncResult asyncResult) { var response = _webRequest.EndGetResponse(asyncResult); using (var stream = response.GetResponseStream()) { var buffer = new Byte[response.ContentLength]; int offset = 0, actuallyRead = 0; do { actuallyRead = stream.Read(buffer, offset, buffer.Length - offset); offset += actuallyRead; } while (actuallyRead > 0); var image = new BitmapImage { CreateOptions = BitmapCreateOptions.None, CacheOption = BitmapCacheOption.OnLoad }; image.BeginInit(); image.StreamSource = new MemoryStream(buffer); image.EndInit(); var state = asyncResult.AsyncState as ImageCallbackState state.Callback(state.Friend,image); } }
