[site]: stackoverflow
[post_id]: 4290945
[parent_id]: 4290727
[tags]: 
Just doing it the old fashioned way is fine - create an auto pointer whose lifecycle is the whole application life-cycle, and an extern reference to the pointer: // test.h #pragma once #include typedef boost::array bigLut_t; extern const bigLut_t& constLut; // make it a reference // test.cpp #include #include #include "test.h" namespace { std::auto_ptr initializeConstLut() { std::auto_ptr lut(new bigLut_t); if( boost::filesystem::exists("my_binary_file") == false ) { std::ofstream outStream( "my_binary_file", ios::out | ios::binary ); for(int i = 0; i at(i) = i; } outStream.write( reinterpret_cast (lut), sizeof(bigLut_t) ); outStream.close(); // no point writing then reading the same data } else { std::ifstream inStream( "my_binary_file", ios::in | ios::binary ); inStream.read( reinterpret_cast (lut.get()), sizeof(bigLut_t) ); inStream.close(); } return lut; } // local to this compilation unit, deletes object on exit std::auto_ptr constLutPtr ( initializeConstLut() ); } // the extern reference refers to the object held by the auto_ptr const bigLut_t& constLut ( *constLutPtr.get() ); No extra copying, client code sees the extern variable as before, though the linker may have to have an extra indirection rather than the extern varibale being in a fixed address (&constLutPtr is on the heap rather than in static data area). If having a fixed address for constLut is important, go back to having an extern value rather than an extern reference, read the data in using a reinterpret cast and a const_cast of &constLutPtr. pass reinterpret_cast (const_cast (&constLut)) to the stream read.
