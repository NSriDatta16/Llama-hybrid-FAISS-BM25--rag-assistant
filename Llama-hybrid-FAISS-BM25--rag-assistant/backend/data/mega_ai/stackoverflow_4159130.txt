[site]: stackoverflow
[post_id]: 4159130
[parent_id]: 4156538
[tags]: 
Measurements on Visual Studio 2010 show that std::bitset is not generally faster than std::vector . What the exact reason for this is I cannot say -- only that bitset is implemented significantly different from the std::vector full specialization. std::bitset stores it's full content in the object via a template class bitset ..... _Ty _Array[_Words + 1]; // the set of bits }; array and that makes large bitset unsuitable to be put on the stack -- which isn't a performance argument per se. vector doesn't suffer from the stack problem, and testing with a size of 1e6 and 1e7 it seems that on my box here querying values in a loop is actually 2x faster with a vector. Well. I guess the usual timing caveats apply and YMMV, but here's the test code I used should anyone care to try himself: The output on my box is: 1 vector loop with a size of 10000000 and 10 iterations*n: 11187 ms bitset loop with 10 iterations*n: 22719 ms 101250010 Press any key to continue . . . BitMap.cpp #include "stdafx.h" #include "BitMap.h" using namespace std; // Global var to prevent optimizer from messing things up volatile size_t ext; volatile clock_t t1; volatile clock_t t2; double delta1; double delta2; int main(int argc, _TCHAR* argv[]) { ext = 1; printf("%d\n", ext); vb_t *const vec = new vb_t(bssz); bs_t *const bits = new bs_t(); // must put large bitset on heap const int iter = 10; delta1=0; delta2=0; for(int o=0; o loop with a size of " loop with " BitMap.h #pragma once #include #include extern volatile size_t ext; const size_t bssz = size_t(1e7); // 1e7 ca 10m using namespace std; // Test code, using here is OK. typedef vector vb_t; typedef bitset bs_t; template void bs_loop(const int iterations, COLL const& v); bs_loop.cpp #include "stdafx.h" #include "BitMap.h" template void bs_loop(const int iterations, COLL const& v) { ext = sizeof(COLL); for(size_t i=0; i!=iterations; ++i) { ++ext; for(size_t j=0, e=v.size(); j!=e; ++j) { if(v[j]) { --ext; } else { ++ext; } } } } template void bs_loop(const int iterations, vb_t const& v); template void bs_loop(const int iterations, bs_t const& v); Compiler command line: /Zi /nologo /W3 /WX- /O2 /Oi /Oy- /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_UNICODE" /D "UNICODE" /Gm- /EHsc /GS /Gy /fp:precise /Zc:wchar_t /Zc:forScope /Yu"StdAfx.h" /Fp"Release\BitMap.pch" /Fa"Release\" /Fo"Release\" /Fd"Release\vc100.pdb" /Gd /analyze- /errorReport:queue note the /O2 and the missing /GL (no whole prg opt).
