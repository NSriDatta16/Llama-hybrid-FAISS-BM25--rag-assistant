[site]: stackoverflow
[post_id]: 3592151
[parent_id]: 3588651
[tags]: 
(Warning: Mammoth answer ahead!) I think it's called a macro ;) Well, at least outside the C/C++ world (where "macro" refers to this severly limited substitution the preprocessor provides). And it's not very novel. Though I think a proper, powerful macro system can add more power to a language than any other feature (given we preserve enough primitives that it's not merely turing-completene, but useful for real programming), in that a sufficently smart programmer can add nearly all features that might prove useful in the future or for a specific domain without adding (further) rules to the language. The basic idea is to parse a program into a representation above a string with the source code, say, an AST or a parse tree . Such trees provide more information about the program, and another program can walk this tree and modify it. For example, it would be possible to look for a VariableDeclaration node, check if it declares a plain old array of T , and replace it with a new VariableDeclaration node that instead declares a std::variable_array of T . This can for example be refined by providing pattern matching for the tree, making metaprogramming easier. A powerful procedure, if and only if the programmer can cope with this level of abstractness and knows how to put it to good use. Note that when I'm speaking of "pattern matching", I speak of the pattern matching in functional programming, not of regular expressions. Regular expressions are insufficent to make sense of irregular languages, this includes about every useful language - merely allowing expressions of abritary size, including balanced parentheses, rules regular expressions out. See the accepted answer on What is 'Pattern Matching' in functional languages? for an excellent introduction to pattern matching, and maybe learn a functional language like Haskell oder O'Caml if only to learn how to use it and how to process trees (and there's a ton of other cool features!). Now on the language you propose: Honestly, I doubt it would be useful. C++ itself is a perfect example of how not to design a language (unless you want to successful): Take an existing one, stay backward-compatible = keep all of it (including the bad stuff), and add a bunch of new features that are complex enough by themselves, then tweak them a thousand times and add a hundred special cases to work more-or-less with the syntax and semantics of the existing language. It makes success more likely (if the language you started with is already popular), but you end up with an arcane and inelegant beast. That being said, I'd really love to see a non-lisp language that allows macros of such power. The right (or at least, a better) way would be rethinking every single bit, from the most basics semantics to the exact syntax, integrate it with what you want to add, and tweak all parts of the newly formed language until the whole picture looks right. In your case, this would have an extremely convenient side effect: Ease of parsing. Of course, the source must be parsed before macros can be applied, as they concern themselfes with a tree, not with string fragments. But C++ is very hard to parse. Like, literally the hardest-to-parse language in common use. Oh, while we're at it: Macros themselves can make the life of our beloved tools (IDEs with autocomplete and call tips, static code analysis, etc pp) miserable. Making sense of a piece of code is hard enough, but it gets even worse if this code will be transformed abritarily, and possibly very heavily, before it reaches the form that is executed. In general, code analysis tools can't cope with macros. The whole area is so hard that clever people make up new languages for research on it and write papers on it neither of us can comprehend. So be aware that macros do have downsides.
