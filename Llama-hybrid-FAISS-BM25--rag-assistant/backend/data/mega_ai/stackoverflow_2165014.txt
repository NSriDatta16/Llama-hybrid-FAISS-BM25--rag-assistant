[site]: stackoverflow
[post_id]: 2165014
[parent_id]: 2164433
[tags]: 
Since your customer is yourself, you'll need to decide the answer to all of the questions that Mark Byers asked. However, I'll give you some suggestions and hopefully they'll give you a start. Let's assume your factory takes a few different parts and assembles them into just one finished product. A flowchart of the assembly process might look like this: Factory Flowchart http://img62.imageshack.us/img62/863/factoryflowchart.jpg For the first diamond, where widgets A and B are assembled, assume it takes on average 30 seconds to complete this step. We'll assume the actual time it takes the two widgets to be assembled is distributed normally , with mean 30 s and variance 5 s. For the second diamond, assume it also takes on average 30 seconds, but most of the time it doesn't take nearly that long, and other times it takes a lot longer. This is well approximated by an exponential distribution , with 30 s as the rate parameter, often represented in equations by a lambda. For the first process, compute the time to assemble widgets A and B as: timeA = randn(mean, sqrt(variance)); // Assuming C# has a function for a normally // distributed random number with mean and // sigma as inputs For the second process, compute the time to add widget C to the assembly as: timeB = rand()/lambda; // Assuming C# has a function for a uniformly distributed // random number Now your total assembly time for each iGadget will be timeA + timeB + waitingTime . At each assembly point, store a queue of widgets waiting to be assembled. If the second assembly point is a bottleneck, it's queue will fill up. You can enforce a maximum size for its queue, and hold things further up stream when that max size is reached. If an item is in a queue, it's assembly time is increased by all of the iGadgets ahead of it in the assembly line. I'll leave it up to you to figure out how to code that up, and you can run lots of trials to see what the total assembly time will be, on average. What does the resultant distribution look like? Ways to "spice this up": Require 3 B widgets for every A widget. Play around with inventory. Replenish inventory at random intervals. Add a quality assurance check (exponential distribution is good to use here), and reject some of the finished iGadgets. I suggest using a low rejection rate. Try using different probability distributions than those I've suggested. See how they affect your simulation. Always try to figure out how the input parameters to the probability distributions would map into real world values. You can do a lot with this simple simulation. The next step would be to generalize your code so that you can have an arbitrary number of widgets and assembly steps. This is not quite so easy. There is an entire field of applied math called operations research that is dedicated to this type of simulation and analysis.
