[site]: stackoverflow
[post_id]: 5399774
[parent_id]: 5397777
[tags]: 
Let's say I need to fetch all items where the parentid equals 1. First, stop thinking of your data access needs this way. You DO NOT need to " fetch all items where the parentid equals 1 ". It will help to try and stop thinking in such a data oriented way. What you need is to fetch all items with a particular parent. This is a concept that exists in your problem space (your application's domain). The fact that you model this in the database with a foreign key and a field named parentid is an implementation detail . Encapsulate this, do not leak it throughout your application. One way is to use the IQueryable List() and get all documents and then add a where clause to select the items where the parentid equals 1. This seems like a bad idea because I can't use any index features in RavenDB. So the other approach is to have something like this, IEnumerable Find(string index, Func predicate) in the repository but that also seems like a bad idea because Both of these are bad ideas. What you are suggesting is requiring the code that calls your repository or query to have knowledge of your schema. Why should the consumer of your repository care or know that there is a parentid field? If this changes, if the definition of some particular concept in your problem space changes, how many places in your code will have to change? Every single place that fetches items with a particular parent. This is bad, it is the antithesis of encapsulation. My opinion is that you will want to model queries as explicit concepts, and not lambda's or strings passed around and used all over. You can model queries explicitly with the Specification pattern, named query methods on a repository, Query Object pattern, etc. it's not generic enough and requires that I implement this method for if I would change from RavenDB to a common sql server. Well, that Func is too generic. Again, think about what your consuming code will need to know in order to use such a method of querying, you will be tying upper layers of your code directly to your DB schema doing this. Also, if you change from one storage engine to another, you cannot avoid re-implementing queries where performance was enough of a factor to use storage-engine-specific aids (indexes in Raven, for example).
