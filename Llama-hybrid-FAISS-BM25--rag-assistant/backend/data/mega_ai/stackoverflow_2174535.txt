[site]: stackoverflow
[post_id]: 2174535
[parent_id]: 
[tags]: 
Multithreading in... functional languages? (Prolog)

When my friend started learning Prolog in school, I made fun of him for learning a useless language. However, he's showed me some stuff I never even knew possible; I want to know where this technique comes from. The technique is this: permutation(List) :- isAMember(X, List), deleteFirstElement(X, List, Substring), % and so on In this code, isAMember(X, List) is a function that returns true if X is in List . However, up to this point X is not defined as a variable - so the program will spawn a bunch of new threads, one for each possible value of X that makes isAMember(X, List) true, and continue from there. This allows us to create a multi-threaded algorithm in the simplest, most elegant way I could have ever imagined possible. So my question is: Is this Prolog-specific, or a feature of all logical- and/or functional-languages? Also, where can I learn more amazing multithreading techniques like this - this is surely the future of programming.
