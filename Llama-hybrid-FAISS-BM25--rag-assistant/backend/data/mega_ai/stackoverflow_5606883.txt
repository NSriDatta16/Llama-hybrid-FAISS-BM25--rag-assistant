[site]: stackoverflow
[post_id]: 5606883
[parent_id]: 
[tags]: 
DBD::SQLite, how to pass array in query via placeholder?

Let's have a table: sqlite> create table foo (foo int, bar int); sqlite> insert into foo (foo, bar) values (1,1); sqlite> insert into foo (foo, bar) values (1,2); sqlite> insert into foo (foo, bar) values (1,3); Then SELECT some data: sqlite> select * from foo where foo = 1 and bar in (1,2,3); 1|1 1|2 1|3 Works all right. Now I'm trying to use DBD::SQLite 1.29: my $sth = $dbh->prepare('select * from foo where foo = $1 and bar in ($2)'); $sth->execute(1,[1,2,3]); And this gives me null results. DBI trace shows that 2nd placeholder is bound to array all right, but no score. If I join array values in a string and pass it, no result. If I flatten the array, I get predictable error of "called with N placeholders instead of 2". I'm kinda at loss. What else is there to try? Upd: All right, here's one bona fide example taken from the real world application. First, the setup: I have several tables filled with statistical data, number of columns varies from 10 to 700+. The queries I'm talking about select subset of that data for reporting purposes. Different reports consider different aspects and therefore run different queries, one or more per request. There are more than 200 reports, i.e. 200-300 queries. This approach was developed for Postgres and now I need to scale it down and make it work with SQLite. Considering that all this works well with Postgres, I can't justify going over all queries and rewriting them. Bad for maintenance. I can and do use in-place query adjustments, like replacing = ANY () with IN (), these are minor aspects. So, here's my example: 2 queries ran in succession for one report: SELECT SPLIT, syn(SPLIT), (SELECT COUNT(*) FROM cagent WHERE ACD = $1 AND SPLIT = $2 AND LOC_ID = ANY ($3) AND LOGID IS NOT NULL AND WORKMODE = 40), (SELECT COUNT(*) FROM cagent WHERE ACD = $1 AND SPLIT = $2 AND LOC_ID = ANY ($3) AND LOGID IS NOT NULL AND WORKMODE = 30), (SELECT COUNT(*) FROM cagent WHERE ACD = $1 AND SPLIT = $2 AND LOC_ID = ANY ($3) AND LOGID IS NOT NULL AND WORKMODE = 50), (SELECT COUNT(*) FROM cagent WHERE ACD = $1 AND SPLIT = $2 AND LOC_ID = ANY ($3) AND LOGID IS NOT NULL AND WORKMODE = 220), (SELECT COUNT(*) FROM cagent WHERE ACD = $1 AND SPLIT = $2 AND LOC_ID = ANY ($3) AND LOGID IS NOT NULL), (SELECT COUNT(*) FROM cagent WHERE ACD = $1 AND SPLIT = $2 AND LOC_ID = ANY ($3) AND LOGID IS NOT NULL AND WORKMODE = 20), (SELECT COUNT(*) FROM cagent WHERE ACD = $1 AND SPLIT = $2 AND LOC_ID = ANY ($3) AND LOGID IS NOT NULL AND WORKMODE = 80) FROM csplit WHERE ACD = $1 AND SPLIT = $2 SELECT syn(LOGID), syn(LOC_ID), LOGID, EXTENSION, syn(ROLE), PERCENT, syn(AUXREASON), syn(AWORKMODE), syn(DIRECTION), WORKSKILL, syn(WORKSKLEVEL), AGTIME FROM cagent WHERE ACD = $1 AND SPLIT = $2 AND LOC_ID = ANY ($3) AND LOGID IS NOT NULL This is not the most complex example, as there can be any number of input parameters used and reused in different places in query; replacing them with generic ? placeholders is not a trivial task. Code that runs queries against Postgres looks like that (after input cleansing et al): sub run_select { my ($class, $dbh, $sql, @bind_values) = @_; my $sth; eval { $sth = $dbh->prepare_cached($sql); $sth->execute(@bind_values); }; $@ and die "Error executing query: $@"; my %types; { my $dbt = $dbh->type_info_all; @types{ map { $_->[1] } @$dbt[1..$#$dbt] } = map { $_->[0] } @$dbt[1..$#$dbt]; }; my @result; while (my $row = $sth->fetchrow_arrayref) { my $i = 0; push @result, [ map { [ $types{${$sth->{TYPE}}[$i++]}, $_ ] } @$row ]; }; return \@result; }; I can rewrite queries and inject values directly; SQL injection is not much of a threat because all input is untainted through regex patterns long before it can hit SQL engine. I don't want to rewrite queries dynamically for two reasons: a) it can potentially lead to problems with value quotation and b) it kinda kills the whole reason behind prepare_cached. SQL engine can't cache reuse prepared statement if it changes every time. Now as I said, the code above works well with Postgres. Since SQLite engine itself obviously have the possibility of working with data sets, I thought it was a deficiency in DBD::SQLite implementation. So the real question sounds like: is there any way to pass a data set in a placeholder with DBD::SQLite? Not necessarily array though that would be most logical.
