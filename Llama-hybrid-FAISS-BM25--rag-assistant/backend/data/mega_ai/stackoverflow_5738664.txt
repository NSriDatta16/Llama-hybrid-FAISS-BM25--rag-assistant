[site]: stackoverflow
[post_id]: 5738664
[parent_id]: 
[tags]: 
Calling an expensive Reactive Extensions `IObservable` function only when values not in local cache

I'm using the Reactive Extensions (Rx) and a repository pattern to facilitate getting data from a relatively slow data source. I have the following (simplified) interface: public interface IStorage { IObservable Fetch(IObservable ids); } Creating an instance of the implementation of IStorage is slow - think creating a web service or db connection. Each Guid in the ids observable results in a one-to-one INode (or null ) in the return observable and each result is expensive. Therefore , it makes sense to me only to instantiate IStorage only if I have at least one value to fetch and then to use IStorage to fetch only the values once for each Guid . To limit the calls to IStorage I cache the results in my Repository class that looks like this: public class Repository { private Dictionary NodeCache { get; set; } private Func StorageFactory { get; set; } public IObservable Fetch(IObservable ids) { var lazyStorage = new Lazy (this.StorageFactory); // from id in ids // if NodeCache contains id select NodeCache[id] // else select node from lazyStorage.Value.Fetch(...) } } In the Repository.Fetch(...) method I've included comments indicating what I'm trying to do. Essentially though, if the NodeCache contains all of the ids being fetched then IStorage is never instantiated and the results are returned with almost no delay. However, if any one id is not in the cache then IStorage is instantiated and all of the unknown ids are passed through the IStorage.Fetch(...) method. The one-to-one mapping, including order preservation, needs to be maintained. Any ideas?
