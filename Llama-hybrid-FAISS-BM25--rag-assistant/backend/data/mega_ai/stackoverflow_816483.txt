[site]: stackoverflow
[post_id]: 816483
[parent_id]: 816232
[tags]: 
Recursion can work, as can building an auxiliary data structure, such as an array with one entry for each element of the original list. If you want a solution for a single-threaded list without requiring O(n) extra storage, the best bet is to reverse the list in place as Michael suggests. I wrote an example for this, [but I'll leave it out given the concern about homework]. One caution about reversing the list: if there are any other data structures that hold pointers to the original list, and you might be accessing them during your traversal, they won't work if they need to access the list while it's reversed, and this might lead to data corruption if they try to modify the list. Update: Ok, here's the (C++) routine to reverse a list in place. It hasn't been tested, though. And I'll note that if this is homework, the poster still needs to figure out how to use this routine correctly to get a complete answer. Node *ReverseList(Node *head) { // Reverse a single-threaded list in place, return new head Node *prev=NULL; Node *cur=head; while (Node *next=cur->next_) { cur->next_ = prev; prev = cur; cur = next; } cur->next_ = prev; return cur; }
