[site]: stackoverflow
[post_id]: 1728779
[parent_id]: 1725810
[tags]: 
Getting the progress window consistently displayed on top of the (dead) form is the difficult requirement. This is normally handled by using the Form.Show(owner) overload. It causes trouble in your case, WF isn't going to appreciate the owner form belonging to another thread. That can be worked around by P/Invoking SetWindowLong() to set the owner. But now a new problem emerges, the progress window goes belly-up as soon as it tries to send a message to its owner. Somewhat surprisingly, this problem kinda disappears when you use Invoke() instead of BeginInvoke() to update progress. Kinda, you can still trip the problem by moving the mouse over the border of the disabled owner. Realistically, you'll have to use TopMost to nail down the Z-order. More realistically, Windows just doesn't support what you are trying to do. You know the real fix, it is at the top of your question. Here's some code to experiment with. It assumes you progress form is called dlgProgress: Imports System.Threading Public Class ShowProgress Implements IDisposable Private Delegate Sub UpdateProgressDelegate(ByVal pct As Integer) Private mOwnerHandle As IntPtr Private mOwnerRect As Rectangle Private mProgress As dlgProgress Private mInterlock As ManualResetEvent Public Sub New(ByVal owner As Form) Debug.Assert(owner.Created) mOwnerHandle = owner.Handle mOwnerRect = owner.Bounds mInterlock = New ManualResetEvent(False) Dim t As Thread = New Thread(AddressOf dlgStart) t.SetApartmentState(ApartmentState.STA) t.Start() mInterlock.WaitOne() End Sub Public Sub Dispose() Implements IDisposable.Dispose mProgress.BeginInvoke(New MethodInvoker(AddressOf dlgClose)) End Sub Public Sub UpdateProgress(ByVal pct As Integer) mProgress.Invoke(New UpdateProgressDelegate(AddressOf dlgUpdate), pct) End Sub Private Sub dlgStart() mProgress = New dlgProgress mProgress.StartPosition = FormStartPosition.Manual mProgress.ShowInTaskbar = False AddHandler mProgress.Load, AddressOf dlgLoad AddHandler mProgress.FormClosing, AddressOf dlgClosing EnableWindow(mOwnerHandle, False) SetWindowLong(mProgress.Handle, -8, mOwnerHandle) Application.Run(mProgress) End Sub Private Sub dlgLoad(ByVal sender As Object, ByVal e As EventArgs) mProgress.Location = New Point( _ mOwnerRect.Left + (mOwnerRect.Width - mProgress.Width) \ 2, _ mOwnerRect.Top + (mOwnerRect.Height - mProgress.Height) \ 2) mInterlock.Set() End Sub Private Sub dlgUpdate(ByVal pct As Integer) mProgress.ProgressBar1.Value = pct End Sub Private Sub dlgClosing(ByVal sender As Object, ByVal e As FormClosingEventArgs) EnableWindow(mOwnerHandle, True) End Sub Private Sub dlgClose() mProgress.Close() mProgress = Nothing End Sub '--- P/Invoke Public Shared Function SetWindowLong(ByVal hWnd As IntPtr, ByVal nIndex As Integer, ByVal dwNewLong As IntPtr) As IntPtr If IntPtr.Size = 4 Then Return SetWindowLongPtr32(hWnd, nIndex, dwNewLong) Else Return SetWindowLongPtr64(hWnd, nIndex, dwNewLong) End If End Function Private Declare Function EnableWindow Lib "user32.dll" (ByVal hWnd As IntPtr, ByVal enabled As Boolean) As Boolean Private Declare Function SetWindowLongPtr32 Lib "user32.dll" Alias "SetWindowLongW" (ByVal hWnd As IntPtr, ByVal nIndex As Integer, ByVal dwNewLong As IntPtr) As IntPtr Private Declare Function SetWindowLongPtr64 Lib "user32.dll" Alias "SetWindowLongW" (ByVal hWnd As IntPtr, ByVal nIndex As Integer, ByVal dwNewLong As IntPtr) As IntPtr End Class Sample usage: Private Sub Button1_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles Button1.Click Using dlg As New ShowProgress(Me) For ix As Integer = 1 To 100 dlg.UpdateProgress(ix) System.Threading.Thread.Sleep(50) Next End Using End Sub
