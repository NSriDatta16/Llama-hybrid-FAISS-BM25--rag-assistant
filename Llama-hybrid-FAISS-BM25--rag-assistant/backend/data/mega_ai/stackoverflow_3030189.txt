[site]: stackoverflow
[post_id]: 3030189
[parent_id]: 3030033
[tags]: 
First off, Georg's version with the map is more elegant and extensible than a long cascade of comparisons. However, if you are concerned with performance and your cascade being 'slow', then measure how fast it is. For the example strings you give, I constructed three variations of a function which incremented a value in an array based on the string passed to it. The first was based on your code, the second on Georg's, and the third on the code below, which is the same as yours but with constant strings rather than having to construct the strings from literals each time it's called. void foo (const std::string& str, int (&count)[6]) { static const std::string s0 = "something"; static const std::string s1 = "something else"; static const std::string s2 = "something more"; static const std::string s3 = "something again"; static const std::string s4 = "something different"; static const std::string s5 = "something really different"; if(str == s0) { ++count[0]; }else if(str == s1) { ++count[1]; }else if(str == s2) { ++count[2]; }else if(str == s3) { ++count[3]; }else if(str == s4) { ++count[4]; }else if(str == s5) { ++count[5]; } } Using VS 2008 Express on the default release settings, these come out as: operator== with constant strings (the code above) time 7.015 seconds 0.116917 microseconds per call std::map lookup (Georg's code) time 9.687 seconds 0.16145 microseconds per call operator== with literal strings (original code) time 10.437 seconds 0.17395 microseconds per call So unless you're calling the code a lot, then you are not going to notice 174 nanoseconds for your original version. Assuming the map and the if-cascade behave as expected (O(N) and O(log 2 N)), then the map should be faster at around 13 strings. But if it matters that much to you, then profile or benchmark it.
