[site]: stackoverflow
[post_id]: 4257675
[parent_id]: 4256961
[tags]: 
I don't think you're breaking RAII (Resource Acquisition Is Initialization) at all, as long as your Cell destructor actually deletes the QAbstractGraphicsItem object (its destructor is virtual, right?) if one is there. However, you appear to be concerned about the potential coupling between your graphics items and cells in this architecture. Yes, it's attractive to completely separate the object store from its presentation. The perfect tool for this (as pointed out by Ben Voigt) is something that lets you extend your class definition, from outside the class, with an extra data element. But C++ doesn't support this. Your suggestion to keep another matrix for the visualization pointers is the best I can think of, but then you have to maintain this second data structure. If you don't want to do this, you're going to need to sacrifice this perfect separation for practical simplicity. Assuming you only have one visualization active at any time, I don't see a problem with keeping a single pointer in your Cells for use by the visualization system. Your code is fine as-is. Yes, you are tying together the data storage and presentation, but it's a pretty loose link. Your cells still don't depend on anything relating to presentation, other than recognizing that the layer exists and might want to store some (opaque) Cell-specific data. To address other suggestions, the visitor pattern is useful for designing the visualizers, but that's an orthogonal design point. What if those visitors need to store extra data per-cell? That's the real question. As for simulating a property extensions with a map, it's complicated, and it's also not necessary unless you have multiple visualizations operating concurrently on a single matrix.
