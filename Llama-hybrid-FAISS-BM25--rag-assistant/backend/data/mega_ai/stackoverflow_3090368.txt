[site]: stackoverflow
[post_id]: 3090368
[parent_id]: 2814565
[tags]: 
To meet your requirement "to expand/collapse records that span multiple lines" , I'd simply use a drawgrid. To check it out, drag a drawgrid onto a form, then plug in the following Delphi 6 code. You can collapse and expand 5,000,000 multiline records (or whatever quantity you want) with essentially no overhead. It's a simple technique, doesn't require much code, and works surprisingly well. unit Unit1; interface uses Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms, Dialogs, Grids, StdCtrls; type TForm1 = class(TForm) DrawGrid1: TDrawGrid; procedure DrawGrid1DrawCell(Sender: TObject; ACol, ARow: Integer; Rect: TRect; State: TGridDrawState); procedure DrawGrid1SelectCell(Sender: TObject; ACol, ARow: Integer; var CanSelect: Boolean); procedure DrawGrid1TopLeftChanged(Sender: TObject); procedure DrawGrid1DblClick(Sender: TObject); procedure FormCreate(Sender: TObject); private procedure AdjustGrid; end; var Form1: TForm1; implementation {$R *.dfm} // Display a large number of multi-line records that can be expanded or collapsed, using minimal overhead. // LinesInThisRecord() and RecordContents() are faked; change them to return actual data. const TOTALRECORDS = 5000000; // arbitrary; a production implementation would probably determine this at run time // keep track of whether each record is expanded or collapsed var isExpanded: packed array[1..TOTALRECORDS] of boolean; // initially all FALSE function LinesInThisRecord(const RecNum: integer): integer; begin // how many lines (rows) does the record need to display when expanded? result := (RecNum mod 10) + 1; // make something up, so we don't have to use real data just for this demo end; function LinesDisplayedForRecord(const RecNum: integer): integer; begin // how many lines (rows) of info are we currently displaying for the given record? if isExpanded[RecNum] then result := LinesInThisRecord(RecNum) // all lines show when expanded else result := 1; // show only 1 row when collapsed end; procedure GridRowToRecordAndLine(const RowNum: integer; var RecNum, LineNum: integer); var LinesAbove: integer; begin // for a given row number in the drawgrid, return the record and line numbers that appear in that row RecNum := Form1.DrawGrid1.TopRow; // for simplicity, TopRow always displays the record with that same number if RecNum > TOTALRECORDS then RecNum := 0; // avoid overflow LinesAbove := 0; while (RecNum > 0) and ((LinesDisplayedForRecord(RecNum) + LinesAbove) TOTALRECORDS then RecNum := 0; // avoid overflow end; LineNum := RowNum - Form1.DrawGrid1.TopRow + 1 - LinesAbove; end; function RecordContents(const RowNum: integer): string; var RecNum, LineNum: integer; begin // display the data that goes in the grid row. for now, fake it GridRowToRecordAndLine(RowNum, RecNum, LineNum); // convert row number to record and line numbers if RecNum = 0 then result := '' // out of range else begin result := 'Record ' + IntToStr(RecNum); if isExpanded[RecNum] then // show line counts too result := result + ' line ' + IntToStr(LineNum) + ' of ' + IntToStr(LinesInThisRecord(RecNum)); end; end; procedure TForm1.AdjustGrid; begin // don't allow scrolling past last record if DrawGrid1.TopRow > TOTALRECORDS then DrawGrid1.TopRow := TOTALRECORDS; if RecordContents(DrawGrid1.Selection.Top) = '' then // move selection back on to a valid cell DrawGrid1.Selection := TGridRect(Rect(0, TOTALRECORDS, 0, TOTALRECORDS)); DrawGrid1.Refresh; end; procedure TForm1.DrawGrid1DrawCell(Sender: TObject; ACol, ARow: Integer; Rect: TRect; State: TGridDrawState); var s: string; begin // time to draw one of the grid cells if ARow = 0 then s := 'Data' // we're in the top row, get the heading for the column else s := RecordContents(ARow); // painting a record, get the data for this cell from the appropriate record // draw the data in the cell ExtTextOut(DrawGrid1.Canvas.Handle, Rect.Left, Rect.Top, ETO_CLIPPED or ETO_OPAQUE, @Rect, pchar(s), length(s), nil); end; procedure TForm1.DrawGrid1SelectCell(Sender: TObject; ACol, ARow: Integer; var CanSelect: Boolean); var RecNum, ignore: integer; begin GridRowToRecordAndLine(ARow, RecNum, ignore); // convert selected row number to record number CanSelect := RecNum <> 0; // don't select unoccupied rows end; procedure TForm1.DrawGrid1TopLeftChanged(Sender: TObject); begin AdjustGrid; // keep last page looking good end; procedure TForm1.DrawGrid1DblClick(Sender: TObject); var RecNum, ignore, delta: integer; begin // expand or collapse the currently selected record GridRowToRecordAndLine(DrawGrid1.Selection.Top, RecNum, ignore); // convert selected row number to record number isExpanded[RecNum] := not isExpanded[RecNum]; // mark record as expanded or collapsed; subsequent records might change their position in the grid delta := LinesInThisRecord(RecNum) - 1; // amount we grew or shrank (-1 since record already occupied 1 line) if isExpanded[RecNum] then // just grew else delta := -delta; // just shrank DrawGrid1.RowCount := DrawGrid1.RowCount + delta; // keep rowcount in sync AdjustGrid; // keep last page looking good end; procedure TForm1.FormCreate(Sender: TObject); begin Caption := FormatFloat('#,##0 records', TOTALRECORDS); DrawGrid1.RowCount := TOTALRECORDS + 1; // +1 for column heading DrawGrid1.ColCount := 1; DrawGrid1.DefaultColWidth := 300; // arbitrary DrawGrid1.DefaultRowHeight := 12; // arbitrary DrawGrid1.Options := DrawGrid1.Options - [goVertLine, goHorzLine, goRangeSelect] + [goDrawFocusSelected, goThumbTracking]; // change some defaults end; end.
