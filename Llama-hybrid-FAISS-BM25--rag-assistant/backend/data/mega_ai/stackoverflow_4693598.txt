[site]: stackoverflow
[post_id]: 4693598
[parent_id]: 4693288
[tags]: 
No, it's not a shortcoming of the PTL. The elephant in the room is those two-minute webservice calls; they shouldn't take that long. All the PTL can do is call code. If that code blocks, it has no way of signalling it to stop, so has to wait or abort the thread. I suppose it could kill threads and things, but that's dangerous and will cause far more outrage than not being able to, as people will use it incorrectly (remember Thread.IsBackground ?). Idea 1 Personal choice would be to make a webservice call that simply puts a message on a queue (or use an ESB like NServiceBus) and returns immediately. That message would then be processed by one or more instances of a separate service (for scalability purposes). That service can then take as long as it likes to process the message, and you are moving the parallelism from the client to the server - no need to use multiple threads on the client means a simpler client. You can then request the state later on either by polling or sending messages back etc. In the meantime, you may chose to mark some sort of local state as "pending" or something to give feedback to the user. Idea 2 If the webservice call is out of your control and takes 2 mins, then you're in trouble. You could write your own threading code and handle killing threads when the app closes, but that's a bad idea. You could have a local Windows service as part of your client application that is running all the time, processing messages from MSMQ queues on the local machine. Then you can have that service app call the long-running webservice methods, and still have a client app that closes quickly and is responsive? Idea 3 Have a proxy webservice that you do control (i.e. write yourself) that basically does what I said in idea 1 above, but where the act of "processing the message" is actually calling the long-running webservice.
