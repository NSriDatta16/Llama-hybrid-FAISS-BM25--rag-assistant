[site]: stackoverflow
[post_id]: 990332
[parent_id]: 990269
[tags]: 
A circular buffer is the best answer. It is the easiest way to model a hardware FIFO in pure software. The real issue is likely to be either the way you are collecting bytes from the UART to put in the buffer, or overflow of that buffer. At 115200 baud with the usual 1 start bit, 1 stop bit and 8 data bits, you can see as many as 11520 bytes per second arrive at that port. That gives you an average of just about 86.8 Âµs per byte to work with. In a PC, that will seem like a lot of time, but in a small microprocessor, it might not be all that many total instructions or in some cases very many I/O register accesses. If you overfill your buffer because bytes are arriving on average faster than you can consume them, then you will have errors. Some general advice: Don't do polled I/O. Do use a Rx Ready interrupt. Enable the receive FIFO, if available. Empty the FIFO completely in the interrupt handler. Make the ring buffer large enough. Consider flow control. Sizing your ring buffer large enough to hold a complete message is important. If your protocol has known limits on the message size, then you can use the higher levels of your protocol to do flow control and survive without the pains of getting XON/XOFF flow to work right in all of the edge cases, or RTS/CTS to work as expected in both ends of the wire which can be nearly as hairy. If you can't make the ring buffer that large, then you will need some kind of flow control.
