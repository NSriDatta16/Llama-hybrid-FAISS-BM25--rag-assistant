[site]: stackoverflow
[post_id]: 5082991
[parent_id]: 
[tags]: 
Influencing foreign key column naming in EF code first (CTP5)

I have a POCO class that has two one-way unary relationships with another class, both classes share an ancestor. The names of the foreign keys in the generated schema do not reflect the property names. (Properties MainContact and FinancialContact give PersonId and PersonId1 field names). How can I influence schema generation to generate database column names that match the property names? The model looks like this: The code looks like this: public class CustomerContext: DbContext { public DbSet Organisations { get; set; } public DbSet Persons { get; set; } protected override void OnModelCreating(ModelBuilder builder) { DbDatabase.SetInitializer(new DropCreateDatabaseAlways ()); } } public abstract class Customer { public int Id { get; set; } public string Name { get; set; } } public class Person : Customer { public string Email { get; set; } } public class Organisation : Customer { public Person FinancialContact { get; set; } public Person MainContact { get; set; } } The schema looks like this: Answer from druttka druttka's answer below did the job and it's nice to know that it's a CTP5 bug that's behind this. EF also needs the cascade behaviour to be specified and I've used the fluent API to do this following the example in the link given by druttka. Some more good reading from Morteza Manavi here . The code now is this: public class CustomerContext : DbContext { public DbSet Organisations { get; set; } public DbSet Persons { get; set; } protected override void OnModelCreating(ModelBuilder builder) { DbDatabase.SetInitializer(new DropCreateDatabaseAlways ()); builder.Entity () .HasRequired(p => p.MainContact) .WithMany() .HasForeignKey(p => p.MainContactId) .WillCascadeOnDelete(false); builder.Entity () .Property(p => p.MainContactId) .HasColumnName("MainContact"); builder.Entity () .HasRequired(p => p.FinancialContact) .WithMany() .HasForeignKey(p => p.FinancialContactId) .WillCascadeOnDelete(false); builder.Entity () .Property(p => p.FinancialContactId) .HasColumnName("FinancialContact"); } } public abstract class Customer { public int Id { get; set; } public string Name { get; set; } } public class Person : Customer { public string Email { get; set; } } public class Organisation : Customer { public Person FinancialContact { get; set; } public int FinancialContactId { get; set; } public Person MainContact { get; set; } public int MainContactId { get; set; } } Which now gives the far more suitable database:
