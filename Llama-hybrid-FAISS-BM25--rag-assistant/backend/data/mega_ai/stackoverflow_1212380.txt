[site]: stackoverflow
[post_id]: 1212380
[parent_id]: 1212308
[tags]: 
It's funny, but almost every problem people have with databases is speed, not storage requirements. That should tell you something :-) We've had problems like this before and I've said this many times: per-row functions generally do not scale well. The best method we've found to fix them is with insert/update triggers (I'm assuming MySQL has these). Create another column call pretty_city_state (or whatever) and have the triggers populate it from city and state whenever you insert or update a row. Then create an index on it. This takes advantage of the fact that database rows are generally read far more often than they're written (especially in this case). By evaluating that column on write, you bear the cost across the writes (thousands) rather than the reads (millions probably). And it's the writing when it should be borne simply because pretty_city_state will only change when either city or state changes. If you do the concat on every select, you're wasting effort. Try that and measure the difference - I'm sure you'll find that your selects will scream along at a minimal cost for the triggers (and that cost disappears totally once you have all cities and states within your database. And yes, I know this breaks 3NF. It's perfectly acceptable to do so for performance reasons if you know what you're doing . Your query could be done as: SELECT pretty_city_state as location, AVG(latitude), AVG(longitude) FROM places WHERE city='New York' AND state='NY' GROUP BY pretty_city_state or, maybe even faster (measure, don't guess) if you can concatenate the city and state before starting the query: SELECT pretty_city_state as location, AVG(latitude), AVG(longitude) FROM places WHERE pretty_city_state ='New York, NY' GROUP BY pretty_city_state
