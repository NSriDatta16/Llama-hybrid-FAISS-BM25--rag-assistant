[site]: stackoverflow
[post_id]: 3042640
[parent_id]: 3038136
[tags]: 
This question may contradict the above, but should my salt ever be a randomly generated value? If so, when may it be useful? Salts should be random. Their sole use is to make brute-force attacks on hashes much more expensive. Something called a "rainbow table" (which is a fancy name for a database where someone hashed a whole bunch of possible passwords in advance, and lets you look up passwords if you know the hash) makes it possible to take unsalted password hashes and turn them into passwords in a fraction of a second in many cases. A moderately sized salt can increase the complexity of a precomputed brute-force attack exponentially. For every single bit of random data in your salt, you double the time required for a precomputed brute force attack. For every unique salt value in your database, the attacker has to start over when attacking the password protected by that salt. If you had 1kB of random salt for every user's password, precomputed hashes would be out the window. You wouldn't affect the amount of time it would take to brute-force a single user's password though. One way you can make the brute-force attacker's life harder is by making the hashing process computationally intensive (e.g. 5000 rounds of sha1(salt+sha1(salt+sha1(salt+password)))). You only have to do that for every login attempt. The attacker has to do it for every salt + password combination they want to guess. You have to decide if this is something that is worthwhile for your needs. The answer is probably no. Edit: Other than passwords, in a user system, what else should be encrypted as a good practice? Do they encrypt usernames or anything else? I'm paranoid, but I would say any information that you the site owner doesn't need while the user isn't logged in should be encrypted with a derivative of the user's password. That way attackers don't have access because you don't have access. For an online order processing system, for example, you might need their mailing address, their name and most recent order unencrypted, but their order history and favorite color might be encrypted with their account password. Note that if you do this, and they lose their password, the protected information is lost also. 2nd Edit: What is a one-way hash? I mean, technically, can I not reverse engineer my source code? Maybe this is a bad question because I do not know much about one-way hashing. A hash is a method for systematically throwing away information. Say you start with a string, and produce "srflcdos" by throwing away all but about every fourth character. The text I "hashed" could be: "spear if fish lies calmly. don't sit!", or it could be: "supercalifragilisticexpialidotious". There is no way to prove either way. Cryptographic hashes do a lot more mixing and other transformations along with the throwing away, to make them more secure for small amounts of input data, and to avoid leaking any facts at all about the input data. As an example of an insecure hash, if you know that whenever the input contains the letter A, the 12 bit of the hash is 1, then you are exposing information about the original text, and the result is not a cryptographically secure hash. The principle is that you can't reverse engineer a process if between each transformation you throw away information vital to reversing the previous transformation. An MD5sum produces 128 bits of output, regardless of whether you put in 1 bit or 12 petabytes of information. You obviously can't compress 12 petabytes into 128 bits, so information is clearly being thrown away in the process of computing the hash.
