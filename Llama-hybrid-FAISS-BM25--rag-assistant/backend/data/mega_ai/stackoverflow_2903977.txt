[site]: stackoverflow
[post_id]: 2903977
[parent_id]: 2903708
[tags]: 
Here is what I would do. Note that it's not exactly what you're looking for and, well, abstract situation modelling is always tough :) But I hope this code would make you understand what you have to do. Also, I am not exactly sure about using pointers to class fields, because this tends to be a situation where pointer usage is superflous. #include #include #include #include // Some abstract type used to measure prices typedef size_t money_t; struct Item { // Item's name and price std::string name; money_t price; // Could also have something that makes // it an item, but this is not necessary // This could be anything, because we're actually // modelling an abstract situation // (...) // Note that we don't allow unnamed items Item(const std::string& name, const money_t& price = 0) : name(name), price(price) { } // Note here that items are treated as 'same' only by names // This means we're actually talking about 'logical groups' of items bool operator==(const Item& item) const { return name == item.name; } bool operator==(const std::string& item_name) const { return name == item_name; } }; class Store { private: // Store's item storage // Note that items actually represent infinite groups // of items (in our case store is an abstract store // which items simply can't end) std::vector items; public: // Initialize a store that doesn't sell anything Store() { } // Initialize a store that could sell specified types of items Store(const std::vector & items) : items(items) { } // Show what we actually sell in this store void EnumerateItems() const { for (size_t i = 0; i ::const_iterator what = std::find(items.begin(), items.end(), name); // If nothing found, throw an exception if (what == items.end()) { throw std::domain_error("Store doesn't sell this type of item"); } // Return item as a sold one return (*what); } }; class Person { private: // Person's name (identity) std::string name; // Item's that are currently possesed // by this person std::vector owned_items; // Amount of cash that this person has money_t cash; public: // Note that we don't allow unnamed persons Person(const std::string& name, const money_t& cash = 0) : name(name), cash(cash) { } void Buy(const Item& what) { owned_items.push_back(what); cash -= what.price; } }; void GoShopping(Person& person, const Store& store) { // Let's simulate buying one item // You could easily make a loop and determine what to buy in // every loop iteration store.EnumerateItems(); person.Buy(store.Sell("Shoes")); } int main() { // Initialize our store that sells only shoes std::vector items; items.push_back(Item("Shoes", 25)); Store grocery(items); // Initialize our person Person jim_carrey("Jim Carrey", 500); // The yummy part GoShopping(jim_carrey, grocery); return 0; }
