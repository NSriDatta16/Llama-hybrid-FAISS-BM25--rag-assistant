[site]: stackoverflow
[post_id]: 4094627
[parent_id]: 4088776
[tags]: 
Here are some real data about speed, according to diverse client/server investigation. All benchmarks were run locally on one computer. You can achieve more than 15000 queries per second on direct access, 4300 queries per second on HTTP/1.1 remote access. This was benchmarked on a Notebook using a Centrino2 CPU, with AntiVirus ON. 2.5. Client server access: - Http client keep alive: 3001 assertions passed first in 7.87ms, done in 153.37ms i.e. 6520/s, average 153us - Http client multi connect: 3001 assertions passed first in 151us, done in 305.98ms i.e. 3268/s, average 305us - Named pipe access: 3003 assertions passed first in 78.67ms, done in 187.15ms i.e. 5343/s, average 187us - Local window messages: 3002 assertions passed first in 148us, done in 112.90ms i.e. 8857/s, average 112us - Direct in process access: 3001 assertions passed first in 44us, done in 41.69ms i.e. 23981/s, average 41us Total failed: 0 / 15014 - Client server access PASSED This benchmark tests both client and server speed, and is not multithreaded (even if our framework is multi-thread safe). So you can guess that, for a 4 KB data block of JSON content for each request: The direct access (like your dll approach) is the fastest, and less resource consuming. Then GDI messages. Then named pipes. Then FastCGI and HTTP (depending on your web server for FastCGI, the HTTP classes are very low consuming). Keep alive connections are HTTP/1.1 connections, and multi connect is plain HTTP/1.0, with a new connection for every request. Multi-connect is not so bad, because from the server point of view, we used an efficient Thread Pool based on I/O completion ports. See http://synopse.info/forum/viewtopic.php?id=90
