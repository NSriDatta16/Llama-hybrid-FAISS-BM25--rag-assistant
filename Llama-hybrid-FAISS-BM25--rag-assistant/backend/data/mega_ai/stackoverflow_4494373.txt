[site]: stackoverflow
[post_id]: 4494373
[parent_id]: 4494347
[tags]: 
Yes. It is undefined behavior. No, the type of T doesn't matter. The accepted answer in the linked duplicate is in error by its very own selection of standard citations. Unfortunately he muddles logic at the end to come up with exactly the opposite conclusion. The note in 3.9.2/3 is contained within a paragraph that is quite clearly talking about the type , not the ability to dereference. The type of the pointer (array+size) is the same "as-if" there was a valid object of type T there; this does not mean that there IS a valid object there and in fact there isn't. There is a citation in the duplicate of the C99 standard that clearly states that &array[index] will not result in a pointer dereference that is normally implied by array[index]. C99 is not C++ though and I've not seen any equivalent text that says the same thing. It is only by that rule that it is legal in C. C++0x will contain some of C99, I don't know if this bit is included. You should not consider them the same language. Most C++ compilers will happily eat it up but you could always run into a compliant compiler that does not.
