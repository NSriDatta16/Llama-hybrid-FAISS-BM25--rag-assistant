[site]: stackoverflow
[post_id]: 3678779
[parent_id]: 3678353
[tags]: 
Yes. I. This XSLT 1.0 transformation : when applied on this XML document : 1 2 3 4 5 produces : 3 5 7 9 11 Do note : Two transformations are actually performed , the second is performed on the result of the first. The result of the first transformation is the content of the variable $vrtfPass1 . In XSLT 1.0 the type of variables that contain dynamically generated (temporary) XML trees (XML document or XML fragment) is RTF (Result-Tree-Fragment). No XPath operations are possible on an RTF -- it needs to be converted to a regular node-set using the extension function xxx:node-set() , which is provided by the vast majority of XSLT 1.0 processor vendors. In this example exslt:node-set() is used, because EXSLT is implemented by many different vendors. The second transformation is applied on the result of the first : . A separate mode is used in order to cleanly separate the code of the two transformations. The first transformation multiplies each num/text() by 2. The second transformation increments each num/text() . The result is 2*.+1 II. This XSLT 2.0 transformation : when applied on the same XML document, produces the same wanted and correct result . Do note : In XSLT 2.0/XPath 2.0 the RTF type has been abolished. No xxx:node-set() extension function is needed.
