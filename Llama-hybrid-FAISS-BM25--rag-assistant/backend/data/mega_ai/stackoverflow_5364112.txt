[site]: stackoverflow
[post_id]: 5364112
[parent_id]: 5363094
[tags]: 
Via self.timescore , inctime: is called 10 times a second. Each time, it increments the time variable by 0.1 of a second. So the time variable is the time in seconds since the timer began, rounded to the nearest 0.1 of a second. E.g. you'd get the same if you did: ... elsewhere ... @property (nonatomic, assign) NSTimeInterval startTime; - (void)initializeTime { self.startTime = [NSDate timeIntervalSinceReferenceDate]; } - (void)move:(NSTimer *)theTimer { NSTimeInterval timeSinceInitializeTimeWasCalled = [NSDate timeIntervalSinceReferenceData] - self.startTime; // round down the nearest multiple of 0.1 if necessary, e.g. timeSinceInitializeTimeWasCalled -= fmod(timeSinceInitializeTimeWasCalled, 0.1); } This line: CGFloat moduloResult = (float)((int)time % (int)5); Is called in a method that you state is called 30 times a second. Given that it's positive, the (int)time will round 'time' down to the nearest whole number. So moduloResult will be '0' 30 times â€” in the period between entering the fifth second and exiting it again. What you probably want, as hinted at in the code I posted immediately above, is: CGFloat moduloResult = fmod(time, 5.0); And even then you don't want to compare the result directly to 0 because floating point numbers tend to round in ways so as to be non-exact. If you're calling that method 30 times a second, I instead recommend: CGFloat moduloResult = fmod(time + 1.0 / 60, 5.0); if(moduloResult So you're checking whether time is within the 1/30th of a second surrounding when time mod 5 is zero.
