[site]: stackoverflow
[post_id]: 186703
[parent_id]: 186649
[tags]: 
Polymorphism: When ever you have a select statement using the type of an object, it is a prime candidate for refactoring to polymorphism. Check out the book Refactoring by Martin Fowler: "One of the most obvious symptoms of object-oriented code is its comparative lack of switch (or case) statements. The problem with switch statements is essentially that of duplication. Often you find the same switch statement scattered about a program in different places. If you add a new clause to the switch, you have to find all these switch, statements and change them. The objectoriented notion of polymorphism gives you an elegant way to deal with this problem. Most times you see a switch statement you should consider polymorphism. The issue is where the polymorphism should occur. Often the switch statement switches on a type code. You want the method or class that hosts the type code value. So use Extract Method to extract the switch statement and then Move Method to get it onto the class where the polymorphism is needed. At that point you have to decide whether to Replace Type Code with Subclasses or Replace Type Code with State/Strategy. When you have set up the inheritance structure, you can use Replace Conditional with Polymorphism." Here is one approach to using polymorphism in your situation: Define an abstract method in AbstractNode named something like Display(). Then actually implement Display() in each of the SiteNode and SiteSubNode classes. Then, when you need to display these nodes, you could simply iterate through a collection containing items of type AbstractNode and call Display() for each. The call to Display() will automatically resolve to the actual concrete implementation for the real type of that item. Note: You could also move the Display() method from AbstractNode to the INode interface if VirtualNode is to be displayed.
