[site]: stackoverflow
[post_id]: 3214201
[parent_id]: 3213490
[tags]: 
(Edit: leaving the body for posterity, but jump to the end for the real solution) In the declaration instance MyClass a => Show a , let's examine the error "Constraint is no smaller than the instance head." The constraint is the type class constraint to the left of '=>', in this case MyClass a . The "instance head" is everything after the class you're writing an instance for, in this case a (to the right of Show ). One of the type inference rules in GHC requires that the constraint have fewer constructors and variables than the head. This is part of what are called the ' Paterson Conditions '. These exist as a guarantee that type checking terminates. In this case, the constraint is exactly the same as the head, i.e. a , so it fails this test. You can remove the Paterson condition checks by enabling UndecidableInstances , most likely with the {-# LANGUAGE UndecidableInstances #-} pragma. In this case, you're essentially using your class MyClass as a typeclass synonym for the Show class. Creating class synonyms like this is one of the canonical uses for the UndecidableInstances extension, so you can safely use it here. 'Undecidable' means that GHC can't prove typechecking will terminate. Although it sounds dangerous, the worst that can happen from enabling UndecidableInstances is that the compiler will loop, eventually terminating after exhausting the stack. If it compiles, then obviously typechecking terminated, so there are no problems. The dangerous extension is IncoherentInstances, which is as bad as it sounds. Edit: another problem made possible by this approach arises from this situation: instance MyClass a => Show a where data MyFoo = MyFoo ... deriving (Show) instance MyClass MyFoo where Now there are two instances of Show for MyFoo , the one from the deriving clause and the one for MyClass instances. The compiler can't decide which to use, so it will bail out with an error message. If you're trying to make MyClass instances of types you don't control that already have Show instances, you'll have to use newtypes to hide the already-existing Show instances. Even types without MyClass instances will still conflict because the definition instance MyClass => Show a because the definition actually provides an implementation for all possible a (the context check comes in later; its not involved with instance selection) So that's the error message and how UndecidableInstances makes it go away. Unfortunately it's a lot of trouble to use in actual code, for reasons Edward Kmett explains. The original impetus was to avoid specifying a Show constraint when there's already a MyClass constraint. Given that, what I would do is just use myShow from MyClass instead of show . You won't need the Show constraint at all.
