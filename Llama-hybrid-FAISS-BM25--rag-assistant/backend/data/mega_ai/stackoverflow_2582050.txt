[site]: stackoverflow
[post_id]: 2582050
[parent_id]: 2582005
[tags]: 
There's no documented method of checking for this kind of condition at runtime, and if there were, I'd be suspicious of any code that used it, because any code that alters its behaviour based on the call stack would be very difficult to debug. True ACID semantics are not trivial to implement, and I personally wouldn't try; that's what we have databases for, and you can use an in-memory database if you need the code to be fast/portable. If you just want forced-single-threaded semantics, that is a somewhat easier beast to tame, although as a disclaimer I should mention that in the long run you'd be better off simply providing atomic operations as opposed to trying to prevent multi-threaded access. Let's suppose that you have a very good reason for wanting to do this. Here is a proof-of-concept class you could use: public interface ILock : IDisposable { } public class ThreadGuard { private static readonly object SlotMarker = new Object(); [ThreadStatic] private static Dictionary locks; private Guid lockID; private object sync = new Object(); public void BeginGuardedOperation() { lock (sync) { if (lockID == Guid.Empty) throw new InvalidOperationException("Guarded operation " + "was blocked because no lock has been obtained."); object currentLock; Locks.TryGetValue(lockID, out currentLock); if (currentLock != SlotMarker) { throw new InvalidOperationException("Guarded operation " + "was blocked because the lock was obtained on a " + "different thread from the calling thread."); } } } public ILock GetLock() { lock (sync) { if (lockID != Guid.Empty) throw new InvalidOperationException("This instance is " + "already locked."); lockID = Guid.NewGuid(); Locks.Add(lockID, SlotMarker); return new ThreadGuardLock(this); } } private void ReleaseLock() { lock (sync) { if (lockID == Guid.Empty) throw new InvalidOperationException("This instance cannot " + "be unlocked because no lock currently exists."); object currentLock; Locks.TryGetValue(lockID, out currentLock); if (currentLock == SlotMarker) { Locks.Remove(lockID); lockID = Guid.Empty; } else throw new InvalidOperationException("Unlock must be invoked " + "from same thread that invoked Lock."); } } public bool IsLocked { get { lock (sync) { return (lockID != Guid.Empty); } } } protected static Dictionary Locks { get { if (locks == null) locks = new Dictionary (); return locks; } } #region Lock Implementation class ThreadGuardLock : ILock { private ThreadGuard guard; public ThreadGuardLock(ThreadGuard guard) { this.guard = guard; } public void Dispose() { guard.ReleaseLock(); } } #endregion } There's a lot going on here but I'll break it down for you: Current locks (per thread) are held in a [ThreadStatic] field which provides type-safe, thread-local storage. The field is shared across instances of the ThreadGuard , but each instance uses its own key (Guid). The two main operations are GetLock , which verifies that no lock has already been taken and then adds its own lock, and ReleaseLock , which verifies that the lock exists for the current thread (because remember, locks is ThreadStatic ) and removes it if that condition is met, otherwise throws an exception. The last operation, BeginGuardedOperation , is intended to be used by classes that own ThreadGuard instances. It's basically an assertion of sorts, it verifies that the currently-executed thread owns whichever lock is assigned to this ThreadGuard , and throws if the condition isn't met. There's also an ILock interface (which doesn't do anything except derive from IDisposable ), and a disposable inner ThreadGuardLock to implement it, which holds a reference to the ThreadGuard that created it and calls its ReleaseLock method when disposed. Note that ReleaseLock is private, so the ThreadGuardLock.Dispose is the only public access to the release function, which is good - we only want a single point of entry for acquisition and release. To use the ThreadGuard , you would include it in another class: public class MyGuardedClass { private int id; private string name; private ThreadGuard guard = new ThreadGuard(); public MyGuardedClass() { } public ILock Lock() { return guard.GetLock(); } public override string ToString() { return string.Format("[ID: {0}, Name: {1}]", id, name); } public int ID { get { return id; } set { guard.BeginGuardedOperation(); id = value; } } public string Name { get { return name; } set { guard.BeginGuardedOperation(); name = value; } } } All this does is use the BeginGuardedOperation method as an assertion, as described earlier. Note that I'm not attempting to protect read-write conflicts, only multiple-write conflicts. If you want reader-writer synchronization then you'd need to either require the same lock for reading (probably not so good), use an additional lock in MyGuardedClass (the most straightforward solution) or alter the ThreadGuard to expose and acquire a true "lock" using the Monitor class (be careful). And here's a test program to play with: class Program { static void Main(string[] args) { MyGuardedClass c = new MyGuardedClass(); RunTest(c, TestNoLock); RunTest(c, TestWithLock); RunTest(c, TestWithDisposedLock); RunTest(c, TestWithCrossThreading); Console.ReadLine(); } static void RunTest(MyGuardedClass c, Action testAction) { try { testAction(c); Console.WriteLine("SUCCESS: Result = {0}", c); } catch (Exception ex) { Console.WriteLine("FAIL: {0}", ex.Message); } } static void TestNoLock(MyGuardedClass c) { c.ID = 1; c.Name = "Test1"; } static void TestWithLock(MyGuardedClass c) { using (c.Lock()) { c.ID = 2; c.Name = "Test2"; } } static void TestWithDisposedLock(MyGuardedClass c) { using (c.Lock()) { c.ID = 3; } c.Name = "Test3"; } static void TestWithCrossThreading(MyGuardedClass c) { using (c.Lock()) { c.ID = 4; c.Name = "Test4"; ThreadPool.QueueUserWorkItem(s => RunTest(c, cc => cc.ID = 5)); Thread.Sleep(2000); } } } As the code (hopefully) implies, only the TestWithLock method completely succeeds. The TestWithCrossThreading method partially succeeds - the worker thread fails, but the main thread has no trouble (which, again, is the desired behaviour here). This isn't intended to be production-ready code, but it should give you the basic idea of what has to be done in order to both (a) prevent cross-thread calls and (b) allow any thread to take ownership of the object as long as nothing else is using it.
