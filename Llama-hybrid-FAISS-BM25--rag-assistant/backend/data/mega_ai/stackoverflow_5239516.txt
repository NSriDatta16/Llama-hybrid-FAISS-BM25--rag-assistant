[site]: stackoverflow
[post_id]: 5239516
[parent_id]: 5239310
[tags]: 
2 things: Performance of reflection has gotten much better in newer runtimes, because it is a major power of .NET languages and because so much attention has been paid to the difference between static and dynamic performance. I assume you're running this in Framework v3.5 or 4.0; If you were to execute this code in the Framework v2.0, it would probably perform more poorly. Most of what you're doing is not very "heavy" use of reflection. Dynamic property invocation is kind of heavy, but most of what you're doing is just getting information. The real heavy-hitters are dynamic method invocation and dynamic instance creation. Say that you ran the following test. Very simple, and the only thing different is static instantiation and invocation vs reflective: public class ReflectionTest { public int Method1(){return 1;} public int Method2() { return 2; } public int Method3() { return 3; } public int Method4() { return 4; } public int Method5() { return 5; } public int Method6() { return 6; } } [Test] public void TestStatic() { for (var i = 1; i If you wanted to make sure the testing was completely fair, you could remove the inner for loop and call GetMethod 6 times with string literals "Method1", "Method2", etc. The reflection test not only invokes methods dynamically, it searches the manifest to find and instantiate a Type object, then it dynamically instantiates the actual object from the Type, on which the methods are dynamically called. I would bet that if you ran both tests, the second one would perform much more poorly. Also, explore passing parameters to these methods; First you have to find the right overload, then the reflective invocation takes an Object[] array, which will box and unbox any value-type parameters of the method(s), further slowing the reflective algorithm down. In short, reflection will perform more poorly than a static algorithm; HOWEVER there have been great strides made to improve its performance, so as of .NET 4.0, an intelligently-written dynamic algorithm is not such a huge loss versus a counterpart static algorithm, making reflection far more viable when needed. EDIT: After running the above 2 tests side by side, there is a big relative difference: static algorithm 0.07s for 100k iterations, reflective a whopping 2.12s. Reflective instantiation/invocation takes 30 times longer than static. However, the difference took 100,000 iterations to be significant; the Debug.WriteLine statements in my original incarnation of this test were, by far, the slowest part of either test.
