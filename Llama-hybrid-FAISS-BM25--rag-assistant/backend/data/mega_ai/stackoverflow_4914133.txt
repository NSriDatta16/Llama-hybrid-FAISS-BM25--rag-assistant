[site]: stackoverflow
[post_id]: 4914133
[parent_id]: 4914060
[tags]: 
A common design method is to create a "Parts" table, ex: CREATE TABLE parts (page_id INTEGER, part_name VARCHAR(255), body TEXT); which will work fine at lower traffic. (page_id in this case is the foreign key to the page which "owns" this part - you'd get all parts for a given page by saying, natch SELECT * FROM parts WHERE page_id = :some_page_id ) As your traffic rises, the cost of pulling in and assembling the pages may become egregious, in which case the splitting apart the body contents from a larger text field (as you suggested) would not be a terrible idea. At this level, the speed gains from doing direct serialization of a hash into the database column and making the app server's CPU bear the brunt of the work (as opposed to the DB server) may be worth it. The column types you'd be interested in are enumerated here under "Storage Requirements for String Types": http://dev.mysql.com/doc/refman/5.0/en/storage-requirements.html Summarized, TEXT (64KB) should be large enough to hold most basic data. MEDIUMTEXT (16 MB) or LONGTEXT (4096 MB) if your data is noticeably large or you foresee it growing. BLOB, MEDIUMBLOB or LONGBLOB (same sizes as the *TEXT types) if you intend to do any PHP variable deserialization from DB columns.
