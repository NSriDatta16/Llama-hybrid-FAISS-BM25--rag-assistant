[site]: stackoverflow
[post_id]: 5309453
[parent_id]: 5308542
[tags]: 
I assume: The array you want to sort is small ( It is a part of some bigger GPU algorithm The array resides in shared memory space, or can be copied there If any of these is not true, don't do bubble sort! the number of threads in the block is half the size of the array. Is this a good implementation? It is reasonable. When a divergent branch occurs in a warp, all threads execute all branches in a perfect sync, simply some threads have their flag "disabled" set. This way, every branch is executed only once . The only exception --- when no thread from a warp is taking a branch --- then the branch is simply skipped. BUG! In your code, however I see a problem. If you want one thread to operate on two elements of the array, make them handle it exclusively, that is: if(a[2*threadIdx.x]>a[2*threadIdx.x + 1]) Swap(a[2*threadIdx.x] , a[2*threadIdx.x + 1]); Otherwise, if Swap is executed by two neighbouring threads, some values may dissapear and some other values may get duplicated in the array. Another bug! If your block is bigger than a warp size, remember to put __syncthreads() when needed. Even if your block is smaller (shouldn't be), you should check the __threadfence_block() to ensure that writes to shared memory are visible by other threads of the same block. Otherwise, the compiler may be too aggressive on optimisations and make your code invalid. Another problem If you fix the first bug, you will have 2-way bank conflict on your shared memory. It is not very important, but you might want to reorganise the data in your array to avoid them, e.g. have the consecutive elements in the following order: [1, 3, 5, 7, 9, ..., 29, 31, 2, 4, 6, 8, ... , 30, 32] This way, elements 1 and 2 belong to the same bank in shared memory.
