[site]: stackoverflow
[post_id]: 2894102
[parent_id]: 2894083
[tags]: 
If You define an array like double myArr[5][2]; All cells occupy a continuous chunk of memory and I'm pretty sure dataset->AddSerie relies on that. You can't guarantee that if you allocate memory in chunks, using consecutive calls to new. My proposition is to write a simple class that allocates a continuous chunk of memory for storage and uses operator() to access that memory as a two dimensional array using 2 indices. Internally You can use a vector to manage the storage, and You can pass the address of the first element of that vector to dataset->AddSerie Please check the code in this C++ FAQ example and try to understand it. The matrix example uses new[] and delete[]. You should use a vector instead, and the type double instead of Fred Where in the example, there is a private section like this class Matrix { public: ... private: unsigned nrows_, ncols_; Fred* data_; }; (The example shows a matrix of Freds ) You should use a vector class Matrix { public: ... private: unsigned nrows_, ncols_; vector data_; }; That will make the code much simpler. You don't even need a destructor, because the vector manages the memory.
