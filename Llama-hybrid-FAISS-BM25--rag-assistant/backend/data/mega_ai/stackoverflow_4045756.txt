[site]: stackoverflow
[post_id]: 4045756
[parent_id]: 4044400
[tags]: 
Simply understanding what LINQ is doing internally should yield enough information to know whether you are taking a performance hit. Here is a simple example where LINQ helps performance. Consider this typical old-school approach: List foos = GetSomeFoos(); List filteredFoos = new List (); foreach(Foo foo in foos) { if(foo.SomeProperty == "somevalue") { filteredFoos.Add(foo); } } myRepeater.DataSource = filteredFoos; myRepeater.DataBind(); So the above code will iterate twice and allocate a second container to hold the filtered values. What a waste! Compare with: var foos = GetSomeFoos(); var filteredFoos = foos.Where(foo => foo.SomeProperty == "somevalue"); myRepeater.DataSource = filteredFoos; myRepeater.DataBind(); This only iterates once (when the repeater is bound); it only ever uses the original container; filteredFoos is just an intermediate enumerator. And if, for some reason, you decide not to bind the repeater later on, nothing is wasted. You don't even iterate or evaluate once. When you get into very complex sequence manipulations, you can potentially gain a lot by leveraging LINQ's inherent use of chaining and lazy evaluation. Again, as with anything, it's just a matter of understanding what it is actually doing.
