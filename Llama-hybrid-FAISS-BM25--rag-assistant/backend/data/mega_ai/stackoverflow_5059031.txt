[site]: stackoverflow
[post_id]: 5059031
[parent_id]: 5049119
[tags]: 
Don't understand what exactly I did wrong for this particular server.. What remains "strange" is that destroying "known_hosts" on the client side did not drive to the expected positive effect. Anyway pls find hereafter what I did manually, quite ugly but works: Note: This assumes full access to both machines (client and server) server side : regenerate the 2 pairs of keys (rsa and dsa) ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_key ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key client side : generate a pair of dsa keys (private and public) for the user "foo" ssh-keygen -t dsa -f /home/foo/.ssh/my_client_key add this new key to the ssh-agent if running ssh-add /home/foo/.ssh/my_client_key add the content of the server ssh_host_rsa_key.pub to the client /home/foo/.ssh/known_hosts, after the IP/port: [server_ip]:server_port copy/paste here the server public rsa key (ctrl+shift+C/V) [server_ip]:server_port copy/paste here the server public dsa key (ctrl+shift+C/V) now back to the server side : copy/paste the client public key /home/foo/.ssh/my_client_key.pub into /home/bar/.ssh/.authorized_keys in order to allow connection to the user "foo" to connect to "bar" account: make sure of the path consistency with /etc/ssh/sshd_config to be able tu use the file .authorized_keys : AuthorizedKeysFile %h/.ssh/.authorized_keys restart the ssh server /etc/init.d/ssh restart client : now the client "foo" can ssh to the user "bar" on the server : foo@client>$ ssh -p PORT bar@server_ip Note: in my case, both client and server are running locally within VM's. Do not use these settings for production obviously. EDIT : Reading a bit more carefully the man ssh pages, it should be possible to get around this in a much proper manner, ref to the man: "The StrictHostKeyChecking option can be used to control logins to machines whose host key is not known or has changed."
