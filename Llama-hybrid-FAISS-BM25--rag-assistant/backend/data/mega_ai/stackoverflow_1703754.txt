[site]: stackoverflow
[post_id]: 1703754
[parent_id]: 1703553
[tags]: 
If we are looking for the shortest path cycle, it seems easy enough. Just do a breadth first search on all nodes searching for the shortest path from a node to itself. if you find no path, you can remove this node it is in no cycle if you find a path, you have found one of your minimal cycles (as we looked for shortest path, we can ensure this cycle can't be the union of two shorter cycles). Collapse all nodes in it in one big new node and adapt edges as necessary. Go on until there is no node any-more. When You you have treated all nodes (vertexes) you have the minimal cycles you where looking for... but there is a trick. If a cycle is expressed using only nodes from the initial set you can keep it "as is". But you have to translate "big nodes" to paths (common edges between cycles) and every big nodes may be replaced by several such path (at least 2 for a big node of level-1, that is that does not contains big nodes itself). The cycles found are constructed in such a way that you can choose any path and still get a minimal cycle set (no cycle can be get doing the union of two others), but there is several possible such sets. You can add a constraint to always take a shortest path when selecting a path in a big node, but there still can be paths of the same length. So the solution of this problem is clearly enough not unique. With this naive approach complexity would be O(V.(E+V)) where V is the number of vertexes and E the number of edges. O(E+V) comes from breadth first and at worst you have to perform a BFS V times. Hence it is definitely polynomial of better. I believe what I described is really O(log(V).(E+V)) in the average case, but I didn't prove it yet (if it's true).
