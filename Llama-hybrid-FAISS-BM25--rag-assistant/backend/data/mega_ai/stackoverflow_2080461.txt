[site]: stackoverflow
[post_id]: 2080461
[parent_id]: 2079450
[tags]: 
There are couple automatic memory management strategies in different platforms and programming languages. Two major approaches are applicable to automatic memory management: reference counting and garbage collection. They are both worth examining, although the second one is by far the more powerful and generally applicable. (Object-Oriented Software Construction by Bertran Meyer, p.301) Reference counting (i.e. shared_ptr ) is one of the simplest way to achieve automatic memory management. It pretty simple but have some significant drawbacks (it can't deal with cyclic structures, and it has performance overhead in both time and space. For every operation on references the implementation will now execute an arithmetic operation â€” and, in the detachment case, a conditional instruction. In addition, every object must be extended with an extra field to hold the count). The idea behind the first automatic memory management technique, reference counting, is simple. In every object, we keep a count of the number of references to the object; when this count becomes null, the object may be recycled. This solution is not hard to implement (at the language implementation level). We must update the reference count of any object in response to all operations that can create the object, attach a new reference to it and detach a reference from it. (Object-Oriented Software Construction by Bertran Meyer, p.301) Garbage collection (witch is used in CLR) is based on two main properties: Soundness : every collected object is unreachable. Completeness : every unreachable object will be collected. Garbage collection basis The basic algorithm usually includes two phases, at least conceptually: mark and sweep. The mark phase, starting from the origins, follows references recursively to traverse the active part of the structure, marking as reachable all the objects it encounters. The sweep phase traverses the whole memory structure, reclaiming unmarked elements and unmarking everything. As with reference counting, objects must include an extra field, used here for the marking; but the space overhead is negligible, since one bit suffices per object. As will be seen when we study dynamic binding, implementation of O-O facilities requires that every object carry some extra internal information (such as its type) in addition to its official fields corresponding to the attributes of the generating class. This information typically occupies one or two words per object; the marking bit can usually be squeezed into one of these extra words, so that in practice there is no observable overhead. P.S. For more information about garbage collection in CLR see Chapter 20 "CLR via C#" by Jeffrey Richter P.S.S. There is no equivalent for shared_ptr in .Net because .Net uses Garbage Collection for automatic memory management and if you want to use reference counting - you should implement it by hand (for example, for resource management).
