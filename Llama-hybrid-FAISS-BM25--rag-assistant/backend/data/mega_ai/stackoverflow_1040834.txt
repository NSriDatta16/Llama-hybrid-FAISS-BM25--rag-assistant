[site]: stackoverflow
[post_id]: 1040834
[parent_id]: 1040805
[tags]: 
Use option 1. A NUMBER is a NUMBER internally to Oracle, regardless of precision and scale. Option 2 appears to be a horrible maintenance nightmare from the get-go, and what do you do if you decide to change the precision of one of your values? EDIT: to illustrate, consider: SQL> CREATE TABLE testing (n1 NUMBER(38,12), n2 NUMBER(5)); Table created SQL> INSERT INTO testing VALUES (1, 1); 1 row inserted SQL> INSERT INTO testing VALUES (990, 9900); 1 row inserted SQL> INSERT INTO testing VALUES (1999999.999999, 1); 1 row inserted SQL> SELECT n1, DUMP(n1) n1d, n2, DUMP(n2) n2d FROM testing; N1 N1D N2 N2D --------------------- ------------------------------ ------ -------------------- 1.000000000000 Typ=2 Len=2: 193,2 1 Typ=2 Len=2: 193,2 990.000000000000 Typ=2 Len=3: 194,10,91 9900 Typ=2 Len=2: 194,100 1999999.999999000000 Typ=2 Len=8: 196,2,100,100,100 1 Typ=2 Len=2: 193,2 ,100,100,100 SQL> No difference in storage. The length stored is data dependent, not the precision/scale of the column definition. This link gives a pretty good explanation of how the NUMBER type is stored. It's not as simple as comparing the values to get an idea of how much storage it will take for a given number. For example, it takes 3 bytes to store the number 990, but only 2 bytes to store 9900.
