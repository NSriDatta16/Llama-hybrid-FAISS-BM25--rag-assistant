[site]: stackoverflow
[post_id]: 5203064
[parent_id]: 
[tags]: 
WPF Observable Collection. Count == 0 on refresh but has many items

Good morning, Apologies for the mass of text im about to provide but... I have a WPF ListView with its ItemsSource bound to an ObservableCollection in it's respective ViewModel. When the window loads, the observable collection is populated from a web service by means of a Command. However, as the program is running, this collection is periodically updated by a BackgroundWorker thread in order to add new items to the ObservableCollection. This mechanism works fine. The ListView is updated without issue on both the UI thread and the background thread. However, when an item in the ListView is double clicked, a new window is opened to display details of the Ticket object contained within the aforementioned ObservableCollection. I have a private method which fires each time the ObservableCollection's set method is called which serves to find the Ticket item from within the collection which has been opened in the new window and update its properties according to the items in the newly updated ObservableCollection. Before doing this update, I check to ensure the ObservableCollection.Count is greater than 1, there is no point doing an update if there is nothing to update from! My issue is that the ObservableCollection.Count property ALWAYS equates to 0. But I know this not to be true as the ListView is still updating its items with new Ticket objects added to this collection, if the count of this collection really was 0, then this would be reflected by the ListView also having no items in it as it is bound to this collection. So what is going on here ? Im wondering maybe because the BackgroundWorker is calling; myCollection = new ObservableCollection(); on a different thread to the UI that when I check the count on the UI thread, the wrong collection object is actually tested for 'Count'. But this still doesn't explain why the ListView reflects the contents of the ObservableCollection without issue. Again, apologies for the wall-o-text but I wanted to explain this issue fully. Thank you for your time and any input you may give. EDIT FOR MORE DETAIL The list view section of user control The view model of the above user control Here you see the TicketSummaries collection which the list view is bound to as well as the refreshOpenTicket() method used to update the Ticket property in a child view model which the new instance of itself in the newly refreshed collection. public class MainWindowViewModel : ViewModelBase { private DispatcherTimer timer; private BackgroundWorker worker_TicketLoader; private ObservableCollection ticketSummaries; public ObservableCollection TicketSummaries { get { return ticketSummaries; } set { ticketSummaries = value; this.RaisePropertyChanged(p => p.TicketSummaries); refreshOpenTicket(); } } private void refreshOpenTicket() { // Check there are actually some tickets to refresh if (TicketSummaries.Count ticket.ID == TicketDetailsViewModel.Ticket.ID ).First(); // Make sure we are not going to overrite with a null reference if (openTicket != null) TicketDetailsViewModel.Ticket = openTicket; } } } This collection is updated from various sources via the following command private void Execute_GetAgentsTickets(object agent) { TicketSummaries = new ObservableCollection (); var agentsTickets = ticketService.GetAgentsTickets((Agent)agent); agentsTickets.ForEach( ticket => TicketSummaries.Add(ticket) ); AppSettings.LoggedAgent = (Agent)agent; RequeryCommands(); } But occasionally this collection will be modified off-thread by the background worker void worker_TicketLoader_DoWork(object sender, DoWorkEventArgs e) { State = "Loading Tickets"; IsLoadingTickets = true; var agentsTickets = ticketService.GetAgentsTickets(AppSettings.LoggedAgent); TicketSummaries = new ObservableCollection (); foreach (Ticket ticket in agentsTickets) { TicketSummaries.AddOnUIThread (ticket); } refreshOpenTicket(); lastRefresh = DateTime.Now; } Just in case it makes a difference, the TicketSummaries.AddOnUIThread(ticket); is a solution I found on StackOverflow to trying to add items to a collection which is a binding source to UI controls off-thread and is as; public static void AddOnUIThread (this ICollection collection, T item) { Action addMethod = collection.Add; Application.Current.Dispatcher.BeginInvoke(addMethod, item); } I hope this helps shed some more light on the situation. Thanks again for your time.
