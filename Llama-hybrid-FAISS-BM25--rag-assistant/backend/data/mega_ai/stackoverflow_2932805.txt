[site]: stackoverflow
[post_id]: 2932805
[parent_id]: 2932515
[tags]: 
Take a look at the excellent Pitfalls of Object-Oriented Programming slides for some info about restructuring code for locality. In my experience getting better locality is almost always the biggest win. General process: Learn to love the Disassembly View in your debugger, or have your build system generate the intermediate assembly files (.s) if at all possible. Keep an eye on changes or for things that look egregious -- even without familiarity with a given instruction set architecture, you should be able to see some things fairly clearly! (I sometimes check in a series of .s files with corresponding .cpp/.c changes, just to leverage the lovely tools from my SCM to watch the code and corresponding asm change over time.) Get a profiler that can watch your CPU's performance counters , or can at least guess at cache misses. (AMD CodeAnalyst, cachegrind, vTune, etc.) Some other specific things: Understand strict aliasing. Once you do, make use of restrict if your compiler has it. (Examine the disasm here too!) Check out different floating point modes on your processor and compiler. If you don't need the denormalized range, choosing a mode without this can result in better performance. (It sounds like you've already done some things in this area, based on your discussion of rounding modes.) Definitely avoid allocs: call reserve on std::vector when you can, or use std::array when you know the size at compile-time. Use memory pools to increase locality and decrease alloc/free overhead; also to ensure cacheline alignment and prevent ping-ponging. Use frame allocators if you're allocating things in predictable patterns, and can afford to deallocate everything in one go. Do be aware of invariants . Something you know is invariant may not be to the compiler, for example a use of a struct or class member in a loop. I find the single easiest way to fall into the correct habit here is to give a name to everything, and prefer to name things outside of loops. E.g. const int threshold = m_currentThreshold; or perhaps Thing * const pThing = pStructHoldingThing->pThing; Fortunately you can usually see things that need this treatment in the disassembly view. This also helps with debugging later (makes the watch/locals window behave much more nicely in debug builds)! Avoid writes in loops if possible -- accumulate first, then write, or batch a few writes together. YMMV, of course. WRT your std::priority_queue question: inserting things into a vector (the default backend for a priority_queue) tends to move a lot of elements around. If you can break up into phases, where you insert data, then sort it, then read it once it's sorted, you'll probably be a lot better off. Although you'll definitely lose locality, you may find a more self-ordering structure like a std::map or std::set worth the overhead -- but this is really dependent on your usage patterns.
