[site]: stackoverflow
[post_id]: 4373015
[parent_id]: 4372524
[tags]: 
I’m not completely certain what you mean by nesting regexes. The way this sort of thing is usually approached is to carefully pull off just a bit at a time, like a lexer. That way you don’t have to try to build everything into one pattern. Instead of using Matcher.matches() , you might go at it by using Matcher.lookingat() , which looks for something from the current start point. That way you could test for a bunch of them from the same position. A similar tactic involves using the one-argument form of Matcher.find() , where you supply a starting character position as the argument. A related feature is the \G anchor, a zero-width assertion that makes the search start up just where the last match on that same string left off. It saves you some bookkeeping that way. By combining judicious uses of the find(N) and lookingat() methods (plus start() ), perhaps with the \G assertion, you can build yourself a more flexible and sophisticated processing algorithm than is practicable using a single regular expression alone. It really is a lot easier to use structural logic with regular Java managing your regexes for the pieces than it is to try to do everything in one gargantuan regex. It’s much easier to develop, debug, and unit-test that way, too. Regexes work best at dealing with pieces of strings, not trying to encode an entire parsing algorithm in them. Plus in Java you can’t really do that anyway, since there’s no support for recursion within the pattern. Perhaps it’s just as well, because it encourages you to put the control structures in the outer language, since you can’t always put all of what you’d need in the inner one.
