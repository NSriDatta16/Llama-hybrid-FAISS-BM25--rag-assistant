[site]: stackoverflow
[post_id]: 1785524
[parent_id]: 1785439
[tags]: 
Automatically launching an application is not possible in Mac OS X. There are some safety reasons against it. The only thing that can be automatically launched is a .pkg file and this only through Safari AFAIK. It is possible to determine the DMG file the application resides on. You have to use IOKit for this. Try playing around with IORegistryExplorer. Some code that may help you Those are my first attempts on using IOKit, it's for another purpose but it should help non-the-less. // hopefully all needed headers #include #include #include #include /* First we want to get the major and minor BSD number * of the DMG that our app is residing on. * * char *path is the path of a file that resides on the disk image. * It is like this: /Volumes/Partition Name/SomeFile * The simplest method to get such a path is to ask * NSBundle for the path of the executable. */ // look up device number with stat char *path = "path/to/app"; struct stat stats; if (stat(path, &stats) != 0) { return; } int bsd_major = major(stats.st_dev); int bsd_minor = minor(stats.st_dev); /* Now that we've got the BSD numbers we have to locate the * IOService that has those numbers. IOKit works with * CoreFoundation types. */ CFTypeRef keys[2] = { CFSTR(kIOBSDMajorKey), CFSTR(kIOBSDMinorKey) }; CFTypeRef values[2]; values[0] = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &bsd_major); values[1] = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &bsd_minor); CFDictionaryRef matchingDictionary; matchingDictionary = CFDictionaryCreate(kCFAllocatorDefault, &keys, &values, sizeof(keys) / sizeof(*keys), &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks); CFRelease(values[0]); CFRelease(values[1]); // IOServiceGetMatchingService uses up one reference to the dictionary io_service_t service = IOServiceGetMatchingService(kIOMasterPortDefault, matchingDictionary); if (!service) { return; } /* Now this part is quite different from what I need * for my application. I'm not sure how this works * because I'm currently not at my Mac and cannot try it. * * You need to go up the IOService chain. It looks like this: +-o IOHDIXHDDriveOutKernelUserClient +-o IODiskImageBlockStorageDeviceOutKernel Much of this can be done using the Foundation classes instead of the CoreFoundation classes because of the toll-free bridging support. This makes it a little bit easier and more legible. The sample code above is working if the parent IOService of IOBlockStorageDriver is IODiskImageBlockStorageDeviceOutKernel. If the name of the parent IOService is "AppleDiskImageDevice", the IOService chain looks a bit different: +-o IOHDIXHDDriveOutKernelUserClient +-o AppleDiskImageDevice You can obtain the image file path URL string like bellow after the for-loop above: CFMutableDictionaryRef properties = nil; IORegistryEntryCreateCFProperties(service, &properties, kCFAllocatorDefault, kNilOptions); if (properties) { CFStringRef url = CFDictionaryGetValue(properties, CFSTR("DiskImageURL")); CFRelease(properties); } IOObjectRelease(service);
