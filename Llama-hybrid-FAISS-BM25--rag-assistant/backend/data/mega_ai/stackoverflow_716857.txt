[site]: stackoverflow
[post_id]: 716857
[parent_id]: 
[tags]: 
Recursive data processing performance using Java and SQLite

If you have an answer that is not Java / SQLite related, I'd be pleased to read it. The environment I store items in a database with the following scheme : ################### # Item # ################### # _id # This is the primary key # parent_id # If set, it the ID of the item containing this item # date # An ordinary date # geocontext_id # Foreign key to a pair of named coordinates ################### ################### # Geocontext # ################### # _id # This is the primary key # name # Way for the user to label a pair of coordinates (e.g : "home", "work") # x # One of the coordinate # y # The other one ################### The problem I must filter the items according to the geocontext and the date. It would be a easy job if items were all at the same level, but the trick is it's recursive. E.G : root |_item 1 |_item 2 | |_item 4 | |_item 5 | |_item 6 |_item 3 | |_item 8 | |_item 10 |_item 11 | |_item 12 |_item 7 There is no explicit limit to the recursive depth. Now, if we are in any node and filter with the date "1st of April", we must see not only the items directly contained in the node that match the date, but we must see the items that contain items matching the date as well . E.G : We are in "Items 2", if "item 6" matches the date, then we consider "item 5" matches the date too and we must keep it. If we are at the root, then item 2 must be displayed. Same goes for the geocontext, but it's even harder because : It's stored in an other table. Matching the context is a costly mathematical computation. Of course, brute forcing the matching would result in the software to be slow and a very poor user experience. NOTE : I don't need to display a tree . I display a list of filtered data from a tree. We must see only a flat list of the top elements. The challenge is to decide whether to display each element or not, according to all the children hierachy. How I tried to solve it I thought I could ease a bit the problem by using more tables to cache flat data : ################### # Geocontex_cache # ################### # item_id # I can Join the items table on this field # child_id # I can delete / update a child, and so delete / update the cache # geocontext_id # I can delete / update a geocontext, and so delete / update the cache # x # Here, I can brute force :-) # y # ################### ################### # Date_cache # ################### # item_id # # child_id # # date # ################### This seems reasonable, but I haven't tried it yet. Nevertheless, it should the following drawbacks : I moved the costly process to the get / set / create / delete methods that will have to manage the cached date. That will be a troublesome code to write and maintain. A five depth level item will triger a process that will hit recursively five parents. The size ot the data base could become HUGE. A five de depth level item store cached data for five parents. Don't know if it's relevant, since this a a mono-user app with a manual input. I don't think anybody would insert more thatn 1000 items with more than 10 level of depth. Now the good news is we go from the bottom of the pyramid to the top, not the other way, so it's not has horrible as it seems. When I will have to deal with parent item deletion, it will be another nice headache, but I save it for another question ;-). Now my question How would you store the data and process the filtering int the most optimal way ? Optional : Should I define an explicit recursive depth limit ? Should I perform the filtering using SQL or Java ? SQL surely will be faster, but matching the geocontext is far easier to do in Java. As I am working on the Android platform, I have the following constraints : Java is the only language available, and not with the entire standard lib. SQLite is the only DBMS available. Performance and memory are important issues. In case you have to choose, battery life and therefore performance is the priority. Exotics external libs may not be able to be used. P.S : I dug into SO and found some interesting pieces of information (espacially What is the most efficient/elegant way to parse a flat table into a tree? ). It's a hint, but not a problem solver.
