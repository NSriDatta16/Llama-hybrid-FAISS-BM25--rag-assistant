[site]: stackoverflow
[post_id]: 1008183
[parent_id]: 1007390
[tags]: 
Rephrasing the question to a more general: is it possible to convert pointers from unrelated types if the unrelated types are themselves convertible? , the answer is not. And different template instantiations define different unrelated types. You can implicitly convert (see note below) a pointer to a derived object to a pointer of the base object (some restrictions apply due to access or ambiguity) or you can make an explicit conversion from a base pointer to a derived pointer (again with some restrictions). You can also convert back and forth to void*, but converting to an unrelated type ends up with undefined behavior. There are clear reasons for pointers not being convertible from unrelated types. The first of which is that converting one pointer type to another pointer type will not convert the pointed memory. That is, you can convert an int to a double, but converting a pointer to an int to a pointer to double would make the compiler believe that there are 8 bytes of memory at the pointed address while in fact only 4 bytes are present (assuming 32 or 64 bit architecture with 32 bit integers and 64 bit doubles). Dereferencing the pointer will surely end bad. Notes from the standard: Section 4.10 of the standard deals with pointer conversions, first paragraph deals with null-pointer conversions, second paragraph with void pointer conversions. The third paragraph states that you can convert a pointer to type D to a pointer of type B as long as B is a base class of D. No other pointer conversion is defined there. In Section 5.4 where explicit conversions are specified, paragraph 7 deals with pointer conversions and only adds the possible explicit conversion from B* to D* in several situations as long as B is a base of B.
