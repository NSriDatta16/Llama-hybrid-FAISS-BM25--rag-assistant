[site]: stackoverflow
[post_id]: 400349
[parent_id]: 399991
[tags]: 
You might also consider some other means of data persistence. In my own (astronomy) research, I've been experimenting with two different means of storing scripts for reproducibility. The first is to have them exclusively inside a subversion repository, and then have the job submission script automatically commit them. For instance, if you just wanted to do this in bash: alias run_py='svn ci -m "Commit before running"; python2.5 $*' and inside the script, have the output prefixed by the current subversion revision number for that file, you'd have a record of each script that was run and what the input was. You could pull this back out of subversion as need be. Another, substantially less full-featured, means of tracking the input to a function could be via something like LodgeIt , a pastebin that accepts XML-RPC input and comes with Python bindings. (It can be installed locally, and has support for replying to and updating existing pastes.) But, if you are looking for a relatively small amount of code to be included, Vinko's solution using inspect should work quite well. Doug Hellman covered the inspect module in his Python Module of the Week series. You could create a decorator that examines each option and argument and then prints it out as appropriate (I'll use inspect.getargspec to get the names of the arguments.) import inspect from functools import wraps def option_printer(func): @wraps(func) def run_func(*args, **kwargs): for name, arg in zip(inspect.getargspec(func)[0], args) \ + sorted(kwargs.items()): if isinstance(arg, types.FunctionType): print "Function argument '%s' named '%s':\n" % (name, func.func_name) print inspect.getsource(func) else: print "%s: %s" % (name, arg) return func(*args, **kwargs) return run_func This could probably be made a bit more elegant, but in my tests it works for simple sets of arguments and variables. Additionally, it might have some trouble with lambdas.
