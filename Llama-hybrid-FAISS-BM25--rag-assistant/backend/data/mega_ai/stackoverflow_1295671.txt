[site]: stackoverflow
[post_id]: 1295671
[parent_id]: 1295584
[tags]: 
Note added August 2013, updated February 2015: The answer below from 2009 relates to JavaScript's generic Array type. It doesn't relate to the newer typed arrays defined in ES2015 [and available now in many browsers], like Int32Array and such. Also note that ES2015 adds a fill method to both Arrays and typed arrays , which is likely to be the most efficient way to fill them... Also, it can make a big difference to some implementations how you create the array. Chrome's V8 engine, in particular, tries to use a highly-efficient, contiguous-memory array if it thinks it can, shifting to the object-based array only when necessary. With most languages, it would be pre-allocate, then zero-fill, like this: function newFilledArray(len, val) { var rv = new Array(len); while (--len >= 0) { rv[len] = val; } return rv; } But , JavaScript arrays aren't really arrays , they're key/value maps just like all other JavaScript objects, so there's no "pre-allocate" to do (setting the length doesn't allocate that many slots to fill), nor is there any reason to believe that the benefit of counting down to zero (which is just to make the comparison in the loop fast) isn't outweighed by adding the keys in reverse order when the implementation may well have optimized their handling of the keys related to arrays on the theory you'll generally do them in order. In fact, Matthew Crumley pointed out that counting down is markedly slower on Firefox than counting up, a result I can confirm â€” it's the array part of it (looping down to zero is still faster than looping up to a limit in a var). Apparently adding the elements to the array in reverse order is a slow op on Firefox. In fact, the results vary quite a bit by JavaScript implementation (which isn't all that surprising). Here's a quick and dirty test page (below) for browser implementations (very dirty, doesn't yield during tests, so provides minimal feedback and will run afoul of script time limits). I recommend refreshing between tests; FF (at least) slows down on repeated tests if you don't. The fairly complicated version that uses Array#concat is faster than a straight init on FF as of somewhere between 1,000 and 2,000 element arrays. On Chrome's V8 engine, though, straight init wins out every time... Here's a test: const tests = [ { name: "downpre", total: 0, desc: "Count down, pre-decrement", func: makeWithCountDownPre }, { name: "downpost", total: 0, desc: "Count down, post-decrement", func: makeWithCountDownPost }, { name: "up", total: 0, desc: "Count up (normal)", func: makeWithCountUp }, { name: "downandup", total: 0, desc: "Count down (for loop) and up (for filling)", func: makeWithCountDownArrayUp }, { name: "concat", total: 0, desc: "Concat", func: makeWithConcat } ]; const q = sel => document.querySelector(sel); let markup = ""; for (const {name, desc} of tests) { markup += ` ${desc} `; } q("#checkboxes").innerHTML = markup; q("#btnTest").addEventListener("click", btnTestClick); function btnTestClick() { // Clear log q("#log").innerHTML = "Testing..."; // Show running q("#btnTest").disabled = true; // Run after a pause while the browser updates display setTimeout(btnTestClickPart2, 0); } function btnTestClickPart2() { try { runTests(); } catch (e) { log(`Exception: ${e.message}`); } // Re-enable the button q("#btnTest").disabled = false; } function getNumField(name) { const val = q("#" + name).value.trim(); const num = /^\d+$/.test(val) ? parseInt(val) : NaN; if (isNaN(num) || num FAILURE with test ${test.name}: ${invalid}`); return; } } else { // Count this one log(`#${counter}: ${test.desc}: ${time}ms`); test.total += time; } } } } for (const test of tests) { if (q("#chk_" + test.name).checked) { test.avg = test.total / runCount; if (typeof lowest != "number" || lowest > test.avg) { lowest = test.avg; } } } let results = " Results:" + " Length: " + length + " Loops: " + runCount + " "; for (const test of tests) { if (q("#chk_" + test.name).checked) { results += ` ${test.desc}, average time: ${test.avg}ms `; } } results += " "; q("#log").insertAdjacentHTML("afterbegin", results); } catch (e) { log(e.message); return; } } function validateResult(a, length) { if (a.length != length) { return "Length is wrong"; } for (let n = length - 1; n >= 0; --n) { if (a[n] != 0) { return "Index " + n + " is not zero"; } } return undefined; } function makeWithCountDownPre(len) { const a = new Array(len); while (--len >= 0) { a[len] = 0; } return a; } function makeWithCountDownPost(len) { const a = new Array(len); while (len-- > 0) { a[len] = 0; } return a; } function makeWithCountUp(len) { const a = new Array(len); for (let i = 0; i = 0) { a[i++] = 0; } return a; } function makeWithConcat(len) { if (len == 0) { return []; } let a = [0]; let currlen = 1; while (currlen body { font-family: sans-serif; } #log p { margin: 0; padding: 0; } .error { color: red; } .winner { color: green; } Length: Loops:
