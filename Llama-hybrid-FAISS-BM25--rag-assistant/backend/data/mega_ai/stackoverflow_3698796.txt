[site]: stackoverflow
[post_id]: 3698796
[parent_id]: 3544826
[tags]: 
+1. I'm having the exact same problem. I tried switching the layout() and setVisible() calls to no effect. Update: The problem turns out to be the correct sequence in setting the visibility of the nextScreen view. If you set the visibility to VISIBLE before calling layout(), you get the flicker at position 0 as you noticed. But if you call layout() first, it gets ignored because the visibility is GONE. I did two things to fix this: Set the visibility to INVISIBLE before first layout() call. This differs from GONE in that the layout() is executed - you just don't see it. Set the visibility to VISIBLE asynchronously, so the layout() and related messages are processed first In code: case MotionEvent.ACTION_DOWN: nextScreen.setVisibility(View.INVISIBLE); //from View.GONE case MotionEvent.ACTION_MOVE: nextScreen.layout(l, t, r, b); if (nextScreen.getVisibility() != View.VISIBLE) { //the view is not visible, so send a message to make it so mHandler.sendMessage(Message.obtain(mHandler, 0)); } private class ViewHandler extends Handler { @Override public void handleMessage(Message msg) { nextScreen.setVisibility(View.VISIBLE); } } More elegant/easier solutions are welcome!
