[site]: stackoverflow
[post_id]: 1776542
[parent_id]: 1776524
[tags]: 
An instance of the class itself will take up 24 bytes on a 32-bit CLR: 8 bytes of object overhead (sync block and type pointer) 4 bytes for the int 4 bytes for the string reference 8 bytes for the double Note that the memory for the string itself is in addition to that - but many objects could share references to the same string, for example. Methods don't incur the same sort of storage penalty is fields. Essentially they're associated with the type rather than an instance of the type, but there's the IL version and the JIT-compiled code to consider. However, usually you can ignore this in my experience. You'd have to have a large amount of code and very few instances for the memory taken up by the code to be significant compared with the data. The important thing is that you don't get a separate copy of each method for each instance. EDIT: Note that you happened to pick a relatively easy case. In situations where you've got fields of logically smaller sizes (e.g. short or byte fields) the CLR chooses how to lay out the object in memory, such that values which require memory alignment (being on a word boundary) are laid out appropriately, but possibly backing other ones - so 4 byte fields could end up taking 4 bytes, or they could take 16 if the CLR decides to align each of them separately. I think that's implementation-specific, but it's possible that the CLI spec dictates the exact approach taken.
