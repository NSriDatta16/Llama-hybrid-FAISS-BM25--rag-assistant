[site]: stackoverflow
[post_id]: 3401027
[parent_id]: 3397708
[tags]: 
Ultimately you're looking into the philosophy behind mocking in general. I'll give you my two cents, but I'd also refer to you any major mocking library, which is likely to provide good justification for their own existence. Take Mockito , for example. The testing/mocking community often distinguishes between what you're hand-rolling, which is usually called a "stub" (a static, hand-written class) versus a "mock" (a dynamic, runtime-generated class). The benefits of mocking are pretty big in comparison to just stubbing. Many testers chafe at the idea of going off to write implementations of interfaces and/or subclass concrete classes just for the purpose of testing. To do so often requires the implementation of ALL methods of said class/interface, even when you just want to test a specific method. Mocking lets you get around that problem by defining just the methods to which you want to give behavior, and that's powerful. In addition, mocking allows you to change behavior from one test to the next. To do that with stubbing, you'd have to write an entirely new stub class. The syntax varies a little from mocking library to library. Some you may find more readable than others. My current favorite is Mockito, hence the earlier reference, but they evolve over time. It might be worth determining why your organization is using the mocking suite that it is and whether another might still meet your needs as well as being more readable. Hopefully your test-writers are pulling common behavior into test-setup methods (like JUnit's @Before) so you don't have to keep seeing mock-creation and common initialization all over the place.
