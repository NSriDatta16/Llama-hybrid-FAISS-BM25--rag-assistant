[site]: stackoverflow
[post_id]: 2196495
[parent_id]: 2196327
[tags]: 
It is guaranteed behaviour. The actual execution is unrolled as follows: 0: enter block (scope) 1: Foo::Foo() 2. evaluation of bar(); as expression in return statement 3. save result of the expression as value returned from function 4. finalize return statement to leave function to its caller (request exit from current scope) 5: exit block (scope) with call to Foo::~Foo() Here are some references from the standard: What program execution guarantees, generally 1.9 Program execution 10 An instance of each object with automatic storage duration (3.7.2) is associated with each entry into its block. The foo is of automatic storage duration and: 3.7.2 Automatic storage duration 1 Local objects explicitly declared auto or register or not explicitly declared static or extern have automatic storage duration. The storage for these objects lasts until the block in which they are created exits. What is actual effect of return statement 6.6.3 The return statement 2 (...) the value of the expression is returned to the caller of the function and 6.6 Jump statements (return belongs to jump statements) 2 On exit from a scope (however accomplished), destructors (12.4) are called for all constructed objects with automatic storage duration (3.7.2) What guarantees that the effect occurs 6.7 Declaration statement 2 Variables with automatic storage duration declared in the block are destroyed on exit from the block and 12.4 Destructors 10 Destructors are invoked implicitly (1) for a constructed object with static storage duration (3.7.1) at program termination (3.6.3), (2) for a constructed object with automatic storage duration (3.7.2) when the block in which the object is created exits (6.7) It is not easy to grasp single idea form details scattered around all the C++ standard. Hopefully, quick overview will help you to make such analysis yourself too.
