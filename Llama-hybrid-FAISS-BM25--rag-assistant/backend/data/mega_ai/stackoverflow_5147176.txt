[site]: stackoverflow
[post_id]: 5147176
[parent_id]: 5147113
[tags]: 
Anemic domain is when a product or other class doesn't really implement anything more than data setters and getters - no domain behavior. For instance, a product domain object should have some methods exposed, some data validations, some real business logic. Otherwise, the BLL version (the domain object) is hardly better than a DTO. http://martinfowler.com/bliki/AnemicDomainModel.html ProductBLL productBll = new ProductBLL(); List productList = productBll.GetAllProducts(); The problem here is that you are pre-supposing your model is anemic and exposing the DTO to the business layer consumers (the UI or whatever). Your application code generally wants to be working with s, not any BLL or DTO or whatever. Those are implementation classes. They not only mean little to the application programmer level of thought, they mean little to domain experts who ostensibly understand the problem domain. Thus they should only be visible when you are working on the plumbing, not when you are designing the bathroom, if you see what I mean. I name my BLL objects the name of the business domain entity. And the DTO is internal between the business entity and the DAL. When the domain entity doesn't do anything more than the DTO - that's when it's anemic. Also, I'll add that I often just leave out explcit DTO classes, and have the domain object go to a generic DAL with organized stored procs defined in the config and load itself from a plain old datareader into its properties. With closures, it's now possible to have very generic DALs with callbacks which let you insert your parameters. I would stick to the simplest thing that can possibly work: public class Product { // no one can "make" Products private Product(IDataRecord dr) { // Make this product from the contents of the IDataRecord } static private List GetList(string sp, Action addParameters) { List lp = new List (); // DAL.Retrieve yields an iEnumerable (optional addParameters callback) // public static IEnumerable Retrieve(string StoredProcName, Action addParameters) foreach (var dr in DAL.Retrieve(sp, addParameters) ) { lp.Add(new Product(dr)); } return lp; } static public List AllProducts() { return GetList("sp_AllProducts", null) ; } static public List AllProductsStartingWith(string str) { return GetList("sp_AllProductsStartingWith", cm => cm.Parameters.Add("StartsWith", str)) ; } static public List AllProductsOnOrder(Order o) { return GetList("sp_AllProductsOnOrder", cm => cm.Parameters.Add("OrderId", o.OrderId)) ; } } You can then move the obvious parts out into a DAL. The DataRecords serve as your DTO, but they are very short-lived - a collection of them never really exists. Here's a DAL.Retrieve for SqlServer which is static (you can see it's simple enough to change it to use CommandText); I have a version of this which encapsulates the connection string (and so it's not a static method): public static IEnumerable SqlRetrieve(string ConnectionString, string StoredProcName, Action addParameters) { using (var cn = new SqlConnection(ConnectionString)) using (var cmd = new SqlCommand(StoredProcName, cn)) { cn.Open(); cmd.CommandType = CommandType.StoredProcedure; if (addParameters != null) { addParameters(cmd); } using (var rdr = cmd.ExecuteReader()) { while (rdr.Read()) yield return rdr; } } } Later you can move on to full blown frameworks.
