[site]: stackoverflow
[post_id]: 3629283
[parent_id]: 3629131
[tags]: 
C does not have a strong type system. C++ is somewhat stronger typed, but is not really a true strong type system, since it has reinterpret_cast . For a type system to prevent buffer overflow, the type information must either (1) denote an arbitrarily long string or (2) encode the buffer length in the type itself. Further, the type judgment system should ensure buffer-length to be less than or equal to for conversions. Edit: With some care, and neglecting the cast-tastic abilities of C++, you can write a "reasonably strong" no-overflow buffer class in C++. However, this is not strongly typed per the general definition of the term, since it is possible to attempt to access the buffer at an invalid point and still have it compile. Someone much better at templates than I might be able to write a truly template-typed SafeBuffer. Here's my cut at it: template class SafeBuffer { unsigned char[Length]; public: unsigned char& operator[](int index); //when implemented, throws exception on out-of-range access. }; SafeBuffer buf, foo; SafeBuffer bar; buf = foo; //pass buf = bar; //compile-time error. buf[100]; //compiles, but generates error at runtime. Note that we are leveraging the type judgment system of templates to force the compile error of buf = bar . That is an example of what a strongly typed system can do (Also note that casts can 100% destroy the typing - in C++).
