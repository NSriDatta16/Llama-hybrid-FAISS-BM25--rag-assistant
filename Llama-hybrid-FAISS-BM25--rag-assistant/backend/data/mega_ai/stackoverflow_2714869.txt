[site]: stackoverflow
[post_id]: 2714869
[parent_id]: 2697823
[tags]: 
It’s really weird that the behavior looks like being executed MORE times than what it really was. I would expect the opposite. But it’s not a problem, let’s add some concurrency control to your application. You have some options to control the concurrency between threads that are accessing your objects at the same time: optimistic and pessimistic. Optimistic control will let your sessions work until the time they try to save the object, and then will throw an exception. Catching and working around an exception can be a very boring to your user as you will probably have to ask him to do the same operation again, but if the number of occurrences that your concurrence issues happens isn’t meaningful to your context, I’d opt for one of them: their impact in your application overall performance is smaller. In the other side you have pessimistic control. In this case, you won’t have surprises when saving objects, but the second session will have to wait until the first one commits its transaction until it can proceed with its job. If the first session takes too long, obviously, you will get some kind of timeout exception. If it takes a regular time, everything will work, but your system will have this average speed hit by the lock time. Optimistic - Option 1: you can make some kind of dirty checking, so NHibernate will check if the object that is being updated has the same values that it had before the property was modified. Any difference will result in an exception. To configure it (via Fluent NH) you’d have to add something similar to: OptimisticLock.Dirty().DynamicUpdate(); Enabling DynamicUpdate tells NHibernate to check only the properties that are being saved, not the whole object. You can use OptimisticLock.All() to force NHibernate to check all properties, but I think it’s not needed in your case. Optimistic - Option 2: the other option is to explicit have a Version column that will be handled by NH to know if the object you are trying to save is the most updated. If not, as usual, you will get an exception. To configure it via FluentNH: OptimisticLock.Version(); Version(x => x.Version); // supposing that you have a Version property Pessimistic: pessimistic lock is achieved via LockMode enum in your Get methods. As told before, the object won’t be read by any other session until the owner session commits its transaction. Use something like this: MappedEntity ent1 = session1.Get (entity.Id, LockMode.Force); Using any of this approaches will probably solve your problems, but consider the pros and cons of each in your scenario. All the information shown here is also available in Ayende’s blog, with the proper HBM mappings. See this: http://ayende.com/Blog/archive/2009/04/15/nhibernate-mapping-concurrency.aspx Hope this helps, and let me know if I can help you with anything else. Regards, Filipe
