[site]: stackoverflow
[post_id]: 2135857
[parent_id]: 2135788
[tags]: 
Let's take a C program. When you run gcc , clang , or 'cl' on the c program, it will go through these stages: Preprocessor (#include, #ifdef, trigraph analysis, encoding translations, comment management, macros...) including lexing into preprocessor tokens and eventually resulting in flat text for input to the compiler proper. Lexical analysis (producing tokens and lexical errors). Syntactical analysis (producing a parse tree and syntactical errors). Semantic analysis (producing a symbol table, scoping information and scoping/typing errors) Also data-flow, transforming the program logic into an "intermediate representation" that the optimizer can work with. (Often an SSA ). clang/LLVM uses LLVM-IR, gcc uses GIMPLE then RTL. Optimization of the program logic, including constant propagation, inlining, hoisting invariants out of loops, auto-vectorization, and many many other things. (Most of the code for a widely-used modern compiler is optimization passes.) Transforming through intermediate representations is just part of how some compilers work, making it impossible / meaningless to "disable all optimizations" Outputing into assembly source (or another intermediate format like .NET IL bytecode ) Assembling of the assembly into some binary object format. Linking of the assembly into whatever static libraries are needed, as well as relocating it if needed. Output of final executable in elf, PE/coff, MachO64, or whatever other format In practice, some of these steps may be done at the same time, but this is the logical order. Most compilers have options to stop after any given step (e.g. preprocess or asm), including dumping internal representation between optimization passes for open-source compilers like GCC. ( -ftree-dump-... ) Note that there's a 'container' of elf or coff format around the actual executable binary, unless it's a DOS .com executable You will find that a book on compilers(I recommend the Dragon book, the standard introductory book in the field) will have all the information you need and more. As Marco commented, linking and loading is a large area and the Dragon book more or less stops at the output of the executable binary. To actually go from there to running on an operating system is a decently complex process, which Levine in Linkers and Loaders covers. I've wiki'd this answer to let people tweak any errors/add information.
