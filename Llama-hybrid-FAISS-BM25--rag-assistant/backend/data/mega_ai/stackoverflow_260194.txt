[site]: stackoverflow
[post_id]: 260194
[parent_id]: 259957
[tags]: 
I try to implement unit tests to test only a single method. and I make an effort to crete "mock" classes for dependant classes and methods used by the method I am testing... ... so that the exercise of the code in that method does not in fact call code in other methods the unit test is not supposed to be "Testing" (There are other unit tests for those methods) This way, a failure of the unit test reliably indicates a failure of the method the unit test is testing... Mock classes are designed to "simulate" the interface and behavior of dependant classes so that the method I am testing can call them and they will behave ina standard, well-defined way according to system requirements. In order to make this approach work, calls to such dependant classes and to their methods must be made on a well defined interface, so that the "tester" process can "inject" the Mock version of teh dependant class into the class being tested instead of the actual production version... . This is kinda like a common design pattern referred to as "Dependency Injection", or "Inversion of Control" (IOC) There are several third party tools on the market to help you implement this kind of pattern. One I have heard of is called "Rhino-Mock" or something like that... Edit: Rob Wells. @Charles. Thanks for this. I'd forgotten using mock objects to completely replace using other classes except for the one under test. A couple of other things I've remembered after you mentioning mock objects is that: they can be used to simulate errors being returned by the included classes. they can be used to raise specific exceptions to check exception handling in the class under test. they can be used to simulate items where setup costs are high, e.g. a large SQL DB back end. they can be used to verify the contents of an incoming request. For more information, have a look at Martin Fowler's paper called " Mocks Aren't Stubs " and The Pragmatic Programmers's article " Mock Objects "
