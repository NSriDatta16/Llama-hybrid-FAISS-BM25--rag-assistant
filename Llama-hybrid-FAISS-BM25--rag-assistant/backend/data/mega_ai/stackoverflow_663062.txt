[site]: stackoverflow
[post_id]: 663062
[parent_id]: 661862
[tags]: 
Since you're using handles, you have a lot of freedom to move memory around. I think that using a separate thread is probably not the best (safest or fastest) way -- my guess is you'd be better off using a type of incremental copying allocator, where on each malloc() or free() you compact (copy forwards or backwards in memory) some number of allocated blocks, with the number of bytes that you copy depleting a "budget" that is periodically reset to its initial value (e.g. on each screen refresh). (Of course only whole blocks are copied.) The idea is that copying a given number of bytes takes a fairly predictable amount of time, so you can estimate how many bytes of copying you can safely perform per screen refresh, and limit yourself to that. If there's enough time in the budget, a call to malloc() or free() will completely defragment memory, otherwise it will defragment it as much as possible in the given the time constraints. There are some questions I'm leaving unresolved here -- e.g. exactly how to compact the memory. A standard non-incremental copying allocator can just start allocating from the front, then copy everything to the back (freeing up memory at the front) when memory runs out, but you don't have that freedom here. You might need some heuristics to decide whether to move blocks forward or backwards. The important thing is to avoid oscillations (the same block being moved forwards then backwards on successive calls to malloc() or free() ).
