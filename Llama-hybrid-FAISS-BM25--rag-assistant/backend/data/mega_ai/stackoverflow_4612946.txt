[site]: stackoverflow
[post_id]: 4612946
[parent_id]: 4606680
[tags]: 
The best way to smooth the drawing is use a bezeir curve. Here is my code. It is a modified version I found on apple's dev site, but I don't remember the original link: CGPoint drawBezier(CGPoint origin, CGPoint control, CGPoint destination, int segments) { CGPoint vertices[segments/2]; CGPoint midPoint; glDisable(GL_TEXTURE_2D); float x, y; float t = 0.0; for(int i = 0; i That will draw based on three points. The control is the midpoint, which you need to return. The new midpoint will be different than the previous. Also, if you go through the above code, it will only draw half the line. The next stroke will fill it in. This is required. my code for calling this function (the above is in C, this is in Obj-C): //Invert the Y axis to conform the iPhone top-down approach invertedYBegCoord = self.bounds.size.height - [[currentStroke objectAtIndex:i] CGPointValue].y; invertedYEndCoord = self.bounds.size.height - [[currentStroke objectAtIndex:i+1] CGPointValue].y; invertedYThirdCoord = self.bounds.size.height - [[currentStroke objectAtIndex:i+2] CGPointValue].y; //Figure our how many dots you need count = MAX(ceilf(sqrtf(([[currentStroke objectAtIndex:i+2] CGPointValue].x - [[currentStroke objectAtIndex:i] CGPointValue].x) * ([[currentStroke objectAtIndex:i+2] CGPointValue].x - [[currentStroke objectAtIndex:i] CGPointValue].x) + ((invertedYThirdCoord - invertedYBegCoord) * (invertedYThirdCoord - invertedYBegCoord))) / pointCount), 1); newMidPoint = drawBezier(CGPointMake([[currentStroke objectAtIndex:i] CGPointValue].x, invertedYBegCoord), CGPointMake([[currentStroke objectAtIndex:i+1] CGPointValue].x, invertedYEndCoord), CGPointMake([[currentStroke objectAtIndex:i+2] CGPointValue].x, invertedYThirdCoord), count); int loc = [currentStroke count]-1; [currentStroke insertObject:[NSValue valueWithCGPoint:newMidPoint] atIndex:loc]; [currentStroke removeObjectAtIndex:loc-1]; That code will get the mid point based on inverted iPad points, and set the 'control' as the current point. That will smooth out the edges. Now regarding the line width, you just need to find the speed of that drawing. It is easiest just to find the length of your line. This is easily done using component mathematics. I don't have any code for it, but here is a primer for component mathmatics from a physics site. Or you can simply divide (above) count by some number to find out how thick you need the line to be (count uses component mathematics). I store point data in an array called currentStroke, in case it wasn't obvious. That should be all you need. EDIT: To store points, you should use touchesBegin and touchesEnd: - (void) touchesBegan:(NSSet*)touches withEvent:(UIEvent*)event { self.currentStroke = [NSMutableArray array]; CGPoint point = [ [touches anyObject] locationInView:self]; [currentStroke addObject:[NSValue valueWithCGPoint:point]]; [self draw]; } - (void) touchesMoved:(NSSet*)touches withEvent:(UIEvent*)event { CGPoint point = [ [touches anyObject] locationInView:self]; [currentStroke addObject:[NSValue valueWithCGPoint:point]]; [self draw]; } - (void) touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event { CGPoint point = [ [touches anyObject] locationInView:self]; [currentStroke addObject:[NSValue valueWithCGPoint:point]]; [self draw]; } That is pretty much an entire drawing application there. If you are using GL_Paint, then you are already using point sprites, which this system is build on.
