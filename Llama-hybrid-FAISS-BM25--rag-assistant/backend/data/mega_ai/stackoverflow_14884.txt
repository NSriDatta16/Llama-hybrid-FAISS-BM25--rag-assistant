[site]: stackoverflow
[post_id]: 14884
[parent_id]: 
[tags]: 
Find the best combination from a given set of multiple sets

Say you have a shipment. It needs to go from point A to point B, point B to point C and finally point C to point D. You need it to get there in five days for the least amount of money possible. There are three possible shippers for each leg, each with their own different time and cost for each leg: Array ( [leg0] => Array ( [UPS] => Array ( [days] => 1 [cost] => 5000 ) [FedEx] => Array ( [days] => 2 [cost] => 3000 ) [Conway] => Array ( [days] => 5 [cost] => 1000 ) ) [leg1] => Array ( [UPS] => Array ( [days] => 1 [cost] => 3000 ) [FedEx] => Array ( [days] => 2 [cost] => 3000 ) [Conway] => Array ( [days] => 3 [cost] => 1000 ) ) [leg2] => Array ( [UPS] => Array ( [days] => 1 [cost] => 4000 ) [FedEx] => Array ( [days] => 1 [cost] => 3000 ) [Conway] => Array ( [days] => 2 [cost] => 5000 ) ) ) How would you go about finding the best combination programmatically? My best attempt so far (third or fourth algorithm) is: Find the longest shipper for each leg Eliminate the most "expensive" one Find the cheapest shipper for each leg Calculate the total cost & days If days are acceptable, finish, else, goto 1 Quickly mocked-up in PHP (note that the test array below works swimmingly, but if you try it with the test array from above, it does not find the correct combination): $shippers["leg1"] = array( "UPS" => array("days" => 1, "cost" => 4000), "Conway" => array("days" => 3, "cost" => 3200), "FedEx" => array("days" => 8, "cost" => 1000) ); $shippers["leg2"] = array( "UPS" => array("days" => 1, "cost" => 3500), "Conway" => array("days" => 2, "cost" => 2800), "FedEx" => array("days" => 4, "cost" => 900) ); $shippers["leg3"] = array( "UPS" => array("days" => 1, "cost" => 3500), "Conway" => array("days" => 2, "cost" => 2800), "FedEx" => array("days" => 4, "cost" => 900) ); $times = 0; $totalDays = 9999999; print " Shippers to Choose From: "; print_r($shippers); print " "; while($totalDays > $maxDays && $times $leg){ //find longest shipment for each leg (in terms of days) unset($longestShippers[$legName]); $longestDays = null; if(count($leg) > 1){ foreach($leg as $shipperName => $shipper){ if(empty($longestDays) || $shipper["days"] > $longestDays){ $longestShippers[$legName]["days"] = $shipper["days"]; $longestShippers[$legName]["cost"] = $shipper["cost"]; $longestShippers[$legName]["name"] = $shipperName; $longestDays = $shipper["days"]; } } } } foreach($longestShippers as $leg => $shipper){ $shipper["totalCost"] = $shipper["days"] * $shipper["cost"]; //print $shipper["totalCost"] . " &lt;?&gt; " . $worstShipper["totalCost"] . ";"; if(empty($worstShipper) || $shipper["totalCost"] > $worstShipper["totalCost"]){ $worstShipper = $shipper; $worstShipperLeg = $leg; } } //print "worst shipper is: shippers[$worstShipperLeg][{$worstShipper['name']}]" . $shippers[$worstShipperLeg][$worstShipper["name"]]["days"]; unset($shippers[$worstShipperLeg][$worstShipper["name"]]); print " Next: "; print_r($shippers); print " "; foreach($shippers as $legName => $leg){ //find cheapest shipment for each leg (in terms of cost) unset($cheapestShippers[$legName]); $lowestCost = null; foreach($leg as $shipperName => $shipper){ if(empty($lowestCost) || $shipper["cost"] totalDays: $totalDays "; } print " Chosen Shippers: "; print_r($cheapestShippers); print " "; I think I may have to actually do some sort of thing where I literally make each combination one by one (with a series of loops) and add up the total "score" of each, and find the best one.... EDIT: To clarify, this isn't a "homework" assignment (I'm not in school). It is part of my current project at work. The requirements (as always) have been constantly changing. If I were given the current constraints at the time I began working on this problem, I would be using some variant of the A* algorithm (or Dijkstra's or shortest path or simplex or something). But everything has been morphing and changing, and that brings me to where I'm at right now. So I guess that means I need to forget about all the crap I've done to this point and just go with what I know I should go with, which is a path finding algorithm.
