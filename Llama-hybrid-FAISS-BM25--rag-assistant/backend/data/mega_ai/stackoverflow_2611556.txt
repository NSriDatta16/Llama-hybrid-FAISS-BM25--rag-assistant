[site]: stackoverflow
[post_id]: 2611556
[parent_id]: 
[tags]: 
Containers of reference_wrappers (comparison operators required?)

If you use stl containers together with reference_wrappers of POD types, code such as the following works just fine: int i = 0; std::vector > is; is.push_back(boost::ref(i)); std::cout However, if you use non-POD types like (contrived example): struct Integer { int value; bool operator==(const Integer& rhs) const { return value==rhs.value; } bool operator!=(const Integer& rhs) const { return !(*this == rhs); } }; It doesn't suffice to declare the comparison operators above, aditionally you have to declare: bool operator==(const boost::reference_wrapper & lhs, const Integer& rhs) { return boost::unwrap_ref(lhs)==rhs; } And possibly also: bool operator==(const Integer& lhs, const boost::reference_wrapper & rhs) { return lhs==boost::unwrap_ref(rhs); } In order to get the equivalent code to work: Integer j = { 0 }; std::vector > js; js.push_back(boost::ref(j)); std::cout Now, I'm wondering if this is really the way it's meant to be done, since it's somewhat impractical. It just seems there should be a simpler solution, e.g. templates: template bool operator==(const boost::reference_wrapper & lhs, const T& rhs) { return boost::unwrap_ref(lhs)==rhs; } template bool operator==(const T& lhs, const boost::reference_wrapper & rhs) { return lhs==boost::unwrap_ref(rhs); } There's probably a good reason why reference_wrapper behaves the way it does (possibly to accomodate non-POD types without comparison operators?). Maybe there already is an elegant solution and I just haven't found it.
