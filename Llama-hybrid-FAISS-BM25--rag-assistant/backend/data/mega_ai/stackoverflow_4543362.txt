[site]: stackoverflow
[post_id]: 4543362
[parent_id]: 4543316
[tags]: 
Yes, it is possible. However, instead of doing: // moduleA.c int c = 5; void bar(void); void foo(void) { // ... bar(); // ... } // moduleB.c extern int c; // references "c" defined in moduleA void bar(void) { // ... // do something with c // ... } It is almost always better to do: // moduleA.c int c = 5; void bar(int); void foo(void) { // ... bar(c); // ... } // moduleB.c void bar(int c) { // ... // do something with c // ... } In other words, while you can use global variables, passing variables explicitly as parameters is much better design. Please read Global Variables are Bad for a variety of reasons to avoid global variables. To highlight a few reasons why globals are bad: They hide dependencies. For example, when your code references the global variable "c", the developer needs to hunt all over the place to find where it is defined and how it is used, since this variable can be modified by any module at all. In other words, it introduces unnecessary complexity. Global variables are shared by the entire process. Whereas a local variable that is passed around would be created on a stack, and each thread has its own stack, globals share common storage for the entire program. Any function that uses a global variable (unless that global is a constant) is non-reentrant and, unless it locks access to that global variable, is not thread-safe. It is incredibly difficult to make a program that uses global variables thread-safe, and the fact that any module can write to a global variable means it is hard to ensure that all modules that write to the variable lock it.
