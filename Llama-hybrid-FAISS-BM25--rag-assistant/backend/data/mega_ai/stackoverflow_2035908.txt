[site]: stackoverflow
[post_id]: 2035908
[parent_id]: 2035795
[tags]: 
Cobol is a pure procedural language, not even functions in it (I used cobol in the 90s, so it might have changed since). Java is OO (Although I heared there is a OO version for Cobol too), Oh...And the syntax is different. Excelent list of similarities and differences : http://www.jsrsys.com/jsrsys/s8383sra.htm It'swhat we do! COBOL: COBOL Concept Description Java: Java/OO Similar Concept ++: What Java/OO adds to Concept When I began Java, I used to think the OO (Object Orientation) was "just like" good programming practices, except it was more formal, and the compiler enforced certain restrictions. I no longer think that way. However, when you are beginning I think certain "is similar to" examples will help you grasp the concepts. COBOL: Load Module/Program Java: Class COBOL: PERFORM Java: method ++: can pass parameters to method, more like FUNCTION other programs/classes can call methods in different classes if declared public. public/private gives designer much control over what other classes can see inside a class. COBOL: Working Storage, statically linked sub-routine Java: instance variables ++: (see next) COBOL: Working Storge, dynamically loaded sub-routine Java: Class variables ++: Java can mix both Class variables (called static, just the reverse of our COBOL example, and instance variables (the default). Class variables (static) occur only once per Class (really in one JVM run-time environment). Instance variables are unique to each instance of a class. Here is an example from class JsrSysout. From my COBOL background I like to debug my code by DISPLAYing significant data to the SYSOUT data set. There is a Java method for this, System.out.prinln(...). The problem with this method is that the data you want just scrolls off the Java console, the equivalent of SYSOUT or perhaps DISPLAY UPON CONSOLE if you had your own stand-alone machine. I needed a way to easily do displays that would stop when the screen was full. Since there is only one Java console, the line-count for the screen clearly needs to be a class variable, so all instances (each program/class that logs here has its own instance of JsrSysout) stop at the bottom of the screen. Multiple Instances of same class: One (calling program) class can create multiple instances of the same class. Why would you want to do this? One good COBOL example is I/O routines. In COBOL you would need to code one I/O routine for each file you wish to access. If you want to open a particular file twice in one run-time environment you would need a different I/O routine with a different name, even if the logic was identical. With Java you could code just one class for a particular logical file type. Then for each file you wish to read (or write) you simply create another instance of that class using the new operator. Here are some snippets of code from program IbfExtract that do exactly that. This program exploits the fact that I have written a class for Line Input, and another class for Line Output. These are called JsrLineIn and JsrLineOut. This illustrates another dynamic feature of Java. When output is first created, it is an array of null pointers, it takes very little space. Only when a new object is created, and the pointer to it implicitly put in the array does storage for the object get allocated. That object can be anything from a String to an very complex Class. COBOL: PICTURE Java: No real equivalent. I therefore invented a method to mymic a ZZZ,ZZZ,... mask for integer input. I have generally grouped my utility functions in JsrUtil. These are methods that really don't related to any type of object. Here is an example of padLeft that implements this logic. padLeft is also a good example of polymorphism. In COBOL, if you have different parameter lists you need different entry points. In Java, the types of parameters are part of the definition. For example: COBOL: Decimal arithmetic Java: Not in native Java, but IBM has implemented some BigDecimal classes. I consider this the major weakness of Java for accounting type applications. I would have liked to see the packed decimal data type as part of the native JVM byte architecture. I guess it is not there because it is not in C or C++. I have only read about the BigDecimal classes, so I can't realy comment on their effectiveness. COBOL: COPY or INCLUDE Java: Inheritance ++: Much more powerfull! In COBOL, if you change a COPY or INCLUDE member, you must recompile all the programs that use it. In Java, if program B inherits from program A, a change in program A is automatically inherited by program B without recompiling! Yes, this really works, and lends great power to Java applications. I exploited this for my Read/Sort/Report system. Class IbfReport contains all the basic logic common to the report programs. It has appropriate defaults for all of its methods. Classes IbfRP#### extend IbfReport, and contain only those methods unique to a particular report. If a change is made in IbfReport, it is reflected in the IbfRP#### programs (classes) the next time they are run. COBOL: ON EXCEPTION Java: try/throw/catch ++: can limit scope of error detection (see following) COBOL: OPEN Java: Input Streams ++: Automatic error detection, both a blessing and a curse. COBOL: WRITE Java: write (yes, really). COBOL: CLOSE Java: close method COBOL: READ Java: read...
