[site]: stackoverflow
[post_id]: 4116700
[parent_id]: 4116069
[tags]: 
There are four ways to do that: Write an ARRAY-MAP function based on the array dimensions and iterate over those. Use ROW-MAJOR-AREF , which views the array like a vector. Use displaced one-dimensional arrays for the operations. Example for a use of displaced arrays: (defun array-map (function &rest arrays) "maps the function over the arrays. Assumes that all arrays are of the same dimensions. Returns a new result array of the same dimension." (flet ((make-displaced-array (array) (make-array (reduce #'* (array-dimensions array)) :displaced-to array))) (let* ((displaced-arrays (mapcar #'make-displaced-array arrays)) (result-array (make-array (array-dimensions (first arrays)))) (displaced-result-array (make-displaced-array result-array))) (declare (dynamic-extent displaced-arrays displaced-result-array)) (apply #'map-into displaced-result-array function displaced-arrays) result-array))) Using it: CL-USER 3 > (array-map #'1+ #2A((0 1 2) (3 4 5) (6 7 8))) #2A((1 2 3) (4 5 6) (7 8 9)) CL-USER 4 > (array-map #'+ #2A((1 2) (3 4) (5 6)) #2A((-1 -1) (-2 -2) (-3 -3)) ) #2A((0 1) (1 2) (2 3)) Use internal, implementation specific, operations for efficient array operations.
