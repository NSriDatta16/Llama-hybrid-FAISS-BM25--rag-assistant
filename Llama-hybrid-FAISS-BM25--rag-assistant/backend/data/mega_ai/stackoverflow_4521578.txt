[site]: stackoverflow
[post_id]: 4521578
[parent_id]: 4520935
[tags]: 
Actually you don't have to decide. You can combine. Here is a code sample for a full send/recv implementation. Just let me know if you improved it... h file: #pragma once #include // ========================================================================== // MSMQWrapper - wrappes the COM object used to send and receive messages through the MSMQ class CMSMQWrapper { HANDLE m_hQ; public: CMSMQWrapper() { m_hQ= INVALID_HANDLE_VALUE; ::CoInitializeEx(NULL, COINIT_MULTITHREADED); } ~CMSMQWrapper() { ::CoUninitialize(); } bool InitLocalQueue (const WCHAR* wczQueueName ); // [i] .\private$\queue_name bool InitDestQueue (const WCHAR* wczDestQueueName ); // [i] comp_name\private$\queue_name bool ReadQueue (const WCHAR* wczQueueName , // [i] BYTE* pBuf , // [i] size_t nBufLen , // [i] int& nBytesRead ); // [o] bool SendToDestQueue(const BYTE* pBuf , size_t nBufLen ); }; cpp file: #include "stdafx.h" #include "msmqwrap.h" #include #include #import "mqoa.dll" named_guids // no_namespace #pragma comment (lib, "Mqrt.lib") #include "mq.h" using namespace MSMQ; // ========================================================================== // CMSMQWrapper // ========================================================================== bool CMSMQWrapper::InitLocalQueue(const WCHAR* wczQueueName) { CComQIPtr ipQueueInfo; HRESULT hr= ::CoCreateInstance(CLSID_MSMQQueueInfo , NULL , CLSCTX_SERVER , IID_IMSMQQueueInfo , (void**)(&ipQueueInfo.p) ); if (S_OK != hr) return false; hr= ipQueueInfo->put_PathName(_bstr_t(wczQueueName)); if (S_OK != hr) return false; hr= ipQueueInfo->put_Label(_bstr_t(wczQueueName)); if (S_OK != hr) return false; VARIANT vtFalse; VariantInit(&vtFalse); vtFalse.vt = VT_BOOL; vtFalse.boolVal= FALSE ; try { hr= ipQueueInfo->Create(&vtFalse, &vtFalse); } catch (_com_error& er) { if (MQ_ERROR_QUEUE_EXISTS == er.Error()) // queue already exists hr= S_OK; else { // report error - Failed receiving, (WCHAR*)er.Description() return false; } } return true; } // -------------------------------------------------------------------------- bool CMSMQWrapper::ReadQueue(const WCHAR* wczQueueName, // [i] BYTE* pBuf , // [i] size_t nBufLen , // [i] int& nBytesRead ) // [o] { // set value of ReceiveTimout parameter _variant_t vtReceiveTimeout; vtReceiveTimeout= (long)INFINITE; try { IMSMQQueueInfoPtr qinfo("MSMQ.MSMQQueueInfo"); qinfo->PathName= wczQueueName; IMSMQQueuePtr qRec; qRec= qinfo->Open(MQ_RECEIVE_ACCESS, MQ_DENY_NONE); // open queue to retrieve message // retrieve messages from queue IMSMQMessagePtr msgRec("MSMQ.MSMQMessage"); msgRec= qRec->Receive(&vtMissing, &vtMissing, &vtMissing, &vtReceiveTimeout); if (NULL == msgRec) { nBytesRead= 0; // there are no messages in the queue return true; } nBytesRead = msgRec->BodyLength; _variant_t recVariant= msgRec->Body ; // close queue qRec->Close(); SAFEARRAY* psa= recVariant.parray; nBytesRead = __min(psa->rgsabound->cElements, nBufLen); for (LONG ind= 0; ind
