[site]: stackoverflow
[post_id]: 1784966
[parent_id]: 
[tags]: 
F# :: traversing lists There and Back Again

Write a function that counts the number of elements in the list that are larger than or equal to the average (using integer division for simplicity). Using just a single traversal of the list structure! I already have a solution to this, BUT it involves ref variable changed from closure foo' . I'm interested in a way how to functionally pass value when [] is met ? My naÃ¯ve solution using ref : let foo ls = let avg = ref 0 let rec foo' xs sumAcc lenAcc = match xs with | x'::xs' -> let s = foo' xs' (x' + sumAcc) (1 + lenAcc) if x' avg := (sumAcc / lenAcc) //? how to change THIS to functional code ? 0 foo' ls 0 0 EDIT (3) : I was interested in performance... on list [1..11000] `(my solution with REF) 5501: elapsed ` `(nlucaroni) 5501: elapsed ` `(kvb) 5501: elapsed ` ` since 1. and 3. solutions are non-tail-recursive, // simple two-pass solution let foo2pass (xs : System.Numerics.BigInteger list) = let len = System.Numerics.BigInteger.Parse(xs.Length.ToString()) let avg = List.sum xs / len (List.filter (fun x -> x >= avg) xs).Length two pass and kvb 's version works on big lists, ie: list [1I .. 10 000 000I] : (two-pass solution) 5000001: elapsed 5 times for each solution (kvb tail-recursive) 5000001I: elapsed (kvb tail-recursive) 5000001I: elapsed (kvb tail-recursive) 5000001I: elapsed and for list [1I .. 1 000 000I] , kvb 's solution is faster (two-pass solution) 500001I: elapsed (kvb tail-recursive) 500001: elapsed
