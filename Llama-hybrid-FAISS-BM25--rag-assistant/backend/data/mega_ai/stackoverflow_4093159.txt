[site]: stackoverflow
[post_id]: 4093159
[parent_id]: 
[tags]: 
what is the correct way to implement a QThread... (example please...)

The Qt documentation for QThread says to create a class from QThread, and to implement the run method. Below is taken from the 4.7 Qthread documentation... To create your own threads, subclass QThread and reimplement run(). For example: class MyThread : public QThread { public: void run(); }; void MyThread::run() { QTcpSocket socket; // connect QTcpSocket's signals somewhere meaningful ... socket.connectToHost(hostName, portNumber); exec(); } So in every single thread I've created, I've done just that and for most things it works just fine (I do not implement moveToThread(this) in any of my objects and it works great). I hit a snag last week (managed to get through it by working around where I created my objects) and found the following blog post . Here is basically says that subclassing QThread really isn't the correct way to do it (and that the documentation is incorrect). This is coming from a Qt developer so at first glance I was interested and upon further reflection, agree with him. Following OO principles, you really only want to subclass a class to further enhance that class... not to just use the classes methods directly... thats why you instantiate... Lets say I wanted to move a custom QObject class to a thread... what would be the 'correct' way of doing it? In that blog post, he 'says' he has an example somewhere... but if someone could further explain it to me it'd be greatly appreciated! Update: Since this question gets so much attention, here is a copy and paste of the 4.8 documentation with the 'proper' way to implement a QThread. class Worker : public QObject { Q_OBJECT QThread workerThread; public slots: void doWork(const QString &parameter) { // ... emit resultReady(result); } signals: void resultReady(const QString &result); }; class Controller : public QObject { Q_OBJECT QThread workerThread; public: Controller() { Worker *worker = new Worker; worker->moveToThread(&workerThread); connect(workerThread, SIGNAL(finished()), worker, SLOT(deleteLater())); connect(this, SIGNAL(operate(QString)), worker, SLOT(doWork(QString))); connect(worker, SIGNAL(resultReady(QString)), this, SLOT(handleResults(QString))); workerThread.start(); } ~Controller() { workerThread.quit(); workerThread.wait(); } public slots: void handleResults(const QString &); signals: void operate(const QString &); }; I still believe that it is worthwhile to point out that they include an extra Worker::workerThread member that is unnecessary and is never used in their example. Remove that piece and it is a proper example of how to do threading in Qt.
