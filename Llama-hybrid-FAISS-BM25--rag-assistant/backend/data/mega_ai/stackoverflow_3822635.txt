[site]: stackoverflow
[post_id]: 3822635
[parent_id]: 3785808
[tags]: 
Okay I tried to read the C++ standard myself to find some answers. I see from the answers I get that there is a lot of confusion about difference between constructing an object and allocating it. From the standard: 3.6.2 Initialization of non-local objects Objects with static storage duration (3.7.1) shall be zero-initialized (8.5) before any other initialization takes place. A reference with static storage duration and an object of POD type with static storage duration can be initialized with a constant expression (5.19); this is called constant initialization. Together, zero-initialization and constant initialization are called static initialization; all other initialization is dynamic initialization. Static initialization shall be performed before any dynamic initialization takes place. Dynamic initialization of an object is either ordered or unordered. My interpretatio of this is that a const char[] will always be guaranteed to have been set before any constructor is run. 3.6.3 Termination Destructors (12.4) for initialized objects of static storage duration (declared at block scope or at namespace scope) are called as a result of returning from main and as a result of calling std::exit (18.3). These objects are destroyed in the reverse order of the completion of their constructor or of the completion of their dynamic initialization. If an object is initialized statically, the object is destroyed in the same order as if the object was dynamically initialized. From what I can read from this POD types with constant expression will be initialized before any object types and destroyed after any object types. Meaning no code will run that can access them while they are not valid. Which should explain why Google's C++ code standard says you should only use POD types with constant expressions. : As a result we only allow static variables to contain POD data. This rule completely disallows vector (use C arrays instead), or string (use const char []).
