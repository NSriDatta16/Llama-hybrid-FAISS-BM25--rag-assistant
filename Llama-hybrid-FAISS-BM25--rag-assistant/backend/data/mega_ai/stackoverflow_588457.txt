[site]: stackoverflow
[post_id]: 588457
[parent_id]: 581247
[tags]: 
Knowing that it will be probably ok if the user have to log on once online before being able to log on offline , consider the following algorithm: user provides your application with a (username + password) application attempts to contact LDAP for authentication working online? (e.g. connection successful) application authenticates against LDAP using (username + password) authentication succesful? application stores or updates hash(password) as (cached_credentials) for (username) into local secure storage application proceeds as authenticated [[STOP]] authentication failed? application proceeds as non-authenticated (incorrect credentials) [[STOP]] working offline? (e.g. network error) application attempts retrieve (cached_credentials) for (username) from local secure storage (cached_credentials) exists AND more recent than (1 week) ? application compares (cached_credentials) against hash(password) match? application proceeds as authenticated [[STOP]] no match? application proceeds as non-authenticated (incorrect credentials) [[STOP]] (cached_credentials) does not exist OR less recent than (1 week) ? application proceeds as non-authenticated (network error) [[STOP]] This is (or was, IIRC), by the way, the same model employed by Windows NT+ for user authentication against domain controllers. Upon login an attempt is made to authenticate against the domain controller and create or update the local (cached) version of the user profile. If the domain controller is not available, the user is prompted to proceed with authentication against the credentials captured in the local (cached) profile (if one exists.) EDIT Yes, this is, in spirit, the same solution as copying an ldif file locally, except that you do not have to parse ldif when you're offline. :) It is understood that you can store any additional attributes (permissions, etc.) in your cache It is also understood that 'secure storage' is at least signed. :) You can do this easily enough with a SHA-1 hash and a secret, or you can use full-fledged cryptographic providers available on your platform (or in Java, if using Java.) You do not need to crypt it as long as no secret information is stored inside.
