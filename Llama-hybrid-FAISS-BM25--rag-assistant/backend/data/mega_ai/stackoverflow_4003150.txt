[site]: stackoverflow
[post_id]: 4003150
[parent_id]: 4003018
[tags]: 
Oh. The funny array arithmetic. The idea is to count from the end, so that when you reach the end you know you're done. In pieces: 1. Find the address of dataLength (BYTE*)(&dataLength) 2. Skip to the end of dataLength + sizeof(dataLength) 3. Back up by the number of bytes we expect to receive - cbLeftToReceive This is where we are writing the bytes we get from the network. As we get bytes from the network, we reduce cbLeftToReceive ( cbLeftToReceive -= cbBytesRet; ) and continue trying to receive bytes until we are done. So every time through the loop, bp points to where we need to write the next bytes we Receive(). EDIT: So now that we know how many bytes we're going to get, how to we receive them without potentially filling all of RAM with hunks of the data? We get a buffer, repeatedly fill it, and flush that buffer to disk whenever it's not empty. When there's still a lot of data (more than a buffer) left to receive, we try to Receive() a fill buffer. When there's less than a full buffer to go, we only request to the end of the file. iiGet = (cbLeftToReceive The we catch and handle errors. If there was no error, write however many bytes we got and reduce the number of bytes we expect to receive by the number we got. destFile.Write( recdData, iiRecd); // Write it cbLeftToReceive -= iiRecd; If we're still not done receiving bytes, go back to the top and keep going. while ( cbLeftToReceive > 0 ); General advice: It's good to practice reading code where you don't pay too much attention to the error handling and exception handling code. Typically what's left is much easier to understand.
