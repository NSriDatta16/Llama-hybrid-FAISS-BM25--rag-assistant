[site]: datascience
[post_id]: 37831
[parent_id]: 
[tags]: 
How to save Tensorflow predictions to data frame?

I am new to Tensorflow. I have trained Tensorflow model, but I need to take model predictions and add them to my original test set as a column. How can I do that? def model(self, layers_dims, X_train, Y_train, X_test, Y_test, learning_rate=0.00001, num_epochs=1000, print_cost=True): """ Implements a three-layer tensorflow neural network: LINEAR->RELU->LINEAR->RELU->LINEAR->SOFTMAX. Arguments: X_train -- training set, of shape (input size = 12288, number of training examples = 1080) Y_train -- test set, of shape (output size = 6, number of training examples = 1080) X_test -- training set, of shape (input size = 12288, number of training examples = 120) Y_test -- test set, of shape (output size = 6, number of test examples = 120) learning_rate -- learning rate of the optimization num_epochs -- number of epochs of the optimization loop minibatch_size -- size of a minibatch print_cost -- True to print the cost every 100 epochs Returns: parameters -- parameters learnt by the model. They can then be used to predict. """ ops.reset_default_graph() # to be able to rerun the model without overwriting tf variables tf.set_random_seed(1) # to keep consistent results seed = 3 # to keep consistent results (n_x, m) = X_train.shape # (n_x: input size, m : number of examples in the train set) n_y = Y_train.shape[0] # n_y : output size #print('Ytrain shape', Y_train.shape) costs = [] # To keep track of the cost # Create Placeholders of shape (n_x, n_y) X, Y = self.create_placeholders(n_x, n_y) # Initialize parameters parameters = NN_predict_trading_decisions.initialize_parameters(layers_dims) # Forward propagation: Build the forward propagation in the tensorflow graph ZL = NN_predict_trading_decisions.forward_propagation(X, parameters) # Cost function: Add cost function to tensorflow graph cost = NN_predict_trading_decisions.compute_cost(ZL, Y) # Backpropagation: Define the tensorflow optimizer. Use an AdamOptimizer. #optimizer = tf.train.AdamOptimizer(learning_rate=learning_rate).minimize(cost) optimizer = tf.train.GradientDescentOptimizer(learning_rate).minimize(cost) # Initialize all the variables init = tf.global_variables_initializer() # Start the session to compute the tensorflow graph with tf.Session() as sess: # Run the initialization sess.run(init) # Do the training loop for epoch in range(num_epochs): epoch_cost = 0. # Defines a cost related to an epoch current_cost = sess.run([optimizer, cost], feed_dict= {X: X_train, Y: Y_train}) epoch_cost += current_cost[1] # Print the cost every epoch if print_cost == True and epoch % 100 == 0: print("Cost after epoch %i: %f" % (epoch, epoch_cost)) if print_cost == True and epoch % 5 == 0: costs.append(epoch_cost) # plot the cost plt.plot(np.squeeze(costs)) plt.ylabel('cost') plt.xlabel('iterations (per tens)') plt.title("Learning rate =" + str(learning_rate)) plt.show() # lets save the parameters in a variable parameters = sess.run(parameters) print("Parameters have been trained!") # Calculate the correct predictions correct_prediction = tf.equal(tf.argmax(ZL), tf.argmax(Y)) # Calculate accuracy on the test set accuracy = tf.reduce_mean(tf.cast(correct_prediction, "float")) print("Train Accuracy:", accuracy.eval({X: X_train, Y: Y_train})) print("Test Accuracy:", accuracy.eval({X: X_test, Y: Y_test})) return parameters
