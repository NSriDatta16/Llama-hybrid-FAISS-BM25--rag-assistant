[site]: stackoverflow
[post_id]: 1050065
[parent_id]: 1049734
[tags]: 
In general, this is hard. The question of "who has a reference to me?" is not generally solvable in C++. It may be worth looking at the bigger picture of the specific problem(s) you are trying to solve, and seeing if there is a better way. There are a few things I can come up with that can get you partway there, but none of them are quite what you want. You can establish the concept of "the owning thread" for an object, and REJECT operations from any other thread, a la Qt GUI elements. (Note that trying to do things thread-safely from threads other than the owner won't actually give you thread-safety, since if the owner isn't checked it can collide with other threads.) This at least gives your users fail-fast behavior. You can encourage reference counting by having the user-visible objects being lightweight references to the implementation object itself [and by documenting this!]. But determined users can work around this. And you can combine these two-- i.e. you can have the notion of thread ownership for each reference , and then have the object become aware of who owns the references. This could be very powerful, but not really idiot-proof. You can start restricting what users can and cannot do with the object, but I don't think covering more than the obvious sources of unintentional error is worthwhile. Should you be declaring operator& private, so people can't take pointers to your objects? Should you be preventing people from dynamically allocating your object? It depends on your users to some degree, but keep in mind you can't prevent references to objects, so eventually playing whack-a-mole will drive you insane. So, back to my original suggestion: re-analyze the big picture if possible.
