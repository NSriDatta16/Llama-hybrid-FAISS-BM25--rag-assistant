[site]: stackoverflow
[post_id]: 1234015
[parent_id]: 1233958
[tags]: 
And it can be so simple... Either you use DataReceived handler but without a loop and certainly without Sleep(), read what data is ready and push it somewhere (to a Queue or MemoryStream), or Start a Thread (BgWorker) and do a (blocking) serialPort1.Read(...), and again, push or assemble the data you get. Edit: From what you posted I would say: drop the eventhandler and just Read the bytes inside Dowork(). That has the benefit you can specify how much data you want, as long as it is (a lot) smaller than the ReadBufferSize. Edit2, regarding Update2: You will still be much better of with a while loop inside a BgWorker, not using the event at all. The simple way: byte[] buffer = new byte[128]; // 128 = (average) size of a record while(port.IsOpen && ! worker.CancelationPending) { int count = port.Read(buffer, 0, 128); // proccess count bytes } Now maybe your records are variable-sized and you don't don't want to wait for the next 126 bytes to come in to complete one. You can tune this by reducing the buffer size or set a ReadTimeOut. To get very fine-grained you could use port.ReadByte(). Since that reads from the ReadBuffer it's not really any slower.
