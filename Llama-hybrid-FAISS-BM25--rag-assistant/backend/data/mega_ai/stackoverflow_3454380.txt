[site]: stackoverflow
[post_id]: 3454380
[parent_id]: 3452430
[tags]: 
A better representation of a bitmap index, is if given the sample above: Identifier Gender RowID 1 Female R1 2 Male R2 3 Male R3 4 Unspecified R4 5 Female R5 the a bitmap index on the gender column would (conceptually) look like this: Gender R1 R2 R3 R4 R5 Female 1 0 0 0 1 Male 0 1 1 0 0 Unspecified 0 0 0 1 0 Bitmap indexes are used when the number of distinct values in a column is relatively low (consider the opposite where all values are unique: the bitmap index would be as wide as every row, and as long making it kind of like one big identity matrix.) So with this index in place a query like SELECT * FROM table1 WHERE gender = 'Male' the database looks for a match in the gender values in the index, finds all the rowids where the bit was set to 1, and then goes and gets the table results. A query like: SELECT * FROM table1 WHERE gender IN ('Male', 'Unspecified') would get the 1 bits for Male, the 1 bits for Unspecified, do a bitwise-OR then go get the rows where the resulting bits are 1. So, the advantages of using a bitmap index over a b*tree index are storage (with low cardinality, bitmap indexes are pretty compact), and the ability to do bitwise operations before resolving the actual rowids which can be pretty quick. Note that bitmap indexes can have performance implications with inserts/deletes (conceptually, you add/remove a column to/from the bitmap and rejig it accordingly...), and can create a whole lot of contention as an update on a row can lock the entire corresponding bitmap entry and you can't update a different row (with the same bitmap value) until the first update is committed/rolled back.
