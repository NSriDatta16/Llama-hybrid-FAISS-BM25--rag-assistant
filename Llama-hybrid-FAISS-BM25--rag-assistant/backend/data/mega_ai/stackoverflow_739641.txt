[site]: stackoverflow
[post_id]: 739641
[parent_id]: 739589
[tags]: 
but this is not possible in fscanf, It is, with a bit of wickedness ;) Update: More clarification on evilness but unfortunately a bit wrong. I assume [^\n]%*[^\n] should read [^\n]%* . Moreover, one should note that this approach will strip whitespaces from the lines. â€“ dragonfly Note that xstr(MAXLINE) [^\n] reads MAXLINE characters which can be anything except the newline character (i.e. \n ). The second part of the specifier i.e. *[^\n] rejects anything (that's why the * character is there) if the line has more than MAXLINE characters upto but NOT including the newline character. The newline character tells scanf to stop matching. What if we did as dragonfly suggested? The only problem is scanf will not know where to stop and will keep suppressing assignment until the next newline is hit (which is another match for the first part). Hence you will trail by one line of input when reporting. What if you wanted to read in a loop? A little modification is required. We need to add a getchar() to consume the unmatched newline. Here's the code: #include #define MAXLINE 255 /* stringify macros: these work only in pairs, so keep both */ #define str(x) #x #define xstr(x) str(x) int main() { char line[ MAXLINE + 1 ]; /* Wickedness explained: we read from `stdin` to `line`. The format specifier is the only tricky part: We don't bite off more than we can chew -- hence the specification of maximum number of chars i.e. MAXLINE. However, this width has to go into a string, so we stringify it using macros. The careful reader will observe that once we have read MAXLINE characters we discard the rest upto and including a newline. */ int n = fscanf(stdin, "%" xstr(MAXLINE) "[^\n]%*[^\n]", line); if (!feof(stdin)) { getchar(); } while (n == 1) { printf("[line:] %s\n", line); n = fscanf(stdin, "%" xstr(MAXLINE) "[^\n]%*[^\n]", line); if (!feof(stdin)) { getchar(); } } return 0; }
