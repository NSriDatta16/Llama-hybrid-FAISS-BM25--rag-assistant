[site]: stackoverflow
[post_id]: 2949655
[parent_id]: 2949587
[tags]: 
I believe you've quoted the crucial paragraph, you just stopped too soon. 16.3.4/2 (emphasis mine): If the name of the macro being replaced is found during this scan of the replacement list (not including the rest of the source fileâ€™s preprocessing tokens), it is not replaced. Further, if any nested replacements encounter the name of the macro being replaced, it is not replaced. These nonreplaced macro name preprocessing tokens are no longer available for further replacement even if they are later (re)examined in contexts in which that macro name preprocessing token would otherwise have been replaced. So, when x is replaced with x[0] during the parameter substitution of y , it is fully macro replaced, meaning that it is rescanned at that point, and x is caught by the recursion rule. This means that the x in x[0] is no longer eligible for further replacement, including during the rescanning of the partly-expanded result of y(x) .
