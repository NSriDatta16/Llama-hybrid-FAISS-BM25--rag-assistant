[site]: stackoverflow
[post_id]: 671904
[parent_id]: 671861
[tags]: 
Test that the ‘two’ node has a child node before accessing its data. childNodes.item(i) (or the JavaScript simple form childNodes[i]) should generally be avoided, it's a bit fragile relying on whitespace text nodes being in the exact expected place. I'd do something like: var tracks= xmlDoc.getElementsByTagName('track')[0]; var track= tracks.getElementsByTagName('one')[0]; var info= track.getElementsByTagName('two')[0]; var value= info.firstChild? info.firstChild.data : ''; (If you don't know the tagnames of ‘one’ and ‘two’ in advance, you could always use ‘getElementsByTagName('*')’ to get all elements, as long as you don't need to support IE5, where this doesn't work.) An alternative to the last line is to use a method to read all the text inside the node, including any of its child nodes. This doesn't matter if the node only ever contains at most one Text node, but can be useful if the tree can get denormalised or contain EntityReferences or nested elements. Historically one had to write a recurse method to get this information, but these days most browsers support the DOM Level 3 textContent property and/or IE's innerText extension: var value= info.textContent!==undefined? info.textContent : info.innerText;
