[site]: crossvalidated
[post_id]: 529620
[parent_id]: 525251
[tags]: 
The proper way to account for error measuments in the y-values is weighted least squares . Seeing however that all y-values are corrupted by noise of the same standard deviation (0.1 in your code), standard least squares should return the same solution in this case. It seems that what you are doing in your second call to least squares, is replacing the y-values that come from the same x-values by their average. This of course will suppress the noise on them and will most likely lead to a better estimation as the averaged y-values are expected to be closer to the "true" y-values, i.e. the y-values before adding noise on them. Here, however, you should not notice any difference between your two solutions as the standard deviation of the noise is the same for all y-values. I guess the difference you observe, is purely down to numerics, as you are passing slightly different values to the solver. Perhaps it is worth trying out repeating the experiment with standard deviations that are different for each observed y-value. I am neither familiar with python nor the leastsq function, so I am not entirely sure what they should exactly deliver for your inputs.
