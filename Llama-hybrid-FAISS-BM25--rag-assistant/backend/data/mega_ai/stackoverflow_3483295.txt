[site]: stackoverflow
[post_id]: 3483295
[parent_id]: 3482941
[tags]: 
Resizing in C++ is awkward because of the potential need to call constructors and destructors. I don't think there's a fundamental reason why in C++ you couldn't have a resize[] operator to go with new[] and delete[] , that did something similar to this: newbuf = new Type[newsize]; std::copy_n(oldbuf, std::min(oldsize, newsize), newbuf); delete[] oldbuf; return newbuf; Obviously oldsize would be retrieved from a secret location, same is it is in delete[] , and Type would come from the type of the operand. resize[] would fail where the Type is not copyable - which is correct, since such objects simply cannot be relocated. Finally, the above code default-constructs the objects before assigning them, which you would not want as the actual behaviour. There's a possible optimisation where newsize , to call destructors for the objects "past the end" of the newly-ensmallened array and do nothing else. The standard would have to define whether this optimisation is required (as when you resize() a vector), permitted but unspecified, permitted but implementation-dependent, or forbidden. The question you should then ask yourself is, "is it actually useful to provide this, given that vector also does it, and is designed specifically to provide a resize-able container (of contiguous memory--that requirement omitted in C++98 but fixed in C++03) that's a better fit than arrays with the C++ ways of doing things?" I think the answer is widely thought to be "no". If you want to do resizeable buffers the C way, use malloc / free / realloc , which are available in C++. If you want to do resizeable buffers the C++ way, use a vector (or deque , if you don't actually need contiguous storage). Don't try to mix the two by using new[] for raw buffers, unless you're implementing a vector-like container.
