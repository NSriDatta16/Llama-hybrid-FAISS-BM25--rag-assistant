[site]: stackoverflow
[post_id]: 5573445
[parent_id]: 5568294
[tags]: 
Your expressions are not equivalent and thus you get skewed results. I wrote a test bench to test this. The tests include the regular lambda call, the equivalent compiled expression, a hand made equivalent compiled expression, as well as composed versions. These should be more accurate numbers. Interestingly, I'm not seeing much variation between the plain and composed versions. And the compiled expressions are slower naturally but only by very little. You need a large enough input and iteration count to get some good numbers. It makes a difference. As for your second question, I don't know how you'd be able to get more performance out of this so I can't help you there. It looks as good as it's going to get. You'll find my answer to your third question in the HandMadeLambdaExpression() method. Not the easiest expression to build due to the extension methods, but doable. using System; using System.Collections.Generic; using System.Linq; using System.Diagnostics; using System.Linq.Expressions; namespace ExpressionBench { class Program { static void Main(string[] args) { var values = Enumerable.Range(0, 5000); var lambda = GetLambda(); var lambdaExpression = GetLambdaExpression().Compile(); var handMadeLambdaExpression = GetHandMadeLambdaExpression().Compile(); var composed = GetComposed(); var composedExpression = GetComposedExpression().Compile(); var handMadeComposedExpression = GetHandMadeComposedExpression().Compile(); DoTest("Lambda", values, lambda); DoTest("Lambda Expression", values, lambdaExpression); DoTest("Hand Made Lambda Expression", values, handMadeLambdaExpression); Console.WriteLine(); DoTest("Composed", values, composed); DoTest("Composed Expression", values, composedExpression); DoTest("Hand Made Composed Expression", values, handMadeComposedExpression); } static void DoTest (string name, TInput sequence, Func operation, int count = 1000000) { for (int _ = 0; _ , IList > GetLambda() { return v => v.Where(i => i % 2 == 0).Where(i => i > 5).ToList(); } static Expression , IList >> GetLambdaExpression() { return v => v.Where(i => i % 2 == 0).Where(i => i > 5).ToList(); } static Expression , IList >> GetHandMadeLambdaExpression() { var enumerableMethods = typeof(Enumerable).GetMethods(); var whereMethod = enumerableMethods .Where(m => m.Name == "Where") .Select(m => m.MakeGenericMethod(typeof(int))) .Where(m => m.GetParameters()[1].ParameterType == typeof(Func )) .Single(); var toListMethod = enumerableMethods .Where(m => m.Name == "ToList") .Select(m => m.MakeGenericMethod(typeof(int))) .Single(); // helpers to create the static method call expressions Func , Expression> WhereExpression = (instance, param, body) => Expression.Call(whereMethod, instance, Expression.Lambda(body(param), param)); Func ToListExpression = instance => Expression.Call(toListMethod, instance); //return v => v.Where(i => i % 2 == 0).Where(i => i > 5).ToList(); var exprParam = Expression.Parameter(typeof(IEnumerable ), "v"); var expr0 = WhereExpression(exprParam, Expression.Parameter(typeof(int), "i"), i => Expression.Equal(Expression.Modulo(i, Expression.Constant(2)), Expression.Constant(0))); var expr1 = WhereExpression(expr0, Expression.Parameter(typeof(int), "i"), i => Expression.GreaterThan(i, Expression.Constant(5))); var exprBody = ToListExpression(expr1); return Expression.Lambda , IList >>(exprBody, exprParam); } static Func , IList > GetComposed() { Func , IEnumerable > composed0 = v => v.Where(i => i % 2 == 0); Func , IEnumerable > composed1 = v => v.Where(i => i > 5); Func , IList > composed2 = v => v.ToList(); return v => composed2(composed1(composed0(v))); } static Expression , IList >> GetComposedExpression() { Expression , IEnumerable >> composed0 = v => v.Where(i => i % 2 == 0); Expression , IEnumerable >> composed1 = v => v.Where(i => i > 5); Expression , IList >> composed2 = v => v.ToList(); var exprParam = Expression.Parameter(typeof(IEnumerable ), "v"); var exprBody = Expression.Invoke(composed2, Expression.Invoke(composed1, Expression.Invoke(composed0, exprParam))); return Expression.Lambda , IList >>(exprBody, exprParam); } static Expression , IList >> GetHandMadeComposedExpression() { var enumerableMethods = typeof(Enumerable).GetMethods(); var whereMethod = enumerableMethods .Where(m => m.Name == "Where") .Select(m => m.MakeGenericMethod(typeof(int))) .Where(m => m.GetParameters()[1].ParameterType == typeof(Func )) .Single(); var toListMethod = enumerableMethods .Where(m => m.Name == "ToList") .Select(m => m.MakeGenericMethod(typeof(int))) .Single(); Func , Expression> LambdaExpression = (param, body) => Expression.Lambda(body(param), param); Func , Expression> WhereExpression = (instance, param, body) => Expression.Call(whereMethod, instance, Expression.Lambda(body(param), param)); Func ToListExpression = instance => Expression.Call(toListMethod, instance); var composed0 = LambdaExpression(Expression.Parameter(typeof(IEnumerable ), "v"), v => WhereExpression( v, Expression.Parameter(typeof(int), "i"), i => Expression.Equal(Expression.Modulo(i, Expression.Constant(2)), Expression.Constant(0)))); var composed1 = LambdaExpression(Expression.Parameter(typeof(IEnumerable ), "v"), v => WhereExpression( v, Expression.Parameter(typeof(int), "i"), i => Expression.GreaterThan(i, Expression.Constant(5)))); var composed2 = LambdaExpression(Expression.Parameter(typeof(IEnumerable ), "v"), v => ToListExpression(v)); var exprParam = Expression.Parameter(typeof(IEnumerable ), "v"); var exprBody = Expression.Invoke(composed2, Expression.Invoke(composed1, Expression.Invoke(composed0, exprParam))); return Expression.Lambda , IList >>(exprBody, exprParam); } } } And the results on my machine: Lambda: Elapsed: 340971948 123230 (ms) Average: 340.971948 0.12323 (ms) Lambda Expression: Elapsed: 357077202 129051 (ms) Average: 357.077202 0.129051 (ms) Hand Made Lambda Expression: Elapsed: 345029281 124696 (ms) Average: 345.029281 0.124696 (ms) Composed: Elapsed: 340409238 123027 (ms) Average: 340.409238 0.123027 (ms) Composed Expression: Elapsed: 350800599 126782 (ms) Average: 350.800599 0.126782 (ms) Hand Made Composed Expression: Elapsed: 352811359 127509 (ms) Average: 352.811359 0.127509 (ms)
