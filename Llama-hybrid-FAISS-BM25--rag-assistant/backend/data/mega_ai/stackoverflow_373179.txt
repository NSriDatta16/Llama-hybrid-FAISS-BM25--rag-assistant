[site]: stackoverflow
[post_id]: 373179
[parent_id]: 373142
[tags]: 
Language techniques Pimpl Idiom Take a look at the Pimpl idiom here , and here , also known as an opaque pointer or handle classes. Not only does it speed up compilation, it also increases exception safety when combined with a non-throwing swap function. The Pimpl idiom lets you reduce the dependencies between headers and reduces the amount of recompilation that needs to be done. Forward Declarations Wherever possible, use forward declarations . If the compiler only needs to know that SomeIdentifier is a struct or a pointer or whatever, don't include the entire definition, forcing the compiler to do more work than it needs to. This can have a cascading effect, making this way slower than they need to be. The I/O streams are particularly known for slowing down builds. If you need them in a header file, try #including instead of and #include the header in the implementation file only. The header holds forward declarations only. Unfortunately the other standard headers don't have a respective declarations header. Prefer pass-by-reference to pass-by-value in function signatures. This will eliminate the need to #include the respective type definitions in the header file and you will only need to forward-declare the type. Of course, prefer const references to non-const references to avoid obscure bugs, but this is an issue for another question. Guard Conditions Use guard conditions to keep header files from being included more than once in a single translation unit. #pragma once #ifndef filename_h #define filename_h // Header declarations / definitions #endif By using both the pragma and the ifndef, you get the portability of the plain macro solution, as well as the compilation speed optimization that some compilers can do in the presence of the pragma once directive. Reduce interdependency The more modular and less interdependent your code design is in general, the less often you will have to recompile everything. You can also end up reducing the amount of work the compiler has to do on any individual block at the same time, by virtue of the fact that it has less to keep track of. Compiler options Precompiled Headers These are used to compile a common section of included headers once for many translation units. The compiler compiles it once, and saves its internal state. That state can then be loaded quickly to get a head start in compiling another file with that same set of headers. Be careful that you only include rarely changed stuff in the precompiled headers, or you could end up doing full rebuilds more often than necessary. This is a good place for STL headers and other library include files. ccache is another utility that takes advantage of caching techniques to speed things up. Use Parallelism Many compilers / IDEs support using multiple cores/CPUs to do compilation simultaneously. In GNU Make (usually used with GCC), use the -j [N] option. In Visual Studio, there's an option under preferences to allow it to build multiple projects in parallel. You can also use the /MP option for file-level paralellism, instead of just project-level paralellism. Other parallel utilities: Incredibuild Unity Build distcc Use a Lower Optimization Level The more the compiler tries to optimize, the harder it has to work. Shared Libraries Moving your less frequently modified code into libraries can reduce compile time. By using shared libraries ( .so or .dll ), you can reduce linking time as well. Get a Faster Computer More RAM, faster hard drives (including SSDs), and more CPUs/cores will all make a difference in compilation speed.
