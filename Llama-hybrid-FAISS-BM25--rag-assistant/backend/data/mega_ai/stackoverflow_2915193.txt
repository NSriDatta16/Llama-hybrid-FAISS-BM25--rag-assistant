[site]: stackoverflow
[post_id]: 2915193
[parent_id]: 
[tags]: 
Elegant way for a recursive C++ template to do something different with the leaf class?

I have a C++ class template that makes an Array of pointers. This also gets typedefed to make Arrays of Arrays and so on: typedef Array ElemArray; typedef Array ElemArrayArray; typedef Array ElemArrayArrayArray; I would like to be able to set one leaf node from another by copying the pointer so they both refer to the same Elem. But I also want to be able to set one Array (or Array of Arrays etc) from another. In this case I don't want to copy the pointers, I want to keep the arrays seperate and descend into each one until I get to the leaf node, at where I finally copy the pointers. I have code that does this (below). When you set something in an Array it calls a CopyIn method to do the copying. But because this is templated it also has to call the CopyIn method on the leaf class, which means I have to add a dummy method to every leaf class that just returns false. I have also tried adding a flag to the template to tell it whether it contains Arrays or not, and so whether to call the CopyIn method. This works fine - the CopyIn method of the leaf nodes never gets called, but it still has to be there for the compile to work! Is there a better way to do this? #include class Elem { public: Elem(int v) : mI(v) {} void Print() { printf("%d\n",mI); } bool CopyIn(Elem *v) { return false; } int mI; }; template class Array { public: Array(int size) : mB(0), mN(size) { mB = new T* [size]; for (int i=0; i CopyIn(v) ) { // its not an array, so copy the pointer mB[i] = v; } } bool CopyIn(Array * v) { for (int i=0; i mN ) { if ( ! mB[i]->CopyIn( v->mB[i] )) { // its not an array, so copy the pointer mB[i] = v->mB[i]; } } else { mB[i] = 0; } } return true; // we did the copy, no need to copy pointer } void Print() { for (int i=0; i Print(); } } private: T **mB; int mN; }; typedef Array ElemArray; typedef Array ElemArrayArray; typedef Array ElemArrayArrayArray; int main () { ElemArrayArrayArray* a = new ElemArrayArrayArray(2); ElemArrayArrayArray* b = new ElemArrayArrayArray(3); // In this case I need to copy the pointer to the Elem into the ElemArrayArray a->Get(0)->Get(0)->Set(0, b->Get(0)->Get(0)->Get(0)); // in this case I need go down through a and b until I get the to Elems // so I can copy the pointers a->Set(1,b->Get(2)); b->Get(0)->Get(0)->Get(0)->mI = 42; // this will also set a[0,0,0] b->Get(2)->Get(1)->Get(1)->mI = 96; // this will also set a[1,1,1] // should be 42,2, 2,2, 3,3, 3,96 a->Print(); }
