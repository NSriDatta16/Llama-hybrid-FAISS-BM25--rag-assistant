[site]: stackoverflow
[post_id]: 2782092
[parent_id]: 
[tags]: 
Casting a container of shared_ptr

I have a method void foo(list >& myList); Which I'm trying to call with a two different types of lists, one of DerivedClass1 and one of DerivedClass2 list > myList1; foo(myList1); list > myList2; foo(myList2); However this obviously generates a compiler error error: a reference of type "std::list , std::allocator >> &" (not const-qualified) cannot be initialized with a value of type "std::list , std::allocator >>" Is there any easy way to cast a container of shared_ptr? Of alternate containers that can accomplish this? Update : Thanks to everyone who responded. Working within the confines of the language, it seems the best way to go while keeping the method 'as-is' is to use a container of shared_ptr and pass exactly that in (creating a new list at the call site). I guess I pretty much already knew this, but I remembered reading about other parts of the boost library dealing with containers of shared_ptr and thought maybe it was solved more elegantly by someone else already. From my own further research however these seem to be geared more towards reducing overhead of shared_ptr in cases where a number of pointers are owned exclusively (therefore requiring a single lock per container rather than one per object in the container). Thanks again, you guys are all awesome!
