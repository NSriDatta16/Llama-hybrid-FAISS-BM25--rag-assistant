[site]: stackoverflow
[post_id]: 238789
[parent_id]: 165767
[tags]: 
Personally, I would just implement a function which takes a list and return a unique set. I've drafted something together which works for me: (defun make-set (list-in &optional (list-out '())) (if (endp list-in) (nreverse list-out) (make-set (cdr list-in) (adjoin (car list-in) list-out :test 'equal)))) Basically, the adjoin function prepends an item to a list non-destructively if and only if the item is not already present in the list, accepting an optional test function (one of the Common Lisp "equal" functions). You can also use pushnew to do so destructively, but I find the tail-recursive implementation to be far more elegant. So, Lisp does export several basic functions that allow you to use a list as a set; no built-in datatype is needed because you can just use different functions for prepending things to a list. My data source for all of this (not the function, but the info) has been a combination of the Common Lisp HyperSpec and Common Lisp the Language (2nd Edition) .
