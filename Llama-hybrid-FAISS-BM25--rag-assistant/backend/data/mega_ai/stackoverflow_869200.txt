[site]: stackoverflow
[post_id]: 869200
[parent_id]: 867723
[tags]: 
You can't do this: bitmapBytesPerRow = (pixelsWide * 1); // not * 4, because I just want alpha The function you're calling will always return all the image data. The kCGImageAlphaOnly constant is used to tell YOU that an image only contains an alpha channel, no colour information. You'll need to use pixelsWide * 4 for the bytesPerRow. Also note that the bitmapData argument to CGBitmapContextCreate() is used to provide storage space explicitly, rather than having it drawn for you. Possibly what you want to do is this (untested code, just typed from memory): CGImageRef image = GetMyImageFromWhereverItIs(); CGColorSpaceRef space = CGColorSpaceCreateDeviceRGB(); CGContextRef ctx = CGBitmapContextCreate( NULL, CGImageGetWidth(image), CGImageGetHeight(image), CGImageGetBitsPerComponent(image), CGImageGetBytesPerRow(image), space, kCGBitmapByteOrderDefault | kCGImageAlphaLast ); CGColorSpaceRelease( space ); // now draw the image into the context CGRect rect = CGRectMake( 0, 0, CGImageGetWidth(image), CGImageGetHeight(image) ); CGContextDrawImage( ctx, rect, image ); UInt32 * pixels = CGBitmapContextGetData( ctx ); // now we can iterate through the data & read the alpha values int i, count = CGBitmapContextGetBytesPerRow(ctx) * CGBitmapContextGetHeight(ctx); for ( i = 0; i
