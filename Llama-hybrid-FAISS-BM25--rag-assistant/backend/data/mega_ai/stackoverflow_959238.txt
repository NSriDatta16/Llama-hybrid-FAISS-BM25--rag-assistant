[site]: stackoverflow
[post_id]: 959238
[parent_id]: 
[tags]: 
Any sucess using UI-based program structuring?

Have you ever structured your source code based on your user interface parts? For example if your UI consists of: GridView for showing some properties 3D rendering panel panel for choosing active tools , then you name and group your variables and functions more or less in the following way: class Application { string PropertiesPanel_dataFile; DataSet PropertiesPanel_dataSet; string[] PropertiesPanel_dataIdColumn; void PropertiesPanel_OpenXml(); void PropertiesPanel_UpdateGridView(); string ThreeDView_modelFile; Panel ThreeDView_panel; PointF[] ThreeDView_objectLocations; void ThreeDView_RenderView(); string ToolPanel_configurationFile; Button[] ToolPanel_buttons; void ToolPanel_CreateButtons(); } What's your opinions on this? Can this architecture work in long run? PS. Even though this solution might remind you of Front-ahead-design april-fool's joke http://thedailywtf.com/Articles/FrontAhead-Design.aspx my question is serious one. EDIT Have been maintaining and extending this kind of code for half a year now. Application has grown to over 3000 lines in the main .cs file, and about 2000 lines spread out in to smaller files (that contain generic-purpose helper-functions and classes). There are many parts of the code that should be generalized and taken out of the main file, and I'm constantly working on that, but in the end it doesn't really matter. The structure and subdivision of the code is so simple, that it's really easy to navigate though it. Since the UI contains less than 7 major components, there's no problem in fitting the whole design in you head at once. It's always pleasant to return to this code (after some break) and know immediately where to start from. I guess one the reasons this gigantic procedural-like structure works in my case is the event-like nature of UI programming in c#. For the most part all this code does is implementation of different kinds of events, that are really specific to this project. Even though some event-functions immediately grow into couple of pages long monsters, coupling between event-handlers is not that tight, so it makes it easier to refactor and compress them afterwards. That's why Iam intentionally leaving generalization and refactoring for later time, when other projects start to require the same parts of implementation that this project uses. PS to make it possible to navigate through 3000 lines of code I'm using FindNextSelection- and FindPrevSelection-macros in visual studio. After left-clicking on some variable I'm pressing F4 to jump to the next instance of it, and F2 to the previous instance. It's also possible to select some part of variable name and jump between partial-name matches. Without these shortcuts I would most defenetly lost my way long time ago :)
