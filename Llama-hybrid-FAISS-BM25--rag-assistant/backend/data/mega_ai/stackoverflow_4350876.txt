[site]: stackoverflow
[post_id]: 4350876
[parent_id]: 4349375
[tags]: 
Fun little problem :) If you look at the diagram closer, the sequence is clearly stated: There are probably many solutions to drawing these, maybe more elegant, but here's mine: You know the hypotenuse is square root of the current segment count+1 and the opposite side of the triangle is always 1. Also you know that Sine(Math.sin) of the angle is equal to the opposite side divided by the hypotenuse. from the old mnenonic SOH(Sine,Opposite,Hypotenuse),-CAH-TOA. Math.sin(angle) = opp/hyp You know the value of the sine for the angle, you know the two sides, but you don't know the angle yet, but you can use the arc sine function(Math.asin) for that angle = Math.asin(opp/hyp) Now you know the angle for each segment, and notice it increments with each line. Now that you have an angle and a radius(the hypotenuse) you can use for polar to cartesian formula to convert that angle,radius pair to a x,y pair. x = Math.cos(angle) * radius; y = Math.sin(angle) * radius; Since you asked for an actionscript solution, there Point class already provides this function for you through the polar() method. You pass it a radius and angle and it returns your x and y in a Point object. Here's a little snippet which plots the spiral. You can control the number of segments by moving the mouse on the Y axis. var sw:Number = stage.stageWidth,sh:Number = stage.stageHeight; this.addEventListener(Event.ENTER_FRAME,update); function update(event:Event):void{ drawTheodorus(144*(mouseY/sh),sw*.5,sh*.5,20); } //draw points function drawTheodorus(segments:int,x:Number,y:Number,scale:Number):void{ graphics.clear(); var points:Array = getTheodorus(segments,scale); for(var i:int = 0 ; i 0) graphics.lineTo(points[i-1].x,points[i-1].y);//draw opposite } } //calculate points function getTheodorus(segments:int = 1,scale:Number = 10):Array{ var result = []; var radius:Number = 0; var angle:Number = 0; for(var i:int = 0 ; i used asin to get angle result[i] = Point.polar(radius*scale,angle);//same as new Point(Math.cos(angle)*radius.scale,Math.sin(angle)*radius.scale) } return result; } This could've been written in less lines, but I wanted to split this into two functions: one that deals only with computing the numbers, and the other which deals with drawing the lines. Here are some screenshots: For fun I added a version of this using ProcessingJS here . Runs a bit slow, so I would recommend Chromium/Chrome for this. Now you can actually run this code right here (move the mouse up and down): var totalSegments = 850,hw = 320,hh = 240,segments; var len = 10; points = []; function setup(){ createCanvas(640,480); smooth(); colorMode(HSB,255,100,100); stroke(0); noFill(); //println("move cursor vertically"); } function draw(){ background(0); translate(hw,hh); segments = floor(totalSegments*(mouseY/height)); points = getTheodorus(segments,len); for(var i = 0 ; i 0) line(points[i].x,points[i].y,points[i-1].x,points[i-1].y); } } function getTheodorus(segments,len){ var result = []; var radius = 0; var angle = 0; for(var i = 0 ; i
