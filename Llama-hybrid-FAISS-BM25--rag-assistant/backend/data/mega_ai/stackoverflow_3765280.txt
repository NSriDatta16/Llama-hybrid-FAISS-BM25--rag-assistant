[site]: stackoverflow
[post_id]: 3765280
[parent_id]: 3764912
[tags]: 
I see two possible solutions. static Make the Register() method a template. The simple solution would be to limit the number of dependencies to some reasonable maximum. template void Register(T* test_case, IDependency * d1) { BOOST_STATIC_ASSERT(boost::is_base_and_derived , T>::value); // since we now know that T is a IDependent , a dynamic_cast would only be necessary // to allow virtual inheritance. static_cast *>(test_case)->SetDependency(d1); Register(test_case); } template void Register(T* test_case, IDependency * d1, IDependency * d2) { BOOST_STATIC_ASSERT(boost::is_base_and_derived , T>::value); static_cast *>(test_case)->SetDependency(d1); Register(test_case, d2); } template void Register(T* test_case, IDependency * d1, IDependency * d2, IDependency * d3) { BOOST_STATIC_ASSERT(boost::is_base_and_derived , T>::value); static_cast *>(test_case)->SetDependency(d1); Register(test_case, d2, d3); } // ... With compilers that support variadic templates this could probably be written in just one function template, for an unlimited amount of dependencies. Alternatively you could make Register() return a proxy-class, so that you could write something like this: Register(test_case)(dep1)(dep2)(dep3) /* ... */ (depN); The proxy class would store a pointer to the container and the test-case, and define a function-call-operator that looks just like the Register(T* test_case, IDependency* d1) function in the example above, only without the "test_case" argument and the final call to Register(test_case) (which one could do in the dtor of the proxy class). dynamic If I understand what you're trying to do correctly, every "Dependency" can only produce one type of result. In that case you could modify the IDependency interface like this: class IDependencyBase { public: virtual void ApplyTo(ITest* target) = 0; }; template class IDependency : public IDependencyBase { public: virtual void ApplyTo(ITest* target) { // cast to reference gives us an std::bad_cast if the types are not compatible, // which I think is a good thing here dynamic_cast &>(*target).SetDependancy(this); } virtual T Get() = 0; }; template void Register(ITest* test_case, InputIterator begin, InputIterator end) { for (; begin != end; ++begin) { IDependancyBase* dep = *begin; dep->ApplyTo(test_case); } Register(test_case); } template void Register(ITest* test_case, Container deps) { Register(test_case, deps.begin(), deps.end()); } Now it might seem tempting to you to implement your varargs solution again, something like this (continuing from the second example): void Register(ITest* test_case, ...) { va_list dep_list; va_start(dep_list, test_case); while(IDependencyBase* dep = va_arg(dep_list, ITest*)) dep->ApplyTo(test_case); va_end(dep_list); Register( test_case ); } // and use it like int _tmain( int argc, _TCHAR* argv[] ) { Foo foo; Bar bar; Register(&foo); Register(&bar, &foo, 0); list_->begin()->Execute(); return 0; } However that isn't guaranteed to work. In the code above, a Foo* is stored as a varagrs argument, and read back as a IDependencyBase*. That's not guaranteed to work, since neither Foo nor IDependencyBase are PODs (IIRC they would both have to be PODs for this to be guaranteed to work -- maybe it's not guaranteed even then, I'd have to look it up in the standard). This is not some far fetched "not guaranteed by the standatd but will work everywhere" thing. Introduce multiple and/or virtual inheritance and this is almost guaranteed to fail. So general advice when using C++: don't use varargs functions unless there is no other way. And there is always another way.
