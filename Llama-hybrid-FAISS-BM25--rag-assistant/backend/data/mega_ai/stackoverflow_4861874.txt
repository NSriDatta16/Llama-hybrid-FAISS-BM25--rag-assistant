[site]: stackoverflow
[post_id]: 4861874
[parent_id]: 4860493
[tags]: 
"As space-efficient as an ordinary hash-table" is a rather vague specification, since "ordinary" may mean linked or probed depending on who you ask. I don't think anyone has designed easy-to-understand persistent hash tables yet. The easiest way to get a persistent key-value map with the complexity that you want is to use a persistent binary search tree. Lookup is the familiar algorithm from ephemeral (non-persistent) BSTs. Insert changes however, and becomes something like (pseudo-Java): // overwrites the value for k if it's already in the tree Node insert(Node node, Key k, Value v) { if (k node.key) return new Node(node.key, node.val, node.left, insert(node.right, k, v)); else return new Node(k, v, node.left, node.right); } Note that the insert routine returns a new tree, which may seem inefficient, but it only changes those nodes it traverses. This is on average O(lg n ), so it does O(lg n ) allocations on average. This is about as space-efficient as it gets. To get worst-case O(lg n ) behavior, use a red-black tree. See also the literature on data structures in functional programming, e.g. the works of Okasaki.
