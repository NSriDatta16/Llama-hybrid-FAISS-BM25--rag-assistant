[site]: stackoverflow
[post_id]: 475373
[parent_id]: 405338
[tags]: 
There are multiple ways you could go about implementing a fragment id into your URLs. Below are some options, along with some pros and cons for each. Direct Add You could simply add the "#$fragment_id" after your url() call. Inelegant, but simple. If you don't use page anchors much (i.e. One or two pages only), this is the way to go. Write a custom url() helper You could write a custom version of url() appending an optional 5th argument for the fragment id: class My_View_Helper_Url extends Zend_View_Helper_Url { public function url(array $urlOptions = array(), $name = null, $reset = false, $encode = true, $fragment_id = null) { $uri = parent::url($urlOptions, $name, $reset, $encode); if(!is_null($fragment_id)) { $uri .= "#$fragment_id"; } return $uri; } } This way, anchor (and anchor/fragment id) information is kept strictly withing the realm of the View. This is good for general use, but can get a little unwieldy for the default route. Also, this is still a little too hard-coded for some uses. Write a custom Route class (Extreme) As a third option, you could write a custom version of the Zend_Controller_Router_Route class(es), specifically the assemble($data, $reset, $encode) method (the match($path) method ignores fragment ids by default). Using this method can be quite tricky, but very useful, especially if use is only limited to specific routes (this method can be used to base the fragment id off of any variable). Caveat Certain considerations must be taken into account when using fragment ids. For example, query strings have to precede the fragment id in the uri, otherwise, the query string ignored by PHP. However, most ZF applications tend to avoid use of query strings, so it may not be an issue.
