[site]: crossvalidated
[post_id]: 436109
[parent_id]: 410727
[tags]: 
To tackle your problem you could fit a logistic regression playing with your covariates to capture the time and group effects conjointly. library(Hmisc) #> Loading required package: lattice #> Loading required package: survival #> Loading required package: Formula #> Loading required package: ggplot2 #> #> Attaching package: 'Hmisc' #> The following objects are masked from 'package:base': #> #> format.pval, units library(rms) #> Loading required package: SparseM #> #> Attaching package: 'SparseM' #> The following object is masked from 'package:base': #> #> backsolve library(broom) library(modelr) #> #> Attaching package: 'modelr' #> The following object is masked from 'package:broom': #> #> bootstrap library(yardstick) #> For binary classification, the first factor level is assumed to be the event. #> Set the global option `yardstick.event_first` to `FALSE` to change this. #> #> Attaching package: 'yardstick' #> The following objects are masked from 'package:modelr': #> #> mae, mape, rmse library(tidyverse) make_obs % complete(nesting(Group, Ind), Day = 1:15) %>% mutate( Obs = make_obs(Group, Day) ) example_data %>% group_by(Group, Day) %>% summarise(prop = mean(Obs)) %>% ggplot(aes(Day, prop, group=Group)) + geom_line() By examining the grouped plot by day and group form the data you generated, you can see that there is a highly non linear effect from day and group interactions. I propose the following 4 model to study how the effect of Day and Group onto Obs. In models 3 and 4 I fit a non-linear transformation to Days, a restricted cubic spline to attempt to capture the effect mentioned in the previous plot. df % group_by(model, Group, Day) %>% summarise(prop = mean(Obs), fitted = mean(pred) ) %>% ggplot(aes(x = Day, group=Group)) + geom_line(aes(y = prop)) + geom_line(aes(y = fitted, group=model, color = model), lty='dashed') + facet_wrap(~Group, ncol =1) I the gather the predictions from each model and aggregate them to have a visual check of fit. As you can see, models 3 and 4 capture the effect you are interested in. md_frame % augment( . , df, type.predict='response') %>% mutate(Obs = as.factor(Obs)) %>% yardstick::roc_auc(., truth=Obs, .fitted) %>% pull(.estimate) md_frame %>% mutate(auc = map_dbl(model, get_auc)) %>% mutate(other_metrics = map(model, glance)) %>% unnest(other_metrics) %>% select(model_number = number, auc, AIC, deviance, BIC, logLik) -> metrics metrics %>% pivot_longer(-model_number, names_to = 'metric_name', values_to='values') %>% mutate(model_number = paste0('model ', model_number)) %>% ggplot(aes(model_number, values)) + geom_point(aes(fill=model_number), size = 4, pch=21, show.legend = F) + facet_wrap(~metric_name, scales = 'free') + labs(title = 'Model metrics', x = NULL, y=NULL) Now, to check the metrics for accessing the quality of fit from each of these models also indicate that models 3 and 4 capture the Days effect. By inspecting the models you can check the coefficients. Now, if you intend to perform some statistical inferences with these models, there are better approaches when it comes estimating nested variances and time dependent effects, so a longitudinal approach could be advantageous here. Created on 2019-11-14 by the reprex package (v0.3.0)
