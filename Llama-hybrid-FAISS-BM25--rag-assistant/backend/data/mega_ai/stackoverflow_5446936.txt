[site]: stackoverflow
[post_id]: 5446936
[parent_id]: 5446855
[tags]: 
One of your possible issues is that when you have the following line: tmp_s = np.array; tmp_idx = np.array; You are setting tmp_s and tmp_idx to the built-in function np.array. Then when you append, you have have object type arrays, which np.interp has no idea how to deal with. I think you probably thought that you were creating empty arrays of zero length, but that isn't how numpy or python works. Try something like the following instead: class myClass def myfunction(self, in_array, in_indeces = None): if(in_indeces is None): self.indeces = np.arange(len(in_array)) # NOTE: Use in_array.size or in_array.shape[0], etc instead of len() else: self.indeces = in_indeces # clean data # set ii to the indices of in_array that are neither nan or inf ii = ~np.isnan(in_array) & ~np.isinf(in_array) # assuming in_indeces and in_array are the same shape tmp_s = in_array[ii] tmp_idx = in_indeces[ii] self.indeces = np.arange(tmp_idx.size) self.samples = np.interp(self.indeces, tmp_idx, tmp_s) No guarantees that this will work perfectly, since I don't know your inputs or desired outputs, but this should get you started. As a note, in numpy, you are generally discouraged from looping through array elements and operating on them one at a time, if there is a method that performs the desired operation on the entire array. Using built-in numpy methods are always much faster. Definitely look through the numpy docs to see what methods are available. You shouldn't treat numpy arrays the same way you would treat a regular python list.
