[site]: stackoverflow
[post_id]: 1557660
[parent_id]: 1548209
[tags]: 
Keep in mind that things like ISeq are Java. In Clojure the seq abstraction is really just 'something' that you can supply to the first, rest and nth functions (note you don't call first on a seq, you call first with a seq argument). The Clojure language core functions all operate on collections, seqs, or primitive types. There is no data bundled with methods in the exposed interfaces. So the implementation of Clojure is in Java and all interop with JVM is going to involve Classes/Objects, but Clojure the language itself does not. Bundling methods with data structures is what Clojure discourages. Having said all that... the reality is that functions do have limitations on what arguments they will work with. first rest and nth will only work on something that can be a seq. From this perspective there isn't much difference whether the data structures are bundled with methods or not - you still have to match them up correctly. The big wins come from the flexibility. Functions can be written to take any arguments and then composed with higher order functions without defining classes etc: (def farms [{:name "Swansea", :value 100} {:name "Broadmarsh", :value 200, :produce [:corn :wheat :rye]} {:name "Snug", :value 50, :animals [:goats :pigs]}]) (reduce + (map :value farms)) -> 350 (reduce + (map :value (filter :animals farms))) -> 50
