[site]: stackoverflow
[post_id]: 550907
[parent_id]: 550887
[tags]: 
An alternative way to do this is to create a wrapper around the SmtpClient that implements the same interface. Then inject and use the wrapper in your class. When doing unit testing you can then substitute a mock wrapper that has expectations for the method calls and responses. EDIT : The wrapper is needed (for RhinoMocks, at least) because SmtpClient doesn't derive from an interface and doesn't have virtual methods. If you use a mocking framework that can mock a class without virtual methods directly, you can skip the wrapper and inject the SmtpClient mock directly. public class SmtpClientWrapper { private SmtpClient Client { get; set; } public SmtpClientWrapper( SmtpClient client ) { this.Client = client; } public virtual void Send( MailMessage msg ) { this.Client.Send( msg ); } ... } public class MyClass { private SmtpClientWrapper Client { get; set; } public MyClass( SmtpClientWrapper client ) { this.Client = client; } public void DoSomethingAndNotify() { ... this.Client.Send( msg ); } } Tested (with RhinoMocks) as: public void DoSomethingAndNotifySendsAMessageTest() { SmtpClientWrapper client = MockRepository.GenerateMock (); client.Expect( c => c.Send( new MailMessage() ) ).IgnoreArguments(); MyClass klass = new MyClass( client ); klass.DoSomethingAndNotify(); client.VerifyAllExpectations(); }
