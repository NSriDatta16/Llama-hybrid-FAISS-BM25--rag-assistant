[site]: stackoverflow
[post_id]: 3137528
[parent_id]: 3137476
[tags]: 
As far as I know, there is no way to enforce a type-specific check on a single property of an attribute. However, and let me note that this is not the most elegant solution, you could use polymorphism to your advantage: [AttributeUsage(AttributeTargets.Property)] public class ColumnBindAttribute: Attribute { public string ColumnName { get; set; } public object DefaultUntypedValue { get; protected set; } } [AttributeUsage(AttributeTargets.Property)] public class ColumnBindGenericAttribute : ColumnBindAttribute { public T DefaultValue { get { return (T)DefaultUntypedValue; } set { DefaultUntypedValue = value; } } } [AttributeUsage(AttributeTargets.Property)] public class ColumnBindInt32Attribute: ColumnBindGenericAttribute {} [ColumnBindInt32(ColumnName = "Category", DefaultValue = 100)] public int CategoryId { get; set; } When retrieving an attribute, the search looks for both the specific type, as well as base types, of the attribute actually applied to the member. You could retrieve all of the ColumBindAttributes decorating a member even if they are derived attributes. EDIT: Apologies. The code will not compile if any generic type, directly or indirectly, derives from the Attribute type. That makes the ColumnBindGenericAttribute class impossible. I thought I had found a hole in the compiler...turns out its smarter than me. :P
