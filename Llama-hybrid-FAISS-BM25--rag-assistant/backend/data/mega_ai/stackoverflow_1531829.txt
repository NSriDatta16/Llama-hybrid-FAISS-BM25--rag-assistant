[site]: stackoverflow
[post_id]: 1531829
[parent_id]: 1531702
[tags]: 
How about we test instead of guess? Shame to see the wrong answer get out. var ints = Enumerable.Range(0, 10000000).ToList(); var sw1 = Stopwatch.StartNew(); var findall = ints.FindAll(i => i % 2 == 0); sw1.Stop(); var sw2 = Stopwatch.StartNew(); var where = ints.Where(i => i % 2 == 0).ToList(); sw2.Stop(); Console.WriteLine("sw1: {0}", sw1.ElapsedTicks); Console.WriteLine("sw2: {0}", sw2.ElapsedTicks); /* Debug sw1: 1149856 sw2: 1652284 Release sw1: 532194 sw2: 1016524 */ Edit: Even if I turn the above code from var findall = ints.FindAll(i => i % 2 == 0); ... var where = ints.Where(i => i % 2 == 0).ToList(); ... to ... var findall = ints.FindAll(i => i % 2 == 0).Count; ... var where = ints.Where(i => i % 2 == 0).Count(); I get these results /* Debug sw1: 1250409 sw2: 1267016 Release sw1: 539536 sw2: 600361 */ Edit 2.0... If you want a list of the subset of the current list the fastest method if the FindAll(). The reason for this is simple. The FindAll instance method uses the indexer on the current List instead of the enumerator state machine. The Where() extension method is an external call to a different class that uses the enumerator. If you step from each node in the list to the next node you will have to call the MoveNext() method under the covers. As you can see from the above examples it is even faster to use the index entries to create a new list (that is pointing to the original items, so memory bloat will be minimal) to even just get a count of the filtered items. Now if you are going to early abort from the Enumerator the Where() method could be faster. Of course if you move the early abort logic to the predicate of the FindAll() method you will again be using the indexer instead of the enumerator. Now there are other reasons to use the Where() statement (such as the other linq methods, foreach blocks and many more) but the question was is the FindAll() faster than Where(). And unless you don't execute the Where() the answer seems to be yes. (When comparing apples to apples) I am not say don't use LINQ or the .Where() method. They make for code that is much simpler to read. The question was about performance and not about how easy you can read and understand the code. By fast the fastest way to do this work would be to use a for block stepping each index and doing any logic as you want (even early exits). The reason LINQ is so great is becasue of the complex expression trees and transformation you can get with them. But using the iterator from the .Where() method has to go though tons of code to find it's way to a in memory statemachine that is just getting the next index out of the List. It should also be noted that this .FindAll() method is only useful on objects that implmented it (such as Array and List.) Yet more... for (int x = 0; x i % 2 == 0).Count; sw1.Stop(); var sw2 = Stopwatch.StartNew(); var where = ints.AsEnumerable().Where(i => i % 2 == 0).Count(); sw2.Stop(); var sw4 = Stopwatch.StartNew(); var cntForeach = 0; foreach (var item in ints) if (item % 2 == 0) cntForeach++; sw4.Stop(); Console.WriteLine("sw1: {0}", sw1.ElapsedTicks); Console.WriteLine("sw2: {0}", sw2.ElapsedTicks); Console.WriteLine("sw4: {0}", sw4.ElapsedTicks); } /* averaged results sw1 575446.8 sw2 605954.05 sw3 394506.4 /*
