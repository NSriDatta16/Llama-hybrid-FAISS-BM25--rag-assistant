[site]: stackoverflow
[post_id]: 4877967
[parent_id]: 4877841
[tags]: 
Think of the asterisk as a "barrier". Qualifiers ( const or volatile ) closer to the variable name than the asterisk modify the pointer itself. Qualifiers farther way from the variable name than the asterisk modify what the pointer will refer to. In this case, therefore, you would have: static void * volatile f_pointer(void *); Except, of course, that you need parens to define a pointer to a function instead of declaring a function returning a pointer: static void (*volatile f_pointer)(void *); static is a storage class rather than a qualifier, so the same is not true in its case. You can only specify a storage class for the variable itself, not what it points at. There's no such thing as a "pointer to extern int" or "pointer to static int", only "pointer to int". If you specify a storage class ( static or extern ), it always comes first . Other threads have discussed the relationship between threading and volatile so I won't repeat that here beyond noting that this probably won't be useful.
