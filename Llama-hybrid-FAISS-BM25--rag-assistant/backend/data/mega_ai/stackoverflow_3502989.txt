[site]: stackoverflow
[post_id]: 3502989
[parent_id]: 3500094
[tags]: 
Your fetchedResults variable contains a NSArray object. However, a NSArray can hold any arbitrary group of objects. Unlike a standard C array, there is no requirement that the NSArray objects all be of a single class. The dot notation you are using here: [fetchResults objectAtIndex:i].UserID = ... while a legal syntax, nevertheless confuses the compiler because the compiler has no idea what class of object is returned by [fetchResults objectAtIndex:i] . Without knowing the class it has no idea what the heck UserID is. Hence the error "request for member 'UserID' in something not a structure or union" . At the very least you have to cast the return of [fetchResults objectAtIndex:i] to some class so that the complier has a clue as to what 'UserID' is. However, you simply shouldn't use this construction even though it legal because it is dangerous. See below for the best practice form. Understanding NSManagedObject and its subclasses can be tricky because NSManagedObject itself uses a trick called associative storage which allows any generic NSManagedObject instances to store any property of any entity defined in any model. This can confuse novices because there are multiple ways to refer to the same entities, instances and properties. Sometimes the examples use generic NSMangedObjects and setValue:forKey: / valueForKey: and other times they use objectInstance.propertyName . Associative storage works like a dictionary attached to every instance of the NSManagedObject class. When you insert a generic NSManagedObject like this: NSManagedObject *mo=[NSEntityDescription insertNewObjectForEntityForName:@"User" inManagedObjectContext:self.managedObjectContext]; ... you get an instance of the NSManageObject class whose associative storage keys are set to the properties of the User entity as defined in your data model. You can then set and retrieve the values using key-value coding (which has the same syntax as dictionaries) thusly: [mo setValue:@"userid0001" forKey:@"UserID"]; NSString *aUserID=[mo valueForKey:@"UserID"]; Associative storage allows you represent any complex data model in code without having to write any custom NSManagedObject subclasses. (In Cocoa, it allows you to use bindings which let you create entire programs without writing any data management code at all.) However, the generic NSManagedObject class is little better than a glorified dictionary whose saving and reading is handled automatically. If you need data objects with customized behaviors you need to explicitly define a NSManagedObject subclass. If you let Xcode generate the class from the entity in the data model you end up with a source file something like: User.h @interface User : NSManagedObject { } @property (nonatomic, retain) NSString * firstName; @property (nonatomic, retain) NSString * userID; @property (nonatomic, retain) NSString * lastName; @end User.m #import "User.h" @implementation User @dynamic firstName; @dynamic userID; @dynamic lastName; @end Now, you are no longer limited by to the key-value syntax of associative storage. You can use the dot syntax because the complier has a class to refer to: User *aUser=[NSEntityDescription insertNewObjectForEntityForName:@"User" inManagedObjectContext:self.managedObjectContext]; aUser.userID=@"userID0001"; NSString *aUserID=aUser.userID; With all this in mind, the proper forms of reference to the fetchedResults array become clear. Suppose you want to set all userID properties to a single default value. If you use the generic NSManagedObject class you use: for (NSManagedObject *aMO in fetchedResults) { [aMO setValue:@"userid0001" forKey:@"UserID"]; NSString *aUserID=[aMO valueForKey:@"UserID"]; } If you use a dedicated subclass you would use: for (User *aUserin fetchedResults) { aUser.userID=@"userID0001"; NSString *aUserID=aUser.userID; } (Note: you can always use the generic form for all NSManagedObject subclasses as well.)
