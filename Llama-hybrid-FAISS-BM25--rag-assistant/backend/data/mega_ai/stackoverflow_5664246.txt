[site]: stackoverflow
[post_id]: 5664246
[parent_id]: 
[tags]: 
Release Mode doesn't allow large textures

Is there any setting in MS Visual Studio 2005 that will prevent OpenGL from allocating large textures? I am experiencing the following behavior: The situation: I create two large objects: one texture and one buffer both about 260 mb In Debug Mode: Allocation and use of both objects works fine. I can even destroy and recreate the objects several times with different but comparable sizes. In Release Mode: The Buffer is allocated but OpenGL throws [1] an OUT_OF_MEMORY error when i try to allocate the texture. At this point there is about 1000mb video memory available. [2] Does anyone know some MSVC settings/parameters/whatever that can affect OpenGL in this way? confused Edit adding some code: This is the place i create the buffer (called updateBuffer): glm::u32 size = glm::compMul(size) * sizeof(glm::u16); util::odprintf("[...] creating updatebuffer\n"); util::odprintf("[...] - for texture size: %s\n", glm::string(size).c_str()); util::odprintf("[...] - new size: %.2fkb\n", size / 1024.0f); updateBuffer.create(size, GL_STREAM_DRAW); util::odprintf("[...] - done\n"); At this point the buffer is mapped, data is written, the buffer is unmapped and the data is streamed to the graphics card. At the beginning of the next frame I create the texture: util::odprintf("[...] initialize new data texture\n"); util::odprintf("[...] - available vram (before): %.2f\n", ogl::getCurrentAvailableVidMem() / 1024.0f); util::odprintf("[...] - old texture: %d\n", newDataTexture()); // returns opengl handle util::odprintf("[...] - new size: %s\n", glm::string(size).c_str()); newDataTexture.create( GL_R16F, // internal format size, // size 0, // border GL_RED, // data format updateGLType, // data type 0); // copy from buffer util::odprintf("[...] - new texture %d\n", newDataTexture()); util::odprintf("[...] - available vram (after): %.2f\n", ogl::getCurrentAvailableVidMem() / 1024.0f); (the buffer is of course bound to GL_PIXEL_UNPACK_BUFFER before this) The output is the same for release and debug build ... but in release OpenGL fails to create the texture: [...] processing scheduled update [...] creating updatebuffer [...] - for texture size: ivec3(1376, 1040, 93) [...] - new size: 259935.00kb [...] - done [...] update available [...] initialize new data texture [...] - available vram (before): 1004.09 [...] - old texture: 1 [...] - new size: ivec3(1376, 1040, 93) Eine Ausnahme (erste Chance) bei 0x7c812afb in ....exe: Microsoft C++-Ausnahme: ogl::debug_output an Speicherposition 0x0012dc68.. Edit 2 as by request: the code for the texture class #pragma once #include "GLTypes.h" #include "ParameterTraits.h" #include "Wrapper.h" #include "TextureUnit.h" namespace ogl { namespace detail { template <> struct ReferenceHandler { static void onDestroy(gl_texture & handle){ TRACE("[Texture] destroying texture %d (%p)\n", handle, &handle); glDeleteTextures(1,&handle.t); handle = 0; }; }; } template struct texture_traits {}; template <> struct texture_traits { typedef int size_t; }; template <> struct texture_traits { typedef glm::ivec2 size_t; }; template <> struct texture_traits { typedef glm::ivec3 size_t; }; template class Texture : public detail::Wrapper , public detail::TextureUnit::Bindable { public: typedef typename texture_traits ::size_t size_t; public: /** * \brief default constructor * * this actually doesn't do anything useful */ Texture() : Wrapper () { glGenTextures(1,&object.t); }; /** * \brief create new texture * * this constructs a new texture * the new texture will have a size and * will be empty * * \param internalFormat texture format * \param size texture size * \param border texture border */ void create( GLint internalFormat, size_t size, GLint border); /** * \brief create new texture * * this constructs a new texture * the new texture will have a size and * will be empty * * \param internalFormat texture format * \param size texture size * \param border texture border * \param format data format * \param type data type */ void create( GLint internalFormat, size_t size, GLint border, GLenum format, GLenum type, void * data); /** * \brief virtual deconstructor */ virtual ~Texture(void){}; /** * \brief copy constructor */ Texture & Texture::operator = (Texture const& rhs) { if (this != &rhs) { detail::Wrapper ::operator=(rhs); } return *this; } /** * \brief update texture data * * update texture with new data * * \param level texture level to update * \param offset offset in texture * \param size size of update data * \param format data format * \param type data type * \param data data */ void update( GLint level, size_t offset, size_t size, GLenum format, GLenum type, void * data); /** * \brief convenience method that updates the whole texture * * note: uses getters to determinate size of texture -> slow */ void updateAll( GLint level, GLenum format, GLenum type, void * data); /** * \brief bind texture to texture unit * * this should not be included in texture. but texture unit is no real * object so this is defined here */ void bind(GLenum texUnit) const { glBindMultiTextureEXT(texUnit, target, object); } // --- parameter access // - setters /** * \brief set texture parameters */ template void setParameter(GLenum name, T param); template <> void setParameter(GLenum name, GLint param) { glTextureParameteriEXT(object, target, name, param); } template <> void setParameter(GLenum name, GLfloat param) { glTextureParameterfEXT(object, target, name, param); } template <> void setParameter(GLenum name, GLint * param) { glTextureParameterivEXT(object, target, name, param); } template <> void setParameter(GLenum name, GLfloat * param) { glTextureParameterfvEXT(object, target, name, param); } // - getters /** * \brief get texture parameters */ template void getParameter(GLenum name, T & value); template <> void getParameter(GLenum name, GLfloat & value) { glGetTextureParameterfvEXT( object, target, name, &value); } template <> void getParameter(GLenum name, GLint & value) { glGetTextureParameterivEXT( object, target, name, &value); } // - level getters /** * \brief get texture level parameters */ template void getLevelParameter(GLint level, GLenum name, T & value); template <> void getLevelParameter(GLint level, GLenum name, GLint & value) { glGetTextureLevelParameterivEXT( object, target, level, name, &value); } template <> void getLevelParameter(GLint level, GLenum name, GLfloat & value) { glGetTextureLevelParameterfvEXT( object, target, level, name, &value); } /** * \brief generate mipmap levels for this texture */ void generateMipmap() { glGenerateTextureMipmapEXT(object, target); } }; // --- specialization for 1d texture template <> inline void Texture ::create( GLint internalFormat, GLint size, GLint border ) { //glGenTextures(1,&object.t); //std::vector tmp(size*4); glTextureImage1DEXT( object, // texture GL_TEXTURE_1D, // target 0, // level internalFormat, // internal format size, // size border, // border GL_RGBA, // format GL_BYTE, // type 0); // don't load anything } template <> inline void Texture ::create( GLint internalFormat, size_t size, GLint border, GLenum format, GLenum type, void * data) { //glGenTextures(1,&object.t); glTextureImage1DEXT( object, // texture GL_TEXTURE_1D, // target 0, // level internalFormat, // internal format size, // size border, // border format, // data format type, // data type data); // data } template <> inline void Texture ::update( GLint level, GLint offset, GLint size, GLenum format, GLenum type, void * data ) { glTextureSubImage1DEXT( object, GL_TEXTURE_1D, level, offset, size, format, type, data ); } template <> inline void Texture ::updateAll( GLint level, GLenum format, GLenum type, void * data) { GLint size; glGetTextureLevelParameterivEXT( object, GL_TEXTURE_1D, level, GL_TEXTURE_WIDTH, &size ); update(level, 0, size, format, type, data); } // --- specialization for 2d texture template <> inline void Texture ::create( GLint internalFormat, glm::ivec2 size, GLint border ) { //glGenTextures(1,&object.t); //std::vector tmp(glm::compMul(size)*4); glTextureImage2DEXT( object, // texture GL_TEXTURE_2D, // target 0, // level internalFormat, // internal format size.x, size.y, // size border, // border GL_RGBA, // format GL_BYTE, // type 0); // don't load anything } template <> inline void Texture ::create( GLint internalFormat, size_t size, GLint border, GLenum format, GLenum type, void * data) { //glGenTextures(1,&object.t); glTextureImage2DEXT( object, // texture GL_TEXTURE_2D, // target 0, // level internalFormat, // internal format size.x, size.y, // size border, // border format, // data format type, // data type data); // data } template <> inline void Texture ::update( GLint level, glm::ivec2 offset, glm::ivec2 size, GLenum format, GLenum type, void * data ) { glTextureSubImage2DEXT( object, GL_TEXTURE_2D, level, offset.x, offset.y, size.x, size.y, format, type, data ); } template <> inline void Texture ::updateAll( GLint level, GLenum format, GLenum type, void * data) { glm::ivec2 size; glGetTextureLevelParameterivEXT( object, GL_TEXTURE_2D, level, GL_TEXTURE_WIDTH, &size.x ); glGetTextureLevelParameterivEXT( object, GL_TEXTURE_2D, level, GL_TEXTURE_HEIGHT, &size.y ); update(level, glm::ivec2(0,0), size, format, type, data); } // --- specialization for 3d texture template <> inline void Texture ::create( GLint internalFormat, glm::ivec3 size, GLint border ) { //glGenTextures(1,&object.t); //std::vector tmp(glm::compMul(size)*4); glTextureImage3DEXT( object, // texture GL_TEXTURE_3D, // target 0, // level internalFormat, // internal format size.x, size.y, size.z, // size border, // border GL_RGBA, // format GL_BYTE, // type 0); // don't load anything } template <> inline void Texture ::create( GLint internalFormat, size_t size, GLint border, GLenum format, GLenum type, void * data) { //glGenTextures(1,&object.t); glTextureImage3DEXT( object, // texture GL_TEXTURE_3D, // target 0, // level internalFormat, // internal format size.x, size.y, size.z, // size border, // border format, // data format type, // data type data); // data } template <> inline void Texture ::update( GLint level, glm::ivec3 offset, glm::ivec3 size, GLenum format, GLenum type, void * data ) { glTextureSubImage3DEXT( object, GL_TEXTURE_3D, level, offset.x, offset.y, offset.z, size.x, size.y, size.z, format, type, data ); } template <> inline void Texture ::updateAll( GLint level, GLenum format, GLenum type, void * data) { glm::ivec3 size; glGetTextureLevelParameterivEXT( object, GL_TEXTURE_3D, level, GL_TEXTURE_WIDTH, &size.x ); glGetTextureLevelParameterivEXT( object, GL_TEXTURE_3D, level, GL_TEXTURE_HEIGHT, &size.y ); glGetTextureLevelParameterivEXT( object, GL_TEXTURE_3D, level, GL_TEXTURE_DEPTH, &size.z ); update(level, glm::ivec3(0,0,0), size, format, type, data); } typedef Texture Texture1d; typedef Texture Texture2d; typedef Texture Texture3d; }; As you can see i am using EXT_direct_state_access. The "Wrapper" class is a standard refcounted design. I can't disclose that one ... but i can say for sure that it is proven to work. Please keep asking if you need to know more ... i am running out of ideas here. :( ** The solution ** man ... someone had disabled /LARGEMEMORYAWARE in the release build ... thanks to everyone who tried to warp their head around this :) [1] I am using ARB_debug_output [2] checked with GL_NVX_gpu_memory_info
