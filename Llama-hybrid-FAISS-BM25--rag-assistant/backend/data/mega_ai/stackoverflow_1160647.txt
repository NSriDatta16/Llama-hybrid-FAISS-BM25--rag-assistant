[site]: stackoverflow
[post_id]: 1160647
[parent_id]: 1160620
[tags]: 
Updated: So, from the comment discussion, it appears that you can't rely on [UIDevice currentDevice].orientation until the orientation actually changes for the first time. If so, you could probably hack it by getting raw accelerometer readings. #define kUpdateFrequency 30 // Hz #define kUpdateCount 15 // So we init after half a second #define kFilteringFactor (1.0f / kUpdateCount) - (void)applicationDidFinishLaunching:(UIApplication *)app { [UIAccelerometer sharedAccelerometer].updateInterval = (1.0 / kUpdateFrequency); [UIAccelerometer sharedAccelerometer].delegate = self; accelerometerCounter = 0; ... } - (void)accelerometer:(UIAccelerometer *)accelerometer didAccelerate:(UIAcceleration *)accel { // Average out the first kUpdateCount readings // acceleration_[xyz] are ivars typed float acceleration_x = (float)accel.x * kFilteringFactor + acceleration_x * (1.0f - kFilteringFactor); acceleration_y = (float)accel.y * kFilteringFactor + acceleration_y * (1.0f - kFilteringFactor); acceleration_z = (float)accel.z * kFilteringFactor + acceleration_z * (1.0f - kFilteringFactor); accelerometerCounter++; if (accelerometerCounter == kUpdateCount) { [self initOrientation]; [UIAccelerometer sharedAccelerometer].delegate = nil; } } - (void)initOrientation { // Figure out orientation from acceleration_[xyz] and set up your UI... } Original response: Does [UIDevice currentDevice].orientation return the correct orientation during applicationDidFinishLaunching: ? If so, you can set up your initial UI according to that orientation. If that property doesn't get set until some later time, you might try experimenting with performSelector:afterDelay: to initialize the UI after a small delay. This code sample is from Kendall's answer below, added here for completeness: [self performSelector:@selector(getOriented) withObject:nil afterDelay:0.0f]; I'm not sure if a zero-second delay is sufficient -- this means the code for getOriented will run during the first pass through the event run loop. You may need to wait longer for the accelerometer readings to register on UIDevice .
