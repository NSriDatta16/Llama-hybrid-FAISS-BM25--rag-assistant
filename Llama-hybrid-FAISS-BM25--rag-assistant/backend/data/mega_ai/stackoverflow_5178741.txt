[site]: stackoverflow
[post_id]: 5178741
[parent_id]: 2670842
[tags]: 
I'm sure you solved this problem by now, but we just had a similar issue and hit upon a solution that may be of some help. It may not be possible to handle the case purely in the declarative authorization DSL but you can leverage the DSL to do the right thing in your models and views. Basically, we needed access to the role hierarchy graph. The clue is that declarative_authorization has a nifty controller which produces a graph showing the hierarchy of your roles. Using the same supporting code they have, you can easily access the ancestors of any role thusly: class Role :assignments validates :name, :presence => true validates :name, :uniqueness => true def ancestors Authorization::DevelopmentSupport::AnalyzerEngine::Role.for_sym(self.name.to_sym, Authorization::Engine.instance).ancestors.map { |r| r.instance_variable_get("@role") } end def self_and_ancestors ancestors You can then use this to do things like only offer role selections in the User editor which are the same or inferior to the current_user's role and also deny access or not permit the change in the model to someone trying to promote a user inappropriately. It's not that useful in the context of the declarative authorization DSL itself since it would need to be parsed first, creating a kind of circular reference. Hope this helps anyone out there needing it.
