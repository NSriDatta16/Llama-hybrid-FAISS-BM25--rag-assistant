[site]: stackoverflow
[post_id]: 1069420
[parent_id]: 1068849
[tags]: 
DON'T use floor(log10(...)). These are floating-point functions, and slow ones, to add. I believe the fastest way would be this function: int ilog10(int num) { unsigned int num = abs(num); unsigned int x, i; for(x=10, i=1; ; x*=10, i++) { if(num INT_MAX/10) return i+1; } } Note that the binary search version some people suggested could be slower due to branch mispredictions. EDIT: I did some testing, and got some really interesting results. I timed my function together with all the functions tested by Pax, AND the binary search function given by lakshmanaraj. The testing is done by the following code snippet: start = clock(); for(int i=0; i Where the numbers[] array contains randomly generated numbers over the entire range of the int type (barring MIN_INT). The testing was repeated for each tested function on THE SAME numbers[] array. The entire test was made 10 times, with results averaged over all passes. The code was compiled with GCC 4.3.2 with -O3 optimization level. Here are the results: floating-point log10: 10340ms recursive divide: 3391ms iterative divide: 2289ms iterative multiplication: 1071ms unrolled tests: 859ms binary search: 539ms I must say I got really astonished. The binary search performed far better than I thought it would. I checked out how GCC compiled this code to asm. O_O. Now THIS is impressive. It got optimized much better than I thought possible, avoiding most branches in really clever ways. No wonder it is FAST.
