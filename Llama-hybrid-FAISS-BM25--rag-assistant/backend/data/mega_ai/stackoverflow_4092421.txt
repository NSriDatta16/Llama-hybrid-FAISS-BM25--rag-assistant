[site]: stackoverflow
[post_id]: 4092421
[parent_id]: 4090945
[tags]: 
importlib may be more appropriate, as it uses/implements the PEP302 mechanism. Follow the DictImporter example, but override find_module to find the real filename and store it in the dict, then override load_module to get the code from the found file. You shouldn't need to use sys.path once you've created your Storage module #from importlib import abc import imp import os import sys import logging logging.basicConfig(level=logging.DEBUG) dprint = logging.debug class MyImporter(object): def __init__(self,path): self.path=path self.names = {} def find_module(self,fullname,path=None): dprint("find_module({fullname},{path})".format(**locals())) ml = imp.find_module(fullname,path) dprint(repr(ml)) raise ImportError def load_module(self,fullname): dprint("load_module({fullname})".format(**locals())) return imp.load_module(fullname) raise ImportError def load_storage( path, modname=None ): if modname is None: modname = os.path.basename(path) mod = imp.new_module(modname) sys.modules[modname] = mod assert mod.__name__== modname mod.__path__=[path] #sys.meta_path.append(MyImporter(path)) mod.__loader__= MyImporter(path) return mod if __name__=="__main__": load_storage("arbitrary-path-to-code/Storage") from Storage import plain from Storage import mypkg Then when you import Storage.mypackage , python will immediately use your importer without bothering to look on sys.path That doesn't work. The code above does work to import ordinary modules under Storage without requiring Storage to be on sys.path, but both 3.1 and 2.6 seem to ignore the loader attribute mentioned in PEP302. If I uncomment the sys.meta_path line, 3.1 dies with StackOverflow, and 2.6 dies with ImportError. hmmm... I'm out of time now, but may look at it later.
