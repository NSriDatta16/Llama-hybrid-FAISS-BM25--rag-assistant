[site]: stackoverflow
[post_id]: 1715350
[parent_id]: 1715304
[tags]: 
You can always turn a recursive problem into an iterative one if you maintain your own stack of important data - that's if the reason for avoiding recursion is that the language doesn't support it. But, if the language does support it, then recursive solutions are far more elegant. The only other reason I can think of for avoiding recursion is limited stack depth. In that case an iterative conversion of a recursive solution will mitigate the problem by not requiring as much stack space. But you need to understand that the stack depth for processing n numbers only grows relative to log 10 n. In other words, you only get an extra stack frame per digit (only 10 stack frames to handle the full range of 32-bit integers). Aside: by the time you get to that point, you're algorithm will be taking so long to run, stack frames will be the least of your problems :-) Here's a recursive Python solution: def recur (numdigits,sum,pref="",prefsum=0): if numdigits == 0: if prefsum == sum: print "%s, sum=%d"%(pref,prefsum) else: for i in range (1,10): recur (numdigits-1,sum,"%s%d"%(pref,i),prefsum+i) def do (n): for i in range (1,n*9+1): recur (n,i) do (2) do (3) which outputs (for 2 and 3): 11, sum=2 111, sum=3 12, sum=3 112, sum=4 21, sum=3 121, sum=4 13, sum=4 211, sum=4 22, sum=4 113, sum=5 31, sum=4 122, sum=5 14, sum=5 131, sum=5 23, sum=5 212, sum=5 32, sum=5 221, sum=5 41, sum=5 311, sum=5 15, sum=6 114, sum=6 : : : : 89, sum=17 989, sum=26 98, sum=17 998, sum=26 99, sum=18 999, sum=27 Keep in mind that solution could still be optimized somewhat - I left it in its initial form to show how elegant recursion can be. A pure-iterative solution follows, but I still prefer the recursive one. Run the following program and use sort and awk under UNIX to get the desired order. For example: go | sort | awk '{print $2}' Note that this uses external tools to do the sorting but you could just as easily sort within the C code (memory permitting). #include int main (void) { int i, sum, carry, size; int *pDigit; // Choose your desired size. size = 2; // Allocate and initialise digits. if ((pDigit = malloc (size * sizeof (int))) == NULL) { fprintf (stderr, "No memory\n"); return 1; ) for (i = 0; i
