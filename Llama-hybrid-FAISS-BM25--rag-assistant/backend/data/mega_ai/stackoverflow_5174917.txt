[site]: stackoverflow
[post_id]: 5174917
[parent_id]: 5174579
[tags]: 
The first problem you're having is that your original expressions are very fragile, because of the ".*?>" intended to match everything up to the earliest ">" -- but which will actually match to the following ">" if the rest of the expression fails and backtracks. Use a construct like "[^>]*>" instead. The second problem is that you're misinterpreting the meaning of the negative lookahead: it's not checking that the given pattern does not occur ahead of its position -- it's looking ahead of its position to check that the pattern does not occur AT THAT POSITION. With these two changes, your first attempt was very close to solving your test cases: $ pcretest PCRE version 7.8 2008-09-05 re> /(?si) ]*>(?!.*(colspan|>0?0800))(.*?) / data> No match data> Date Time 0: Date Time 1: 2: Date Time data> 05-01-2011 08004913 No match data> 05-01-2011 0123456789 0: 05-01-2011 0123456789 1: 2: 05-01-2011 0123456789 Note this will still fail to solve the whole problem because the presence of a "colspan" or 800 number later in the string will block the match. You need further test cases, such as: $ pcretest PCRE version 7.8 2008-09-05 re> /(?si) ]*>(?!.*(colspan|>0?0800))(.*?) / data> 05-01-2011 0123456789 No match So you need to ensure that the negative lookahead never crosses to the next : $ pcretest PCRE version 7.8 2008-09-05 re> /(?si) ]*>(?!((?! 0?0800))(.*?) / data> No match data> Date Time 0: Date Time 1: 2: 3: Date Time data> 05-01-2011 08004913 No match data> 05-01-2011 0123456789 0: 05-01-2011 0123456789 1: 2: 3: 05-01-2011 0123456789 data> 05-01-2011 0123456789 0: 05-01-2011 0123456789 1: 2: 3: 05-01-2011 0123456789 At which point one may wonder whether RegExps are the right tool for this particular problem :-)
