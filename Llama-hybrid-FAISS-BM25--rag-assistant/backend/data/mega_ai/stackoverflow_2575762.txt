[site]: stackoverflow
[post_id]: 2575762
[parent_id]: 2575663
[tags]: 
Define "secure." DES is more secure than plain text, but due to it's 56-bit keysize, it's not usually used anymore. If you're protecting data against your family, or the casual ease dropper this might be okay. If people are using DES these days, it's Triple DES which essentially runs DES, three times, on each datablock. Now a days the symmetric encryption algorithm (which DES is) of choice is AES, which is like the spiritual successor to DES. AES with a sufficiently large key of 256 (really 512 or higher now a days) is cryptographically secure for most applications. The few caveats of AES are: It's still restricted to US Export controls The NSA can decrypt your information if they want to (yes this is tin hat thinking) Regarding your error, first try switching to AES, and see if you still get a problem. Regarding AES: Key selection is important, as well as key protection. Key Selection If you want to "password" protect your data, using AES, then you need to convert your password into an AES key. This is a common pitfall for many amateur computer security developers. Adobe essentially destroyed all the protection of AES in their PDF's by using an MD5 hash of the users password as the key. Needless to say, you're smarter than all of Adobe's engineers combined, so you won't make that mistake. The proper way to generate a key from a password is using RFC2898 aka PBKD2 (password based key derivation function). .NET handily has a method that does this: Rfc2898DeriveBytes(). Essentially what this does is cryptographically securely hashes your password, with a supplied salt (more on this in a bit), a number of times, supplied by the user. This provides several layers to protect against brute force attacks against your password (assuming your key is large enough to prevent brute force attacks against it!) Each iteration of PBKD2 takes a minuscule amount of time to run. The more interation you run (i think the recommend number is > 1000), the more computer time it takes. This time is still less than a human would recognize, but in computer time it's like a century. Thus without knowing the exact iteration count, it makes it a very lengthy process to brute force attack a password. Salt. Rather than taking a direct hash of your password, a salt adds extra information to your input password, creating a unique hash. This prevents rainbow table attacks, assuming you keep your salt value protected. Key Storage The other side to cryptography is key storage. If you are password protecting your data, then you need to securely store the password. The easiest way is to use the OS's built in security. On Windows thats using DPAPI in the registry, and Unix, filepermissions. AES as a Session Key If you are looking to securely transmit data across a nonsecure channel (or even adding your own extra security ontop of SSL), you may want to looking at using AES as a session encryption. Essentially this is two scheme encryption system that works as follows: You generate a public/private key pair using your favorite assymetric encryption (RSA!) for your server. Each trusted client is given the public key. During a session, the client generates a new random AES key of 256 bit or higher. This AES Session key is encrypted using the public RSA key. This encrypted data containing the AES session key is sent to the server. The server decrypts the data using it's private RSA key, and keeps the AES Session key. During the rest of the session, all data is encrypted with the session AES key. At the end of the session, the AES key is discarded. While this does require more handshaking, this gives you the added protection of limiting exposure. Since the AES key is only good for a session, if it's discovered, the damage is only limited to a single session.
