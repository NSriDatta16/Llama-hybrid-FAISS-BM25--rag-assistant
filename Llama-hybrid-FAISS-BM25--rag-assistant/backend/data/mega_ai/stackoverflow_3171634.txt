[site]: stackoverflow
[post_id]: 3171634
[parent_id]: 3171610
[tags]: 
I agree - comparing directly against an integer is fragile, since the comparisons are only guaranteed to return e.g. less than zero, and not specifically -1. You can use a Predicate to perform the comparison. This encapsulates the evaluation of the condition that you want to count. For example, abstract class ComparisonPredicate { private SomeObject a; // set in constructor public abstract boolean evaluate(SomeObject b); } class LessThanPredicate extends ComparisonPredicate { public boolean evaluate(SomeObject b) { return a.compareTo(b) And then the count method becomes: private int count(ComparisonPredicate comparison){ int number = 0; for (SomeObeject b : this.listOfSomeObjects){ if (comparison.evaluate(b)){ number++; } } return number; } The method is then called like: SomeObject a = ...; int lessThanCount = count(new LessThanPredicate(a)); This can be used to find the number of objects for any type of evaluation - not just less than/greater than comparison, but also equality and any other relations that are defined on your object. Alternatively, you can normalize the comparison values to that they are -1, 0, 1.
