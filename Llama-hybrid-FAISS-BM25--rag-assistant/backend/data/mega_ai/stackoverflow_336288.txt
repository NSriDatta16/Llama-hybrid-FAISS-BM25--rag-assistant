[site]: stackoverflow
[post_id]: 336288
[parent_id]: 
[tags]: 
How can I use Mock Objects in my unit tests and still use Code Coverage?

Presently I'm starting to introduce the concept of Mock objects into my Unit Tests. In particular I'm using the Moq framework. However, one of the things I've noticed is that suddenly the classes I'm testing using this framework are showing code coverage of 0%. Now I understand that since I'm just mocking the class, its not running the actual class itself....but how do I write these tests and have Code Coverage return accurate results? Do I have to write one set of tests that use Mocks and one set to instantiate the class directly. Perhaps I am doing something wrong without realizing it? Here is an example of me trying to Unit Test a class called "MyClass": using Moq; using NUnitFramework; namespace MyNameSpace { [TestFixture] public class MyClassTests { [Test] public void TestGetSomeString() { const string EXPECTED_STRING = "Some String!"; Mock myMock = new Mock (); myMock.Expect(m => m.GetSomeString()).Returns(EXPECTED_STRING); string someString = myMock.Object.GetSomeString(); Assert.AreEqual(EXPECTED_STRING, someString); myMock.VerifyAll(); } } public class MyClass { public virtual string GetSomeString() { return "Hello World!"; } } } Does anyone know what I should be doing differently?
