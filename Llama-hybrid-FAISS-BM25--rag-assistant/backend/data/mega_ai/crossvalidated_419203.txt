[site]: crossvalidated
[post_id]: 419203
[parent_id]: 418584
[tags]: 
another way to go about this would be to use a Bayesian formulation, it can be a bit heavy going to start with but it tends to make it much easier to express specifics of your problem as well as getting better ideas of where the "uncertainty" is Stan is a Monte Carlo sampler with a relatively easy to use programmatic interface, libraries are available for R and others but I'm using Python here we use a sigmoid like everybody else: it has biochemical motivations as well as being mathematically very convenient to work with. a nice parameterization for this task is: import numpy as np def sigfn(x, alpha, beta): return 1 / (1 + np.exp(-(x - alpha) * beta)) where alpha defines the midpoint of the sigmoid curve (i.e. where it crosses 50%) and beta defines the slope, values nearer zero are flatter to show what this looks like, we can pull in your data and plot it with: import pandas as pd import matplotlib.pyplot as plt import seaborn as sns df = pd.read_table('raw_data.txt', delim_whitespace=True) df.columns = ['subsample', 'virus', 'coverage', 'copies'] df.coverage /= 100 x = np.logspace(-1, 6, 201) plt.semilogx(x, sigfn(np.log(x), 5.5, 3), label='sigfn', color='C2') sns.scatterplot(df.copies, df.coverage, hue=df.virus, edgecolor='none') where raw_data.txt contains the data you gave and I transformed the coverage to something more useful. the coefficients 5.5 and 3 look nice and give a plot very much like the other answers: to "fit" this function using Stan we need to define our model using its own language that's a mix between R and C++. a simple model would be something like: data { int N; // number of rows vector[N] log_copies; vector [N] coverage; } parameters { real alpha; real beta; real sigma; } model { vector[N] mu; mu = 1 ./ (1 + exp(-(log_copies - alpha) * beta)); sigma ~ cauchy(0, 0.1); alpha ~ normal(0, 5); beta ~ normal(0, 5); coverage ~ normal(mu, sigma); } which hopefully reads OK. we have a data block that defines the data we expect when we sample the model, parameters define the things that are sampled, and model defines the likelihood function. You tell Stan to "compile" the model, which takes a while, and then you can sample from it with some data. for example: import pystan model = pystan.StanModel(model_code=code) model.sampling(data=dict( N=len(df), log_copies=np.log(df.copies), coverage=df.coverage, ), iter=10000, chains=4, thin=10) import arviz arviz.plot_trace(fit) arviz makes nice diagnostic plots easy, while printing the fit gives you a nice R-style parameter summary: 4 chains, each with iter=10000; warmup=5000; thin=10; post-warmup draws per chain=500, total post-warmup draws=2000. mean se_mean sd 2.5% 25% 50% 75% 97.5% n_eff Rhat alpha 5.51 6.0e-3 0.26 4.96 5.36 5.49 5.64 6.12 1849 1.0 beta 2.89 0.04 1.71 1.55 1.98 2.32 2.95 8.08 1698 1.0 sigma 0.08 2.7e-4 0.01 0.06 0.07 0.08 0.09 0.1 1790 1.0 lp__ 57.12 0.04 1.76 52.9 56.1 57.58 58.51 59.19 1647 1.0 the large standard deviation on beta says that the data really doesn't provide much information about this parameter. also some of the answers giving 10+ significant digits in their model fits are overstating things somewhat because some answers noted that each virus might need its own parameters I extended the model to allow alpha and beta to vary by "Virus". it all gets a bit fiddly, but the two viruses almost certainly have different alpha values (i.e. you need more copies/Î¼L of RRAV for the same coverage) and a plot showing this is: the data is the same as before, but I've drawn a curve for 40 samples of the posterior. UMAV seems relatively well determined, while RRAV could follow the same slope and need a higher copy count, or have a steeper slope and a similar copy count. most of the posterior mass is on needing a higher copy count, but this uncertainty might explain some of the differences in other answers finding different things I mostly used answering this as an exercise to improve my knowledge of Stan, and I've put a Jupyter notebook of this here in case anyone is interested/wants to replicate this.
