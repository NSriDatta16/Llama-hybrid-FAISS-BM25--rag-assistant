[site]: stackoverflow
[post_id]: 424286
[parent_id]: 424220
[tags]: 
This will work if you want to implement/leverage a diff algorithm ala Python's difflib -- you will probably have to do some kind of diff in any case. This snippet calls the user with the most text churn the winner. Excuse my hardcoding. #!/usr/bin/env python import collections import difflib import logging import pprint import urllib2 import re class OwnageDeterminer(object): add_coefficient = 1 remove_coefficient = .5 def __init__(self, edits): self.edits = edits self.counts_by_username = {} def __call__(self): edits, counts_by_username = self.edits, self.counts_by_username for i, edit in enumerate(edits): username = edit['username'] unique_counts = {'added': 0, 'removed': 0} existing_text = edits[i-1]['text'] if i > 0 else '' new_text = edits[i]['text'] for char_diff in difflib.ndiff(existing_text, new_text): if char_diff.startswith('+'): unique_counts['added'] += 1 elif char_diff.startswith('-'): unique_counts['removed'] += 1 user_counts = counts_by_username.get(username, collections.defaultdict(int)) user_counts['removed'] += self.remove_coefficient * unique_counts['removed'] user_counts['added'] += self.add_coefficient * unique_counts['added'] counts_by_username[username] = user_counts winner = None winning_score = 0 score_by_username = {} for username, counts in counts_by_username.iteritems(): score = counts['removed'] + counts['added'] if score > winning_score: winner = username winning_score = score score_by_username[username] = score logging.debug('Scores: %s', pprint.pformat(score_by_username)) return winner if __name__ == '__main__': logging.basicConfig(level=logging.DEBUG) site = urllib2.urlopen('http://stackoverflow.com/revisions/327973/list') contents = site.read() regex = re.compile(r'(/revisions/viewmarkup/\d+).*?/users/\d+/([\w-]+)', re.MULTILINE|re.DOTALL) revisions = regex.findall(contents) print revisions edits = [] for reluri, username in sorted(revisions, key=lambda t: t[0]): text = urllib2.urlopen('http://stackoverflow.com{0}'.format(reluri)).read() edit = {'username': username, 'text': text} edits.append(edit) od = OwnageDeterminer(edits) print od() The output: DEBUG:root:Scores: {'blorgbeard': 0.5, 'dave-markle': 0.5, 'dbr': 1172.0, 'gatekiller': 69.5, 'joseph-ferris': 0.0, 'lkessler': 0.0, 'mark-harrison': 592.0, 'mdb': 3.0, 'onebyone-livejournal-com': 0.0, 'paul-oyster': 482.0, 'rob-wells': 0.0, 'simucal': 1070.5, 'skiphoppy': 0.0, 'thesoftwarejedi': 701.0} dbr Difflib docs on complexity: Timing: The basic Ratcliff-Obershelp algorithm is cubic time in the worst case and quadratic time in the expected case. SequenceMatcher is quadratic time for the worst case and has expected-case behavior dependent in a complicated way on how many elements the sequences have in common; best case time is linear. Another nice thing is that this winner calculation is linear, so you can cache the original results and do incremental updates on new edits, despite the large initialization load.
