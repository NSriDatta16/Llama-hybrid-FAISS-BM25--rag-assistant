[site]: stackoverflow
[post_id]: 2896946
[parent_id]: 2865874
[tags]: 
Not sure if this is elegant enough for you ;-) but since I like Linq, this is what I would have done (using your naming scheme): public static IEnumerable Equalize( this IEnumerable series, int defaultCount) { var allStamps = series .SelectMany(s => s.Data.Select(d => d.Stamp)) .Distinct() .OrderBy(d => d) .ToList(); return series.Select(serie => new Serie( serie.Name, allStamps.Select(d => serie.Data.FirstOrDefault(stat => stat.Stamp == d) ?? new Stat(d, defaultCount)) )); } For this code to compile, your classes needs a couple of constructors: public class Stat { public Stat() {} public Stat(DateTime stamp, int count) { Stamp = stamp; Count = count; } public DateTime Stamp { get; set; } public int Count { get; set; } } public class Serie { public Serie() {} public Serie(string name, IEnumerable data) { Name = name; Data = new List (data); } public string Name { get; set; } public List Data { get; set; } } When calling series.Equalize(0) the code above will leave the original instances intact, and return a sequence of newly created Serie -instances with their Data padded with defaults. Nothing magic about it. Just the sweetness of Linq... (and the null coalescing operator!) I haven't tried this with loads and loads of data, so your milage may vary.
