[site]: stackoverflow
[post_id]: 1035703
[parent_id]: 1035197
[tags]: 
Using sequential ids is probably best unless you want them to be random for some reason (like because customers shouldn't be able to guess the order id of another order from roughly the same time period). Using sequential ids allows you to read the current max and then check that none have been written in the range you are going to write just before you commit orders from your batch process. If you don't want the burden of checking the database and can be sure that other processes aren't going to interfere, you might be able to leverage DateTime.UtcNow and a Base64 conversion. A really clunky illustration might be something like: Convert.ToBase64String(new byte[] { (byte)DateTime.UtcNow.Year, (byte)DateTime.UtcNow.Month, (byte)DateTime.UtcNow.Day, (byte)DateTime.UtcNow.Hour, (byte)DateTime.UtcNow.Minute, (byte)DateTime.UtcNow.Second, (byte)DateTime.UtcNow.Millisecond }) Or Convert.ToBase64String(new byte[] { (byte)DateTime.UtcNow.Ticks }) You'd probably be more interested in a Base32 conversion (it uses letters A-Z and digits 2-7), though there's no native .Net conversion so you'd have to search one out.
