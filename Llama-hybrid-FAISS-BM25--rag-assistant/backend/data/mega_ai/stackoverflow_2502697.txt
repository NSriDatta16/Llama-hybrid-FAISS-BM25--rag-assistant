[site]: stackoverflow
[post_id]: 2502697
[parent_id]: 2501383
[tags]: 
I really think that what you have is in fact a many-to-many association between two Entities (let's call them Message and Group ). The DDL to represent this would be: CREATE TABLE "APP"."MESSAGE" ( "MESSAGE_ID" INTEGER NOT NULL GENERATED ALWAYS AS IDENTITY (START WITH 1, INCREMENT BY 1), "AUTHOR" CHAR(20) NOT NULL ); ALTER TABLE "APP"."MESSAGE" ADD CONSTRAINT "MESSAGE_PK" PRIMARY KEY ("MESSAGE_ID"); CREATE TABLE "APP"."GROUP" ( "GROUP_ID" INTEGER NOT NULL GENERATED ALWAYS AS IDENTITY (START WITH 1, INCREMENT BY 1) ); ALTER TABLE "APP"."GROUP" ADD CONSTRAINT "GROUP_PK" PRIMARY KEY ("GROUP_ID"); CREATE TABLE "APP"."MESSAGE_GROUP" ( "GROUP_ID" INTEGER NOT NULL, "MESSAGE_ID" INTEGER NOT NULL ); ALTER TABLE "APP"."MESSAGE_GROUP" ADD CONSTRAINT "MESSAGE_GROUP_PK" PRIMARY KEY ("MESSAGE_ID", "GROUP_ID"); ALTER TABLE "APP"."MESSAGE_GROUP" ADD CONSTRAINT "MESSAGE_GROUP_FK1" FOREIGN KEY ("MESSAGE_ID") REFERENCES "APP"."MESSAGE" ("MESSAGE_ID"); ALTER TABLE "APP"."MESSAGE_GROUP" ADD CONSTRAINT "MESSAGE_GROUP_FK2" FOREIGN KEY ("GROUP_ID") REFERENCES "APP"."MESSAGE" ("GROUP_ID"); And the annotated classes: @Entity public class Message { @Id @Column(name = "MESSAGE_ID") @GeneratedValue(strategy = GenerationType.IDENTITY) private Long messageId; @ManyToMany @JoinTable( name = "MESSAGE_GROUP", joinColumns = @JoinColumn(name = "MESSAGE_ID"), inverseJoinColumns = @JoinColumn(name = "GROUP_ID") ) private List groups = new ArrayList (); private String author; //... } @Entity public class Group { @Id @GeneratedValue @Column(name = "GROUP_ID") private Long groupId; @ManyToMany(mappedBy = "groups") private List messages = new ArrayList (); //... } I'm not sure you need a bi-directional association though. But you definitely need to start to think object if you want to use JPA (in you're example, you're still setting ids, you should set Entities). Or maybe JPA is not what you need. isn't there a more elegant solution? I'm not sure "elegant" is appropriate but JPA 2.0 defines an ElementCollection mapping (as I said in my previous answer): It is meant to handle several non-standard relationship mappings. An ElementCollection can be used to define a one-to-many relationship to an Embeddable object, or a Basic value (such as a collection of Strings). But that's in JPA 2.0. In JPA 1.0, you would have to use a provider specific equivalent, if your provider does offer such an extension. It appears that OpenJPA does with @PersistentCollection .
