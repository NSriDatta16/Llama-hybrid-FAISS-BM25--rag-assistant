[site]: stackoverflow
[post_id]: 5036284
[parent_id]: 
[tags]: 
Recursively sort non-contiguous list to list of contiguous lists

I've been trying to learn a bit of functional programming (with Haskell & Erlang) lately and I'm always amazed at the succinct solutions people can come up with when they can think recursively and know the tools. I want a function to convert a list of sorted, unique, non-contiguous integers into a list of contiguous lists, i.e: [1,2,3,6,7,8,10,11] to: [[1,2,3], [6,7,8], [10,11] This was the best I could come up with in Haskell (two functions):: make_ranges :: [[Int]] -> [Int] -> [[Int]] make_ranges ranges [] = ranges make_ranges [] (x:xs) | null xs = [[x]] | otherwise = make_ranges [[x]] xs make_ranges ranges (x:xs) | (last (last ranges)) + 1 == x = make_ranges ((init ranges) ++ [(last ranges ++ [x])]) xs | otherwise = make_ranges (ranges ++ [[x]]) xs rangify :: [Int] -> [[Int]] rangify lst = make_ranges [] lst It might be a bit subjective but I'd be interested to see a better, more elegant, solution to this in either Erlang or Haskell (other functional languages too but I might not understand it.) Otherwise, points for just fixing my crappy beginner's Haskell style!
