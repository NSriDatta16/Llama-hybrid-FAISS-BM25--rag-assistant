[site]: stackoverflow
[post_id]: 1449329
[parent_id]: 
[tags]: 
Heap Corruption, Possible Memory Leaks, C++

I have a homework assignment that I've nearly completed. As inefficient as it is be I was just wanting to know how I can prevent a crash when my program ends. quack::quack(int capacity) : backPtr( NULL ), frontPtr( NULL ) { items = new item[capacity]; backPtr = new item; frontPtr = new item; midPtr = new item; current = new item; maxSize = capacity; back = maxSize-1; count = 0; top = -1; } quack::~quack(void) { delete frontPtr; delete backPtr; delete current; delete midPtr; delete [] items; //Heap Corruption Debug Error at the end of program. items = NULL; maxSize = 0; back = 0; } bool quack::pushFront(const int n) { int i = 0; if ( count == maxSize ) // Then we cant add to it n e more. { throw runtime_error( "Stack is Full" );// Full Stack return false; } backPtr->n = items[back-1].n; while ( i n = items[top+1].n; items[top+1].n = backPtr->n; } midPtr->n = items[++i].n; items[i].n = current->n; if ( i != back-1 ) { current->n = items[++i].n; items[i].n = midPtr->n; } } ++count; items[top+1].n = n; return true; } bool quack::pushBack(const int n) { items[count].n = n; count++; return true; } bool quack::popFront(int& n) { n = items[top+1].n; for ( int i = 0; i 0 ) // rotate postively. { frontPtr->n = items[top+1].n; for ( int i = 0; i n; r--; } while ( r n = items[back-1].n; current->n = items[top+1].n; items[top+1].n = backPtr->n; } midPtr->n = items[++i].n; items[i].n = current->n; if ( i == back-1 ) { items[back-1].n = current->n; i = 0; r++; continue; } else { current->n = items[++i].n; items[i].n = midPtr->n; if ( i == back-1 ) { i = 0; r++; continue; } } } } void quack::reverse(void) { int j = 0; // Variable declaration/initialization. frontPtr->n = items[top+1].n; backPtr->n = items[back-1].n; for ( int i = 0; i n; } items[top+1].n = backPtr->n; items[back-1].n = frontPtr->n; } int quack::itemCount(void) { return count; } ostream& operator and the header file: #include using namespace std; class quack { public: quack(int capacity); ~quack(void); bool pushFront(const int n); // Push an item onto the front. bool pushBack(const int n); // Push an item onto the back. bool popFront(int& n); // Pop an item off the front. bool popBack(int& n); // Pop an item off the back. void rotate(int r); // "rotate" the stored items (see note below). void reverse(void); // Reverse the order of the stored items. int itemCount(void); // Return the current number of stored items. private: int maxSize; // is for the size of the item stack int back; // is for the back or "bottom" of the stack int count; // to count the items added to the stack int top; struct item // Definition of each item stored by the quack. { int n; }; item *items; // Pointer to storage for the circular array. item *backPtr; item *frontPtr; item *midPtr; item *current; public: friend ostream& operator
