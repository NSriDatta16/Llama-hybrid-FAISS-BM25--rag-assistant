[site]: stackoverflow
[post_id]: 1498193
[parent_id]: 1494167
[tags]: 
I also use a bootstrapper to handle this sort of startup task thing. Actually, I use a chain of bootstrappers because I am crazy like that. Automapper-wise, we found it was alot cleaner to make some AutoMappingBuddy classes and decorate them with an attribute. We then wire up the mappers via some reflection calls (not cheap, but they only fire once at the get go). This solution was discovered after we got sick of finding an AutoMapper issue in line 841 of a 1200+ line file. I thought about posting the code, but I can't really call it that purdy. Anyhow, here goes: First, a simple interface for the AutoMappingBuddies: public interface IAutoMappingBuddy { void CreateMaps(); } Second, a little attribute to provide some glue: public class AutoMappingBuddyAttribute : Attribute { public Type MappingBuddy { get; private set; } public AutoMappingBuddyAttribute(Type mappingBuddyType) { if (mappingBuddyType == null) throw new ArgumentNullException("mappingBuddyType"); MappingBuddy = mappingBuddyType; } public IAutoMappingBuddy CreateBuddy() { ConstructorInfo ci = MappingBuddy.GetConstructor(new Type[0]); if (ci == null) { throw new ArgumentOutOfRangeException("mappingBuddyType", string.Format("{0} does not have a parameterless constructor.")); } object obj = ci.Invoke(new object[0]); return obj as IAutoMappingBuddy; } } Third, the AutoMappingEngine. It's where the magic happens: public static class AutoMappingEngine { public static void CreateMappings(Assembly a) { Dictionary mappingDictionary = GetMappingDictionary(a); foreach (Type t in a.GetTypes()) { var amba = t.GetCustomAttributes(typeof (AutoMappingBuddyAttribute), true).OfType (). FirstOrDefault(); if (amba!= null && !mappingDictionary.ContainsKey(amba.MappingBuddy)) { mappingDictionary.Add(amba.MappingBuddy, amba.CreateBuddy()); } } foreach (IAutoMappingBuddy mappingBuddy in mappingDictionary.Values) { mappingBuddy.CreateMaps(); } } private static Dictionary GetMappingDictionary(Assembly a) { if (!assemblyMappings.ContainsKey(a)) { assemblyMappings.Add(a, new Dictionary ()); } return assemblyMappings[a]; } private static Dictionary > assemblyMappings = new Dictionary >(); } Kinda slapped together in an hour or so, there are probably more elegant ways to get there.
