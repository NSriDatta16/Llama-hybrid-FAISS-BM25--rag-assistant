[site]: stackoverflow
[post_id]: 2024801
[parent_id]: 2024607
[tags]: 
"Elegant" Control Filter (No LINQ) Thanks to C# 3 there are many elegant solutions. This one doesn't use LINQ query operators; it uses lambdas and delegates. This filters all controls for given criteria (can filter against multiple criteria). Returns multiple matches. It allows for more than name detection. /// /// Recurses through all controls, starting at given control, /// and returns an array of those matching the given criteria. /// public Control[] FilterControls(Control start, Func isMatch) { var matches = new List (); Action filter = null; (filter = new Action (c => { if (isMatch(c)) matches.Add(c); foreach (Control c2 in c.Controls) filter(c2); }))(start); return matches.ToArray(); } Filter Usage... It's quite flexible as far as usage Control[] foundControls = null; // Find control with Name="tabs1". foundControls = FilterControls(this, c => c.Name != null && c.Name.Equals("tabs1")); // Find all controls that start with ID="panel*... foundControls = FilterControls(this, c => c.Name != null && c.Name.StartsWith("panel")); // Find all Tab Pages in this form. foundControls = FilterControls(this, c => c is TabPage); Console.Write(foundControls.Length); // is an empty array if no matches found. Equivalent Extension Method Extension methods add an heir of elegancy to applications also. The exact same logic can be injected into an extension method like so. static public class ControlExtensions { static public Control[] FilterControls(this Control start, Func isMatch) { // Put same logic here as seen above (copy & paste) } } Extension usage is: // Find control with Name="tabs1" in the Panel. panel1.FilterControls(c => c.Name != null && c.Name.Equals("tabs1")); // Find all panels in this form this.FilterControls(c => c is Panel); Another Extension to Return One Control or null Calls the first extension method (see above) to get all matching controls, then returns the first one in the matches, otherwise null if the match list is empty. This isn't efficient because it iterates over all controls even after finding the first match - but just playing around here for the sake of SO comments. static public Control FilterControlsOne(this Control start, Func isMatch) { Control[] arrMatches = ControlExtensions.FilterControls(start, isMatch); return arrMatches.Length == 0 ? null : arrMatches[0]; }
