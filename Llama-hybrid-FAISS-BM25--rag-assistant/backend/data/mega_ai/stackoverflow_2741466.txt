[site]: stackoverflow
[post_id]: 2741466
[parent_id]: 2741299
[tags]: 
At a superficial level, languages grow from predecessors because there are users who already know the syntax and there are not too many different ways to actually do the syntax. At a more meaningful level, prior languages may be being used in repetitive ways that could be made easier by adding some syntax and behavior. I'm thinking of how one would do OOP in C before C++ came along. Or the distinction between Fortran with GOTO and Algol with block structure. It was a pain to keep making labels, and they could be automatically generated. Personally, I could be wrong, but I don't see general purpose languages (GPL) evolving much further (not to say small languages won't proliferate). I do think special-purpose languages (DSLs) will continue to grow, and I think one of the key features of any GPL will be how well it assists the creation of new DSLs. I think this because there is a continuum of representations between problem-specific data structure on the one hand, and programming languages on the other. Any data that is read by some program is, in a sense, expressed in a language, and that program is its interpreter. So the only thing that really separates the extremes is the degree of sophistication and generality of its interpreter. What I look for in a DSL is the property of minimum redundancy with respect to its intended problem domain. The idea is if there are some requirements, and if a program is written (by a human, at a keyboard) to correctly implement those requirements, and then if a single coherent change is made to the requirements, there is some amount of editing that must be done to the program to correctly implement the change, then the redundancy of the language w.r.t. the domain is the size of such edits, averaged (somehow) over the space of possible changes. A very simple way to measure this is to use a diff program between the before-and-after code. The number of differences is a measure of the redundancy for that change. This is a bit long-winded, but that's what I look for to be minimized, to say that a language is well adapted to a domain. If redundancy of a language is minimized, then it means fewer edit changes are required to implement functional changes, and not only is the code likely to be shorter, but there are thus fewer chances to put in bugs . The way programmers are currently taught, these ideas are in their future. Minimizing redundancy of source code is not yet seriously valued. What we have instead is bandwagons like OOP that, in spite of their obvious value, tend to lead to massively redundant code. One promissing development is the rise of code generators, but again they are in danger of becoming ends in themselves rather than serving the goal of reducing source code redundancy.
