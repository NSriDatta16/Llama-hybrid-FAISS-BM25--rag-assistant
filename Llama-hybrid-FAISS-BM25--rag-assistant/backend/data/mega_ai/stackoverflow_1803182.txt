[site]: stackoverflow
[post_id]: 1803182
[parent_id]: 1802355
[tags]: 
There are two separate ways to implement a timer using callbacks in Windows, SetTimer and timeSetEvent. The basics are: SetTimer uses messages, even if you use a callback (the callback function is invoked as a result of processing a message). So SetTimer isn't viable if you don't run a message pump. Callbacks are called by the operating system, which doesn't know a C++ "this" pointer from a hole in the ground, so your callback either has to be a global C-style function or a static member. timeSetEvent is part of the "multimedia" timer family, and doesn't require a message pump. The observations about the callback function signature above still apply though. The lack of requirement for a message pump can be important if you're writing a console app though. You might also consider threading and CreateWaitableTimer, but I don't use waitable timers very often so can't comment on them. If you need to do work in the background, then threading can be a much more elegant way to address the problem. You don't have to divide the work up into chunks when you're threading (which you do if you're kicking the work from a timer). But of course your thread can't touch the GUI, so life can get a little complicated when you start threading. There's an intro to worker threads on my website here .
