[site]: stackoverflow
[post_id]: 2574106
[parent_id]: 2574041
[tags]: 
First, your last else if conditional clause is redundant. Swap it with an else clause. Secondly, I think it would make things easier for you if you'd take as parameter a pointer to the node to remove. You can write a find() function which would find a node given its key. I'm assuming of course that you can change the function signature. If you can take as parameter the node to remove you can focus on removing the node rather than add logic for finding the node. Otherwise, still write that find() function and use that for getting the pointer to the relevant node. When you remove a node in a binary search tree you must maintain the ordering so the tree doesn't lose its integrity. Recall that there is a specific ordering in the tree that supports the fast retrieval of elements. So, enumerate the possible cases: The node to delete has no children. That's easy: just release its resources and you're done. The node has a single child node. That's fairly simple too. Release the node and replace it with its child, so the child holds the removed node's place in the tree. The node has two children. Let's call the node D . Find the right-most child of D 's left subtree. Let's call this node R . Assign the value of R to D , and delete R (as described in this algorithm). Notice that R can have zero or one children. The third scenario, illustrated: . . . / D / \ /\ . / \ / \ +------+ \ R / ?
