[site]: stackoverflow
[post_id]: 4112742
[parent_id]: 4108948
[tags]: 
What you're doing is declaring properties as if you were declaring instance variables. You should not be using the names in the getter and setter attributes on the @property declaration with dot syntax; that it happens to be working now is not - so far as I know - by design. The property should be what you use with dot syntax. For some reason - unfamiliarity with Cocoa coding conventions, I expect - you named your properties m_topString and m_PINMaxLength . That means you should use them as someObject.m_topString and someObject.m_PINMaxLength . If you want to use those names for the instance variables that you've decided to use for the properties' backing storage, you should declare that in the @synthesize directive instead. This is how your class should look, to be more in line with regular Cocoa and Objective-C coding conventions: @interface SomeClass : NSObject { @private NSString *m_topString; } @property (nonatomic, readwrite, copy) NSString *topString; - (id)initWithTopString:(NSString *)initialTopString; @end @implementation SomeClass @synthesize topString = m_topString; // this says to use the instance variable m_topString // for the property topString's storage - (id)initWithTopString:(NSString *)initialTopString { if ((self = [super init])) { m_topString = [initialTopString copy]; // use the ivar directly in -init, not the property } return self; } - (void)dealloc { [m_topString release]; // use the ivar directly in -dealloc, not the property [super dealloc]; } - (NSString *)description { return [NSString stringWithFormat:@"SomeClass (%@)", self.topString]; // elsewhere in your class, use the property // this will call through its getter and setter methods } @end
