[site]: stackoverflow
[post_id]: 584018
[parent_id]: 583896
[tags]: 
first, i don't think it's apropriate to compare pthread_create() time with a hashmap operation. better compare with (un)lock times, both in the contended and noncontended cases. still, you're right, synchronisation times are the bottleneck and getting worse, since they have to go to the inter-CPU bus/bridge/channel, whatever, while most other datastructs try to stay in cache (or even in shadow registers). there are two main directions to attack this problem: better shared structures: check lock-free structures and/or transactional-memory. both try to maximize accessibility by replacing the 'lock-modify-release' cycle with 'try-check-commit/rollback'. in most cases, the check should succeed, so the rollback shouldn't affect average performance. usually the check/commit is done atomically, so it's expensive in terms of CPU bandwidth, but it's a lot less than traditional locks. less sharing: that's what erlang/haskell languages emphasize. making it easy and inexpensive to transfer small messages, inter-thread communication looks more like function calls with parameters, and less than shared memory. this is far more scalable, since only two processes have to synchronize, and could (in theory) use non-RAM channels with lower latencies. edit: i'm surprised nobody has any opinion about lock-free structures. check this (pdf) and this (video) about a lock-free hashtable implementation in Java that scales (almost) linearly up to 300 CPUS
