[site]: stackoverflow
[post_id]: 2334407
[parent_id]: 2332401
[tags]: 
Complete rewrite (see edits), shorter, more elegant, maybe less readable. Still pinching Brian's logic. UPDATE : now works, at least for the test above let third = [(12,22,3.1);(43,56,3.2)] let second = [(6,20,2.1);(35,63,2.2)] let first = [(0,30,1.1);(35,50,1.2)] //===helper functions=== // foldable combined min and max finder let minmax (mn,mx) (x,y,_) = (min mn x, max mx y) // test if x - y range overlaps position i let overlaps i (x,y,_) = x 1 then (i, il, L) else (i, iu, L @ U) let input = [first;second;third] // input data - 'bottom' first //find max and min positions let (x0,yn) = input |> Seq.concat |> Seq.fold minmax (0,0) //transform each data list to a list of (i,[z]) let valsByPos = input |> List.map (fun level -> //for each data 'level' [x0..yn] |> List.map (fun i -> //for each position in range //collect values of all elements in level that // overlap this position (i, level |> List.filter (overlaps i) |> List.map getz))) // 'merge up' each level, keeping only upper values if lower values exist // after we will have just one list of (i, [z]) let mergedValsByPos = valsByPos //offside here for SO formatting //add an index into each tuple |> List.mapi (fun i l -> l |> List.map (fun (j,z) -> (j,i,z))) //use index to determine if we should 'merge up' for each subsublst |> List.reduce (List.map2 merge) //rip the index back out |> List.map (fun (i,_,z) -> (i,z)) //get first value as seed for fold let x1,l1 = Seq.nth 0 mergedValsByPos //transform list (i,[z]) into list of (x,y,[z]) //key: (l)ow, (h)igh, (s)et, (nx)-next x, (ns)-next set let result = mergedValsByPos //first remove any positions where there are no values |> List.filter (fun el -> snd(el) <> []) //double capture on state so we can take all or part of it |> List.fold (fun (((l,h,s)::t) as prev) (nx,ns) -> //if [z] value hasn't changed, we just enlarge range // of current state (from (l,h) to (l,nx)) // otherwise we add a new element (nx,nx,ns) to state if s=ns then (l,nx,s)::t else (nx,nx,ns)::prev ) [x1,x1,l1] //initial state from seed values |> List.rev //folded value is backwards (because of::), so reverse
