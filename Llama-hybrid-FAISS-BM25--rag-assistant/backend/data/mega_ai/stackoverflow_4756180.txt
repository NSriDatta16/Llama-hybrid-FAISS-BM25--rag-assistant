[site]: stackoverflow
[post_id]: 4756180
[parent_id]: 4755557
[tags]: 
Check out liftA2 and liftA3 . Also, you can easily write your own applyTwice or applyThrice methods like so: applyTwice :: (a -> a -> b) -> a -> b applyTwice f x = f x x applyThrice :: (a -> a -> a -> b) -> a -> b applyThrice f x = f x x x There's no easy way I can see to get the generic applyMany you're asking for, but writing trivial helpers such as these is neither difficult nor uncommon. [edit] So it turns out, you'd think something like this would work liftA4 f a b c d = f a b c d quadraApply f x = f x x x x data MyType = MyType Int String Double Char instance Arbitrary MyType where arbitrary = (liftA4 MyType) `quadraApply` arbitrary But it doesn't. (liftA4 MyType) has a type signature of (Applicative f) => f Int -> f String -> f Double -> f Char -> f MyType . This is incompatible with the first parameter of quadraApply, which has a type signature of (a -> a -> a -> a -> b) -> a -> b . It would only work for data structures that hold multiple values of the same Arbitrary type. data FourOf a = FourOf a a a a instance (Arbitrary a) => Arbitrary (FourOf a) where arbitrary = (liftA4 FourOf) `quadraApply` arbitrary ghci> sample (arbitrary :: Gen (FourOf Int)) Of course you could just do this if you had that situation ghci> :l +Control.Monad ghci> let uncurry4 f (a, b, c, d) = f a b c d ghci> samples forM_ samples (print . uncurry4 FourOf) There might be some language pragma that can shoehorn the "arbitrary" function into the more diverse data types. But that's currently beyond my level of Haskell-fu.
