[site]: stackoverflow
[post_id]: 1566328
[parent_id]: 1565600
[tags]: 
What you are showing is that operator chaining is allowed. X& x = getx().ref(); // OK The expression is 'getx().ref();' and this is executed to completion before assignment to 'x'. Note that getx() does not return a reference but a fully formed object into the local context. The object is temporary but it is not const, thus allowing you to call other methods to compute a value or have other side effects happen. // It would allow things like this. getPipeline().procInstr(1).procInstr(2).procInstr(3); // or more commonly std::cout Look at the end of this answer for a better example of this You can not bind a temporary to a reference because doing so will generate a reference to an object that will be destroyed at the end of the expression thus leaving you with a dangling reference (which is untidy and the standard does not like untidy). The value returned by ref() is a valid reference but the method does not pay any attention to the lifespan of the object it is returning (because it can not have that information within its context). You have basically just done the equivalent of: x& = const_cast (getX()); The reason it is OK to do this with a const reference to a temporary object is that the standard extends the lifespan of the temporary to the lifespan of the reference so the temporary objects lifespan is extended beyond the end of the statement. So the only remaining question is why does the standard not want to allow reference to temporaries to extend the life of the object beyond the end of the statement? I believe it is because doing so would make the compiler very hard to get correct for temporary objects. It was done for const references to temporaries as this has limited usage and thus forced you to make a copy of the object to do anything useful but does provide some limited functionality. Think of this situation: int getI() { return 5;} int x& = getI(); x++; // Note x is an alias to a variable. What variable are you updating. Extending the lifespan of this temporary object is going to be very confusing. While the following: int const& y = getI(); Will give you code that it is intuitive to use and understand. If you want to modify the value you should be returning the value to a variable. If you are trying to avoid the cost of copying the obejct back from the function (as it seems that the object is copy constructed back (technically it is)). Then don't bother the compiler is very good at 'Return Value Optimization'
