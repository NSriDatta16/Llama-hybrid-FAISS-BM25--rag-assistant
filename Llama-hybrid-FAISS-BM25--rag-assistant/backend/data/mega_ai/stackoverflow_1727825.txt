[site]: stackoverflow
[post_id]: 1727825
[parent_id]: 1723796
[tags]: 
Now that's an interesting problem! The obvious (and simple) solution would be to go template crazy. If every single function only required an interface (and not a definite type), this would alleviate most of your concerns. But of course this has a penalty of its own in term of dependency and you reject this solution in point 4). Dynamic casting ? struct Feature { virtual ~Feature() {} }; class F: public Feature {}; class G: public Feature {}; Now a class which implements F and G is declared like that class Impl: public F, public G {}; And a method requiring F and G like this void method(Feature const& i) { F const& myF = dynamic_cast (i); G const& myG = dynamic_cast (i); myF.f(2.0); myG.g(2.0); } Admittedly there may be a slight performance penalty and the type-safety is not checked at compile-time. Template Forwarding This however entails another solution: namespace detail { void methodImpl(F const& f, G const& g); } template void method(T const& t) { detail::methodImpl(t,t); } This combines the approach of BostonLogan with a better interface. No user code should ever mention the detail namespace (which is easy to test) and if so you are guaranteed that no one use two different objects to invoke methodImpl . This seems to cover most of your needs: The runtime performance is equivalent to your example T might be inheriting from H or Z , you don't care, as long as it inherits from F and G the code will compile Adding another Feature does not change anything ... well you have to template the interface ( method ), but this is a one-liner forwarder to a non-template method which does the actual heavy-lifting. The only thing that annoys me there is that methodImpl actually have 2 references to the same object, which might entails problems for the future. Getting rid of multiple references It's not going to be easy, but we are going to wrap this object and delegate the work. The idea is that from an object of an unknown type inheriting from a given set of functionality, we can create an object of a known type that forwards all operations to the first object (which it takes in its constructor). To achieve this we need 2 more things though: Each Feature should declare a forwarder We need a system of forwarder aggregation Let's cover the first point: class F { public: void f(double d); void f2(double d, double e) const; }; class FForwarder { public: FForwarder(F& f) : m_object(f) {} void f(double d) { m_object.f(d); } void f2(double d, double e) const { m_object.f(d,e); } private: F& m_object; }; Easy enough, but cumbersome. Let's cover the aggregation: struct nil {}; template struct Aggregator: Head, Aggregator { typedef Head head; typedef Tail tail; template Aggregator(T& t) : Head(t), Aggregator (t) {} }; template struct Aggregator : Head { typedef Head head; typedef nil tail; template Aggregator(T& t) : Head(t) {} }; template <> struct Aggregator { typedef nil head; typedef nil tail; template Aggregator(T&) {} }; And now, on to the usage. Either by putting the burden on the caller: int method(Aggregator >& fgh); Or by writing a template forwarder: namespace detail { typedef Aggregator > methodImplArg; int methodImpl(methodImplArg& arg); } template int method(T& t) { detail::methodImplArg arg = detail::methodImplArg(t); //named temporary because it is passed by reference to non-const return detail::methodImpl(arg); // forward the result as well }; This addresses the problem of methodImpl being passed 2 arguments rather neatly, though it does require extra work... I suppose there should be a simpler way but could not pinpoint it yet.
