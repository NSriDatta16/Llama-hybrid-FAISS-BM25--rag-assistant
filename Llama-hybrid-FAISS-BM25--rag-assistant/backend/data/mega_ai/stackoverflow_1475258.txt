[site]: stackoverflow
[post_id]: 1475258
[parent_id]: 1472949
[tags]: 
tomshardware.com contains a comprehensive list of CPU benchmarks. However... you can't just divide them, you need to find as close to an apples to apples comparison as you can get and you won't quite get it because the mix of instructions on your workload may or may not depend. I would guess please don't take this as official, you need to have real data for this that you're probably in the 1.5x - 1.75x single threaded speedup if work is cpu bound and not highly vectorized. You also need to take into account that you are: 1) using C# and the CLR, unless you've taken steps to prevent it GC may kick in and serialize you. 2) the nehalems have hyperthreads so you won't be seeing perfect 16x speedup, more likely you'll see 8x to 12x speedup depending on how optimized your code is. Be optimistic here though (just don't expect 16x). 3) I don't know how much contention you have, getting good scaling on 3 threads != good scaling on 16 threads, there may be dragons here (and usually is). I would envelope calc this as: 15 hours * 3 threads / 1.5 x = 30 hours of single threaded work time on a nehalem. 30 / 12 = 2.5 hours (best case) 30 / 8 = 3.75 hours (worst case) implies a parallel run time if there is truly a 20x increase: 2.5 hours * 20 = 50 hours (best case) 3.74 hours * 20 = 75 hours (worst case) How much have you profiled, can you squeeze 2x out of app? 1 server may be enough, but likely won't be. And for gosh sakes try out the task parallel library in .Net 4.0 or the .Net 3.5 CTP it's supposed to help with this sort of thing. -Rick
