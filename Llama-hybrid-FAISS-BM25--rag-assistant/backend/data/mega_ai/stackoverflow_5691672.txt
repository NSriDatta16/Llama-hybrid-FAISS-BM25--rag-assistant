[site]: stackoverflow
[post_id]: 5691672
[parent_id]: 5686708
[tags]: 
The first thing that caught my attention in your code is that it processes the input string three times: twice with Split() and once with Replace() . The Matches() method is a much better tool than Split() for this job. With it, you can extract everything you need in a single pass. It makes the code a lot easier to read, too. The second thing I noticed was all those loops and intermediate objects. You're using LINQ already; really use it, and you can eliminate all of that clutter and improve performance. Check it out: public static Dictionary GetSelectValuesDictionary(string inputString) { return Regex.Matches(inputString, @"(? [0-9]+)\$*(? [^$]+)") .Cast () .ToDictionary( m => int.Parse(m.Groups["key"].Value), m => m.Groups["value"].Value); } notes: Cast () is necessary because MatchCollection only advertises itself as an IEnumerable , and we need it to be an IEnumerable . I used [0-9] instead of \d on the off chance that your values might contain digits from non-Latin writing systems; in .NET, \d matches them all. Static Regex methods like Matches() automatically cache the Regex objects, but if this method is going to be called a lot (especially if you're using a lot of other regexes, too), you might want to create a static Regex object anyway. If performance is really critical, you can specify the Compiled option while you're at it. My code, like yours, makes no attempt to deal with malformed input. In particular, mine will throw an exception if the number turns out to be too large, while yours just converts it to zero. This probably isn't relevant to your real code, but I felt compelled to express my unease at seeing you call TryParse() without checking the return value. :/ You also don't make sure your keys are unique. Like @Gabe, I flipped it around used the numeric values as the keys, because they happened to be unique and the string values weren't. I trust that, too, is not a problem with your real data. ;)
