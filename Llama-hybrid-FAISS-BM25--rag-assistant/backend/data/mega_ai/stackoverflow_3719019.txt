[site]: stackoverflow
[post_id]: 3719019
[parent_id]: 
[tags]: 
How to manage concurrent development with mercurial?

This is a best practice question, and I expect the answer to be "it depends". I just hope to learn more real world scenarios and workflows. First of all, I'm talking about different changes for the same project, so no subrepo please. Let's say you have your code base in an hg repository. You start to work on a complicated new feature A, then a complicated bug B is reported by your trusted tester (you have testers, right?). It's trivial if (the fix for) B depends on A. You simlply ci A then ci B. My question is what to do when they are independent (or at least it seems now). I can think of the following ways: Use a separate clone for B. Use anonymous or named branches, or bookmarks, in the same repository. Use MQ (with B patch on top of A). Use branched MQ (I'll explain later). Use multiple MQ (since 1.6) 1 and 2 are covered by an excellent blog by @Steve Losh linked from a slightly related question . The one huge advantage of 1 over the other choices is that it doesn't require any rebuild when you switch from working on one thing to the other, because the files are physically separated and independent. So it's really the only choice if, for example, A and/or B touches a header file that defines a tri-state boolean and is included by thousands of C files (don't tell me you haven't seen such a legacy code base). 3 is probably the easiest (in terms of setup and overhead), and you can flip the order of A and B if B is a small and/or urgent fix. However it can get tricky if A and B touches the same file(s). It's easy to fix patch hunks that failed to apply if A and B changes are orthogonal within the same file(s), but conceptually it's still a bit risky. 4 can make you dizzy but it's the most powerful and flexible and scalable way. I default hg qinit with -c since I want to mark work-in-progress patches and push/pull them, but it does take a conceptual leap to realize that you can branch in MQ repo too. Here are the steps (mq = hg --mq): hg qnew bugA ; make changes for A; hg qref mq branch branchA; hg qci hg qpop; mq up -rtip^ hg qnew bugB ; make changes for B; hg qref mq branch branchB; hg qci To work on A again: hg qpop; mq up branchA; hg qpush It seems crazy to take so many steps, and whenever you need to switch work you must hg qci; hg qpop; mq up ; hg qpush . But consider this: you have several named release branches in the same repository, and you need to work on several projects and bug fixes at the same time for all of them (you'd better get guaranteed bonus for this kind of work). You'd get lost very soon with the other approaches. Now my fellow hg lovers, are there other/better alternatives? (UPDATE) qqueue almost makes #4 obsolete. See Steve Losh's elegant description here .
