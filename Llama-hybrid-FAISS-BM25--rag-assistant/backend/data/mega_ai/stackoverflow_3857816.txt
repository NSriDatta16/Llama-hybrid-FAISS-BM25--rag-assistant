[site]: stackoverflow
[post_id]: 3857816
[parent_id]: 3856635
[tags]: 
The expensive part of this algorithm is figuring out where each item goes. The rest of it is just applying a permutation one cycle at a time. This code takes O(n^2) figuring out where the items go and O(n) to actually move them. If you're willing to use some temporary storage (DRAM instead of flash, say), you could make it much faster by using a temporary array of pointers, sorting that, and then using the result to move the actual data. This is how you would sort large records where the cost of moving them repeatedly is prohibitive. If you aren't allowed to have O(n lg(n)) bits of auxiliary storage, I think you might be out of luck. Just recording which permutation to do requires log(n!) = O(n lg(n)) bits of storage. So you would need to compute the permutation incrementally (like cycleSort does) and I don't see any way to do that cheaply.
