[site]: stackoverflow
[post_id]: 4810657
[parent_id]: 
[tags]: 
Compile String to AST inside CompilerPlugin?

I would like to create a templating plugin and as the first step convert an arbitrary string to it's "compiled" AST representation (as the scala interpreter does, I guess). So a compiler plugin could e.g assign someString to "HELLO WORLD": @StringAnnotation("""("hello world").toString.toUpperCase""") var someString = "" My current first shot plugin does in short: runafter parser create a new representation only compiler and a VirtualFile with the annotation content compile and print unit.body see: http://paste.pocoo.org/show/326025/ a) Right now, "object o{val x = 0}" returns an AST, but e.g. "var x = 1+ 2" doesn't because it wouldn't be a valid .scala file. How can I fix this? b) Is onlyPresentation a good choice? Should I instead overriding computeInternalPhases with the appropriate phases or use -Ystop:phase? c) Is it possible to bind the environment of the outer compiler to the inner one, so that e.g. var x = _ (...) @StringAnnotation("x += 3") would work? I found following code[1] using an interpreter and one variable which does something similar: Interpreter interpreter = new Interpreter(settings); String[] context = { "FOO" }; interpreter.bind("context", "Array[String]", context); interpreter .interpret("de.tutorials.scala2.Test.main(context)"); context[0] = "BAR"; interpreter .interpret("de.tutorials.scala2.Test.main(context)"); [1] http://www.tutorials.de/java/320639-beispiel-zur-einbindung-des-scala-interpreters-kompilierte-scala-anwendungen.html#post1653884 thanks Complete Code: class AnnotationsPI(val global: Global) extends Plugin { import global._ val name = "a_plugins::AnnotationsPI" //a_ to run before namer val description = "AST Trans PI" val components = List[PluginComponent](Component) private object Component extends PluginComponent with Transform with TypingTransformers with TreeDSL { val global: AnnotationsPI.this.global.type = AnnotationsPI.this.global val runsAfter = List[String]("parser"); val phaseName = AnnotationsPI.this.name def newTransformer(unit: CompilationUnit) = { new AnnotationsTransformer(unit) } val SaTpe = "StringAnnotation".toTypeName class AnnotationsTransformer(unit: CompilationUnit) extends TypingTransformer(unit) { /** When using preTransform , each node is * visited before its children. */ def preTransform(tree: Tree): Tree = tree match { case anno@ValDef(Modifiers(_, _, List(Apply(Select(New(Ident(SaTpe)), _), List(Literal(Constant(a))))), _), b, c, d) => //Apply(Select(New(Ident(SaTpe)), /*nme.CONSTRUCTOR*/_), /*List(x)*/x) val str = a.toString val strArr = str.getBytes("UTF-8") import scala.tools.nsc.{ Global, Settings, SubComponent } import scala.tools.nsc.reporters.{ ConsoleReporter, Reporter } val settings = new Settings() val compiler = new Global(settings, new ConsoleReporter(settings)) { override def onlyPresentation = true } val run = new compiler.Run val vfName = "Script.scala" var vfile = new scala.tools.nsc.io.VirtualFile(vfName) val os = vfile.output os.write(strArr, 0, str.size) // void write(byte[] b, int off, int len) os.close new scala.tools.nsc.util.BatchSourceFile(vfName, str) run.compileFiles(vfile :: Nil) for (unit tree } override def transform(tree: Tree): Tree = { super.transform(preTransform(tree)) } } }
