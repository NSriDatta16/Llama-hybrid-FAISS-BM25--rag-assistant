[site]: stackoverflow
[post_id]: 1241683
[parent_id]: 1241633
[tags]: 
You might try looking into something similar to the strategy pattern. Basically, you start by clicking the room button on your toolbar. The toolbar goes through and tells the grid to use the 'room place' actionlistener. Presumably removing any previous action listener that was listening The room place actionlistener would in turn implement all the interesting bit of logic for left/right clicking, dragging, etc. If you have multiple stages to building a room (say, placing doors, then windows, then trap doors); the action listeners would be responsible for handing control off to the next stage: a bit of a finite state machine. So, start by clicking 'room' button, 'place room' listener is added. Drag out the area you want the room to be, 'place room' modifies the game state, then changes the actionlistener to the 'place windows' listener. Ad infinitum... until you finish. One very simple (non compilable) example: class GridPanel extends JPanel { void SetMouseListener(MouseListener newListener) { for(MouseListener ml : getMouseListeners()) removeMouseListener(ml); addMouseListener(newListener); } } class ControlPanel extends JPanel { GridPanel gameGrid; void OnRectangleButtonClicked(some stuff) { gameGrid.SetMouseListener(new PlaceRoomListener(gameGrid)); } } class PlaceRoomListener extends MouseAdapter { GridPanel gameGrid; //constructor, etc void OnClick(mouse event) { gameGrid.doCoolStuff(); gameGrid.SetMouseListener(new PlaceTrapDoorListener()); } } //etc Now, that non-compilable example aside, Pyrolistical does have a point: you generally don't want to combine your game model and graphic interface into one single glob of classes. You want the model separated from the GUI, and to manipulate it through a well defined interface. (Also, there are probably better methods for going about removing the mouse listener then just randomly removing all listeners... I was in a bit of a rush, sorry)
