[site]: stackoverflow
[post_id]: 4764573
[parent_id]: 
[tags]: 
Why is TypedReference behind the scenes? It's so fast and safe... almost magical!

Warning: This question is a bit heretical... religious programmers always abiding by good practices, please don't read it. :) Does anyone know why the use of TypedReference is so discouraged (implicitly, by lack of documentation)? I've found great uses for it, such as when passing generic parameters through functions that shouldn't be generic (when using an object might be overkill or slow, if you need a value type), for when you need an opaque pointer, or for when you need to access an element of an array quickly, whose specs you find at runtime (using Array.InternalGetReference ). Since the CLR doesn't even allow incorrect usage of this type, why is it discouraged? It doesn't seem to be unsafe or anything... Other uses I've found for TypedReference : "Specializing" generics in C# (this is type-safe): static void foo (ref T value) { //This is the ONLY way to treat value as int, without boxing/unboxing objects if (value is int) { __refvalue(__makeref(value), int) = 1; } else { value = default(T); } } Writing code that works with generic pointers (this is very unsafe if misused, but fast and safe if used correctly): //This bypasses the restriction that you can't have a pointer to T, //letting you write very high-performance generic code. //It's dangerous if you don't know what you're doing, but very worth if you do. static T Read (IntPtr address) { var obj = default(T); var tr = __makeref(obj); //This is equivalent to shooting yourself in the foot //but it's the only high-perf solution in some cases //it sets the first field of the TypedReference (which is a pointer) //to the address you give it, then it dereferences the value. //Better be 10000% sure that your type T is unmanaged/blittable... unsafe { *(IntPtr*)(&tr) = address; } return __refvalue(tr, T); } Writing a method version of the sizeof instruction, which can be occasionally useful: static class ArrayOfTwoElements { static readonly Value = new T[2]; } static uint SizeOf () { unsafe { TypedReference elem1 = __makeref(ArrayOfTwoElements .Value[0] ), elem2 = __makeref(ArrayOfTwoElements .Value[1] ); unsafe { return (uint)((byte*)*(IntPtr*)(&elem2) - (byte*)*(IntPtr*)(&elem1)); } } } Writing a method that passes a "state" parameter that wants to avoid boxing: static void call(Action action, TypedReference state) { //Note: I could've said "object" instead of "TypedReference", //but if I had, then the user would've had to box any value types try { action(0, state); } finally { /*Do any cleanup needed*/ } } So why are uses like this "discouraged" (by lack of documentation)? Any particular safety reasons? It seems perfectly safe and verifiable if it's not mixed with pointers (which aren't safe or verifiable anyway)... Update: Sample code to show that, indeed, TypedReference can be twice as fast (or more): using System; using System.Collections.Generic; static class Program { static void Set1 (T[] a, int i, int v) { __refvalue(__makeref(a[i]), int) = v; } static void Set2 (T[] a, int i, int v) { a[i] = (T)(object)v; } static void Main(string[] args) { var root = new List (); var rand = new Random(); for (int i = 0; i (Edit: I edited the benchmark above, since the last version of the post used a debug version of the code [I forgot to change it to release], and put no pressure on the GC. This version is a bit more realistic, and on my system, it's more than three times faster with TypedReference on average.)
