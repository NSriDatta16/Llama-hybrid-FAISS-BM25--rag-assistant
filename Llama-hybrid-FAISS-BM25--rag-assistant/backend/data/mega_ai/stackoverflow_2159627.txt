[site]: stackoverflow
[post_id]: 2159627
[parent_id]: 
[tags]: 
Linkage in C: does GCC follow the C99 spec, or do I not understand the spec?

I'm trying to understand the exact behavior of storage class specifiers in C99, and some GCC behavior seems not to follow the spec, unless I misunderstand the spec. From 6.2.2 (2): Within one translation unit, each declaration of an identifier with internal linkage denotes the same object or function. However, I tested GCC (powerpc-apple-darwin9-gcc-4.2.1) with the following program: #include static int f() { static int x = 0; return x++; } static int g() { static int x = 0; return x++; } int main(int argc, char *argv[]) { printf("g() = %i\n", g()); printf("g() = %i\n", g()); printf("f() = %i\n", f()); printf("f() = %i\n", f()); return 0; } Compiled with -std=c99 , It prints the following: g() = 0 g() = 1 f() = 0 f() = 1 If I understand the spec correctly, it should print: g() = 0 g() = 1 f() = 2 f() = 3 I understand why GCC would deviate from the spec here, I'm just wondering if there's a deeper explanation for this behavior.
