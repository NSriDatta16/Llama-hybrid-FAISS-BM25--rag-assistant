[site]: stackoverflow
[post_id]: 1375148
[parent_id]: 
[tags]: 
Autofac, ASP.NET and Microsoft.Practices.ServiceLocation

I've been working thru the details of implementing IoC in my web apps but in a way that leverages Microsoft.Practices.ServiceLocation. I am specifically using Autofac and the asp.net integration, but I wanted to leave myself open to other containers. Along the lines of this question , i was concerned about how to access the container in my web app code. I have a 'core' library that primarily defines interfaces to be resolved. This core library is used by my web app and other apps as well. Very handy to have common interfaces defined. I thought this was an excellent place to put access to the IoC container, and I did so with a static class. The trick is injecting the container into the static class. It's tricky in a web environment becuase the container may be different for each request, while in a non-web app it will probably be the same all the time. At first I tried injecting the container direclty with a method but that quickly failed on the next web request! So I came up with this: public static class IoCContainer { public static void SetServiceLocator(Func getLocator) { m_GetLocator = getLocator; } static private Func m_GetLocator = null; public static T GetInstance (string typeName) { return m_GetLocator().GetInstance (typeName); } } Now in my global.asax.cs I do this: protected void Application_Start(object sender, EventArgs e) { var builder = new Autofac.Builder.ContainerBuilder(); ... register stuff ... var container = builder.Build(); _containerProvider = new Autofac.Integration.Web.ContainerProvider(container); Xyz.Core.IoCContainer.SetServiceLocator(() => new AutofacContrib.CommonServiceLocator.AutofacServiceLocator (_containerProvider.RequestContainer)); } public IContainerProvider ContainerProvider { get { return _containerProvider; } } static IContainerProvider _containerProvider; And calls to resolve dependences look like var someService = Xyz.Core.GetInstance (); So rather than pass a specific container I pass a delegate that knows how to GET a container. For non-web applications the delegate would probably just return what builder.Build() serves up. My question to the experts is, does this make sense? I have an easy way to get to something that can resolve dependencies without knowing what the container product is or where the container itself comes from. What do you think?
