[site]: stackoverflow
[post_id]: 1980927
[parent_id]: 685758
[tags]: 
Basically, it simplifies any loop that uses a boolean flag like this: found = False # and allows you to skip the management of the flag: for divisor in range(2, n): if n % divisor == 0: print(n, "is divisible by", divisor) break else: print(n, "is prime") Note that there is already a natural place for code to execute when you do find a divisor - right before the break . The only new feature here is a place for code to execute when you tried all divisors and did not find any. This helps only in conjuction with break . You still need booleans if you can't break (e.g. because you looking for the last match, or have to track several conditions in parallel). Oh, and BTW, this works for while loops just as well. any/all If the only purpose of the loop is a yes-or-no answer, any() / all() functions with a generator or generator expression can be utilized: if any(n % divisor == 0 for divisor in range(2, n)): print(n, "is composite") else: print(n, "is prime") Note the elegancy! The code is 1:1 what you want to say! [This has similar efficiency to a loop with a break , because the any() function is short-circuiting, only running the generator expression until it yeilds True .] But that won't give you the actual divisor, as any() always returns exactly True or False . A loop with else: is hard to beat when you need both (A) access to current value that was "found" (B) separate code paths for "found" vs. "not found" cases.
