[site]: stackoverflow
[post_id]: 2738548
[parent_id]: 2707567
[tags]: 
Utilizing any driver within the OSGi environment requires you using a DynamicImport-Package: * statement so your bundle can resolve these packages when you load a driver with Class.forName(..). Probably the easiest way is to try to access a class that is in the org.osgi.framework package. Those should at least be always around in an OSGi environment (see snippet below). There are more sophisticated mechanisms, so let me know if you need something more advanced. Also, take a look at the OSGi R4.2 core spec, paragraph 3.8.9 which shows some methods of finding the Bundle and BundleContext of a class and therefore indirect helps in determining if you're in a framework or not. That depends on what you're doing, no generic "yes" or "no" answer here. OSGi uses classloaders and does so in a way that is not "typical" for a standard Java application, but depending on what you're doing, you might not notice. No. Take a look at the recently released OSGi enterprise specs. They have a chapter on JNDI integration in OSGi which probably allows you to leave your code (largely) unmodified. A simple example snippet: public static boolean inOSGi() { try { Class.forName("org.osgi.framework.FrameworkUtil"); return true; } catch (ClassNotFoundException e) { return false; } } Just make sure that you if you put this code in a bundle, the bundle should import org.osgi.framework (otherwise it will never find that class).
