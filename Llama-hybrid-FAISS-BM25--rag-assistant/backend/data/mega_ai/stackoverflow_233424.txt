[site]: stackoverflow
[post_id]: 233424
[parent_id]: 232678
[tags]: 
My first question is how do you calculate len? Is it just strlen or does it include room for the \0 terminator? I think you may be overshooting your allocation in your strcpy. Bad behavior will tend to happen on word boundaries and appear random. Also, check to make sure that your source strings are null terminated. If you made a mistake on the read side and didn't terminate them. Then strcpy may be randomly overwriting things. *(lines + slot) = (char *) malloc(len * sizeof(char)); if(*(lines + slot) == NULL) exit(EXIT_FAILURE); strcpy(*(lines+slot),s); Perhaps try: lines[slot] = (char *) malloc((len + 1) * sizeof(char)); if(lines[slot] == NULL) exit(EXIT_FAILURE); if(strlen(s) In terms of general form, I'd also encourage you to make a few stylistic changes to make the whole thing a bit more readable, easier to follow and resistant to errors. Pointer arithmetic is valid and fun, but I think your intent is a little more clear if you use the array form like: free(lines[slot]); lines[slot] = NULL; instead of free(*(lines+slot)); *(lines + slot) = NULL; I'd also encourage you to use fewer statics. It's easy enough to through them in a data structure and pass them around into your accessors and mutators. It becomes much more clear where the action is happening prevents you from doing things like: static int numlines = 0; void insert_line(char *s, int len){ int numlines = 5; where you can introduce scoping issues that are just miserable to debug.
