[site]: stackoverflow
[post_id]: 3010412
[parent_id]: 3010245
[tags]: 
It seems like you have a memory leak. 6 threads is not much. I suspect it is because ObjectInputStream and ObjectOutputStream cache all the objects transmitted. This makes them quite unsuitable for long transfers. You think you are sending an object that is then gc'ed, but it's really being held in memory by the object streams. To flush the streams cache, use objectOutputStream.reset() after writing your objects with writeObject() EDIT: To get thread pooling, the SocketHandler can be passed to an Executor instead of starting it's own thread. You create an executor like: Executor executor = Executors.newFiexThreadPool(MaxUsers); The executor is created as a field, or at the same level as the server socket. Then after accepting a connection you add the SocketHandler to the executor: executor.execute(new SocketHandler(...)); However, if your clients are long lived, then this will make little improvement, since the thread startup time is small compared to the amount of work done on each thread. Pools are most effective for executing many small tasks, rather than a few large ones. As to making the server more robust - some quick hints ensure it is started with sufficient memory, or at least that the maximum memory is set to anticipate the need of 1000 users. use a load test framework, such as Apache JMeter to verify it will scale to the maximum number of users. use a connection pool for your database, and don't hand-code JDBC calls - use an established framework, e.g. Spring JDBC. Each thread starts with 2MB stack by default. So, if you have 1000 users, then that will use ~2GB of virtual process space just for the stack. ON many 32-bit systems, this is the amount of user space you can have, so there will be no room for data. If you need more users, then either scale out to more processes, with a load balancer passing requests to each process, or look at server solutions that do not require a thread per connection. attention to detail, particularly exception handling. logging, for diagnosing failures. JMX or other managability to monitor server health, with notification to you when values go out of bounds (e.g. memory/cpu use too high for a long period, or request time slow.) See Architecture of a Highly Scalable Server
