[site]: stackoverflow
[post_id]: 5256500
[parent_id]: 5256313
[tags]: 
You don't need that sort of solution for string literals, since they are concatenated at the language level, and it wouldn't work anyway because "s""1" isn't a valid preprocessor token. [Edit: In response to the incorrect "Just for the record" comment below that unfortunately received several upvotes, I will reiterate the statement above and observe that the program fragment #define PPCAT_NX(A, B) A ## B PPCAT_NX("s", "1") produces this error message from the preprocessing phase of gcc: error: pasting ""s"" and ""1"" does not give a valid preprocessing token ] However, for general token pasting, try this: /* * Concatenate preprocessor tokens A and B without expanding macro definitions * (however, if invoked from a macro, macro arguments are expanded). */ #define PPCAT_NX(A, B) A ## B /* * Concatenate preprocessor tokens A and B after macro-expanding them. */ #define PPCAT(A, B) PPCAT_NX(A, B) Then, e.g., both PPCAT_NX(s, 1) and PPCAT(s, 1) produce the identifier s1 , unless s is defined as a macro, in which case PPCAT(s, 1) produces 1 . Continuing on the theme are these macros: /* * Turn A into a string literal without expanding macro definitions * (however, if invoked from a macro, macro arguments are expanded). */ #define STRINGIZE_NX(A) #A /* * Turn A into a string literal after macro-expanding it. */ #define STRINGIZE(A) STRINGIZE_NX(A) Then, #define T1 s #define T2 1 STRINGIZE(PPCAT(T1, T2)) // produces "s1" By contrast, STRINGIZE(PPCAT_NX(T1, T2)) // produces "T1T2" STRINGIZE_NX(PPCAT_NX(T1, T2)) // produces "PPCAT_NX(T1, T2)" #define T1T2 visit the zoo STRINGIZE(PPCAT_NX(T1, T2)) // produces "visit the zoo" STRINGIZE_NX(PPCAT(T1, T2)) // produces "PPCAT(T1, T2)"
