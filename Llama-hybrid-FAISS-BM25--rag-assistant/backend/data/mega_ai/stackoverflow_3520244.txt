[site]: stackoverflow
[post_id]: 3520244
[parent_id]: 3520052
[tags]: 
If you can instantiate Resource directly you just do that and stick the path and get method on directly. from types import MethodType book = Resource() def get(self): return aBook book.get = MethodType(get, book) book.path = path This assumes though that path and get are not used in the __init__ method of Resource and that path is not used by any class methods which it shouldn't be given your concerns. If your primary concern is making sure that nothing inherits from the Book non-class, then you could just use this metaclass class Terminal(type): classes = [] def __new__(meta, classname, bases, classdict): if [cls for cls in meta.classes if cls in bases]: raise TypeError("Can't Touch This") cls = super(Terminal, meta).__new__(meta, classname, bases, classdict) meta.classes.append(cls) return cls class Book(object): __metaclass__ = Terminal class PaperBackBook(Book): pass You might want to replace the exception thrown with something more appropriate. This would really only make sense if you find yourself instantiating a lot of one offs. And if that's not good enough for you and you're using CPython, you could always try some of this hackery: class Resource(object): def __init__(self, value, location=1): self.value = value self.location = location with Object('book', Resource, 1, location=2): path = '/books/{id}' def get(self): aBook = 'abook' return aBook print book.path print book.get() made possible by my very first context manager. class Object(object): def __init__(self, name, cls, *args, **kwargs): self.cls = cls self.name = name self.args = args self.kwargs = kwargs def __enter__(self): self.f_locals = copy.copy(sys._getframe(1).f_locals) def __exit__(self, exc_type, exc_val, exc_tb): class cls(self.cls): pass f_locals = sys._getframe(1).f_locals new_items = [item for item in f_locals if item not in self.f_locals] for item in new_items: setattr(cls, item, f_locals[item]) del f_locals[item] # Keyser Soze the new names from the enclosing namespace obj = cls(*self.args, **self.kwargs) f_locals[self.name] = obj # and insert the new object Of course I encourage you to use one of my above two solutions or Katrielalex's suggestion of ABC's.
