[site]: stackoverflow
[post_id]: 4860800
[parent_id]: 4860686
[tags]: 
Put the move method where it makes sense, the World can't move, the Agent can. If you're looking to be able to access world-level functionality, give your constructor method a parameter and pass the world instance in. world = World() agent = Agent(world) This give explicit access to the World from your agent, rather than assuming some sort of hierarchy. You can take this a step further and require that all game objects within the world take the world as a parameter. You could enforce this by creating a base GameObject class that your Agent, and other game objects, inherit. class GameObject: def __init__(self, world): self.world = world class Agent(GameObject): def __init__(self, world, startX, startY): # don't forget to call the super and pass the world to it super(Agent, self).__init__(world) self.startX = startX self.startY = startY def move(self): print 'I can see the world' print self.world EDIT: To extend my explanation further, if you had an Enemy class and the enemy had a move() method as well, chances are good you may want the enemy to move towards the agent. However, you don't want the enemy asking the world for the position of the agent, instead you can just store a reference to the agent inside the enemy as it's "target" and check it's position any time you need. class Enemy(GameObject): def __init__(self, world, target): super(Agent, self).__init__(world) self.target = target def move(self): if self.target.x > self.x: self.x += 5
