[site]: stackoverflow
[post_id]: 5233862
[parent_id]: 
[tags]: 
Keep 'obvious' lock-retrieve or employ double-checked locking?

I suck at formulating questions. I have the following piece of (Java) code (pseudo): public SomeObject getObject(Identifier someIdentifier) { // getUniqueIdentifier retrieves a singleton instance of the identifier object, // to prevent two Identifiers that are equals() but not == (reference equals) in the system. Identifier singletonInstance = getUniqueIdentifier(someIdentifier); synchronized (singletonInstance) { SomeObject cached = cache.get(singletonInstance); if (cached != null) { return cached; } else { SomeObject newInstance = createSomeObject(singletonInstance); cache.put(singletonInstance, newInstance); return newInstance; } } } Basically, it makes an identifier 'unique' (reference equals, as in == ), checks a cache, and in case of a cache miss, calls an expensive method (involving calling an external resource and parsing, etc), puts that in the cache, and returns. The synchronized Identifier , in this case, avoids two equals() but not == Identifier objects being used to call the expensive method, which would retrieve the same resource simultaneously. The above works. I'm just wondering, and probably micro-optimizing, would a rewrite such as the following that employs more na√Øve cache retrieval and double-checked locking be 'safe' (safe as in threadsafe, void of odd race conditions) and be 'more optimal' (as in a reduction of unneeded locking and threads having to wait for a lock)? public SomeObject getObject(Identifier someIdentifier) { // just check the cache, reference equality is not relevant just yet. SomeObject cached = cache.get(someIdentifier); if (cached != null) { return cached; } Identifier singletonInstance = getUniqueIdentifier(someIdentifier); synchronized (singletonInstance) { // re-check the cache here, in case of a context switch in between the // cache check and the opening of the synchronized block. SomeObject cached = cache.get(singletonInstance); if (cached != null) { return cached; } else { SomeObject newInstance = createSomeObject(singletonInstance); cache.put(singletonInstance, newInstance); return newInstance; } } } You could say 'Just test it' or 'Just do a micro-benchmark', but testing multi-threaded bits of code isn't my strong point, and I doubt I'd be able to simulate realistic situations or accurately fake race conditions. Plus it'd take me half a day, whereas writing a SO question only takes me a few minutes :).
