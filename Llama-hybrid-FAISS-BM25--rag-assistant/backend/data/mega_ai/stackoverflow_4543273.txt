[site]: stackoverflow
[post_id]: 4543273
[parent_id]: 4543160
[tags]: 
I'm not sure the other solutions will work exactly the way he wants. The reasoning for this is that PdfPage page = doc.AddPage(); creates and adds a new page at the same time, thus it will always be out of order since the order is dictated first come first serve through doc If AddPage is a fast operation, you can create all 100 pages at once, without any processing. Then go back through and render the Tiff images into the page. PdfDocument doc = new PdfDocument(); string mail = textBox1.Text; string[] split = mail.Split(new string[] { Environment.NewLine }, StringSplitOptions.None); int counter = split.Count(); // Source must be array or IList. var source = Enumerable.Range(0, 100000).ToArray(); // Partition the entire source array. var rangePartitioner = Partitioner.Create(0, counter); double[] results = new double[counter]; PdfPage[] pages = new PdfPage[counter]; for (int i = 0; i { // Loop over each range element without a delegate invocation. for (int i = range.Item1; i Edit I think there is a more elegant solution but without knowing the Properties of PdfPage I didn't want to offer it before. If you can tell which page a PfdPage belongs to you can make things very simple like so: PdfDocument doc = new PdfDocument(); string mail = textBox1.Text; string[] split = mail.Split(new string[] { Environment.NewLine }, StringSplitOptions.None); int counter = split.Count(); // Source must be array or IList. var source = Enumerable.Range(0, 100000).ToArray(); // Partition the entire source array. var rangePartitioner = Partitioner.Create(0, counter); double[] results = new double[counter]; // Loop over the partitions in parallel. Parallel.ForEach(rangePartitioner, (range, loopState) => { // Loop over each range element without a delegate invocation. for (int i = range.Item1; i
