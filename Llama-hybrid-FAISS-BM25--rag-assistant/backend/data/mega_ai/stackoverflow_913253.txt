[site]: stackoverflow
[post_id]: 913253
[parent_id]: 912583
[tags]: 
Then, I'd like to be able to get mouse events for each button, so that I can do other things. Don't worry about the mouse. There may not even be a mouse (think of the ever-popular tablet-Mac rumor). I'd like to make a new class (FirstLaunch) for the first launch, but I'm not sure what to call from AppDelegate. You make your own methods here. You'll probably make it a singleton*; then, you'll implement a method named something like runFirstLaunchPanel: , which will be an action method (more on those in a moment): - (IBAction) runFirstLaunchPanel:(id)sender; Instantiate the object in the nib, then, from your app delegate, call the action method with nil as the sender. The reason to put the object in your nib and make the method an action method is that this makes it easy to hook up a menu item to it, so that the user can re-run the first-launch panel at a later time. (For example, if it's a Starting Points window, you might connect the New menu item to this action instead of the default one.) *Yes, I've seen the articles about singletons, and I agree with them. In a case like this, it's OK. Also, to get mouse events, This is the wrong way of thinking about it. What you need to do is set your button up to send a message to your controller to make the controller (probably AppDelegate ) do something . The message you want the button to send is an action message. Implement an action method in the object that owns the nib containing the window with the buttons. Declare this method in the class's header, then connect the button to it in IB by right-clicking on your controller and dragging from the correct action method's circle to the button. This is called the target-action paradigm, and it insulates controller responsibilities (doing things) from the views that ordered them. Because each action method does only one thing, you can have a button, a menu item, and even another controller (your app delegate, above) send the same action message, and the receiving controller won't have to care which control is sending the action, because it already knows what it has to do. shouldn't I be a sublass of the buttons, No. You very rarely create subclasses of anything other than NSObject (or, for model objects in Core Data, NSManagedObject) in Cocoa. Note that I said “rarely”, not “never”. You will have to make the occasional subclass, especially if you want to create custom or customized views and cells (and, maybe, customized windows). However, subclassing is not necessary in Cocoa to the degree that (I hear) it is in some other frameworks on other platforms. and considering that I have multiple buttons, I'm confused. The target-action paradigm means you don't have to create one button subclass per button. One controller class implements all the actions, and the stock buttons, because you've hooked them up in IB, simply tell the controller “do this”. Broken down, I need to access & manipulate IBOutlets I have set in IB, Probably not. At least, not as much as you think you do. determine when buttons are clicked (and which button was clicked). Nope. The buttons will worry about being clicked; you just worry about setting them up to send, and then responding to, their action messages.
