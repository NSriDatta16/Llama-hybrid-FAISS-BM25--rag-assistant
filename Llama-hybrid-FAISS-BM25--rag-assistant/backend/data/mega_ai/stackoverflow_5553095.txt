[site]: stackoverflow
[post_id]: 5553095
[parent_id]: 5384921
[tags]: 
The solution we finally went with was to use 00:00 as a stand-in for 24:00, with logic throughout the class and the rest of the application to interpret this local value. This is a true kludge, but it's the least intrusive and most elegant thing I could come up with. First, the LocalTimeInterval class keeps an internal flag of whether the interval endpoint is end-of-day midnight (24:00). This flag will only be true if the end time is 00:00 (equal to LocalTime.MIDNIGHT). /** * @return Whether the end of the day is {@link LocalTime#MIDNIGHT} and this should be considered midnight of the * following day. */ public boolean isEndOfDay() { return isEndOfDay; } By default the constructor considers 00:00 to be beginning-of-day, but there is an alternate constructor for manually creating an interval that goes all day: public LocalTimeInterval(final LocalTime start, final LocalTime end, final boolean considerMidnightEndOfDay) { ... this.isEndOfDay = considerMidnightEndOfDay && LocalTime.MIDNIGHT.equals(end); } There is a reason why this constructor doesn't just have a start time and an "is end-of-day" flag: when used with a UI with a drop-down list of times, we don't know if the user will choose 00:00 (which is rendered as 24:00), but we know that as the drop-down list is for the end of the range, in our use case it means 24:00. (Although LocalTimeInterval allows empty intervals, we don't allow them in our application.) Overlap checking requires special logic to take care of 24:00: public boolean overlaps(final LocalTimeInterval localInterval) { if (localInterval.isEndOfDay()) { if (isEndOfDay()) { return true; } return getEnd().isAfter(localInterval.getStart()); } if (isEndOfDay()) { return localInterval.getEnd().isAfter(getStart()); } return localInterval.getEnd().isAfter(getStart()) && localInterval.getStart().isBefore(getEnd()); } Similarly, converting to an absolute Interval requires adding another day to the result if isEndOfDay() returns true. It is important that application code never constructs an Interval manually from a LocalTimeInterval's start and end values, as the end time may indicate end-of-day: public Interval toInterval(final ReadableInstant baseInstant) { final DateTime start = getStart().toDateTime(baseInstant); DateTime end = getEnd().toDateTime(baseInstant); if (isEndOfDay()) { end = end.plusDays(1); } return new Interval(start, end); } When persisting LocalTimeInterval in the database, we were able to make the kludge totally transparent, as Hibernate and SQL have no 24:00 restriction (and indeed have no concept of LocalTime anyway). If isEndOfDay() returns true, our PersistentLocalTimeIntervalAsTime implementation stores and retrieves a true time value of 24:00: ... final Time startTime = (Time) Hibernate.TIME.nullSafeGet(resultSet, names[0]); final Time endTime = (Time) Hibernate.TIME.nullSafeGet(resultSet, names[1]); ... final LocalTime start = new LocalTime(startTime, DateTimeZone.UTC); if (endTime.equals(TIME_2400)) { return new LocalTimeInterval(start, LocalTime.MIDNIGHT, true); } return new LocalTimeInterval(start, new LocalTime(endTime, DateTimeZone.UTC)); and final Time startTime = asTime(localTimeInterval.getStart()); final Time endTime = localTimeInterval.isEndOfDay() ? TIME_2400 : asTime(localTimeInterval.getEnd()); Hibernate.TIME.nullSafeSet(statement, startTime, index); Hibernate.TIME.nullSafeSet(statement, endTime, index + 1); It's sad that we had to write a workaround in the first place; this is the best I could do.
