[site]: stackoverflow
[post_id]: 937775
[parent_id]: 937719
[tags]: 
Provided the length of your bitfields is limited, the following may work: First, represent the bitfields that are in the set as an array of booleans, so in your case (4 bit bitfields), new bool[16]; Transform this array of booleans into a bitfield itself, so a 16-bit bitfield in this case, where each bit represents whether the bitfield corresponding to its index is included Then operations become: Remove(0, 0) = and with bitmask 1010101010101010 Remove(1, 0) = and with bitmask 0101010101010101 Remove(0, 2) = and with bitmask 1111000011110000 Note that more complicated 'add/remove' operations could then also be added as O(1) bit-logic. The only down-side is that extra work is needed to interpret the resulting 16-bit bitfield back into a set of values, but with lookup arrays that might not turn out too bad either. Addendum: Additional down-sides: Once the size of an integer is exceeded, every added bit to the original bit-fields will double the storage space. However, this is not much worse than a typical scenario using another collection where you have to store on average half the possible bitmask values (provided the typical scenario doesn't store far less remaining values). Once the size of an integer is exceeded, every added bit also doubles the number of 'and' operations needed to implement the logic. So basically, I'd say if your original bitfields are not much larger than a byte, you are likely better off with this encoding, beyond that you're probably better off with the original strategy. Further addendum: If you only ever execute Remove operations, which over time thins out the set state-space further and further, you may be able to stretch this approach a bit further (no pun intended) by making a more clever abstraction that somehow only keeps track of the int values that are non-zero. Detecting zero values may not be as expensive as it sounds either if the JIT knows what it's doing, because a CPU 'and' operation typically sets the 'zero' flag if the result is zero. As with all performance optimizations, this one'd need some measurement to determine if it is worthwile.
