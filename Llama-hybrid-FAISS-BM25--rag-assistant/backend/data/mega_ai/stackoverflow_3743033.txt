[site]: stackoverflow
[post_id]: 3743033
[parent_id]: 3743011
[tags]: 
In brief, because that in general complicates programming tasks. Manual memory management requires considerable skills and effort to get right - effort you can't use for the actual task you are to solve. The scenario you show above is common, but far from being the only one. What if you return a reference to one of the objects? What if you pass a reference to a called method (where it may get stored)? Etc etc. These are all issues you need to think of before you can responsibly destroy your objects. Altogether these are known as "ownership". The other side of the coin is, would it really have a positive effect to be able to destroy objects at a specified point during execution? This makes possible destructors, and RAII in C++, which is a very powerful idiom. Java doesn't have it, and when I started to use Java, I often missed it. However, there are ways to solve these issues effectively in Java as well (such as the finally block). However elegant RAII is, it still does not pay for the whole mess that manual memory management can cause. Then you might suggest, "why can't we have both: explicit destruction of objects when I want to, and garbage collection for the rest?". And you can start running for cover before the compiler writers and JVM implementors get you :-) That would complicate matters so much, noone would do it without a really huge, tangible benefit. And manual memory management offers no such thing.
