[site]: stackoverflow
[post_id]: 4174371
[parent_id]: 4174256
[tags]: 
A good approach would be to create one thread that only accepts new connections. That's where you have a listener socket. Then, for every connection that gets accepted, you have a new connected socket, so you can spawn another thread, giving it the connected socket as a parameter. That way, your thread that accepts connections doesn't get blocked, and can connect to many clients very fast. The processing threads deal with the clients and then they exit. I don't even know why need to wait for them, but if you do, you may deal with it in some other way, depending on the OS and/or libraries that you use (messages, signals etc can be used). If you don't want to spawn a new thread for each connected client, then as Ben Voigt suggested, you can use select. That is another good approach if you want to make it single threaded. Basically, all your sockets will be in an array of socket descriptors and using select you will know what happened (someone connected, socket is ready for read/write, socket got disconnected etc) and act accordingly. Here's one example Partial one, but it works. you just accept connections in the acceptConnections(), which will then spawn a separate thread for each client. That's where you communicate with the clients. It's from a windows code that i have lying around, but it's very easy to be reimplemented for any platform. typedef struct SOCKET_DATA_ { SOCKET sd; /* other parameters that you may want to pass to the clientProc */ } SOCKET_DATA; /* In this function you communicate with the clients */ DWORD WINAPI clientProc(void * param) { SOCKET_DATA * pSocketData = (SOCKET_DATA *)param; /* Communicate with the new client, and at the end deallocate the memory for SOCKET_DATA and return. */ delete pSocketData; return 0; } int acceptConnections(const char * pcAddress, int nPort) { sockaddr_in sinRemote; int nAddrSize; SOCKET sd_client; SOCKET sd_listener; sockaddr_in sinInterface; SOCKET_DATA * pSocketData; HANDLE hThread; sd_listener = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (INVALID_SOCKET == sd_listener) { fprintf(stderr, "Could not get a listener socket!\n"); return 1; } sinInterface.sin_family = AF_INET; sinInterface.sin_port = nPort; sinInterface.sin_addr.S_un.S_addr = INADDR_ANY; if (SOCKET_ERROR != bind(sd_listener, (sockaddr*)&sinInterface, sizeof(sockaddr_in))) { listen(sd_listener, SOMAXCONN); } else { fprintf(stderr, "Could not bind the listening socket!\n"); return 1; } while (1) { nAddrSize = sizeof(sinRemote); sd_client = accept(sd_listener, (sockaddr*)&sinRemote, &nAddrSize); if (INVALID_SOCKET == sd_client) { fprintf(stdout, "Accept failed!\n"); closesocket(sd_listener); return 1; } fprintf(stdout, "Accepted connection from %s:%u.\n", inet_ntoa(sinRemote.sin_addr), ntohs(sinRemote.sin_port)); pSocketData = (SOCKET_DATA *)malloc(sizeof(SOCKET_DATA)); if (!pSocketData) { fprintf(stderr, "Could not allocate memory for SOCKET_DATA!\n"); return 1; } pSocketData->sd = sd_client; hThread = CreateThread(0, 0, clientProc, pSocketData, 0, &nThreadID); if (hThread == INVALID_HANDLE_VALUE) { fprintf(stderr, "An error occured while trying to create a thread!\n"); delete pSocketData; return 1; } } closesocket(sd_listener); return 0; }
