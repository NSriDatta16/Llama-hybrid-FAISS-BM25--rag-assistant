[site]: stackoverflow
[post_id]: 745531
[parent_id]: 421566
[tags]: 
I've solved this by leveraging the fact that any CLR object wrapped by dotNetObject will automatically wrap return values (method results and property values) with another wrapper. This even applies to static methods and properties on CLR types wrapped with dotNetClass. Lets say I've already got a method in my plugin that lets me execute arbitrary MAXScript: Value* EvalScript(System::String ^script); Now I just need to serialize an object into a string and back again to an active object (a reference to the same object, not just a copy!). I do this by grabbing the GCHandle of the object, using GCHandle::ToIntPtr to convert it to something blittable and using GCHandle::FromIntPtr to materialize the same object in a different context. Of course I am doing this in process (and in the same app domain), this wouldn't work otherwise. Value* WrapObject(System::Object ^obj) { GCHandle handle = GCHandle::Alloc(obj) try { return EvalScript(System::String::Format( L"((dotNetClass \"System.Runtime.InteropServices.GCHandle\").FromIntPtr (dotNetObject \"System.IntPtr\" {0})).get_Target()", GCHandle::ToIntPtr(handle)); } finally { handle.Free(); } } The comment I have explaining this in the real code is more that 10x as long as the actual code.
