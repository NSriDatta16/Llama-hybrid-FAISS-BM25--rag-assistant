[site]: stackoverflow
[post_id]: 5447755
[parent_id]: 
[tags]: 
C pointer conversion rules

I have the following code: #include #include typedef union stateof stateof; union stateof { stateof* foo; double* bar; }; typedef struct hunch hunch; struct hunch{ double* first; double* second; }; void main(){ #define write(x) printf("%d \n",x); int* storage = 0; stateof* un = (stateof*)&storage; un->foo = 300; write(storage); un->bar = 600; write(storage); hunch* h = (hunch*)&storage; h->first = 1200; write(storage); h->second = 1600; write(storage); } The output of this program is: 300 600 1200 1200 What is happening here? What does it mean for the un->{foo,bar} and h->{first,second} statements to execute when they most definitely do not point to valid structures? What is exactly occurring during this period and why is the output of the union different than that of the structure?
