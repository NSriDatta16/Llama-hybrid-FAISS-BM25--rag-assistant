[site]: stackoverflow
[post_id]: 4471810
[parent_id]: 4470424
[tags]: 
Typically when you create a Singleton class you don't want to inherit from it. When you do this you lose some of the goodness of the Singleton pattern (and what I hear from the pattern zealots is that an angel loses its wings every time you do something like this). But lets be pragmatic...sometimes you do what you have to do. Regardless I do not think combining generics and inheritance will work in this instance anyway. You indicated the number of algorithms will be in the tens (not hundreds). As long is this is the case I would create a dictionary keyed off of System.Type and store references to your methods as the values of the dictionary. In this case I used Func as the dictionary value signature. When the class instantiates for the first time register all your available algorithms in the dictionary. At runtime when the class needs to execute an algorithm for type T it will get the Type of T and look up the alogorithm in the dictionary. If the code for the algorithms will be relatively involved I would suggest splitting them off into partial classes just to keep your code readable. public sealed partial class Algorithm { private static object ExecuteForSomeType(DataCache dataCache) { return new SomeType(); } } public sealed partial class Algorithm { private static object ExecuteForSomeOtherType(DataCache dataCache) { return new SomeOtherType(); } } public sealed partial class Algorithm { private readonly Dictionary > _algorithms = new Dictionary >(); private readonly Dictionary _resultsWeak = new Dictionary (); private readonly Dictionary _resultsStrong = new Dictionary (); private Algorithm() { } private static Algorithm _instance; public static Algorithm Instance { get { if (_instance == null) { _instance = new Algorithm (); _instance._algorithms.Add(typeof(SomeType), ExecuteForSomeType); _instance._algorithms.Add(typeof(SomeOtherType), ExecuteForSomeOtherType); } return _instance; } } public T ComputeResult(DataCache dataCache, bool save = false) { T returnValue = (T)(new object()); if (_resultsStrong.ContainsKey(dataCache)) { returnValue = _resultsStrong[dataCache]; return returnValue; } if (_resultsWeak.ContainsKey(dataCache)) { returnValue = (T)_resultsWeak[dataCache].Target; if (returnValue != null) return returnValue; } returnValue = (T)_algorithms[returnValue.GetType()](dataCache); _resultsWeak[dataCache] = new WeakReference(returnValue, true); if (save) _resultsStrong[dataCache] = returnValue; return returnValue; } }
