[site]: stackoverflow
[post_id]: 5607694
[parent_id]: 5163831
[tags]: 
Yes apple has disabled this feature (among others) in UIWebViews and kept it for Safari only. However you can recreate this yourself by extending this tutorial, http://www.icab.de/blog/2010/07/11/customize-the-contextual-menu-of-uiwebview/ . Once you've finished this tutorial you'll want to add a few extra's so you can actually save images (which the tutorial doesn't cover). I added an extra notification called @"tapAndHoldShortNotification" after 0.3 seconds which calls a method with just the disable callout code in it (to prevent both the default and your own menu popping while the page is still loading, a little bug fix). Also to detect images you'll need to extend the JSTools.js, here's mine with the extra functions. function MyAppGetHTMLElementsAtPoint(x,y) { var tags = ","; var e = document.elementFromPoint(x,y); while (e) { if (e.tagName) { tags += e.tagName + ','; } e = e.parentNode; } return tags; } function MyAppGetLinkSRCAtPoint(x,y) { var tags = ""; var e = document.elementFromPoint(x,y); while (e) { if (e.src) { tags += e.src; break; } e = e.parentNode; } return tags; } function MyAppGetLinkHREFAtPoint(x,y) { var tags = ""; var e = document.elementFromPoint(x,y); while (e) { if (e.href) { tags += e.href; break; } e = e.parentNode; } return tags; } Now you can detect the user clicking on images and actually find out the images url they are clicking on, but we need to change the -(void)openContextualMenuAtPoint: method to provide extra options. Again here's mine (I tried to copy Safari's behaviour for this): - (void)openContextualMenuAt:(CGPoint)pt{ // Load the JavaScript code from the Resources and inject it into the web page NSString *path = [[NSBundle mainBundle] pathForResource:@"JSTools" ofType:@"js"]; NSString *jsCode = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:nil]; [webView stringByEvaluatingJavaScriptFromString:jsCode]; // get the Tags at the touch location NSString *tags = [webView stringByEvaluatingJavaScriptFromString: [NSString stringWithFormat:@"MyAppGetHTMLElementsAtPoint(%i,%i);",(NSInteger)pt.x,(NSInteger)pt.y]]; NSString *tagsHREF = [webView stringByEvaluatingJavaScriptFromString: [NSString stringWithFormat:@"MyAppGetLinkHREFAtPoint(%i,%i);",(NSInteger)pt.x,(NSInteger)pt.y]]; NSString *tagsSRC = [webView stringByEvaluatingJavaScriptFromString: [NSString stringWithFormat:@"MyAppGetLinkSRCAtPoint(%i,%i);",(NSInteger)pt.x,(NSInteger)pt.y]]; UIActionSheet *sheet = [[UIActionSheet alloc] initWithTitle:nil delegate:self cancelButtonTitle:nil destructiveButtonTitle:nil otherButtonTitles:nil]; selectedLinkURL = @""; selectedImageURL = @""; // If an image was touched, add image-related buttons. if ([tags rangeOfString:@",IMG,"].location != NSNotFound) { selectedImageURL = tagsSRC; if (sheet.title == nil) { sheet.title = tagsSRC; } [sheet addButtonWithTitle:@"Save Image"]; [sheet addButtonWithTitle:@"Copy Image"]; } // If a link is pressed add image buttons. if ([tags rangeOfString:@",A,"].location != NSNotFound){ selectedLinkURL = tagsHREF; sheet.title = tagsHREF; [sheet addButtonWithTitle:@"Open"]; [sheet addButtonWithTitle:@"Copy"]; } if (sheet.numberOfButtons > 0) { [sheet addButtonWithTitle:@"Cancel"]; sheet.cancelButtonIndex = (sheet.numberOfButtons-1); [sheet showInView:webView]; } [selectedLinkURL retain]; [selectedImageURL retain]; [sheet release]; } (NOTES: selectedLinkURL and selectedImageURL are declared in the .h file to let them be accessed throughout the class, for saving or opening the link latter. So far we've just been going back over the tutorials code making changes but now we will move into what the tutorial doesn't cover (it stops before actually mentioning how to handle saving the images or opening the links). To handle the users choice we now need to add the actionSheet:clickedButtonAtIndex: method. -(void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex{ if ([[actionSheet buttonTitleAtIndex:buttonIndex] isEqualToString:@"Open"]){ [webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:selectedLinkURL]]]; } else if ([[actionSheet buttonTitleAtIndex:buttonIndex] isEqualToString:@"Copy"]){ [[UIPasteboard generalPasteboard] setString:selectedLinkURL]; } else if ([[actionSheet buttonTitleAtIndex:buttonIndex] isEqualToString:@"Copy Image"]){ [[UIPasteboard generalPasteboard] setString:selectedImageURL]; } else if ([[actionSheet buttonTitleAtIndex:buttonIndex] isEqualToString:@"Save Image"]){ NSOperationQueue *queue = [NSOperationQueue new]; NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(saveImageURL:) object:selectedImageURL]; [queue addOperation:operation]; [operation release]; } } This checks what the user wants to do and handles /most/ of them, only the "save image" operation needs another method to handle that. For the progress I used MBProgressHub. Add an MBProgressHUB *progressHud; to the interface declaration in the .h and set it up in the init method (of whatever class you're handling the webview from). progressHud = [[MBProgressHUD alloc] initWithView:self.view]; progressHud.customView = [[[UIImageView alloc] initWithImage:[UIImage imageNamed:@"Tick.png"]] autorelease]; progressHud.opacity = 0.8; [self.view addSubview:progressHud]; [progressHud hide:NO]; progressHud.userInteractionEnabled = NO; And the -(void)saveImageURL:(NSString*)url; method will actually save it to the image library. (A better way would be to do the download through an NSURLRequest and update the progress hud in MBProgressHUDModeDeterminate to deflect how long it'll actually take to download, but this is a more hacked together implementation then that) -(void)saveImageURL:(NSString*)url{ [self performSelectorOnMainThread:@selector(showStartSaveAlert) withObject:nil waitUntilDone:YES]; UIImageWriteToSavedPhotosAlbum([UIImage imageWithData:[NSData dataWithContentsOfURL:[NSURL URLWithString:url]]], nil, nil, nil); [self performSelectorOnMainThread:@selector(showFinishedSaveAlert) withObject:nil waitUntilDone:YES]; } -(void)showStartSaveAlert{ progressHud.mode = MBProgressHUDModeIndeterminate; progressHud.labelText = @"Saving Image..."; [progressHud show:YES]; } -(void)showFinishedSaveAlert{ // Set custom view mode progressHud.mode = MBProgressHUDModeCustomView; progressHud.labelText = @"Completed"; [progressHud performSelector:@selector(hide:) withObject:[NSNumber numberWithBool:YES] afterDelay:0.5]; } And of cause add [progressHud release]; to the dealloc method. Hopefully this shows you how to add some of the options to a webView that apple left out. Of cause though you can add more things to this like a "Read Later" option for instapaper or a "Open In Safari" button. (looking at the length of this post I'm seeing why the original tutorial left out the finial implementation details) Edit: (updated with more info) I was asked about the detail I glossed over at the top, the @"tapAndHoldShortNotification", so this is clarifying it. This is my UIWindow subclass, it adds the second notification to cancel the default selection menu (this is because when I tried the tutorial it showed both menus). - (void)tapAndHoldAction:(NSTimer*)timer { contextualMenuTimer = nil; UIView* clickedView = [self hitTest:CGPointMake(tapLocation.x, tapLocation.y) withEvent:nil]; while (clickedView != nil) { if ([clickedView isKindOfClass:[UIWebView class]]) { break; } clickedView = clickedView.superview; } if (clickedView) { NSDictionary *coord = [NSDictionary dictionaryWithObjectsAndKeys: [NSNumber numberWithFloat:tapLocation.x],@"x", [NSNumber numberWithFloat:tapLocation.y],@"y",nil]; [[NSNotificationCenter defaultCenter] postNotificationName:@"TapAndHoldNotification" object:coord]; } } - (void)tapAndHoldActionShort:(NSTimer*)timer { UIView* clickedView = [self hitTest:CGPointMake(tapLocation.x, tapLocation.y) withEvent:nil]; while (clickedView != nil) { if ([clickedView isKindOfClass:[UIWebView class]]) { break; } clickedView = clickedView.superview; } if (clickedView) { NSDictionary *coord = [NSDictionary dictionaryWithObjectsAndKeys: [NSNumber numberWithFloat:tapLocation.x],@"x", [NSNumber numberWithFloat:tapLocation.y],@"y",nil]; [[NSNotificationCenter defaultCenter] postNotificationName:@"TapAndHoldShortNotification" object:coord]; } } - (void)sendEvent:(UIEvent *)event { NSSet *touches = [event touchesForWindow:self]; [touches retain]; [super sendEvent:event]; // Call super to make sure the event is processed as usual if ([touches count] == 1) { // We're only interested in one-finger events UITouch *touch = [touches anyObject]; switch ([touch phase]) { case UITouchPhaseBegan: // A finger touched the screen tapLocation = [touch locationInView:self]; [contextualMenuTimer invalidate]; contextualMenuTimer = [NSTimer scheduledTimerWithTimeInterval:0.8 target:self selector:@selector(tapAndHoldAction:) userInfo:nil repeats:NO]; NSTimer *myTimer; myTimer = [NSTimer scheduledTimerWithTimeInterval:0.2 target:self selector:@selector(tapAndHoldActionShort:) userInfo:nil repeats:NO]; break; case UITouchPhaseEnded: case UITouchPhaseMoved: case UITouchPhaseCancelled: [contextualMenuTimer invalidate]; contextualMenuTimer = nil; break; } } else { // Multiple fingers are touching the screen [contextualMenuTimer invalidate]; contextualMenuTimer = nil; } [touches release]; } The notification is then handled like this: // in -viewDidLoad [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(stopSelection:) name:@"TapAndHoldShortNotification" object:nil]; - (void)stopSelection:(NSNotification*)notification{ [webView stringByEvaluatingJavaScriptFromString:@"document.documentElement.style.webkitTouchCallout='none';"]; } It's only a little change but it fixes the annoying little bug where you get 2 menus appear (the standard one and yours). Also you could easily add iPad support by sending the touches location as the notification fires and then showing the UIActionSheet from that point, though this was written before the iPad so doesn't include support for that.
