[site]: stackoverflow
[post_id]: 5175424
[parent_id]: 1878060
[tags]: 
i've read your blog, and that brought me to this (i think much easier) concept setup: As you will noticed, i reused some of your code you shared, so i'll share mine back. Create a new custom control called CachedImage. public class CachedImage : Image { private string _imageUrl; static CachedImage() { DefaultStyleKeyProperty.OverrideMetadata(typeof(CachedImage), new FrameworkPropertyMetadata(typeof(CachedImage))); } public string ImageUrl { get { return _imageUrl; } set { if (value != _imageUrl) { Source = new BitmapImage(new Uri(FileCache.FromUrl(value))); _imageUrl = value; } } } } Next i've made a FileCache class (so i have control on all caching not only images) public class FileCache { public static string AppCacheDirectory { get; set; } static FileCache() { // default cache directory, can be changed in de app.xaml. AppCacheDirectory = String.Format("{0}/Cache/", Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData)); } public static string FromUrl(string url) { //Check to see if the directory in AppData has been created if (!Directory.Exists(AppCacheDirectory)) { //Create it Directory.CreateDirectory(AppCacheDirectory); } //Cast the string into a Uri so we can access the image name without regex var uri = new Uri(url); var localFile = String.Format("{0}{1}", AppCacheDirectory, uri.Segments[uri.Segments.Length - 1]); if (!File.Exists(localFile)) { HttpHelper.GetAndSaveToFile(url, localFile); } //The full path of the image on the local computer return localFile; } } Also for downloading content I made a helper class: public class HttpHelper { public static byte[] Get(string url) { WebRequest request = HttpWebRequest.Create(url); WebResponse response = request.GetResponse(); return response.ReadToEnd(); } public static void GetAndSaveToFile(string url, string filename) { using (FileStream stream = new FileStream(filename, FileMode.Create, FileAccess.Write)) { byte[] data = Get(url); stream.Write(data, 0, data.Length); } } } The HttpHelper uses an extension on the WebResponse class for reading the result to an array public static class WebResponse_extension { public static byte[] ReadToEnd(this WebResponse webresponse) { Stream responseStream = webresponse.GetResponseStream(); using (MemoryStream memoryStream = new MemoryStream((int)webresponse.ContentLength)) { responseStream.CopyTo(memoryStream); return memoryStream.ToArray(); } } } Now you got it complete, lets use it in xaml That's all, it's reusable and robust. The only disadvance is, that the image is never downloaded again until you cleanup the cache directory. The first time the image is downloaded from the web and saved in the cache directory. Eventually the image is loaded from the cache and assign to the source of the parent class (Image). Kind regards, Jeroen van Langen.
