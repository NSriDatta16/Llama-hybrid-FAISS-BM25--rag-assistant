[site]: stackoverflow
[post_id]: 5759563
[parent_id]: 5758543
[tags]: 
For behavioral code use either $rtoi() or $realtobits() real in1; integer a1; wire [63:0] b1; a1 = $roti(in1); //Truncates fractional part b1 = $realtobits(in1); //Probably not what you want You can use $bitstoreal() if you need to cast a bit vector to a real type. EDIT: So if I follow your comments correctly, you're building a model of a floating-point ALU that works on 32-bit data values. In this case you could use real data types since Verilog can handle this format natively. Of course, you won't be able to detect certain situations task [31:0] realAdd(input [31:0] in1, input [31:0] in2, output [31:0] out); begin real rIn1,rIn2,rOut; rIn1 = $bitstoreal(in1); rIn2 = $bitstoreal(in2); rOut = rIn1 + rIn2; out = $realtobits(rOut); end endtask These functions all use double precision so you'll need to do some trivial bit extensions to handle single precision inputs, and some non-trivial bounds checking/truncation on the output. You can avoid this by using SystemVerilog, which has the $bitstoshortreal()/$shortrealtobits() functions that work on single precision values. If you want hardware for this, Computer Organization & Design has a description of a multi cycle implementation. As Andy posted, there may be better resources out there for your case. These are not simple to design.
