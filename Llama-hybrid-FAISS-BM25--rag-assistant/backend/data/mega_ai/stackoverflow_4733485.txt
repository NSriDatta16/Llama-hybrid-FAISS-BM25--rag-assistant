[site]: stackoverflow
[post_id]: 4733485
[parent_id]: 4217616
[tags]: 
It's something that can be considered as expected. Modifying stack trace is usual case if you specify throw ex; , FxCop will than notify you that stack is modified. In case you make throw; , no warning is generated, but still, the trace will be modified. So unfortunately for now it's the best not to catch the ex or throw it as an inner one. I think it should be considered as a Windows impact or smth like that - edited . Jeff Richter describes this situation in more detail in his "CLR via C#" : The following code throws the same exception object that it caught and causes the CLR to reset its starting point for the exception: private void SomeMethod() { try { ... } catch (Exception e) { ... throw e; // CLR thinks this is where exception originated. // FxCop reports this as an error } } In contrast, if you re-throw an exception object by using the throw keyword by itself, the CLR doesn’t reset the stack’s starting point. The following code re-throws the same exception object that it caught, causing the CLR to not reset its starting point for the exception: private void SomeMethod() { try { ... } catch (Exception e) { ... throw; // This has no effect on where the CLR thinks the exception // originated. FxCop does NOT report this as an error } } In fact, the only difference between these two code fragments is what the CLR thinks is the original location where the exception was thrown. Unfortunately, when you throw or rethrow an exception, Windows does reset the stack’s starting point. So if the exception becomes unhandled, the stack location that gets reported to Windows Error Reporting is the location of the last throw or re-throw, even though the CLR knows the stack location where the original exception was thrown. This is unfortunate because it makes debugging applications that have failed in the field much more difficult. Some developers have found this so intolerable that they have chosen a different way to implement their code to ensure that the stack trace truly reflects the location where an exception was originally thrown: private void SomeMethod() { Boolean trySucceeds = false; try { ... trySucceeds = true; } finally { if (!trySucceeds) { /* catch code goes in here */ } } }
