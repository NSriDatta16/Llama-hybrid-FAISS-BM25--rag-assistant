[site]: stackoverflow
[post_id]: 2271621
[parent_id]: 2271596
[tags]: 
It will not solve alignment issues, since there shouldn't be alignment issues - the compiler will lay out your local variables correctly aligned, so there should be no alignment issues. The only issue that grouping like-aligned types might have is to reduce use of the stack, but compilers are free to reorder the layout of variables on the stack anyway (or even reuse locations for different local variables at different times, or to keep locals in registers and not ever have them on the stack), so you're generally not buying anything for an optimized compile. If you're going to be 'type punning' items on the stack, you'll need to use the same methods for alignment safety that you'd use for data off the stack - maybe more, since memory allocated by malloc() or new is guaranteed to be appropriately aligned for any type - that guarantee is not made for storage allocated to automatic variables. 'Type punning' is when you circumvent the type system. such as by accessing the bytes in a char array as an int by casting a char* to an int* : int x; char data[4]; fill_data( data, sizeof(data)); int x = *(int*) data; Since the alignment requirement of the char[] might be different from an int , the above access of data through an int* might not be 'alignment safe'. However, since malloc() is specifed to return pointers suitably aligned for any type, the following should not have any alignment problems: int x; char* pData = malloc( 4); if (!pData) exit(-1); fill_data( pData, 4); x = *(int*) pData; However, note that sizeof(int) might not be 4 and int types might be little- or big-endian, so there are still portability issues with the above code - just not alignment issues. There are other ways of performing type punning including accessing data through different members of a union , but those may have their own portability issues notably that accessing a member that wasn't the last written member is unspecified behavior.
