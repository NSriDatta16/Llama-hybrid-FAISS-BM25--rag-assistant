[site]: stackoverflow
[post_id]: 3126175
[parent_id]: 3126072
[tags]: 
Stop! You're making a mistake here. Oh, no, you've picked the right PHP functions to make your data a bit safer. That's fine. Your mistake is in the order of operations , and how and where to use these functions. It's important to understand the difference between sanitizing and validating user data, escaping data for storage, and escaping data for presentation. Sanitizing and Validating User Data When users submit data, you need to make sure that they've provided something you expect. Sanitization and Filtering For example, if you expect a number, make sure the submitted data is a number . You can also cast user data into other types. Everything submitted is initially treated like a string, so forcing known-numeric data into being an integer or float makes sanitization fast and painless. What about free-form text fields and textareas? You need to make sure that there's nothing unexpected in those fields. Mainly, you need to make sure that fields that should not have any HTML content do not actually contain HTML. There are two ways you can deal with this problem. First, you can try escaping HTML input with htmlspecialchars . You should not use htmlentities to neutralize HTML, as it will also perform encoding of accented and other characters that it thinks also need to be encoded. Second, you can try removing any possible HTML. strip_tags is quick and easy, but also sloppy. HTML Purifier does a much more thorough job of both stripping out all HTML and also allowing a selective whitelist of tags and attributes through. Modern PHP versions ship with the filter extension , which provides a comprehensive way to sanitize user input. Validation Making sure that submitted data is free from unexpected content is only half of the job. You also need to try and make sure that the data submitted contains values you can actually work with. If you're expecting a number between 1 and 10, you need to check that value. If you're using one of those new fancy HTML5-era numeric inputs with a spinner and steps, make sure that the submitted data is in line with the step. If that data came from what should be a drop-down menu, make sure that the submitted value is one that appeared in the menu. What about text inputs that fulfill other needs? For example, date inputs should be validated through strtotime or the DateTime class . The given date should be between the ranges you expect. What about email addresses? The previously mentioned filter extension can check that an address is well-formed, though I'm a fan of the is_email library . The same is true for all other form controls. Have radio buttons? Validate against the list. Have checkboxes? Validate against the list. Have a file upload? Make sure the file is of an expected type, and treat the filename like unfiltered user data. Every modern browser comes with a complete set of developer tools built right in, which makes it trivial for anyone to manipulate your form. Your code should assume that the user has completely removed all client-side restrictions on form content ! Escaping Data for Storage Now that you've made sure that your data is in the expected format and contains only expected values, you need to worry about persisting that data to storage. Every single data storage mechanism has a specific way to make sure data is properly escaped and encoded. If you're building SQL, then the accepted way to pass data in queries is through prepared statements with placeholders . One of the better ways to work with most SQL databases in PHP is the PDO extension . It follows the common pattern of preparing a statement , binding variables to the statement , then sending the statement and variables to the server . If you haven't worked with PDO before here's a pretty good MySQL-oriented tutorial . Some SQL databases have their own specialty extensions in PHP, including SQL Server , PostgreSQL and SQLite 3 . Each of those extensions has prepared statement support that operates in the same prepare-bind-execute fashion as PDO. Sometimes you may need to use these extensions instead of PDO to support non-standard features or behavior. MySQL also has its own PHP extensions. Two of them, in fact. You only want to ever use the one called mysqli . The old "mysql" extension has been deprecated and is not safe or sane to use in the modern era. I'm personally not a fan of mysqli. The way it performs variable binding on prepared statements is inflexible and can be a pain to use. When in doubt, use PDO instead. If you are not using an SQL database to store your data, check the documentation for the database interface you're using to determine how to safely pass data through it. When possible, make sure that your database stores your data in an appropriate format. Store numbers in numeric fields. Store dates in date fields. Store money in a decimal field, not a floating point field. Review the documentation provided by your database on how to properly store different data types. Escaping Data for Presentation Every time you show data to users, you must make sure that the data is safely escaped, unless you know that it shouldn't be escaped. When emitting HTML, you should almost always pass any data that was originally user-supplied through htmlspecialchars . In fact, the only time you shouldn't do this is when you know that the user provided HTML, and that you know that it's already been sanitized it using a whitelist. Sometimes you need to generate some Javascript using PHP. Javascript does not have the same escaping rules as HTML! A safe way to provide user-supplied values to Javascript via PHP is through json_encode . And More There are many more nuances to data validation. For example, character set encoding can be a huge trap . Your application should follow the practices outlined in " UTF-8 all the way through ". There are hypothetical attacks that can occur when you treat string data as the wrong character set. Earlier I mentioned browser debug tools. These tools can also be used to manipulate cookie data. Cookies should be treated as untrusted user input . Data validation and escaping are only one aspect of web application security. You should make yourself aware of web application attack methodologies so that you can build defenses against them.
