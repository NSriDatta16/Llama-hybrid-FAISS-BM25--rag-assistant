[site]: stackoverflow
[post_id]: 3783501
[parent_id]: 3636507
[tags]: 
I've never personally done that because I prefer using local interfaces within the same JVM as it improves performance dramatically. But you can check this out: https://glassfish.dev.java.net/javaee5/ejb/EJB_FAQ.html#StandaloneRemoteEJB But you can give this a try: Properties props = new Properties(); props.setProperty("java.naming.factory.initial", "com.sun.enterprise.naming.SerialInitContextFactory"); props.setProperty("java.naming.factory.url.pkgs", "com.sun.enterprise.naming"); props.setProperty("java.naming.factory.state", "com.sun.corba.ee.impl.presentation.rmi.JNDIStateFactoryImpl"); // optional. Defaults to localhost. Only needed if web server is running // on a different host than the appserver props.setProperty("org.omg.CORBA.ORBInitialHost", "ejb_server_ip_or_host_name"); // optional. Defaults to 3700. Only needed if target orb port is not 3700. props.setProperty("org.omg.CORBA.ORBInitialPort", "3700"); InitialContext ic = new InitialContext(props); Step 2. Use the global JNDI name of the target Remote EJB in the lookup. EJB 3.x, assuming a global JNDI name of "com.acme.FooRemoteBusiness" : FooRemoteBusiness foo = (FooRemoteBusiness) ic.lookup("com.acme.FooRemoteBusiness"); EJB 2.x, assuming a global JNDI name of "com.acme.FooHome" : Object obj = ic.lookup("com.acme.FooHome"); FooHome fooHome = (FooHome) PortableRemoteObject.narrow(obj, FooHome.class);
