[site]: stackoverflow
[post_id]: 5211469
[parent_id]: 5210873
[tags]: 
There are two parts to your problem. Parsing the HTML, and doing the analysis. Parsing the HTML is a tedious job and I suspect there's not a whole lot that you can do to make it elegant. The analysis is not hard, but there are some ways to do this in Python that I think might be considered elegant. I'm going to discuss ways to express the brute force analysis in an elegant and concise fashion. I'm not going to discuss ways to do it faster than brute force because the data set is so tiny. import collections Stats = collections.namedtuple("Stats", "speed weight acceleration handling drift offroad turbo") First up we make a named tuple called "Stats". This is the object we will use to represent the stats of a driver or vehicle. Named tuples are nice because: They can be defined very concisely. They provide a constructor that just takes the fields in order. They let us access any field by name, e.g. driver.weight They provide an easy to read __str__ format: "Stats(speed=73, weight=56, acceleration=21, handling=17, drift=27, offroad=19, turbo=16)" They can be accessed as a sequence, just like a regular tuple. Let's define a function to add two sets of stats: def add_stats(xs, ys): return Stats(*[(x+y) for (x,y) in zip(xs,ys)]) Zip takes two sequences and returns a sequence of pairs of items from each sequence. E.g. zip([1,2,3], ['a','b','c']) == [(1,'a'),(2,'b'),(3,'c')]). Then we use a list comprehension ( [blah for blah in blah] ) to add together the stats from each of these pairs. Finally we feed that to the Stats constructor. The * means that we want to use each item in the sequence as an argument to the function. class ThingWithStats(object): def __init__(self, name, stats): self.name = name self.stats = Stats(*stats) def __str__(self): return self.name + " (" + str(self.stats) + ")" class Driver(ThingWithStats): pass class Vehicle(ThingWithStats): pass class Combination(ThingWithStats): def __init__(self, driver, vehicle): self.name = driver.name + " riding " + vehicle.name self.stats = add_stats(driver.stats, vehicle.stats) Now we have defined classes to represent drivers, vehicles and combinations of the two. Note that the constructors for Driver and Vehicle (inherited from ThingWithStats) can take any sequence of the appropriate length as their stats argument. They use a * to convert the sequence into a Stats object. We'll see why this is handy shortly. def make_combinations(drivers, vehicles): return [ Combination(driver, vehicle) for driver in drivers for vehicle in vehicles] This function uses a list comprehension to find all combinations of some list of drivers and some list of vehicles. Note that by using multiple "for"s in a single comprehension we get all combinations . This is also sometimes called a Cartesian product. Now here's the tediuous bit - the data. I copied and pasted these and used some vim magic to massage them into the correct format. Sorry I don't have anything more clever for this. Note that for the stats argument we pass a regular tuple. As mentioned above, the constructor converts with into a Stats object. This saves us a little clutter here. medium_drivers = [ Driver("Mario", (0, 6, 2, 2, 3, 0, 0)), Driver("Luigi", (2, 6, 0, 0, 0, 0, 0)), Driver("Peach", (2, 0, 5, 0, 6, 0, 0)), Driver("Daisy", (4, 0, 0, 2, 0, 0, 3)), Driver("Yoshi", (0, 3, 0, 0, 3, 5, 0)), Driver("Birdo", (0, 3, 0, 0, 0, 3, 5)), Driver("Diddy Kong", (0, 0, 3, 0, 3, 0, 5)), Driver("Bowser Jr.", (0, 0, 0, 0, 0, 3, 3)), Driver("Medium Mii", (3, 3, 0, 0, 0, 3, 3)), ] small_drivers = [ Driver("Baby Mario", (0, 8, 0, 6, 0, 0, 0)), Driver("Baby Luigi", (5, 8, 0, 0, 0, 0, 0)), Driver("Baby Peach", (3, 6, 3, 3, 0, 0, 0)), Driver("Baby Daisy", (5, 6, 0, 0, 0, 0, 3)), Driver("Toad", (0, 0, 6, 0, 6, 0, 0)), Driver("Toadette", (3, 0, 0, 0, 0, 6, 0)), Driver("Koopa Troopa", (0, 0, 0, 3, 0, 0, 6)), Driver("Dry Bones", (0, 0, 3, 0, 3, 0, 6)), Driver("Small Mii", (3, 3, 0, 0, 3, 0, 3)), ] large_drivers = [ Driver("Wario", (0, 3, 0, 0, 0, 3, 6)), Driver("Waluigi", (0, 0, 6, 0, 5, 3, 0)), Driver("Donkey Kong", (0, 3, 2, 2, 0, 0, 3)), Driver("Bowser", (2, 5, 0, 0, 3, 0, 0)), Driver("King Boo", (0, 0, 0, 5, 0, 3, 0)), Driver("Rosalina", (3, 0, 0, 3, 0, 0, 3)), Driver("Funky Kong", (4, 0, 0, 0, 0, 3, 0)), Driver("Dry Bowser", (0, 0, 0, 0, 0, 6, 6)), Driver("Large Mii", (3, 0, 3, 3, 3, 0, 3)), ] small_vehicles = [ Vehicle("Standard Kart S", (41, 29, 48, 48, 51, 40, 45)), Vehicle("Baby Booster / Booster Seat", (27, 27, 56, 64, 37, 54, 59)), Vehicle("Concerto / Mini Beast", (55, 32, 29, 32, 64, 27, 64)), Vehicle("Cheep Charger", (34, 24, 64, 56, 59, 45, 54)), Vehicle("Rally Romper / Tiny Titan", (46, 35, 43, 43, 29, 64, 40)), Vehicle("Blue Falcon", (60, 29, 35, 29, 43, 24, 29)), Vehicle("Standard Bike S", (39, 21, 51, 51, 54, 43, 48)), Vehicle("Bullet Bike", (53, 24, 32, 35, 67, 29, 67)), Vehicle("Nano Bike / Bit Bike", (25, 18, 59, 67, 40, 56, 62)), Vehicle("Quacker", (32, 17, 67, 60, 62, 48, 57)), Vehicle("Magikruiser", (43, 24, 45, 45, 32, 67, 43)), Vehicle("Bubble Bike / Jet Bubble", (48, 27, 40, 40, 45, 35, 37)), ] medium_vehicles = [ Vehicle("Standard Kart M", (46, 45, 40, 43, 45, 35, 40)), Vehicle("Nostalgia 1 / Classic Dragster", (37, 43, 59, 54, 54, 40, 51)), Vehicle("Wild Wing", (57, 51, 21, 29, 59, 24, 59)), Vehicle("Turbo Blooper / Super Blooper", (50, 40, 35, 37, 21, 54, 35)), Vehicle("Royal Racer / Daytripper", (34, 45, 51, 59, 32, 48, 54)), Vehicle("B Dasher Mk. 2 / Sprinter", (64, 48, 27, 24, 37, 21, 24)), Vehicle("Standard Bike M", (43, 37, 43, 45, 48, 37, 43)), Vehicle("Mach Bike", (55, 37, 24, 32, 62, 27, 62)), Vehicle("Bon Bon / Sugarscoot", (32, 32, 54, 62, 35, 51, 56)), Vehicle("Rapide / Zip Zip", (41, 35, 45, 51, 29, 62, 45)), Vehicle("Nitrocycle / Sneakster", (62, 40, 29, 27, 40, 24, 27)), Vehicle("Dolphin Dasher", (48, 43, 37, 40, 24, 56, 37)), ] large_vehicles = [ Vehicle("Standard Kart L", (48, 59, 37, 40, 40, 35, 35)), Vehicle("Offroader", (39, 64, 48, 54, 18, 43, 45)), Vehicle("Flame Flyer", (62, 59, 16, 21, 48, 18, 48)), Vehicle("Piranha Prowler", (55, 67, 29, 35, 35, 29, 27)), Vehicle("Aero Glider / Jetsetter", (69, 56, 21, 17, 27, 16, 16)), Vehicle("Dragonetti / Honeycoupe", (53, 62, 27, 29, 56, 24, 56)), Vehicle("Standard Bike L", (46, 54, 40, 43, 43, 37, 37)), Vehicle("Bowser Bike / Flame Runner", (60, 54, 18, 24, 51, 21, 51)), Vehicle("Wario Bike", (37, 59, 51, 56, 21, 45, 48)), Vehicle("Twinkle Star / Shooting Star", (50, 48, 29, 32, 59, 27, 59)), Vehicle("Torpedo / Spear", (67, 56, 24, 18, 29, 18, 18)), Vehicle("Phantom", (43, 51, 43, 48, 17, 56, 40)), ] With that out of the way, we make lists of all the combinations: small_combinations = make_combinations(small_drivers, small_vehicles) medium_combinations = make_combinations(medium_drivers, medium_vehicles) large_combinations = make_combinations(large_drivers, large_vehicles) all_combinations = small_combinations + medium_combinations + large_combinations Finally we do some basic analysis on the list of all combinations: print "Max speed:", max(all_combinations, key=lambda c:c.stats.speed) print "Max weight:", max(all_combinations, key=lambda c:c.stats.weight) print "Max acceleration:", max(all_combinations, key=lambda c:c.stats.acceleration) print "Max handling:", max(all_combinations, key=lambda c:c.stats.handling) print "Max drift:", max(all_combinations, key=lambda c:c.stats.drift) print "Max offroad:", max(all_combinations, key=lambda c:c.stats.offroad) print "Max turbo:", max(all_combinations, key=lambda c:c.stats.turbo) print print "Min speed:", min(all_combinations, key=lambda c:c.stats.speed) print "Min weight:", min(all_combinations, key=lambda c:c.stats.weight) print "Min acceleration:", min(all_combinations, key=lambda c:c.stats.acceleration) print "Min handling:", min(all_combinations, key=lambda c:c.stats.handling) print "Min drift:", min(all_combinations, key=lambda c:c.stats.drift) print "Min offroad:", min(all_combinations, key=lambda c:c.stats.offroad) print "Min turbo:", min(all_combinations, key=lambda c:c.stats.turbo) The min and max functions provide a key argument for exactly this purpose. It takes a function that takes an item from the list and returns the value that you want to sort by. Here are the results: Max speed: Funky Kong riding Aero Glider / Jetsetter (Stats(speed=73, weight=56, acceleration=21, handling=17, drift=27, offroad=19, turbo=16)) Max weight: Bowser riding Piranha Prowler (Stats(speed=57, weight=72, acceleration=29, handling=35, drift=38, offroad=29, turbo=27)) Max acceleration: Toad riding Quacker (Stats(speed=32, weight=17, acceleration=73, handling=60, drift=68, offroad=48, turbo=57)) Max handling: Baby Mario riding Nano Bike / Bit Bike (Stats(speed=25, weight=26, acceleration=59, handling=73, drift=40, offroad=56, turbo=62)) Max drift: Toad riding Bullet Bike (Stats(speed=53, weight=24, acceleration=38, handling=35, drift=73, offroad=29, turbo=67)) Max offroad: Toadette riding Magikruiser (Stats(speed=46, weight=24, acceleration=45, handling=45, drift=32, offroad=73, turbo=43)) Max turbo: Koopa Troopa riding Bullet Bike (Stats(speed=53, weight=24, acceleration=32, handling=38, drift=67, offroad=29, turbo=73)) Min speed: Baby Mario riding Nano Bike / Bit Bike (Stats(speed=25, weight=26, acceleration=59, handling=73, drift=40, offroad=56, turbo=62)) Min weight: Toad riding Quacker (Stats(speed=32, weight=17, acceleration=73, handling=60, drift=68, offroad=48, turbo=57)) Min acceleration: Wario riding Flame Flyer (Stats(speed=62, weight=62, acceleration=16, handling=21, drift=48, offroad=21, turbo=54)) Min handling: Wario riding Aero Glider / Jetsetter (Stats(speed=69, weight=59, acceleration=21, handling=17, drift=27, offroad=19, turbo=22)) Min drift: Wario riding Phantom (Stats(speed=43, weight=54, acceleration=43, handling=48, drift=17, offroad=59, turbo=46)) Min offroad: Donkey Kong riding Aero Glider / Jetsetter (Stats(speed=69, weight=59, acceleration=23, handling=19, drift=27, offroad=16, turbo=19)) Min turbo: Waluigi riding Aero Glider / Jetsetter (Stats(speed=69, weight=56, acceleration=27, handling=17, drift=32, offroad=19, turbo=16)) Further ideas If you do want to apply this to much larger data sets, you could find the driver and vehicle with the min and max for each stat, and then for each stat combine the max driver with the max vehicle and the min driver with the min vehicle. That would be O(M log M + N log N) instead of O(M*N log M*N). But you would really need to be getting up to thousands of drivers and vehicles before I think this would be an issue. If you want to apply this to massive data sets that won't even fit in memory, you could use generator expressions instead of list comprehensions. You would need to combine this with a parser that can read and yield one driver/vehicle at a time. You could do more specific searches by adding constraints. For example, to find the fastest combination with turbo >= 50 and handling >= 40: max((combination for combination in all_combinations if combination.stats.turbo >= 50 and combination.stats.handling >= 40), key=lambda c:c.stats.speed) If you want to get all those tied for top place, you could do something like this: def all_max(sequence, key): top_value = key(max(sequence, key=key)) return [item for item in sequence if key(item) == top_value] Call it the same as you would call max . It returns a list of all those items tied for maximum value of whatever key specifies.
