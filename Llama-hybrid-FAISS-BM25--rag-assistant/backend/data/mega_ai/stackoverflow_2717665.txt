[site]: stackoverflow
[post_id]: 2717665
[parent_id]: 2717513
[tags]: 
There's one context in C++ where the result of overload resolution depends on the "return type", on the left-hand side of the expression. It is initialization/assignment of the function pointer value with the address of a function. It works with an explicit object of the left-hand size as well as with a temporary object created by an explicit type cast. In your case it can be used to select one specific function from two overloaded ones. For example: int (*pfunc)() = func; // selects `int func()` int i = pfunc(); // calls `int func()` You can use this technique to force overload resolution in one line, although it doesn't look too elegant int i = ((int (*)()) func)(); // selects and calls `int func()` Again, in this case you perform the overload resolution manually. C++ has no feature that would result in implicit overload resolution based on the return type (aside from what I illustrated above).
