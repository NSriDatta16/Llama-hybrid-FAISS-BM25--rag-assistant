[site]: stackoverflow
[post_id]: 2658435
[parent_id]: 2657762
[tags]: 
In a later comment, he clears up the matter a bit This is the important point I tried to get through in the first section. When you use QSharedPointer, you’re sharing the ownership of the pointer. The class controls and handles the pointer only — anything else (like access to the data) is outside its scope. When you use QSharedDataPointer, you’re sharing the data. And that class is intended for implicit sharing: so it may split up. Trying to interpret that: What's important to see is that "pointer" does not mean the object storing the address in this case, but it means the storage location where the object is located (the address itself). So strictly, i think, you have to say you are sharing the address. boost::shared_ptr is thus a smart pointer sharing the "pointer". boost::intrusive_ptr or another intrusive smart pointer seems to share the pointer too, albeit knowing something about the object pointed to (that it has a reference-count member or functions incrementing/decrementing it). Example: If someone shares a black box with you and he doesn't know what is in the black box, it is similar to sharing the pointer (which represents the box), but not the data (what is inside the box). In fact, you can't even know that what is inside the box is sharable (what if the box contains nothing at all?). The smart pointers are represented by you and the other guy (and you aren't shared, of course), but the address is the box, and it is shared. Sharing the data means the smart pointer knows sufficiently enough of the data pointed to that it may change the address pointed to (and this needs to copy over data, etc). So, the pointers now may point to different addresses. Since the address is different, the address isn't shared anymore. This is what std::string does on some implementations, too: std::string a("foo"), b(a); // a and b may point to the same storage by now. std::cout Sharing data does not necessarily mean you have a pointer presented to you. You may use a std::string by pure means of a[0] and cout and never touch any of the c_str() functions. Still sharing may go on behind the scene. The same thing happens with many Qt classes and classes of other widget toolkits too, which is called implicit sharing (or copy on write ). So i think one may sum it up like this: Sharing the pointer: We always point to the same address when we copy a smart pointer, implying that we share the pointer value. Sharing the data: We may point to different addresses at different times. Implying that we know how to copy data from one address to the other. So trying to categorize boost::shared_ptr , boost::intrusive_ptr : Share the pointer, not the data. QString , QPen , QSharedDataPointer : Share the data it contains. std::unique_ptr , std::auto_ptr (and also QScopedPointer ): Neither share the pointer, nor the data.
