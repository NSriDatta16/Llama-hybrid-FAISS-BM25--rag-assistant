[site]: stackoverflow
[post_id]: 2287014
[parent_id]: 2278822
[tags]: 
When I took a compiler course in college I didn't understand FIRST and FOLLOWS at all. I implemented the algorithms described in the Dragon book, but I had no clue what was going on. I think I do now. I assume you have some book that gives a formal definition of these two sets, and the book is completely incomprehensible. I'll try to give an informal description of them, and hopefully that will help you make sense of what's in your book. The FIRST set is the set of terminals you could possibly see as the first part of the expansion of a non-terminal. The FOLLOWS set is the set of terminals you could possibly see following the expansion of a non-terminal. In your first grammar, there are only three kinds of terminals: = , * , and id . (You might also consider $ , the end-of-input symbol, to be a terminal.) The only non-terminals are S (a statement) and L (an Lvalue -- a "thing" you can assign to). Think of FIRST(S) as the set of non-terminals that could possibly start a statement. Intuitively, you know you do not start a statement with = . So you wouldn't expect that to show up in FIRST(S). So how does a statement start? There are two production rules that define what an S looks like, and they both start with L . So to figure out what's in FIRST(S), you really have to look at what's in FIRST(L). There are two production rules that define what an Lvalue looks like: it either starts with a * or with an id . So FIRST(S) = FIRST(L) = { * , id }. FOLLOWS(S) is easy. Nothing follows S because it is the start symbol. So the only thing in FOLLOWS(S) is $ , the end-of-input symbol. FOLLOWS(L) is a little trickier. You have to look at every production rule where L appears, and see what comes after it. In the first rule, you see that = may follow L . So = is in FOLLOWS(L). But you also notice in that rule that there is another L at the end of the production rule. So another thing that could follow L is anything that could follow that production. We already figured out that the only thing that can follow the S production is the end-of-input. So FOLLOWS(L) = { = , $ }. (If you look at the other production rules, L always appears at the end of them, so you just get $ from those.) Take a look at this Easy Explanation , and for now ignore all the stuff about 系 , because you don't have any productions which contain the empty-string. Under "Rules for First Sets", rules #1, #3, and #4.1 should make sense. Under "Rules for Follows Sets", rules #1, #2, and #3 should make sense. Things get more complicated when you have 系 in your production rules. Suppose you have something like this: D -> S C T id = V // Declaration is [Static] [Const] Type id = Value S -> static | 系 // The 'static' keyword is optional C -> const | 系 // The 'const' keyword is optional T -> int | float // The Type is mandatory and is either 'int' or 'float' V -> ... // The Value gets complicated, not important here. Now if you want to compute FIRST(D) you can't just look at FIRST(S), because S may be "empty". You know intuitively that FIRST(D) is { static , const , int , float }. That intuition is codified in rule #4.2. Think of SCT in this example as Y1Y2Y3 in the "Easy Explanation" rules. If you want to compute FOLLOWS(S), you can't just look at FIRST(C), because that may be empty, so you also have to look at FIRST(T). So FOLLOWS(S) = { const , int , float }. You get that by applying "Rules for follow sets" #2 and #4 (more or less). I hope that helps and that you can figure out FIRST and FOLLOWS for the second grammar on your own. If it helps, R represents an Rvalue -- a "thing" you can't assign to, such as a constant or a literal. An Lvalue can also act as an Rvalue (but not the other way around). a = 2; // a is an lvalue, 2 is an rvalue a = b; // a is an lvalue, b is an lvalue, but in this context it's an rvalue 2 = a; // invalid because 2 cannot be an lvalue 2 = 3; // invalid, same reason. *4 = b; // Valid! You would almost never write code like this, but it is // grammatically correct: dereferencing an Rvalue gives you an Lvalue.
