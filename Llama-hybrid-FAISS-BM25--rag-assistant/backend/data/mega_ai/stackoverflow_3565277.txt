[site]: stackoverflow
[post_id]: 3565277
[parent_id]: 3565212
[tags]: 
Individually they are thread-safe, as they use isolated data-contexts etc. However, they are not an atomic unit. So it is not safe to check the count is > 0 and then assume that there is still something there to pop. Any other thread could be mutating the database. If you need something like this, you can wrap in a TransactionScope which will give you (by default) the serializable isolation level: using(var tran = new TransactionScope()) { int count = OCall.Count(); if(count > 0) { var call = Count.PopCall(); // TODO: something will call, assuming it is non-null } } Of course, this introduces blocking. It is better to simply check the FirstOrDefault() . Note that PopCall could still throw exceptions - if another thread/process deletes the data between you obtaining it and calling SubmitChanges . The good thing about it throwing here is that you shouldn't find that you return the same record twice. The SubmitChanges is transactional, but the reads aren't, unless spanned by a transaction-scope or similar. To make PopCall atomic without throwing: public static OCall PopCall() { using(var tran = new TrasactionScope()) using (var db = new MyDataContext()) { var fc = (from c in db.Calls where c.Called == false select c).FirstOrDefault(); OCall call = FillOCall(fc); if (fc != null) { db.Calls.DeleteOnSubmit(fc); db.SubmitChanges(); } return call; } tran.Complete(); } } Now the FirstOrDefault is covered by the serializable isolation-level, so doing the read will take a lock on the data. It would be even better if we could explicitly issue an UPDLOCK here, but LINQ-to-SQL doesn't offer this.
