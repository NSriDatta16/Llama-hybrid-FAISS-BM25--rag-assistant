[site]: datascience
[post_id]: 38857
[parent_id]: 38855
[tags]: 
There are two main steps involved to get where you want. First we need to get the timestamps that you are expecting (going up in seconds without gaps). Scondly we need to assign your data onto those timestamps and fill any missing values with the previously recorded value. This solution is using python. It might be a good exercise to start with if you are new to Python and data frames, which shows the power of programming compared to spreadsheets. Basic setup import pandas as pd import numpy as np This just create the example dataframe you privded. The times will be used to make a date-time index, and the values will be out "data" - our only column. times = ["04:23:12", "04:23:13", "04:23:14", "04:23:15", "04:23:16", "04:24:01", "04:24:02"] values = [2709.082597, 2708.747333, 2708.442548, 2708.229198, 2708.229198, 2708.137763, 2707.924413] We create a proper date-time Series to use as our index index = pd.to_datetime(times) Throw it into a dataframe df = pd.DataFrame(index=index, data=values, columns=['data']) df.head() data 2018-09-27 04:23:12 2709.082597 2018-09-27 04:23:13 2708.747333 2018-09-27 04:23:14 2708.442548 2018-09-27 04:23:15 2708.229198 2018-09-27 04:23:16 2708.229198 Part one Now I will create a second empty dataframe, that will however have the desired timestamps in the index i.e. it will go up in seconds without any gaps . We can use the first and last timestamps that we recorded above (or anythin else you need) new_start = df.index[0] new_end = df.index[-1] We can specify the frequency as seconds, using the parameter freq='s' as shown: new_index = pd.date_range(new_start, new_end, freq='s') Now we create the empty dateframe with the desired index: new_df = pd.DataFrame(index=new_index) Part two Now we combine the two dataframe (the one with your data and the one with the target index), and finally we fill the missing values. We merge the two dataframes based on their indexes. Using the method="outer" means that we keep all values in both indexes, so no timestamps would be lost. In your case we just basically end up with new_index again, as it was already perfect. combined_df = pd.merge(df, new_df, method="outer", left_index=True, right_index=True) The last step is very simple: fill missing values with the last recorded value. Here ffill means forward fill , which does exactly what you want: final_df = combined_df.fillna(method='ffill') final_df data 2018-09-27 04:23:12 2709.082597 2018-09-27 04:23:13 2708.747333 2018-09-27 04:23:14 2708.442548 2018-09-27 04:23:15 2708.229198 2018-09-27 04:23:16 2708.229198 2018-09-27 04:23:17 2708.229198 2018-09-27 04:23:18 2708.229198 ... ... 2018-09-27 04:23:58 2708.229198 2018-09-27 04:23:59 2708.229198 2018-09-27 04:24:00 2708.229198 2018-09-27 04:24:01 2708.137763 2018-09-27 04:24:02 2707.924413 This solution obviously only works for processing such static data, but a better solution might be to implement a short loop during the recording process to simply repeat the last recording if no new one is given, ensuring a datapoint is recorded every second.
