[site]: stackoverflow
[post_id]: 5047728
[parent_id]: 5046145
[tags]: 
Interesting question — here's an idea on how I'd do that probably: http://jsfiddle.net/SaQAs/1/ — Not anyhow optimized! var text = $('p').text(), words = text.split(' '), sortedWords = words.slice(0).sort(), duplicateWords = [], sentences = text.split('.'), sortedSentences = sentences.slice(0).sort(), duplicateSentences = []; for (var i=0; i -1) return ' ' + word + ' '; else return word; }); $('p').html(highlighted.join(' ')); return false; }); $('a.sentences').click(function(){ var highlighted = $.map(sentences, function(sentence){ if ($.inArray(sentence, duplicateSentences) > -1) return ' ' + sentence + ' '; else return sentence; }); $('p').html(highlighted.join('.')); return false; }); Update 1 This one finds sequences of identical words: http://jsfiddle.net/YQdk5/1/ From here it shouldn't be hard to e.g. ignore any kind of punctuation at the end of fragments when comparing — you'd would just have to write your own version of an inArray method. var text = $('p').text(), words = text.split(' '), sortedWords = words.slice(0).sort(), duplicateWords = [] highlighted = []; for (var i=0; i -1); if (!m[j] && m[j-1]) highlighted.push(' '); else if (m[j] && !m[j-1]) highlighted.push(' '); highlighted.push(words[j]); } $('p').html(highlighted.join(' ')); Update 2 My regex-fu is weak, but this (pretty messy!) version seems to work okay: http://jsfiddle.net/YQdk5/2/ — I'm pretty sure that there might be a better way of doing this, but for now I've got to leave it alone! :D — Good luck! Update 3 Thinking about it, I don't think that the code from the previous update is any good. That's why I've removed it. You can still find it here: http://jsfiddle.net/YQdk5/2/ The main point is to use a regex to match words, something along the lines of: /^word(\.?)$/
