[site]: stackoverflow
[post_id]: 4759696
[parent_id]: 4756500
[tags]: 
Depending on how your ContentProvider is implemented this functionality might be handled for you automatically if you chose to extend a CursorAdapter instead of a ListAdapter. If you, in your ContentProvider, call something like: getContext().getContentResolver().notifyChange(uri, myObserver); whenever you change something (insert, delete, update), then (according to the documentation on the 'notifyChange()' function: http://developer.android.com/reference/android/content/ContentResolver.html ) CursorAdapters will get this notification by default. Finally I will take me the liberty of commenting a bit on your database structure (please don't feel offended, I don't mean to be rude, I just want to help). NOTE #1 Many database architects state that it's "de facto standard" to name tables in singular, hence your two tables would maybe look a bit more professional if they were named "note" and "tag". NOTE #2 It also seems like there is a many-to-many relation between your notes and tags (one note can have many tags, but one tag can also belong to many notes). It is then preferred, in order to avoid duplicate data in your "tag" table, to separate the "notes" and "tags" completely from each other and introduce a third table, say, "relation", which will describe the relation between your notes and your tags. You would then have three tables like: CREATE TABLE note (_id INTEGER PRIMARY KEY, content TEXT); CREATE TABLE tag (_id INTEGER PRIMARY KEY, name TEXT, pos INTEGER); CREATE TABLE relation (_id INTEGER PRIMARY KEY, note_id INTEGER, tag_id INTEGER); This architectural change would add complexity to your database but it would also make it more fault tolerant (especially to changes), faster from some perspectives (the database wouldn't need to test for all those duplicates when filtering for a query), and less space consuming. These "new features" become even more interesting as your database grows. A typical SELECT query where everything is selected would then look something like this: SELECT note._id AS noteid, note.text, tag.name, tag.pos FROM note LEFT JOIN relation ON (relation.note_id = note._id) LEFT JOIN tag ON (tag._id = relation.tag_id); NOTE #3: This brings me to my final point. I don't really know what your application looks like, so I might very well be wrong here, but nevertheless: Do you really need to get all info from both tables (currently "notes" and "tags") joined together at once? Is it possible to only fetch all "notes" alone and display them in some sort of list or other GUI constellation and fetching the corresponding tags only when editing or viewing a single note? This way you would get rid of your extra "count" cursor. A SELECT query for fetching all tags belonging to a given note would look something like this: SELECT tag.* FROM relation LEFT JOIN tag ON (tag._id = relation.tag_id) WHERE relation.note_id=12; You would of course replace '12' with whatever id the current note has. I hope you can make some use of of my (very long :-) answer.
