[site]: stackoverflow
[post_id]: 3049609
[parent_id]: 3049597
[tags]: 
The ostream_iterator is an output iterator. http://www.sgi.com/tech/stl/OutputIterator.html One of the requirements of the output iterator is that between each assignment to the stream that the ++ operator (pre or post) is used. Thus it is undefined behavior to assign to the stream twice in a row without incrementing the iterator. Dereference assignment: *x = t Pre-Conditions: x is dereferenceable: If there has been a previous assignment through x, then there has been an intervening increment. So technically what you are doing above is undefined behavior. Thus the implementation is allowed to provide the output you describe. See Expression semantics for de-re assignament (pre-conditions) also See Note [3] in the linked page above. For the official standard quote: http://www.open-std.org/Jtc1/sc22/wg21/docs/papers/2010/n3090.pdf (latest draft) Section 24.2.4: Paragraph 2 (emphasis by me) [ Note: The only valid use of an operator* is on the left side of the assignment statement. Assignment through the same value of the iterator happens only once . Algorithms on output iterators should never attempt to pass through the same iterator twice. They should be single pass algorithms. Equality and inequality might not be defined. Algorithms that take output iterators can be used with ostreams as the destination for placing data through the ostream_iterator class as well as with insert iterators and insert pointers. â€”end note ] I disagree with AndreyT interpretation of defect report 485: a) That each value of the output iterator is written to: The standard allows: ++x; ++x; ++x; b) That assignments to the output iterator are made in order X a(x); ++a; *a=1; *x=2; is allowed c) Chains of output iterators cannot be constructed: X a(x); ++a; X b(a); ++b; X c(b); ++c; is allowed, and under the current wording (I believe) x,a,b,c could be written to in any order. Problem (a) and (c) are not relevant. Problem (b) refers to a situations where there are multiple iterators involved. Note in (b) we are using iterator a (copy of x) and iterator x. The defect is that the current standard does not requrie 'x' to be increment before use; after 'a' has been assigned through. Which is not the situation in this context.
