[site]: stackoverflow
[post_id]: 1610073
[parent_id]: 1609550
[tags]: 
Based on what you've said (in both the question and the comments) there are only a very few values for a (something like 10). That being the case, I'd build an index on the values of a where each one points directly to all the elements in the fooArr with that value of a : std::vector > index(num_a_values); for (int i=0; i Then when you get a value to look up an item, you go directly to those for which fooArr[i].a==value1 : std::vector const &values = index[value1]; for (int i=0; i b && value2 >= values[i]->c && value3 >= values[i]->d) { // yay, found something } } This way, instead of looking at 1000 items in fooArray each time, you look at an average of 100 each time. If you want still more speed, the next step would be to sort the items in each vector in the index based on the value of b . This will let you find the lower bound for value2 using a binary search instead of a linear search, reducing ~50 comparisons to ~10. Since you've sorted it by b , from that point onward you don't have to compare value2 to b -- you know exactly where the rest of the numbers that satisfy the inequality are, so you only have to compare to c and d . You might also consider another approach based on the limited range of the numbers: 0 to 1000 can be represented in 10 bits. Using some bit-twiddling, you could combine three fields into a single 32-bit number, which would let the compiler compare all three at once, instead of in three separate operations. Getting this right is a little tricky, but once you to, it could roughly triple the speed again.
