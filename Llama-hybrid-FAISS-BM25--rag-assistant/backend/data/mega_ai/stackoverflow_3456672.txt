[site]: stackoverflow
[post_id]: 3456672
[parent_id]: 3415733
[tags]: 
I found a solution, though that solution is not really satisfying. In XAML, create a DataTemplate for each type of KeyValuePair you want to display and give it some unique x:Key: Then in codebehind, create a DataTemplateSelector and override SelectTemplate: public class GenericDataTemplateSelector : System.Windows.Controls.DataTemplateSelector { public override System.Windows.DataTemplate SelectTemplate(object item, System.Windows.DependencyObject container) { FrameworkElement element = container as FrameworkElement; if ((element != null) && (item != null)) { if (item is DictItemVM ) { return element.FindResource("DictItemOfStringAndAddressVM") as DataTemplate; } else if(item is SomeOtherComplexType) { // ... } else return base.SelectTemplate(item, container); } return null; } } Again in XAML, declare this class as a resource: Finally, (in my case) in the ContentControl, add the property: ContentTemplateSelector="{StaticResource GenDataTempSelect}" -- Disadvantages: When creating a new DataTemplate you have to change code at two locations. Each ContentControl, ListView, ... must set it's appropriate property. Doesn't really answer the question of how to reference generic types in WPF! Advantages: Easy to add new types of any structure or complexity (enjoying all the benefits C# has over WPF...) No complicated nested type description in WPF, as the above solution would require.
