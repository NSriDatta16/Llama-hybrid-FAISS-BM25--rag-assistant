[site]: stackoverflow
[post_id]: 4008135
[parent_id]: 4008066
[tags]: 
Short answer to your question : YES, you need to take care of concurrency concerns when your JMS code is updating some common in-memory object. However, I'm not sure what you mean by "common current value table"? If this is some database table, then database should take care of concurrency issues for you. EDIT: it turned out that "common current value table" is a common in-memory object. As I mentioned earlier, in this case you need to handle the concurrency concerns yourself ( Java concurrency tutorial ). There are mainly two approaches to this problem: synchronization - suitable if you have low-contention or you are stuck with some non-threadsafe object , then your best choice is synchronization. high-level concurrency objects that come with the JDK - best fit if you have high-contention and you are using some class from regular collections ; just swap in an instance of concurrent collections . In any case, it is highly recommended to do your own testing to choose the best approach for you. If you would be dealing with expensive to create non-threadsafe stateless procedural code (no storage of data involved) then you could also use object pooling (e.g. Commons Pool ), but this is not relevant in your current issue. JMS onMessage() method is always called by the JMS provider's thread (also known as asynchronous calling).
