[site]: stackoverflow
[post_id]: 2101732
[parent_id]: 2101524
[tags]: 
It is a slippery slope. IDisposable has a contract, one that's backed-up by a finalizer. A finalizer is useless in your case. You cannot force the client to use the using statement, only encourage him to do so. You can force it with a method like this: void UseMeUnlocked(Action callback) { Unlock(); try { callback(); } finally { Lock(); } } But that tends to get a bit awkward without lamdas. That said, I've used IDisposable like you did. There is however a detail in your post that makes this dangerously close to an anti-pattern. You mentioned that those methods can throw an exception. This is not something the caller can ignore. He can do three things about that: Do nothing, the exception isn't recoverable. The normal case. Calling Unlock doesn't matter. Catch and handle the exception Restore state in his code and let the exception pass up the call chain. The latter two requires the caller to explicitly write a try block. Now the using statement gets in the way. It may well induce a client into a coma that makes him believe that your class is taking care of state and no additional work needs to be done. That's almost never accurate.
