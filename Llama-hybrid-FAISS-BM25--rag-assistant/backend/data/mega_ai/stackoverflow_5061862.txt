[site]: stackoverflow
[post_id]: 5061862
[parent_id]: 4436857
[tags]: 
A few comments on your code to help improve it, IMHO. There are functions provided by the python C API that do exactly what you need to do, and make sure everything conforms to the Python way of doing things. It will handle embedded NULL's without a problem. Rather than calling malloc directly, change this: cdef char *ciphertext = malloc(src_len) to cdef str retval = PyString_FromStringAndSize(PyString_AsString(source), src_len) cdef char *ciphertext = PyString_AsString(retval) The above lines will create a brand new Python str object initialized to the contents of source . The second line points ciphertext to retval 's internal char * buffer without copying. Whatever modifies ciphertext will modify retval . Since retval is a brand new Python str, it can be modified by C code before being returned from _real_encrypt . See the Python C/API docs on the above functions for more details, here and here . The net effect saves you a copy. The whole code would be something like: cdef extern from "Python.h": object PyString_FromStringAndSize(char *, Py_ssize_t) char *PyString_AsString(object) def _real_encrypt(self, source): src_len = len(source) cdef str retval = PyString_FromStringAndSize(PyString_AsString(source), src_len) cdef char *ciphertext = PyString_AsString(retval) cmc.mcrypt_generic_init(self._mcStream, self._key, len(self._key), NULL) cmc.mcrypt_generic(self._mcStream, ciphertext, src_len) # since the above initialized ciphertext, the retval str is also correctly initialized, too. cmc.mcrypt_generic_deinit(self._mcStream) return retval
