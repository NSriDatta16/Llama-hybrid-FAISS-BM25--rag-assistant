[site]: stackoverflow
[post_id]: 1560229
[parent_id]: 
[tags]: 
Smarty caching components

The Smarty FAQ suggests one way to handle cacheable fragments, but it needs each page controller to do tons of work up-front, instead of encapsulating things properly. We want to get to a stage where we can do something like: {our_categories} {our_subcategories category=$current_category} The output of the our_ prefixed functions should be completely cacheable, only relying on the named parameters (if any.) If we referred to {our_categories} in more than one template, they should all refer to the same cached content. (it's probably worth mentioning that we tried using {insert name="..."} and coding up our own functions, but the results weren't cacheable, and we ended up hand-cranking the HTML retunred, rather than benefiting from Smarty's template processing.) Our first crack at this uses a custom function smarty_function_our_categories , but the caching's going horribly wrong. Here's what our function looks like: function smarty_function_our_categories($params, &$smarty) { $smarty->caching = 2; $smarty->cache_lifetime = 3600; # 1 hour if (!$smarty->is_cached(...)) { // ... do db access to fetch data for template... $smarty->assign(....); } return $smarty->fetch(...); } The problem is: calling $smarty->fetch() within a function confuses smarty, making it lose track of which templates have insert-tags, and which don't. The end result is that Smarty forgets to replace certain markers when serving up cached content (markers it puts there to say: "replace this with the results of some non-caching {insert ...} call.) In our case, this manifests itself with our site showing a couple of md5 checksums and a php-serialized memento where our main menu should be - that's not good. We assume we've made a mistake in how we're building our components, so the question finally becomes: How do you safely create a caching component using Smarty to render itself?
