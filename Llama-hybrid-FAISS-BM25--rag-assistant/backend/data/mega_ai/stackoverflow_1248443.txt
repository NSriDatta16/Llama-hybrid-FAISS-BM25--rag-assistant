[site]: stackoverflow
[post_id]: 1248443
[parent_id]: 1246049
[tags]: 
Unfortunately, my imagination went wild when you asked this question. I don't know if this solution is considered more elegant. However, these classes are simple and easily re-usable so you may find a use for them if they are not satisfactory. You will see everything coming together at the end... public class BinaryCloseable implements Closeable { private Closeable first; private Closeable last; public BinaryCloseable(Closeable first, Closeable last) { this.first = first; this.last = last; } @Override public void close() throws IOException { try { first.close(); } finally { last.close(); } } } BinaryCloseable is used by CompositeCloseable : public class CompositeCloseable implements Closeable { private Closeable target; public CompositeCloseable(Closeable... closeables) { target = new Closeable() { public void close(){} }; for (Closeable closeable : closeables) { target = new BinaryCloseable(target, closeable); } } @Override public void close() throws IOException { target.close(); } } The ResultSetCloser closes ResultSet objects: public class ResultSetCloser implements Closeable { private ResultSet resultSet; public ResultSetCloser(ResultSet resultSet) { this.resultSet = resultSet; } @Override public void close() throws IOException { try { resultSet.close(); } catch (SQLException e) { throw new IOException("Exception encountered while closing result set", e); } } } The PreparedStatementCloser closes PreparedStatement objects: public class PreparedStatementCloser implements Closeable { private PreparedStatement preparedStatement; public PreparedStatementCloser(PreparedStatement preparedStatement) { this.preparedStatement = preparedStatement; } @Override public void close() throws IOException { try { preparedStatement.close(); } catch (SQLException e) { throw new IOException("Exception encountered while closing prepared statement", e); } } } The ConnectionCloser closes Connection objects: public class ConnectionCloser implements Closeable { private Connection connection; public ConnectionCloser(Connection connection) { this.connection = connection; } @Override public void close() throws IOException { try { connection.close(); } catch (SQLException e) { throw new IOException("Exception encountered while closing connection", e); } } } We now refactor your original InputStream idea into: public class ClosingInputStream extends InputStream { private InputStream stream; private Closeable closer; public ClosingInputStream(InputStream stream, Closeable closer) { this.stream = stream; this.closer = closer; } // The other InputStream methods... @Override public void close() throws IOException { closer.close(); } } Finally, it all comes together as: new ClosingInputStream( stream, new CompositeCloseable( stream, new ResultSetCloser(resultSet), new PreparedStatementCloser(statement), new ConnectionCloser(connection) ) ); When this ClosingInputStream 's close() method is called, this is effectively what happens (with exception handling omitted for clarity's sake): public void close() { try { try { try { try { // This is empty due to the first line in `CompositeCloseable`'s constructor } finally { stream.close(); } } finally { resultSet.close(); } } finally { preparedStatement.close(); } } finally { connection.close(); } } You're now free to close as many Closeable objects as you like.
