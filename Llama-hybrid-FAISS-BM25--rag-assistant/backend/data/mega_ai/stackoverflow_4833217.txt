[site]: stackoverflow
[post_id]: 4833217
[parent_id]: 4809051
[tags]: 
Marc B's link shows a nice and simple algorithm which is correct, written by NSLogan. I wrote a slight modification to it to show some size/speed tradeoffs. I thought I'd share for interest's sake. First, the code: #include #include #include #include #include #define USE_BITS #ifdef USE_BITS #define alloc_prime char *prime = calloc(i/8+1,sizeof(*prime)); #define set_not_prime(x) prime[x/8]|= (1 Since this uses sqrt , to compile use: gcc prime.c -lm I've compared three different ways of storing the boolean variables that peoro suggested. One method actually uses bits, the second takes an entire byte, and the last uses an entire machine word. A naive guess about which is fastest might be the machine word method, since each flag/boolean is dealt with more 'naturally' by your machine. The timings to calculate the primes up to 100,000,000 on my machine were as follows: Bits: 3.8s Chars: 5.8s M-words: 10.8s It is interesting to note that even all the ugly bit-shifting necessary to represent a boolean with only one bit is still faster overall. My conjecture is that caching and locality-of-reference seem to outweigh the extra ~3 instructions. Plus, you end up using 1/nth the memory of the n-bit-machine-word method!
