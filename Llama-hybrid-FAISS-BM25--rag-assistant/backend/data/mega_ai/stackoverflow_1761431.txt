[site]: stackoverflow
[post_id]: 1761431
[parent_id]: 1761171
[tags]: 
Overall You best use time() from time.h instead of an NSDate . At the rate of beats the overhead of creating an NSDate could result in an important loss of precision. I believe time_t is guaranteed to be of double precision, therefore you're safe to use time() in combination with difftime() . Use the whole screen for this, don't just give the user 1 small button. Two idea Post-process Store all times in an array. Trim the result. Remove elements from the start and end that are more than a threshold from the average. Get the average from the remaining values. That's your speed. If it's close to a common value, use that. Adaptive Use 2 variables. One is called speed and the other error . After the first 2 beats calculate the estimated speed, set error to speed . After each beat queue = Fifo(5) # First-in, first-out queue. Try out # different values for the length currentBeat = now - timeOflastBeat currentError = |speed - currentBeat| # adapt error = (error + currentError) / 2 # you have to experiment how much # weight currentError should have queue.push(currentBeat) # push newest speed on queue # automatically removes the oldest speed = average(queue) As soon as error gets smaller than a certain threshold you can stop and tell the user you've determined the speed. Go crazy with the interface. Make the screen flash whenever the user taps. Extra sparks for a tap that is nearly identical to the expected time. Make the background color correspond to the error. Make it brighter the smaller the error gets.
