[site]: stackoverflow
[post_id]: 1496687
[parent_id]: 
[tags]: 
Query/Database Optimization: How to optimize this? (and should I use a materialized view?)

I have a question on how to optimize a query. Actually, as I'm going to be running the query frequently, I was thinking of using a materialized or indexed view (is this a good idea here?) or denormalizing. Consider the following four tables (with irrelevant fields omitted): Users (int userId) Groups (int groupId) GroupMemberships (int userId, int groupId, bool isSharing) Computers (int userId) The relationships are that a user can have 0..n computers (one user to many computers) and can be a member of 0..n groups. A group can have 0..n users (many users to many groups). The "isSharing" denotes whether a user is sharing to that group or is a "read-only" member of that group (that is, can see sharing members' computers, but does not share her own). The query is to find, for a given user what computers that user can see. A user can see all of her own computers. She can also see any computers of other users who are in groups that she is a meber of and are sharing to that group. Okay, that doesn't make much sense, so here's the goal in O(n^3) psudocode: List l foreach(Computer c in Computers) if(c.userId == current_user_id) add c to l else foreach(GroupMembership m where m.userId == current_user_id) foreach(GroupMembership m2 where c.userId == m2.userId && m.groupId == m2.groupId) if(m2.isSharing) add c to l Right now I'm using an ORM mapper and basically doing the above (I'm not too good on the whole SQL thing), but that is obviously a less-than-ideal solution. I have indexes on every field I listed there (except isShared) and an extra index on GroupMembership's (userId, groupId) tuple. But can any database wizards out there think of a better solution? The project's not live yet, but I'm guessing there would be an average of maybe 1.2 computers per user (everyone will have one, a few may have more) and maybe 0.75 group memberships per user (many users won't use the groups feature, but those who do will likely be members of multiple groups). Also, all these associated tables will receive frequent additions, which may make materialized views a less practical solution. I'm using SQL Server 2008. Thanks, All the best, Robert
