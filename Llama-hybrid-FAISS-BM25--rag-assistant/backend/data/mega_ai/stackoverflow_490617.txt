[site]: stackoverflow
[post_id]: 490617
[parent_id]: 489317
[tags]: 
Here's how I would have done this in a simplified manner: var collection = new[] {Item.Baloon, Item.Cupcake, Item.Baloon, Item.Coke}; var result = collection.Contains(2.Baloons(), 1.Cupcakes()); where: public enum Item { Baloon, Cupcake, Coke } public static class TableExtensions { public static Pair Baloons(this int count) { return Tuple.From(Item.Baloon, count); } public static Pair Cupcakes(this int count) { return Tuple.From(Item.Cupcake, count); } public static bool Contains(this IEnumerable self, params Pair [] criteria) { foreach (var pair in criteria) { var search = pair.Key; if (self.Count(item => item == search) Remarks: You don't care about the order of items in the parameters. I'm using enums to represent objects, but these could be objects as well Tuples come from the Lokad.Shared Contains currently searches for "at least X items". We could have more flexibility by passing around criteria objects that are actually predicates for the enumerable - rules . This would keep syntax the same , but allow to have more options (i.e.: AtLeast , AtMost , X. VegetarianSets , Y. Drinks , etc). If interested, check out the predefined validation rules from the validation and business rules application block for the similar approach to rule composition.
