[site]: stackoverflow
[post_id]: 499091
[parent_id]: 499016
[tags]: 
What you have here might not crash, but it probably won't do what you want either! Zeroing out the vector won't call the destructor for each a_class instance. It will also overwrite the internal data for a_class.even_more_values (so if your push_back() is after the memset() you are likely to get an access violation). I would do two things differently: Use std::vector for your storage both in a_class and in some_function() . Write a destructor for a_class that cleans up properly If you do this, the storage will be managed for you by the compiler automatically. For instance: class a_class { public: a_class() {...} ~a_class() { /* make sure that even_more_values gets cleaned up properly */ } int some_method(int some_param) {...} int value_1; int value_2; float value_3; std::vector even_more_values; /* and so on */ } void some_function() { std::vector a_instances( 10 ); // Pass a_instances into these functions by reference rather than by using // a global. This is re-entrant and more likely to be thread-safe. do_stuff( a_instances ); do_more_stuff( a_instances ); // a_instances will be cleaned up automatically here. This also allows you some // weak exception safety. } Remember that if even_more_values contains pointers to other objects, you will need to delete those objects in the destructor of a_class . If possible, even_more_values should contain the objects themselves rather than pointers to those objects (that way you may not have to write a destructor for a_class , the one the compiler provides for you may be sufficient).
