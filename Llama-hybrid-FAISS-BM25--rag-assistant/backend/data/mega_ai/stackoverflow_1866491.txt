[site]: stackoverflow
[post_id]: 1866491
[parent_id]: 1866397
[tags]: 
You should implement it as extern strings as in your example: extern NSString * const MyPluginErrorDomain; or provide extern functions which return static storage data. For example: /* h */ extern NSString * MyPluginErrorDomain(); /* m */ NSString * MyPluginErrorDomain() { static NSString * const s = @"MyPluginErrorDomain"; return s; } The reason is that strings and keys are often used and compared by pointer value or hash value, rather than true string comparison (isEqualToString:). At the implementation level, there is a big difference between: In code, that means that when the strings compared are defined in multiple binaries: Say 'MyPluginErrorDomain' and 'key' have identical string values, but are defined in different binaries (i.e. on in the plugin host, one in the plugin). /////// Pointer comparison (NSString) BOOL a = [MyPluginErrorDomain isEqualToString:key]; BOOL b = MyPluginErrorDomain == key; // c may be false because a may be true, in that they represent the same character sequence, but do not point to the same object BOOL c = a == b; /////// Hash use (NSString) // This is true BOOL d = [MyPluginErrorDomain hash] == [key hash]; // This is indicative if true BOOL e = [MyPluginErrorDomain hash] == [someOtherStringKey hash]; // because BOOL f = [MyPluginErrorDomain isEqualToString:someOtherStringKey]; // g may be false (though the hash code is 'generally' correct) BOOL g = e == f; It is therefore necessary to provide the keys in many cases. It may seem like a trivial point, but it is hard to diagnose some of the problems associated with the difference. Hash codes and pointer comparisons are used throughout Foundation and other objc technologies in the internals of dictionary storage, key value coding... If your dictionary is going straight out to xml, that's one thing, but runtime use is another and there are a few caveats in the implementation and runtime details.
