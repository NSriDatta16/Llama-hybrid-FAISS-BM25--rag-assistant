[site]: stackoverflow
[post_id]: 3452251
[parent_id]: 
[tags]: 
unbounded_buffer, _CrtSetDbgFlag and memory leaks

I am trying to use one of the new features - asynchronous agents library. I just added a unbounded_buffer m_myDataBuffer; to my C++ class, nothing more - no agent running yet. To enable memory leak detection in my application, I am using: #ifdef _DEBUG _CrtSetDbgFlag ( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF ); #endif But after closing my application window (I am using simple Win 32 GUI application) Visual Studio shows a bunch of memory leaks: Detected memory leaks! Dumping objects -> {261} normal block at 0x007C4EB8, 288 bytes long. Data: 00 00 02 00 02 00 00 00 10 02 00 00 10 B1 35 00 {260} normal block at 0x007C4E70, 12 bytes long. Data: 00 00 00 00 00 02 00 00 48 4D 7C 00 {259} normal block at 0x007C4E18, 28 bytes long. Data: 00 00 00 00 CD CD CD CD 00 00 00 00 00 00 00 00 {258} normal block at 0x0035AEF0, 28 bytes long. Data: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 {257} normal block at 0x007C4D48, 144 bytes long. Data: A4 C2 F4 55 CD CD CD CD 00 00 00 00 00 00 00 00 {255} normal block at 0x007C0AB8, 16388 bytes long. Data: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 {254} normal block at 0x0035CF30, 12 bytes long. Data: 01 10 00 00 01 00 00 00 B8 0A 7C 00 {253} normal block at 0x007C0978, 256 bytes long. Data: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 {252} normal block at 0x007C08A8, 148 bytes long. Data: 8C 21 F5 55 01 00 00 00 00 00 00 00 00 00 00 00 {251} normal block at 0x0035FEB8, 256 bytes long. Data: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 {250} normal block at 0x0035FDE8, 148 bytes long. Data: 8C 21 F5 55 01 00 00 00 00 00 00 00 00 00 00 00 {249} normal block at 0x007C0068, 2048 bytes long. Data: A0 FD 35 00 CD CD CD CD CD CD CD CD CD CD CD CD {248} normal block at 0x0035FDA0, 12 bytes long. Data: 60 F9 35 00 00 00 00 00 FF FF FF FF {247} normal block at 0x0035F960, 1024 bytes long. Data: E8 FD 35 00 A8 08 7C 00 00 00 00 00 00 00 00 00 {246} normal block at 0x0035F8B8, 104 bytes long. Data: 10 B1 35 00 98 D0 35 00 02 00 00 00 02 00 00 00 {245} normal block at 0x0035F078, 2048 bytes long. Data: 30 F0 35 00 CD CD CD CD CD CD CD CD CD CD CD CD {244} normal block at 0x0035F030, 12 bytes long. Data: F0 EB 35 00 00 00 00 00 FF FF FF FF {243} normal block at 0x0035EBF0, 1024 bytes long. Data: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 {242} normal block at 0x0035E3B0, 2048 bytes long. Data: 68 E3 35 00 CD CD CD CD CD CD CD CD CD CD CD CD {241} normal block at 0x0035E368, 12 bytes long. Data: 28 DF 35 00 00 00 00 00 FF FF FF FF {240} normal block at 0x0035DF28, 1024 bytes long. Data: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 {239} normal block at 0x0035DE08, 224 bytes long. Data: 98 13 F5 55 00 00 00 00 0C DE 35 00 00 00 00 00 {238} normal block at 0x0035D5C8, 2048 bytes long. Data: 80 D5 35 00 CD CD CD CD CD CD CD CD CD CD CD CD {237} normal block at 0x0035D580, 12 bytes long. Data: 40 D1 35 00 00 00 00 00 FF FF FF FF {236} normal block at 0x0035D140, 1024 bytes long. Data: 08 DE 35 00 00 00 00 00 00 00 00 00 00 00 00 00 {235} normal block at 0x0035D098, 104 bytes long. Data: 10 B1 35 00 B8 F8 35 00 08 DE 35 00 CD CD CD CD {234} normal block at 0x0035D008, 80 bytes long. Data: 2C C4 F4 55 5C C1 F4 55 00 00 00 00 00 00 00 00 {233} normal block at 0x0035CF78, 80 bytes long. Data: 2C C4 F4 55 5C C1 F4 55 00 00 00 00 00 00 00 00 {231} normal block at 0x0035CEF0, 4 bytes long. Data: 00 00 00 00 {230} normal block at 0x0035CE58, 88 bytes long. Data: 01 00 00 00 00 00 00 00 01 00 00 00 7C CF 35 00 {229} normal block at 0x0035C300, 44 bytes long. Data: 03 00 00 00 02 00 00 00 02 00 00 00 00 00 00 00 {228} normal block at 0x0035C5E0, 2104 bytes long. Data: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 {227} normal block at 0x0035C4D0, 208 bytes long. Data: 6C 0A F5 55 00 00 00 00 E8 C0 35 00 30 C1 35 00 {225} normal block at 0x0035C2C0, 4 bytes long. Data: B8 F8 35 00 {224} normal block at 0x0035C280, 4 bytes long. Data: 98 D0 35 00 {223} normal block at 0x0035C200, 64 bytes long. Data: 10 C5 35 00 CD CD CD CD CD CD CD CD CD CD CD CD {222} normal block at 0x0035C488, 8 bytes long. Data: 00 00 00 00 01 00 00 00 {221} normal block at 0x0035C418, 48 bytes long. Data: 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 {220} normal block at 0x0035C3D8, 4 bytes long. Data: 00 00 00 00 {219} normal block at 0x0035C378, 36 bytes long. Data: 03 00 00 00 02 00 00 00 00 00 00 00 00 00 00 00 {217} normal block at 0x0035C130, 148 bytes long. Data: 6C D7 F4 55 02 00 00 00 01 00 00 00 10 00 00 00 {216} normal block at 0x0035C0E8, 8 bytes long. Data: C0 11 F5 55 10 B1 35 00 {215} normal block at 0x0035B8A8, 2048 bytes long. Data: 00 AE 35 00 CD CD CD CD CD CD CD CD CD CD CD CD {214} normal block at 0x0035AE00, 12 bytes long. Data: 68 B4 35 00 00 00 00 00 FF FF FF FF {213} normal block at 0x0035B468, 1024 bytes long. Data: 18 4E 7C 00 00 00 00 00 00 00 00 00 00 00 00 00 {212} normal block at 0x0035AF50, 36 bytes long. Data: 00 00 00 00 02 00 00 00 01 00 00 00 01 00 00 00 {211} normal block at 0x0035B110, 368 bytes long. Data: CC 1D F5 55 50 AF 35 00 00 00 00 00 00 00 00 00 Object dump complete. Leaks go away right after I comment out the unbounded_buffer m_myDataBuffer; or after I comment out _CrtSetDbgFlag ( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF ); Is there anything special about unbounded_buffer I have to do to release it even if it is not used? Or do I need to set _CrtSetDbgFlag in some special way? Is _CrtSetDbgFlag the cause of mem leaks or it is somehow creating false detections in this case and there are no real memory leaks? What am I missing here? I am 100% sure that those leaks do not come from my code because I also have #ifdef _DEBUG #define _CRTDBG_MAP_ALLOC #include #include #define new new(_NORMAL_BLOCK,__FILE__, __LINE__) in my stdafx.h so memory leaks from my code have filenames and lines. But those of unbounded_buffer do not have such info, so I guess that means they come from agents library.
