[site]: stackoverflow
[post_id]: 4841189
[parent_id]: 4840763
[tags]: 
If you are not allowed to use anything but Perl regular expressions then you could adapt the code to strip HTML tags from a text : #!/usr/bin/perl -w use strict; use warnings; $_ = do { local $/; }; # see http://www.perlmonks.org/?node_id=161281 # ALGORITHM: # find , # or comment , # or one of the start tags which require correspond # end tag plus all to end tag # or if \s or =" # then skip to next " # else [^>] # > s{ ] | # and not close tag or [\s=] # \s or "=" with `[^`]*` | # something in quotes ` or [\s=] # \s or "=" with '[^']*' | # something in quotes ' or [\s=] # \s or "=" with "[^"]*" # something in quotes " )* # repeat (C) 0 or more times | # else (if previous case is not (4)) .*? # minimum of any chars ) # end if previous char is (4) (?(1) # if comment (1) (? ]*)? # skip junk to ">" ) # end if (3) > # tag closed }{}gsx; # STRIP THIS TAG print; __END__ remove script, ul function getCookies() { return ""; } 1 2 paragraph Output remove script, ul 1 2 paragraph NOTE: This regex doesn't work for nested tag-containers e.g.: Nested &lt;object> example fallback content for uri:here uri:another fallback !!!this text should be striped too!!! Output Nested &lt;object> example !!!this text should be striped too!!! Don't parse html with regexs. Use a html parser or a tool built on top of it e.g., HTML::Parser : #!/usr/bin/perl -w use strict; use warnings; use HTML::Parser (); HTML::Parser->new( ignore_elements => ["script"], ignore_tags => ["ul"], default_h => [ sub { print shift }, 'text'], )->parse_file(\*DATA) or die "error: $!\n"; __END__ remove script, ul function getCookies() { return ""; } 1 2 paragraph Output remove script, ul 1 2 paragraph
