[site]: stackoverflow
[post_id]: 229542
[parent_id]: 229472
[tags]: 
Test-Driven-Development: very occasionally someone might do it for a component. Also, implementing a public specification which comes with conformance tests offers some of the advantages of TDD, and lots of that goes on. Domain-Driven-Design: no Model-Driven-Design/Architecture: no Do you test?: yes Unit Testing: some, although not complete. A lot of components are libraries for customer use. There's a fine line between unit and functional testing of a "strlen" implementation. Integration Testing: not really, there's little between unit and system tests Acceptance Testing: yes, and subsets of the acceptance tests used as system tests Code Reviews: no formal process, but some code gets reviewed Innovative Technologies (Spring, Hibernate, Wicket, JSF, WS, REST, ...): no Agile: no Pair Programming: no UML: no Domain-specific languages: very occasionally Requirement Specification (How?): sort of Continous Integration: no, but daily builds and reversion of failure-causing changes at discretion of the test team Code-Coverage Tools: no formal requirement, test team have been known to use 'em Aenemic Domain Model: I don't even know what this is Communication (Wiki, Mail, IM, Mailinglists, other documents): all of them, chosen ad hoc except that requirement and design docs must be HTML under source control, and internal interface documentation is generated from Doxygen comments in headers. Effort estimates: a bit Team size: about 20 programmers, variously grouped into component teams of 1-4 people. Pretty much nobody works exclusively on the component whose team they belong to. Meetings: weekly full meeting to exchange progress reports and otherwise share what's going on. No other regularly scheduled meetings for developers: discussions arranged as required. Code metrics: no Static code analysis: not unless you count -pedantic ;-) Bug tracking: Bugzilla, somewhat integrated with source-control
