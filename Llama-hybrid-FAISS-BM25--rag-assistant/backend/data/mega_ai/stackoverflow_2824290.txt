[site]: stackoverflow
[post_id]: 2824290
[parent_id]: 2824232
[tags]: 
Here's the simplest working solution I could come up with. Assumptions: You have an array of arrays (your result set); it is named $rows . Empty column values in the result set you give above are equal to null . There are no branches in your tree whose names are string representations of integers. The code: $tree = array(); foreach($rows as $row) { // Second parameter: array of 6 items as per your sample result set place_in_tree($tree, array($row['root'], ... $row['kw5']), $row['file']); } function place_in_tree(array $tree, array $path, $item) { // While there are more branches to be taken in $path while(($branch = array_shift($path)) !== null) { // Create the new branch if it doesn't exist if(!isset($tree[$branch])) { $tree[$branch] = array(); } // Select the subtree in that branch for the next iteration $tree = $tree[$branch]; } // Finally, add the item $tree[] = $item; } This creates an array with nested arrays. This array contains a number of items with string keys (these are "branches", and are of type array ) and a number of items with numeric keys (these are "files", and are of type string ). Child arrays are populated in the same way. If you require something more close to your business model than a big honking array, you can tweak the branch selection and item storage logic in function place_in_tree above. Also, if assumption #3 above does not hold in your case, you will need to get a little involved in the same manner, either choosing a non-ambiguous way to tell apart the branches and leaves of the tree, or choosing another structure to represent it.
