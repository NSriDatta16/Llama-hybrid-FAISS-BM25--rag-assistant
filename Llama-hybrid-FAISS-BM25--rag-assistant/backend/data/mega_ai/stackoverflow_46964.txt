[site]: stackoverflow
[post_id]: 46964
[parent_id]: 46933
[tags]: 
abstract class Animal { public virtual Leg GetLeg () } abstract class Leg { } class Dog : Animal { public override Leg GetLeg () { return new DogLeg(); } } class DogLeg : Leg { void Hump(); } Do it like this, then you can leverage the abstraction in your client: Leg myleg = myDog.GetLeg(); Then if you need to, you can cast it: if (myleg is DogLeg) { ((DogLeg)myLeg).Hump()); } Totally contrived, but the point is so you can do this: foreach (Animal a in animals) { a.GetLeg().SomeMethodThatIsOnAllLegs(); } While still retaining the ability to have a special Hump method on Doglegs.
