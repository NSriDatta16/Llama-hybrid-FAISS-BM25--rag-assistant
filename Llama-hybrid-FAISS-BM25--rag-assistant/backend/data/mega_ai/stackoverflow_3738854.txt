[site]: stackoverflow
[post_id]: 3738854
[parent_id]: 
[tags]: 
Generic Factory for classes?

I am trying to create a class that uses a factory to find the right class and then calls methods on that class. I am doing something wrong though because the intellisense in Visual Studio keeps alerting me to errors and when I try to access the methods that should be within the class the factory returns they are not available. Can anyone tell me what I'm doing wrong? Here is the code where I am trying to get a reference to the class: DBBase dal = DALFactory.GetDAL(typeof(T)); myCollection = dal.GetByCriteria(myCriteria, sortExpression, startRowIndex, maximumRows, propertyNamesToBypassInstantiation); Here is the code for the DALFactory class: internal static class DALFactory { // GetParser internal static DBBase GetDAL(System.Type BOType) { switch (BOType.Name) { case "Person": return new PersonDB(); } // if we reach this point then we failed to find a matching type. Throw // an exception. throw new Exception("Unknown Type"); } } Here is part of the code for the base of the class returned by the factory class: public abstract class DBBase { protected static T GetSingleBO (ref SqlCommand command) where T : BOBase { return GetSingleBO (ref command, null); } protected static T GetSingleBO (ref SqlCommand command, List propertyNamesToBypassInstantiation) where T : BOBase { T BO = default(T); try { command.Connection.Open(); SqlDataReader reader = command.ExecuteReader(); if (reader.HasRows) { reader.Read(); BOParser parser = BOParserFactory.GetParser(typeof(T)); parser.PopulateOrdinals(reader); if (propertyNamesToBypassInstantiation == null) { BO = (T)parser.PopulateBO(reader); } else { BO = (T)parser.PopulateBO(reader, propertyNamesToBypassInstantiation); } reader.Close(); } else { // Whever there's no data, we return null. BO = default(T); } } catch (Exception ex) { StringBuilder sb = new StringBuilder(); sb.AppendFormat("Error populating data: {0}", ex.Message); if (ex.InnerException != null) { sb.AppendFormat(" -- Inner Exception: {0}", ex.InnerException.Message); } throw new Exception(sb.ToString(), ex); } finally { command.Connection.Close(); command.Connection.Dispose(); } // return the BO, it's either populated with data or null. return BO; } protected static EquatableList GetBOEquatableList (ref SqlCommand command) where T : BOBase { return GetBOEquatableList (ref command, null); } protected static EquatableList GetBOEquatableList (ref SqlCommand command, List propertyNamesToBypassInstantiation) where T : BOBase { EquatableList BOList = new EquatableList (); try { command.Connection.Open(); SqlDataReader reader = command.ExecuteReader(); if (reader.HasRows) { // Get a parser for this BO type and populate // the ordinals. BOParser parser = BOParserFactory.GetParser(typeof(T)); parser.PopulateOrdinals(reader); // Use the parser to build our list of BOs. while (reader.Read()) { T BO = default(T); if (propertyNamesToBypassInstantiation == null) { BO = (T)parser.PopulateBO(reader); } else { BO = (T)parser.PopulateBO(reader, propertyNamesToBypassInstantiation); } BOList.Add(BO); } reader.Close(); } } catch (Exception ex) { StringBuilder sb = new StringBuilder(); sb.AppendFormat("Error populating data: {0}", ex.Message); if (ex.InnerException != null) { sb.AppendFormat(" -- Inner Exception: {0}", ex.InnerException.Message); } throw new Exception(sb.ToString(), ex); } finally { command.Connection.Close(); command.Connection.Dispose(); } return BOList; } protected static int GetBOCount(ref SqlCommand command) { int count = 0; try { command.CommandType = CommandType.StoredProcedure; DbParameter idParam = command.CreateParameter(); idParam.DbType = DbType.Int32; idParam.Direction = ParameterDirection.InputOutput; idParam.ParameterName = "@recordCount"; idParam.Value = 0; command.Parameters.Add(idParam); command.Connection.Open(); command.ExecuteNonQuery(); command.Connection.Close(); count = (int)command.Parameters["@recordCount"].Value; } catch (Exception e) { throw new Exception("Error populating data", e); } finally { command.Connection.Close(); command.Connection.Dispose(); } return count; } protected static bool DeleteBO(ref SqlCommand command) { int result = 0; try { command.Connection.Open(); result = command.ExecuteNonQuery(); } catch (Exception e) { throw new Exception("Error deleting data", e); } finally { command.Connection.Close(); command.Connection.Dispose(); } return result > 0; } protected static int GetFKcount(ref SqlCommand command) { int count = 0; try { command.CommandType = CommandType.StoredProcedure; DbParameter idParam = command.CreateParameter(); idParam.DbType = DbType.Int32; idParam.Direction = ParameterDirection.InputOutput; idParam.ParameterName = "@recordCount"; idParam.Value = 0; command.Parameters.Add(idParam); command.Connection.Open(); command.ExecuteNonQuery(); command.Connection.Close(); count = (int)command.Parameters["@recordCount"].Value; } catch (Exception e) { throw new Exception("Error populating data", e); } finally { command.Connection.Close(); command.Connection.Dispose(); } return count; } public static T GetById (Guid Id) where T : BOBase { return GetById (Id, null); } abstract public static T GetById (Guid Id, List propertyNamesToBypassInstantiation) where T : BOBase; public static EquatableList GetByCriteria (TCriteria myCriteria) where T : BOBase where TCriteria : BaseCriteria { return GetByCriteria (myCriteria, null); } public static EquatableList GetByCriteria (TCriteria myCriteria, List propertyNamesToBypassInstantiation) where T : BOBase where TCriteria : BaseCriteria { return GetByCriteria (myCriteria, null, -1, -1, propertyNamesToBypassInstantiation); } public static EquatableList GetByCriteria (TCriteria myCriteria, string sortExpression, int startRowIndex, int maximumRows) where T : BOBase where TCriteria : BaseCriteria { return GetByCriteria (myCriteria, sortExpression, startRowIndex, maximumRows, null); } abstract public static EquatableList GetByCriteria (TCriteria myCriteria, string sortExpression, int startRowIndex, int maximumRows, List propertyNamesToBypassInstantiation) where T : BOBase where TCriteria : BaseCriteria; abstract public static int GetCountForCriteria (TCriteria myCriteria) where TCriteria : BaseCriteria; abstract public static bool Save (T myobject) where T : BOBase; abstract public static bool Delete (Guid Id) where T : BOBase; abstract public static int GetFKcount (Guid Id) where T : BOBase; abstract internal static void CreateCriteriaParameters (ref SqlCommand myCommand, TCriteria myCriteria) where T : BOBase where TCriteria : BaseCriteria; } And this is part of the code for the final bottom class that should be getting returned: public partial class PersonDB : DBBase { public override static Person GetById(Guid Id, List propertyNamesToBypassInstantiation) { SqlCommand command = GetDbSprocCommand("sprocPersonSelectSingleItem"); command.Parameters.Add(CreateParameter("@id", Id)); return GetSingleBO (ref command, propertyNamesToBypassInstantiation); } public override static EquatableList GetByCriteria(PersonCriteria myCriteria, string sortExpression, int startRowIndex, int maximumRows, List propertyNamesToBypassInstantiation) { SqlCommand command = GetDbSprocCommand("sprocPersonSearchList"); CreateCriteriaParameters(ref command, myCriteria); CreatePagingAndSortingParameters(ref command, sortExpression, startRowIndex, maximumRows); return GetBOEquatableList (ref command, propertyNamesToBypassInstantiation); } }
