[site]: stackoverflow
[post_id]: 4944710
[parent_id]: 4944608
[tags]: 
This isn't possible in (reasonable) XSLT. You can work around it. Your solution with concat is invalid: XSLT is not just a fancy string-concatenator, it really transforms the conceptual tree . An encoded character such as &#xf0a7; is a single character - if you were to somehow include the letters & # x f 0 a 7 ; then the XSLT processor would be required to include these letters in the XML data - not the string! So that means it will escape them. There's no feature in XSLT 1.0 that permits converting from a number to a character with that codepoint. In XSLT 2.0, as Michael Kay points out, you can use codepoints-to-string() to achieve this. There are two solutions. Firstly, you could use disable-output-escaping . This is rather nasty and not portable . Avoid this at all costs if you can - but it will probably work in your transformer, and it's probably the only general, simple solution, so you may not be able to avoid this. The second solution would be to hardcode matches for each individual character. That's a mess generally, but quite possible if you're dealing with a limited set of possibilities - that depends on your specific problem. Finally, I'd recommend not solving this problem in XSLT - this is typically something you can do in pre/post processing in another programming environment more appropriately. Most likely, you've an in-memory representation of the XML document to be able to use XSLT in the first place, in which case this won't even take much CPU time.
