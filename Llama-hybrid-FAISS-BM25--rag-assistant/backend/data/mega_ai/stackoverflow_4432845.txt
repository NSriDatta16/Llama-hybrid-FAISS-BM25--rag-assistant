[site]: stackoverflow
[post_id]: 4432845
[parent_id]: 
[tags]: 
iPhone Multiple UITableView controls on one View

Im having a little issue with using more than 1 UITableView on a view. Here's what I've done so far (using examples, etc from here and other places): Created a class for each table. Each class is pretty basic: .h: @interface ConstructionDocumentsJobTable : UITableViewController { NSMutableArray *tableItems; IBOutlet UITableView *itemsTable; NSInteger recordSelected; id tableSelectDelegate; } @property (nonatomic, retain) NSMutableArray *tableItems; @property (nonatomic, assign) id tableSelectDelegate; @end .m: @implementation ConstructionDocumentsJobTable @synthesize tableItems, tableSelectDelegate; #pragma mark - #pragma mark View Life Cycle -(void) loadView { } -(void) dealloc { [tableItems release]; [super dealloc]; } #pragma mark - #pragma mark Table view data source // Customize the number of sections in the table view. - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView { return 1; } // Customize the number of rows in the table view. - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section { return [tableItems count]; } // Customize the appearance of table view cells. - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { static NSString *CellIdentifier = @"Cell"; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier]; if (cell == nil) { cell = [[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] autorelease]; } cell.textLabel.text = [tableItems objectAtIndex:indexPath.row]; return cell; } #pragma mark - #pragma mark Table view delegate - (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath { //pass the tap value back to the delegate } Both are completely identical, save the names. When Im making the call to the first one, it is called in the ViewDidLoad method of the controller of the view. It's pretty basic: NSMutableArray *tableItems = [[NSMutableArray alloc] initWithCapacity:intMax]; //strDocumentType is set elsewhere and loaded here if(strDocumentType == @"typea"){ [tableItems addObject:@"Type A - Value 1"]; [tableItems addObject:@"Type A - Value 2"]; } else { [tableItems addObject:@"Type B - Value 1"]; } if(jobTableController == nil){ jobTableController = [[ConstructionDocumentsJobTable alloc] init]; [jobTableController loadView]; jobTableController.tableItems = tableItems; jobTableController.tableSelectDelegate = self; } [tableJobList setDataSource:jobTableController]; [tableJobList setDelegate:jobTableController]; jobTableController.view = jobTableController.tableView; The second table is built when a cell in the first table is selected. So, in the first tables selection method, the delegate is called back from the parent controller, which then has this: NSMutableArray *tableTypeItems = [[NSMutableArray alloc] initWithCapacity:100]; if(tableSelect == @"plumbing"){ [tableTypeItems addObject:@"Something"]; [tableTypeItems addObject:@"Other"]; } if(typeTableController == nil){ typeTableController = [[ConstructionDocumentsTypeTable alloc] init]; [typeTableController loadView]; typeTableController.tableItems = tableTypeItems; typeTableController.tableSelectDelegate = self; } [tableTypeList setDataSource:typeTableController]; [tableTypeList setDelegate:typeTableController]; typeTableController.view = typeTableController.tableView; [typeTableController.tableView reloadData]; //Code to move the first table off the screen and move this one into view goes here Ive been stuck on this for days, and I really need to get this done!!! Im sure it's something REALLLLLLY simple. Any help you guys can pass along would be HUGELY appreciated. Thanks everyone.
