[site]: stackoverflow
[post_id]: 2225426
[parent_id]: 2225330
[tags]: 
It would be rather strange to expect the function pointers to work the way you expect them to work in your example. "Default argument" is a purely compile-time concept, it is a form of syntactic sugar . Despite the fact that default arguments are specified in the function declaration or definition, they really have nothing to do with the function itself. In reality default arguments are substituted at the point of the call, i.e. they are handled in the context of the caller . From the function's point of view there's no difference between an explicit argument supplied by the user or a default one implicitly supplied by the compiler. Function pointers, on the other hand, are run-time entities. They are initialized at run time. At run-time default arguments simply don't exist. There's no such concept as "run-time default arguments" in C++. Some compilers will allow you to specify default arguments in function pointer declaration, as in void foo(int); int main() { void (*pfoo)(int = 42) = foo; pfoo(); // same as 'pfoo(42)' } but this is not standard C++ and this does not appear to be what you are looking for, since you want the "default argument " value to change at run time depending on the function the pointer is pointing to. As long as you want to stick with genuine function pointers (as opposed to function objects, aka functors) the immediate workaround would be for you to provide a parameter-less version of your function under a different name, as in class MyObj { public: ... int bar(int val = 42) { return 2; } int bar_default() { return bar(); } }; int main() { MyObj o; typedef int (MyObj::*barptr2)(); barptr2 bp2 = &MyObj::bar_default; int r3 = (o.*bp2)(); return 0; } This is, of course, far from elegant. One can actually argue that what I did above with bar_default could have been implicitly done by the compiler, as a language feature. E.g. given the class definition class MyObj { public: ... int bar(int val = 42) { return 2; } ... }; one might expect the compiler to allow the following int main() { MyObj o; typedef int (MyObj::*barptr2)(); barptr2 bp2 = &MyObj::bar; int r3 = (o.*bp2)(); return 0; } where the pointer initialization would actually force the compiler to implicitly generate an "adapter" function for MyObj::bar (same as bar_default in my previous example), and set bp2 to point to that adaptor instead. However, there's no such feature in C++ language at this time. And to introduce something like that would require more effort than it might seem at the first sight. Also note that in the last two examples the pointer type is int (MyObj::*)() , which is different from int (MyObj::*)(int) . This is actually a question to you (since you tried both in your example): how would you want it to work? With an int (MyObj::*)() pointer? Or with a int (MyObj::*)(int) pointer?
