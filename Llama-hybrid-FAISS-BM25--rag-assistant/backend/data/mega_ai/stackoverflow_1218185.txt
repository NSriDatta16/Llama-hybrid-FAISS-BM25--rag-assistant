[site]: stackoverflow
[post_id]: 1218185
[parent_id]: 1218149
[tags]: 
It's all a matter of adequate storage and algorithms to treat numbers as smaller parts. Let's assume you have a compiler in which an int can only be 0 through 99 and you want to handle numbers up to 999999 (we'll only worry about positive numbers here to keep it simple). You do that by giving each number three int s and using the same rules you (should have) learned back in primary school for addition, subtraction and the other basic operations. In an arbitrary precision library, there's no fixed limit on the number of base types used to represent our numbers, just whatever memory can hold. Addition for example: 123456 + 78 : 12 34 56 78 -- -- -- 12 35 34 Working from the least significant end: initial carry = 0. 56 + 78 + 0 carry = 134 = 34 with 1 carry 34 + 00 + 1 carry = 35 = 35 with 0 carry 12 + 00 + 0 carry = 12 = 12 with 0 carry This is, in fact, how addition generally works at the bit level inside your CPU. Subtraction is similar (using subtraction of the base type and borrow instead of carry), multiplication can be done with repeated additions (very slow) or cross-products (faster) and division is trickier but can be done by shifting and subtraction of the numbers involved (the long division you would have learned as a kid). I've actually written libraries to do this sort of stuff using the maximum powers of ten that can be fit into an integer when squared (to prevent overflow when multiplying two int s together, such as a 16-bit int being limited to 0 through 99 to generate 9,801 ( int using 0 through 9,999 to generate 99,980,001 ( Some tricks to watch out for. 1/ When adding or multiplying numbers, pre-allocate the maximum space needed then reduce later if you find it's too much. For example, adding two 100-"digit" (where digit is an int ) numbers will never give you more than 101 digits. Multiply a 12-digit number by a 3 digit number will never generate more than 15 digits (add the digit counts). 2/ For added speed, normalise (reduce the storage required for) the numbers only if absolutely necessary - my library had this as a separate call so the user can decide between speed and storage concerns. 3/ Addition of a positive and negative number is subtraction, and subtracting a negative number is the same as adding the equivalent positive. You can save quite a bit of code by having the add and subtract methods call each other after adjusting signs. 4/ Avoid subtracting big numbers from small ones since you invariably end up with numbers like: 10 11- -- -- -- -- 99 99 99 99 (and you still have a borrow). Instead, subtract 10 from 11, then negate it: 11 10- -- 1 (then negate to get -1). Here are the comments (turned into text) from one of the libraries I had to do this for. The code itself is, unfortunately, copyrighted, but you may be able to pick out enough information to handle the four basic operations. Assume in the following that -a and -b represent negative numbers and a and b are zero or positive numbers. For addition , if signs are different, use subtraction of the negation: -a + b becomes b - a a + -b becomes a - b For subtraction , if signs are different, use addition of the negation: a - -b becomes a + b -a - b becomes -(a + b) Also special handling to ensure we're subtracting small numbers from large: small - big becomes -(big - small) Multiplication uses entry-level math as follows: 475(a) x 32(b) = 475 x (30 + 2) = 475 x 30 + 475 x 2 = 4750 x 3 + 475 x 2 = 4750 + 4750 + 4750 + 475 + 475 The way in which this is achieved involves extracting each of the digits of 32 one at a time (backwards) then using add to calculate a value to be added to the result (initially zero). ShiftLeft and ShiftRight operations are used to quickly multiply or divide a LongInt by the wrap value (10 for "real" math). In the example above, we add 475 to zero 2 times (the last digit of 32) to get 950 (result = 0 + 950 = 950). Then we left shift 475 to get 4750 and right shift 32 to get 3. Add 4750 to zero 3 times to get 14250 then add to result of 950 to get 15200. Left shift 4750 to get 47500, right shift 3 to get 0. Since the right shifted 32 is now zero, we're finished and, in fact 475 x 32 does equal 15200. Division is also tricky but based on early arithmetic (the "gazinta" method for "goes into"). Consider the following long division for 12345 / 27 : 457 +------- 27 | 12345 27 is larger than 1 or 12 so we first use 123. 108 27 goes into 123 4 times, 4 x 27 = 108, 123 - 108 = 15. --- 154 Bring down 4. 135 27 goes into 154 5 times, 5 x 27 = 135, 154 - 135 = 19. --- 195 Bring down 5. 189 27 goes into 195 7 times, 7 x 27 = 189, 195 - 189 = 6. --- 6 Nothing more to bring down, so stop. Therefore 12345 / 27 is 457 with remainder 6 . Verify: 457 x 27 + 6 = 12339 + 6 = 12345 This is implemented by using a draw-down variable (initially zero) to bring down the segments of 12345 one at a time until it's greater or equal to 27. Then we simply subtract 27 from that until we get below 27 - the number of subtractions is the segment added to the top line. When there are no more segments to bring down, we have our result. Keep in mind these are pretty basic algorithms. There are far better ways to do complex arithmetic if your numbers are going to be particularly large. You can look into something like GNU Multiple Precision Arithmetic Library - it's substantially better and faster than my own libraries. It does have the rather unfortunate misfeature in that it will simply exit if it runs out of memory (a rather fatal flaw for a general purpose library in my opinion) but, if you can look past that, it's pretty good at what it does. If you cannot use it for licensing reasons (or because you don't want your application just exiting for no apparent reason), you could at least get the algorithms from there for integrating into your own code. I've also found that the bods over at MPIR (a fork of GMP) are more amenable to discussions on potential changes - they seem a more developer-friendly bunch.
