[site]: stackoverflow
[post_id]: 3701712
[parent_id]: 3701220
[tags]: 
Judging from your __hash__ method, the class stores references to its arguments, and uses that as a hash. The problem is, those arguments are shared with the code that constructed the object. If they change the argument, the hash will change and you won't be able to find the object in any dictionaries it had been in. The arguments need not be anything complicated, just a simple list will do. In [13]: class Spam(object) : ....: def __init__(self, arg) : ....: self.arg = arg ....: def __hash__(self) : ....: return hash(tuple(self.arg,)) In [18]: l = range(5) In [19]: spam = Spam(l) In [20]: hash(spam) Out[20]: -3958796579502723947 If I change the list that I passed as an argument, the hash will change. In [21]: l += [10] In [22]: hash(spam) Out[22]: -6439366262097674983 Since dictionary keys are organized by hash, when I do x in d , the first thing Python does is compute the hash of x, and look in the dictionary for something with that hash value. The problem is, when the hash of an object changes after being put in the dictionary, Python will look at the new hash value, and not see the desired key there. Using the list of keys, forces Python to check each key by equality, bypassing the hash check.
