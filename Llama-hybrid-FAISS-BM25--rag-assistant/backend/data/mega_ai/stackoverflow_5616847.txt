[site]: stackoverflow
[post_id]: 5616847
[parent_id]: 
[tags]: 
Why is this program faster in Python than Objective-C?

I got interested in this small example of an algorithm in Python for looping through a large word list. I am writing a few "tools" that will allow my to slice a Objective-C string or array in a similar fashion as Python. Specifically, this elegant solution caught my attention for executing very quickly and it uses a string slice as a key element of the algorithm. Try and solve this without a slice! I have reproduced my local version using the Moby word list below. You can use /usr/share/dict/words if you do not feel like downloading Moby. The source is just a large dictionary-like list of unique words. #!/usr/bin/env python count=0 words = set(line.strip() for line in open("/Users/andrew/Downloads/Moby/mwords/354984si.ngl")) for w in words: even, odd = w[::2], w[1::2] if even in words and odd in words: count+=1 print count This script will a) be interpreted by Python; b) read the 4.1 MB, 354,983 word Moby dictionary file; c) strip the lines; d) place the lines into a set, and; e) and find all the combinations where the evens and the odds of a given word are also words. This executes in about 0.73 seconds on a MacBook Pro. I tried to rewrite the same program in Objective-C. I am a beginner at this language, so go easy please, but please do point out the errors. #import NSString *sliceString(NSString *inString, NSUInteger start, NSUInteger stop, NSUInteger step){ NSUInteger strLength = [inString length]; if(stop > strLength) { stop = strLength; } if(start > strLength) { start = strLength; } NSUInteger capacity = (stop-start)/step; NSMutableString *rtr=[NSMutableString stringWithCapacity:capacity]; for(NSUInteger i=start; i The Objective-C version produces the same result, (13,341 words), but takes almost 3 seconds to do it. I must be doing something atrociously wrong for a compiled language to be more than 3X slower than a scripted language, but I'll be darned if I can see why. The basic algorithm is the same: read the lines, strip them, and put them in a set. My guess of what is slow is the processing of the NSString elements, but I do not know an alternative. Edit I edited the Python to be this: #!/usr/bin/env python import codecs count=0 words = set(line.strip() for line in codecs.open("/Users/andrew/Downloads/Moby/mwords/354984si.ngl", encoding='utf-8')) for w in words: if w[::2] in words and w[1::2] in words: count+=1 print count For the utf-8 to be on the same plane as the utf-8 NSString. This slowed the Python down to 1.9 secs. I also switch the slice test to short-circuit type as suggested for both the Python and obj-c version. Now they are close to the same speed. I also tried using C arrays rather than NSStrings, and this was much faster, but not as easy. You also loose utf-8 support doing that. Python is really cool... Edit 2 I found a bottleneck that sped things up considerably. Instead of using the [rtr appendFormat:@"%c",[inString characterAtIndex:i]]; method to append a character to the return string, I used this: for(NSUInteger i=start; i Now I can finally claim that the Objective-C version is faster than the Python version -- but not by much.
