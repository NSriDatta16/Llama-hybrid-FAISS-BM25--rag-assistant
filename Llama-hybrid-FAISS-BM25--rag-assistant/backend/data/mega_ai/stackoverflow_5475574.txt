[site]: stackoverflow
[post_id]: 5475574
[parent_id]: 5472905
[tags]: 
It looks like your window's Canvas contains a number of ContentControls. One of these is of interest and contains a grid which in turn contains firstly an instance of your MoveLine class, and secondly a ContentPresenter containing a Rectangle. So your visual tree looks roughly like this: Window1 Canvas ... ContentControl Grid MoveLine ContentPresenter Rectangle (mRect) You're trying to handle an event in MoveLine and modify the ContentPresenter's Rectangle, mRect. You can refer to mRect only in the context of Window1. The problem is that as far as WPF is concerned the MoveLine class could appear anywhere, and so naturally it has no idea what mRect might mean to any particular MoveLine instance. As it happens we know that mRect is the child Rectangle of a sibling ContentPresenter which shares a parent with an instance of MoveLine. If you're absolutely sure that MoveLine will only ever be used here, you could use System.Windows.Media.VisualTreeHelper's GetParent(), GetChildrenCount() and GetChild() methods. You need to go "up" one level from MoveLine, across one, and then down one. You could also go up one level and then search for descendants with the name "mName". See How can I find WPF controls by name or type? . This isn't a very sane approach though. I'd be more tempted to put the handling code onto the canvas, or at least into its ContentControls, since they're the ones being affected. I would add a RoutedEvent called, say, ThumbMoved, to MoveLine. RoutedEvents can "bubble up" to be handled by ancestral controls. You can then add a handler for this event to the ContentControl containing your Rectangle, and it can then use mName to adjust the rectangle. See How to: Create a Custom Routed Event and How to: Handle a Routed Event . Very roughly: class MoveLine : Thumb { public static readonly RoutedEvent ThumbMovedEvent = EventManager.RegisterRoutedEvent("ThumbMoved", RoutingStrategy.Bubble, typeof(DragDeltaRoutedEventHandler), typeof(MoveLine)); public event DragDeltaRoutedEventHandler ThumbMoved { add { AddHandler(ThumbMovedEvent, value); } remove { RemoveHandler(ThumbMovedEvent, value); } } void RaiseThumbMoved(DragDeltaEventArgs e) { DragDeltaRoutedEventArgs newEventArgs = new DragDeltaRoutedEventArgs(ThumbMovedEvent, e); RaiseEvent(newEventArgs); } private void MoveThumb_DragDelta(object sender, DragDeltaEventArgs e) { RaiseThumbMoved(e); ... } (Where DragDeltaRoutedEventArgs is a class derived from RoutedEventArgs which provides the same deltas as DragDeltaEventArgs.) And then in your window's XAML: ... ... And code behind: namespace DiagramDesigner { public partial class Window1 : Window { private void MoveLine_ThumbMoved(object sender, DragDeltaRoutedEventArgs e) { mRect.Foo = "Bar"; // mRect is recognised by Window1. } ...
