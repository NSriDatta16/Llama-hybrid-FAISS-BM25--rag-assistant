[site]: stackoverflow
[post_id]: 5568182
[parent_id]: 5567900
[tags]: 
If you want to keep the Bind operation used in let! generic, then there is no way to say that F# should use different implementation when translating do! (the overloads will necessarily have to overlap). In general, if you want to get different behavior for let! and for do! then it suggests that your computation expression is probably incorrectly defined. The concept is quite flexible and it can be used for more things than just for declaring monads, but you may be stretching it too far. If you can write more information about what you want to achieve, that would be useful. Anyway, here are some possible workarounds... You can add some additional wrapping and write something like do! wrap . type Wrapped = W of 'T type WrappedDo = WD of 'T type FooBuilder() = member b.Bind (x:Wrapped , f:'T->'U):'U = failwith "let!" member b.Bind (x:WrappedDo , f:unit->'U):'U = failwith "do!" member b.Return (x:'T):Wrapped = failwith "return" let wrap (W a) = WD a let bar arg = W arg let foo = FooBuilder() // Thanks to the added `wrap` call, this will use the second overload foo { do! wrap Another alternative would be to use dynamic type tests. This is a bit inefficient (and a bit inelegant), but it may do the trick, depending on your scenario: member b.Bind (x:Wrapped , f:'T->'U):'U = if typeof = typeof then failwith "do!" else failwith "let!" However, this would still use the do! overload when you write let! () = bar .
