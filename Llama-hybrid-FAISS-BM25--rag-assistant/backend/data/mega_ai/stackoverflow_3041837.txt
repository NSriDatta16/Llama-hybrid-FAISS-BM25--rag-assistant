[site]: stackoverflow
[post_id]: 3041837
[parent_id]: 
[tags]: 
NSThread vs. NSOperationQueue vs. ??? on the iPhone

Currently I'm using NSThread to cache images in another thread. [NSThread detachNewThreadSelector:@selector(cacheImage:) toTarget:self withObject:image]; Alternately: [self performSelectorInBackground:@selector(cacheImage:) withObject:image]; Alternately, I can use an NSOperationQueue NSInvocationOperation *invOperation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(cacheImage:) object:image]; NSOperationQueue *opQueue = [[NSOperationQueue alloc] init]; [opQueue addOperation:invOperation]; Is there any reason to switch away from NSThread ? GCD is a 4th option when it's released for the iPhone, but unless there's a significant performance gain, I'd rather stick with methods that work in most platforms. Based on @Jon-Eric's advice, I went with an NSOperationQueue / NSOperation subclass solution. It works very well. The NSOperation class is flexible enough that you can use it with invocations, blocks or custom subclasses, depending on your needs. No matter how you create your NSOperation you can just throw it into an operation queue when you are ready to run it. The operations are designed to work as either objects you put into a queue or you can run them as standalone asynchronous methods, if you want. Since you can easily run your custom operation methods synchronously, testing is trivially easy. I've used this same technique in a handful of projects since I asked this question and I couldn't be happier with the way it keeps my code and my tests clean, organized and happily asynchronous. A++++++++++ Would subclass again
