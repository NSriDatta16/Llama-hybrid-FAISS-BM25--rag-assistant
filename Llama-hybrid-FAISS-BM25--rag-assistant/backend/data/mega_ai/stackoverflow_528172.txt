[site]: stackoverflow
[post_id]: 528172
[parent_id]: 528122
[tags]: 
I suspect there are some practical reasons, and some theoretical reasons: Should the constness apply to the object or the reference ? If it's in the reference, should this be compile-time only, or as a bit within the reference itself? Can something else which has a non-const reference to the same object fiddle with it under the hood? Would you want to be able to cast it away as you can in C++? That doesn't sound very much like something you'd want on a managed platform... but what about all those times where it makes sense in C++? Syntax gets tricky (IMO) when you have more than one type involved in a declaration - think arrays, generics etc. It can become hard to work out exactly which bit is const. If you can't cast it away, everyone has to get it right . In other words, both the .NET framework types and any other 3rd party libraries you use all have to do the right thing, or you're left with nasty situations where your code can't do the right thing because of a subtle problem with constness. There's a big one in terms of why it can't be supported now though: Backwards compatibility: there's no way all libraries would be correctly migrated to it, making it pretty much useless :( I agree it would be useful to have some sort of constness indicator, but I can't see it happening, I'm afraid. EDIT: There's been an argument about this raging in the Java community for ages. There's rather a lot of commentary on the relevant bug which you may find interesting.
