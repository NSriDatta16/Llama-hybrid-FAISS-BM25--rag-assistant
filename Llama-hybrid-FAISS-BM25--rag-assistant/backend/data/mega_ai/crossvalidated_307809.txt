[site]: crossvalidated
[post_id]: 307809
[parent_id]: 307785
[tags]: 
Since you work with time series, you could use the cross-correlation function between the two series. In this accouts for shifted sequences, i.e. a time lag as well. You could normalize them with the product of standard deviations of each signal and arrive at a lag-dependent pearson coefficient. The approach is wide-spread in digital signal processing and is also used on binary sequences. Edit to clarify: If both sequences have the same length N, you can represent them as vectors with the same dimensionality N. then you can calculate the scalar product between them, normalize them with their euclidic length and have a pearson correlation coefficient. Since they are binary, the length is just the square root of the number of ones in each vector. You can now introduce a time lag between the two sequences, when zero padding to both vectors is allowed. The result is the cross correlation function ( numpy example ). The zero padding has an effect to the similarity measure, but you should still be able to see a possible similarity spike if the lag variable is small enough. If you assume some periodicity, it might even make sense to use a circular correlation which can be implemented with a cyclic convolution scipy.ndimage.filters.convolve1d (See https://stackoverflow.com/questions/37150672/circular-convolution-in-python for source) by flipping one of the vectors first. The result does not have the problem from zero padding, but is not justified very well if there is no periodicity. By the way, what result do you expect when only one of both users is active? My naive idea of directly using bit vectors for the correlation would lead to a 'similarity' of 0 here. Therefore it might be wise to apply a mapping of 0 -> -1 first to get a negative result in this case. Furthermore, the normalization factor becomes just 1/N.
