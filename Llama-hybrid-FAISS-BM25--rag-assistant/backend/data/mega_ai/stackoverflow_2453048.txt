[site]: stackoverflow
[post_id]: 2453048
[parent_id]: 
[tags]: 
How can i hold reference in boost::shared_ptr using boost::bind without definition of explicit function?

I want to hold reference to object so it doesn't get deleted in bind function, but without using helper function. struct Int { int *_int; ~Int(){ delete _int; } }; void holdReference(boost::shared_ptr , int*) {} // helper boost::shared_ptr fun() { boost::shared_ptr a ( new Int ); // I get 'a' from some please else, and want to convert it a->_int = new int; return boost::shared ( a->_int, boost::bind(&holdReference, a, _1) ); } Is there a way to declare holdReference function in place? Like with lambda expressions or sth? (without using this nasty holdReference function, that have to be declared outside the scope of fun function) I had few tries but non of them compiled :) Ok, here is more detailed example: #include #include // the case looks more or less like this // this class is in some dll an I don't want to use this class all over my project // and also avoid coppying the buffer class String_that_I_dont_have { char * _data; // this is initialized in 3rd party, and released by their shared pointer public: char * data() { return _data; } }; // this function I created just to hold reference to String_that_I_dont_have class // so it doesn't get deleted, I want to get rid of this void holdReferenceTo3rdPartyStringSharedPtr( boost::shared_ptr , char *) {} // so I want to use shared pointer to char which I use quite often boost::shared_ptr convert_function( boost::shared_ptr other) // 3rd party is using their own shared pointers, // not the boost's ones, but for the sake of the example ... { return boost::shared_ptr ( other->data(), boost::bind( /* some in place here instead of holdReference... */ &holdReferenceTo3rdPartyStringSharedPtr , other, _1 ) ); } int main(int, char*[]) { /* it compiles now */ } // I'm just looking for more elegant solution, for declaring the function in place
