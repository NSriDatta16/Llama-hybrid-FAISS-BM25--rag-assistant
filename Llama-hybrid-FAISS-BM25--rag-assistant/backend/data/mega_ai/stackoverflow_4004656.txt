[site]: stackoverflow
[post_id]: 4004656
[parent_id]: 4004557
[tags]: 
r isn't used at all It's used in the 'two argument' reverse method. 10*r+n%10 That's a pretty tricky thing, actually, and pretty cool. This is a great example of how poorly named variables make it difficult to understand the code. We have 3 lines of code that actually do something, and it's not real obvious how it works. Here's the same code (with the exception of a constant) with different variable names: private static int NOTHING_REVERSED_SO_FAR = 0; private static int reverse(int numberToBeReversed, int reversalSoFar) { if (numberToBeReversed == 0) return reversalSoFar; return reverse(numberToBeReversed/10, 10*reversalSoFar + numberToBeReversed%10); } public static int reverse(int numberToBeReversed) { return reverse(numberToBeReversed, NOTHING_REVERSED_SO_FAR); } So we invoke the public method initially. Say we pass 123 as the numberToBeReversed. This invokes the private version passing the 123 unchanged and initializing the reversalSoFar to 0. So straight away, you see if numberToBeReversed is 0, we return whatever it is we've calculated so far. I recommend you write a junit test that challenges his assertion. So when we recurse, what are we actually doing? First, not that we are not really dividing numberToBeReversed by 10. We're doing the division, and passing the result recursively. numberToBeReversed is not being changed. The result of the division is 123 -> 123/10 -> 12. (Being an int data type, the fraction is lost.) ok, so we're passing a 12 as the first argument. Now what of the 2nd argument. We know we passed reversalSoFar a 0. So we have 10*(0)+(123)%10. 123 is correct here since we didn't change numberToBeReversed. The result is 3. So we're going to recurse again, passing a 12 and a 3. Now, you do the next iteration. 0. 123 0 1. 12 3 2. ?? ?
