[site]: stackoverflow
[post_id]: 4316675
[parent_id]: 4306419
[tags]: 
I felt this was different enough from my previous answer, so here's a new one. Another approach is to leverage the concept of Inversion of Control (IoC). Build an Interface that your Data Access layer implements. Each of the DAL methods should take a list of parameters and return a Data Table. The service layer would instantiate the DAL through the interface and pass that reference to your Domain Model. The domain model would then make it's own calls into the DAL, using the interface methods, and decide when it needs to load child objects or whatever. Something like: interface IDBModel { DataTable LoadUser(Int32 userId); } class MyDbModel : IDBModel { DataTable LoadUser(Int32 userId) { // make the appropriate DB calls here, return a data table } } class User { public User(IDBModel dbModel, Int32 userId) { DataTable data = dbModel.LoadUser(userId); // assign properties.. load any additional data as necessary } // You can do cool things like call User.Save() // and have the object validate and save itself to the passed in // datamodel. Makes for simpler coding. } class MyServiceLayer { public User GetUser(Int32 userId) { IDBModel model = new MyDbModel(); return new User(model, userId); } } With this mechanism, you can actually swap out your db models on demand. For example, if you decide to support multiple databases then you can have code that is specific to a particular database vendors way of doing things and just have the service layer pick which one to use. The domain objects themselves are responsible for loading their own data and you can keep any necessary business logic within the domain model. Another point is that the Domain Model doesn't have a direct dependency on the data layer, which preserves your mocking ability for independent testing of business logic. Further, the DAL has no knowledge of the domain objects, so you can swap those out as necessary or even just test the DAL independently.
