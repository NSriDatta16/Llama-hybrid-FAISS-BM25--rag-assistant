[site]: stackoverflow
[post_id]: 2842063
[parent_id]: 2841932
[tags]: 
Even once the atom is set to true , your version can't stop running until the inner doseq finishes (until y > x). It will terminate the outer loop once the inner loop finishes though. It does terminate eventually when I run it. Not sure what you're seeing. You don't need two doseq s to do this. One doseq can handle two seqs at once. user> (doseq [x (range 0 2) y (range 3 6)] (prn [x y])) [0 3] [0 4] [0 5] [1 3] [1 4] [1 5] (The same is true of for .) There is no mechanism for "breaking out" of nested doseqs that I know of, except throw / catch , but that's rather un-idiomatic. You don't need atoms or doseq for this at all though. (def answers (filter (fn [[x y]] (both-pent? x y)) (for [x pentagonal-list y pentagonal-list :while ( Your code is very imperative in style. "Loop over these lists, then test the values, then print something, then stop looping." Using atoms for control like this is not very idiomatic in Clojure. A more functional way is to take a seq (pentagonal-list) and wrap it in functions that turn it into other seqs until you get a seq that gives you what you want. First I use for to turn two copies of this seqs into one seq of pairs where y filter to turn that seq into one that filters out the values we don't care about. filter and for are lazy, so this will stop running once it finds the first valid value, if one is all you want. This returns the two numbers you want, and then you can subtract them. (apply - (first answers)) Or you can further wrap the function in another map to calculate the differences for you. (def answers2 (map #(apply - %) answers)) (first answers2) There are some advantages to programming functionally in this way. The seq is cached (if you hold onto the head like I do here), so once a value is calculated, it remembers it and you can access it instantly from then on. Your version can't be run again without resetting the atom, and then would have to re-calculate everything. With my version you can (take 5 answers) to get the first 5 results, or map over the result to do other things if you want. You can doseq over it and print the values. Etc. etc. I'm sure there are other (maybe better) ways to do this still without using an atom. You should usually avoid mutating references unless it's 100% necessary in Clojure. The function names for altering atoms/agents/refs are different probably because the mechanics are not the same. Refs are synchronous and coordinated via transactions. Agents are asynchronous. Atoms are synchronous and uncoordinated. They all kind of "change a reference", and probably some kind of super-function or macro could wrap them all in one name, but that would obscure the fact that they're doing drastically different things under the hood. Explaining the differences fully is probably beyond the scope of an SO post to explain, but http://clojure.org fully explains all of the nuances of the differences.
