[site]: stackoverflow
[post_id]: 5642907
[parent_id]: 5642580
[tags]: 
This is just constraint solving. If you have a sudoku board, then, for each cell (i, j) you have these constraints: board[i, j] in [1, 2, 3, 4, 5, 6, 7, 8, 9] for each cell (a, j) where i != a: board[a, j] != board[i, j] for each cell (i, b) where j != b: board[i, b] != board[i, j] For particular cells, you already know what their value is. That's really just a different constraint: board[c1, c2] == 7 And that's it. A brute-force checker can simply run through every possible way to fill in board cells (esp. paying attention to the first constraint), and check whether these constraints hold. If they all hold for that filling-in, then it can output the board. Otherwise, it keeps going. If you now allow inequalities for specific positions, you can use that exact same brute-force algorithm. It's just a new check it has to do before saying the board is filled in correctly: 2 It's easy with brute-force, but it's also pretty easy with a logic programming language like Prolog, or a constraint programming library like Numberjack Here are the Numberjack versions of all the constraints above (in order of appearance): board[i, j] = Variable(1, 9) # ... need to define all the board before you execute the following: for a in xrange(1, 10): model.add(board[a, j] != board[i, j]) model.add(board[i, a] != board[i, j]) model.add(board[c1, c2] == 7) model.add(board[c3, c4] = 2) This is not idiomatic for real use of a constraint solver. In real life, instead of specifying the !=s individually, you'd use an "All of these are different" constraint, AllDiff, and so on. But you get the idea.
