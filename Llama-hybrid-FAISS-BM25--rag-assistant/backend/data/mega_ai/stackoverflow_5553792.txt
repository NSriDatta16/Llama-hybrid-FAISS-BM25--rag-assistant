[site]: stackoverflow
[post_id]: 5553792
[parent_id]: 5552832
[tags]: 
If you want maximum generality, you can memoize a memoizing function. memo :: (Num a, Enum a) => (a -> b) -> [b] memo f = map f (enumFrom 0) gwvals = fmap memo (memo gw) fastgw :: Int -> Int -> Int fastgw x y = gwvals !! x !! y This technique will work with functions that have any number of arguments. Edit: thanks to Philip K. for pointing out a bug in the original code. Originally memo had a "Bounded" constraint instead of "Num" and began the enumeration at minBound , which would only be valid for natural numbers. Lists aren't a good data structure for memoizing, though, because they have linear lookup complexity. You might be better off with a Map or IntMap. Or look on Hackage . Note that this particular code does rely on laziness, so if you wanted to switch to using a Map you would need to take a bounded amount of elements from the list, as in: gwByMap :: Int -> Int -> Int -> Int -> Int gwByMap maxX maxY x y = fromMaybe (gw x y) $ M.lookup (x,y) memomap where memomap = M.fromList $ concat [[((x',y'),z) | (y',z) Int -> Int fastgw2 = gwByMap 20 20 I think ghc may be stupid about sharing in this case, you may need to lift out the x and y parameters, like this: gwByMap maxX maxY = \x y -> fromMaybe (gw x y) $ M.lookup (x,y) memomap
