[site]: stackoverflow
[post_id]: 668917
[parent_id]: 668907
[tags]: 
For very large files I'd do something like this string tempFile = Path.GetTempFileName(); using(var sr = new StreamReader("file.txt")) using(var sw = new StreamWriter(tempFile)) { string line; while((line = sr.ReadLine()) != null) { if(line != "removeme") sw.WriteLine(line); } } File.Delete("file.txt"); File.Move(tempFile, "file.txt"); Update I originally wrote this back in 2009 and I thought it might be interesting with an update. Today you could accomplish the above using LINQ and deferred execution var tempFile = Path.GetTempFileName(); var linesToKeep = File.ReadLines(fileName).Where(l => l != "removeme"); File.WriteAllLines(tempFile, linesToKeep); File.Delete(fileName); File.Move(tempFile, fileName); The code above is almost exactly the same as the first example, reading line by line and while keeping a minimal amount of data in memory. A disclaimer might be in order though. Since we're talking about text files here you'd very rarely have to use the disk as an intermediate storage medium. If you're not dealing with very large log files there should be no problem reading the contents into memory instead and avoid having to deal with the temporary file. File.WriteAllLines(fileName, File.ReadLines(fileName).Where(l => l != "removeme").ToList()); Note that The .ToList is crucial here to force immediate execution. Also note that all the examples assume the text files are UTF-8 encoded.
