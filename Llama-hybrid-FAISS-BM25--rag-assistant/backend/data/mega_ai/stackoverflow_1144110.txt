[site]: stackoverflow
[post_id]: 1144110
[parent_id]: 1143936
[tags]: 
Until the day #pragma once becomes standard (that's not currently a priority for the future standards), I suggest you use it AND use guards, this way: #ifndef BLAH_H #define BLAH_H #pragma once // ... #endif The reasons are : #pragma once is not standard, so it is possible that some compiler don't provide the functionality. That said, all major compiler supports it. If a compiler don't know it, at least it will be ignored. As there is no standard behavior for #pragma once , you shouldn't assume that the behavior will be the same on all compiler. The guards will ensure at least that the basic assumption is the same for all compilers that at least implement the needed preprocessor instructions for guards. On most compilers, #pragma once will speed up compilation (of one cpp) because the compiler will not reopen the file containing this instruction. So having it in a file might help, or not, depending on the compiler. I heard g++ can do the same optimization when guards are detected but it have to be confirmed. Using the two together you get the best of each compiler for this. Now, if you don't have some automatic script to generate the guards, it might be more convenient to just use #pragma once . Just know what that means for portable code. (I'm using VAssistX to generate the guards and pragma once quickly) You should almost always think your code in a portable way (because you don't know what the future is made of) but if you really think that it's not meant to be compiled with another compiler (code for very specific embedded hardware for example) then you should just check your compiler documentation about #pragma once to know what you're really doing.
