[site]: stackoverflow
[post_id]: 682521
[parent_id]: 682434
[tags]: 
In terms of memory management, these two classes are virtually identical. Several other responders have suggested that there is a difference between the two in that one is allocating storage on the stack and other on the heap, but that's not necessarily true, and even in the cases where it is true, it's terribly misleading. In reality, all that's different is where the metadata for the vector is allocated; the actual underlying storage in the vector is allocated from the heap regardless. It's a little bit tricky to see this because you're using std::vector , so the specific implementation details are hidden. But basically, std::vector is implemented like this: template class vector { public: vector() : mCapacity(0), mSize(0), mData(0) { } ~vector() { if (mData) delete[] mData; } ... protected: int mCapacity; int mSize; T *mData; }; As you can see, the vector class itself only has a few members -- capacity, size and a pointer to a dynamically allocated block of memory that will store the actual contents of the vector. In your example, the only difference is where the storage for those few fields comes from. In the first example, the storage is allocated from whatever storage you use for your containing class -- if it is heap allocated, so too will be those few bits of the vector . If your container is stack allocated, so too will be those few bits of the vector . In the second example, those bits of the vector are always heap allocated. In both examples, the actual meat of the vector -- the contents of it -- are allocated from the heap, and you cannot change that. Everybody else has pointed out already that you have a memory leak in your second example, and that is also true. Make sure to delete the vector in the destructor of your container class.
