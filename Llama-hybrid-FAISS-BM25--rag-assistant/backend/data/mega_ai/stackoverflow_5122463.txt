[site]: stackoverflow
[post_id]: 5122463
[parent_id]: 
[tags]: 
Not seeing my DLL function in test application

I'm testing a simple DLL, I wrote using C++/CLI, in a CLR console application. The DLL has only one function I'm trying to use. I'm referencing the DLL and set the Resolve #using Reference in the project property page, but I cannot see the function I wrote. I'm guessing I may have missed an access modifier somewhere, but I'm not sure. Here is a breakdown of my code: DLL Code Header: // LogDLL.h #pragma once #using using namespace System; namespace LogDLL { public ref class LogFuncs { // TODO: Add your methods for this class here. LogFuncs(){;}; ~LogFuncs(){;}; void log_to_file ( System::String ^file, bool overwrite, System::String ^text ); }; } DLL Code Source: #include "stdafx.h" #include "LogDLL.h" using namespace System::Globalization; void LogDLL::LogFuncs::log_to_file ( System::String ^file, bool overwrite, System::String ^text ) { //Do Stuff } And the test code I'm using: #include "stdafx.h" #using using namespace System; int main(array ^args) { Console::WriteLine(L"Hello World"); LogDLL::LogFuncs^ a; a::LogDLL::LogFuncs:: // Again, I'm not sure what I'm missing. It's been awhile since I've worked with C++/CLI so I'm pretty rusty. UPDATE: I went ahead and changed the class to a struct per Peter's advice. Modified DLL Header Code: // LogDLL.h #pragma once #using using namespace System; namespace LogDLL { public ref struct LogFuncs { // TODO: Add your methods for this class here. LogFuncs(){;}; ~LogFuncs(){;}; void log_to_file ( System::String ^file, bool overwrite, System::String ^text ); }; } What I still don't understand is why the class would still default to private even though I specify it as public. Is there some fundamental reason why this is the case? Would it be any different if I was using unmanaged C++??
