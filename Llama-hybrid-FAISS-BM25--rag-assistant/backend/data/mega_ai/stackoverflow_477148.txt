[site]: stackoverflow
[post_id]: 477148
[parent_id]: 477012
[tags]: 
I think the key issue is designing/coding for flexibility. If you have a single use case (e.g. selecting the members of a collection that satisfy some specific condition), then coding a relatively simple loop by hand works. On the other hand... Suppose that the set of possible conditions grew large, or could even be composed on-the-fly at run-time (even dynamically, based on user input/interaction). Or suppose that there were a few very complex conditions which could be composed with operators (e.g. A and B, C and not D, etc.) into even more cases. Suppose that, having made the selection, there was some other processing that was to be done on the resulting collection. Now consider the structure of the code that might result from a brute-force, in-line approach to writing the above: an outer loop containing a complex decision process to determine which test(s) to perform, mixed together with code that does one or more things with the "surviving" members of the collection. Such code tends to be (and especially to become over time with maintenance) difficult to understand and difficult to modify without the risk of introducing defects. So the point is to pursue a strategy in which each aspect: basic "select something" process, predicates that express elementary criteria, combining operators that compose predicates, and transformers that operate on values, can be coded and tested independently, then snapped together as needed.
