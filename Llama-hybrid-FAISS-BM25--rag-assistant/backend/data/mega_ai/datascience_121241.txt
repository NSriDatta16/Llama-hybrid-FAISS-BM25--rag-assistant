[site]: datascience
[post_id]: 121241
[parent_id]: 
[tags]: 
How to make dynamic regression model

I have 2 datasets, namely is FPDataset and SIDataset. then FPDatset and SIDataset then each dataset will be divided into two groups. FPDataset : FPWalking and FPStanding SIDataset: SIWalking and SIStanding ilustration of my dataset is like below: FPWalking = np.array([ [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [5.29, -1.22, 8.282, 8.22], [-1.92, 9.781, 3.28, 1.93], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.27, 6.12, 8.12, 2.34], [6.93, 2.83, 0.72, 7.22] ]) FPStanding = np.array([ [6.93, 2.83, 0.72, 7.22], [0.27, 6.12, 8.12, 2.34], [5.29, -1.22, 8.282, 8.22], [-1.92, 9.781, 3.28, 1.93], ]) SIWalking = np.array([ [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [9.0, 92.0, 0.0, 0.0, 0.0, 1.0, 21.0, 71.0, 0.0, 12.0, 65.0, 45.0], [9.0, 92.0, 0.0, 0.0, 0.0, 1.0, 21.0, 71.0, 0.0, 12.0, 65.0, 45.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 45.0, 0.0, 0.0, 22.0, 45.0, 23.0, 0.0, 77.0, 89.0, 0.0], [0.0, 0.0, 45.0, 0.0, 0.0, 22.0, 45.0, 23.0, 0.0, 77.0, 89.0, 0.0], ]) SIStanding= np.array([ [0.0, 0.0, 0.0, 0.0, 73.0, 12.0, 66.0, 78.0, 0.0, 12.0, 87.0, 0.0], [0.0, 0.0, 0.0, 0.0, 73.0, 12.0, 66.0, 78.0, 0.0, 12.0, 87.0, 0.0], [0.0, 0.0, 0.0, 0.0, 73.0, 12.0, 66.0, 78.0, 0.0, 12.0, 87.0, 0.0], [0.0, 0.0, 0.0, 0.0, 73.0, 12.0, 66.0, 78.0, 0.0, 12.0, 87.0, 0.0], I want to predict FPDataset (FPWalking and FPStanding) using SIDataset(SIWalking and SIStanding). now I alredy make a model then just concat the dataset set as below: SIDataset = np.concatenate((SIDatasetWalking,SIDatasetStanding), axis=0) FPDataset = np.concatenate((FPDatasetWalking,FPDatasetStanding), axis=0) after I concat the datset then I train a model, using resnet for solve my case. but my model only work well at walking data. my architecture code: def identity_block(input_tensor, filters): x = layers.Conv1D(filters, kernel_size=5, padding='same')(input_tensor) x = layers.Activation('relu')(x) x = layers.Conv1D(filters, kernel_size=5, padding='same')(x) x = layers.Activation('relu')(x) x = layers.Conv1D(filters, kernel_size=5, padding='same')(x) x = layers.add([x, input_tensor]) x = layers.Activation('relu')(x) return x def dens_block(input_tensor, filters): x = layers.Conv1D(filters, kernel_size=5, padding='same')(input_tensor) x = layers.Activation('relu')(x) x = layers.Conv1D(filters, kernel_size=5, padding='same')(x) x = layers.Activation('relu')(x) x = layers.Conv1D(filters, kernel_size=5, padding='same')(x) shortcut = layers.Conv1D(filters, kernel_size=5, padding='same')(input_tensor) x = layers.add([x, shortcut]) x = layers.Activation('relu')(x) return x def ResNet50Regression(): input_shape = (89, 1) # Change the number of input features (channels) accordingly width = 32 Res_input = layers.Input(shape=input_shape) x = dens_block(Res_input, width) x = identity_block(x, width) x = identity_block(x, width) x = dens_block(x, width*2) x = identity_block(x, width*2) x = identity_block(x, width*2) x = dens_block(x, width*4) x = identity_block(x, width*4) x = identity_block(x, width*4) x = layers.GlobalAveragePooling1D()(x) x = layers.Dense(6, activation='linear')(x) model = models.Model(inputs=Res_input, outputs=x) return model the Training results prediction: below is walking prediction results below is standing predictions results how to make my model can predict on standing and walking data? becasue now the model only will work well for walking data Myfullcode is here : https://colab.research.google.com/drive/1ajARJWJrYY3Qa7XKldJirX6QHutQzkzc?usp=sharing
