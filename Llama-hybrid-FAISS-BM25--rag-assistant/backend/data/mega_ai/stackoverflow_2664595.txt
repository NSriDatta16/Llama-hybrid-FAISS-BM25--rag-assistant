[site]: stackoverflow
[post_id]: 2664595
[parent_id]: 1448849
[tags]: 
Passing a pointer as an argument to a function lets that function change the contents of the variable pointed to, which can be useful for returning information by means other than the function return value. For example, the return value might already be used to indicate error/success, or you might want to return multiple values. The syntax for this in the calling code is foo(&var), which takes the address of var, i.e., a pointer to var. So as such, if the variable whose contents you want the function to change is itself a pointer (e.g., a string), the parameter would be declared as a pointer to a pointer . #include char *some_defined_string = "Hello, " ; char *alloc_string() { return "World" ; } //pretend that it's dynamically allocated int point_me_to_the_strings(char **str1, char **str2, char **str3) { *str1 = some_defined_string ; *str2 = alloc_string() ; *str3 = "!!" ; if (str2 != 0) { return 0 ; //successful } else { return -1 ; //error } } main() { char *s1 ; //uninitialized char *s2 ; char *s3 ; int success = point_me_to_the_strings(&s1, &s2, &s3) ; printf("%s%s%s", s1, s2, s3) ; } Note that main() does not allocate any storage for the strings, so point_me_to_the_strings() does not write to str1, str2, and str3 as it would if they were passed as pointers to chars. Rather, point_me_to_the_strings() changes the pointers themselves, making them point to different places, and it can do this because it has pointers to them.
