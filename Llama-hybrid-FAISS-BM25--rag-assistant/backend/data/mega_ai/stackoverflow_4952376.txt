[site]: stackoverflow
[post_id]: 4952376
[parent_id]: 4952160
[tags]: 
Let me start of by saying that there is nothing special about a salt from the standpoint of generation. It's just another random string. It's special in how it's used, but not generated. Your specific questions Why does he replace + with . ? I have no idea. Perhaps it's because the + character may be confused with a space in urls. But a salt should never be in a url, so that's likely not it. What does base64/hexdec do: Base64 converts a raw byte stream (each byte having values from 0 to 255) into a base 64 representation. There are plenty of resources on it, so it's not worth going deep into. Read the wikipedia article for more information. hexdec converts a hex number (a-f0-9) into a decimal one. It converts from base 16 to base 10 (just another way of representing numbers). What is a bit and byte: A bit is a single unit of information. It has 2 states, 0 or 1. A Byte is a series of 8 bits. So a byte can have 256 unique combinations. Read Wikipedia ... What is ascii It's a character set. It represents a single printable character in a single 8-bit byte. Again, I'd suggest reading Wikipedia . Salts in General The goal of a good salt generation function is large entropy. That means that the number of possible outputs is as large as possible. So any method should produce a large set of results. Now, you need to define what are acceptable characters for the salt (since you'll need to store the salt to verify the hash). The best possible salts are full-byte numbers and not just displayable characters. Now, you won't be able to display this in a meaningful manor, but you don't need to display it. Plus, for storage, you could always use base64_encode it. Next, you need to choose how big you want the salt to be. The bigger the salt is, the better. A 32 character salt is acceptable, but a 128 character salt is better. The size of the salt, and the number of options per character will dictate the number of possibilities there are. Some common combinations: Hex, 32 characters: 2e38 possibilities Hex, 128 characters: 1e154 possibilities Full Byte, 32 characters: 1e77 possibilities Full Byte, 128 characters: 1e308 possibilities Now, you need to generate the salt. The key is to do as many random calls as necessary to fill out the entropy. You can do this a few ways: System Dependent (only works on *nix but best entropy): $f = fopen('/dev/urandom', 'r'); $seed = fgets($f, $characters); // note that this will always return full bytes fclose($f); Library dependent (good, but requires OpenSSL to be installed) $seed = openssl_random_pseudo_bytes($characters); fallback $seed = ''; for ($i = 0; $i Now, you need to convert it into the desired output format. Hex (a-f0-9): $out = ''; for ($i = 0, $len = strlen($seed); $i Base36 (a-z0-9): $out = ''; for ($i = 0, $len = strlen($seed); $i Base64 (a-zA-Z0-9+=): $out = base64_encode($seed); Full Byte: Nothing is necessary since it's already in this format.
