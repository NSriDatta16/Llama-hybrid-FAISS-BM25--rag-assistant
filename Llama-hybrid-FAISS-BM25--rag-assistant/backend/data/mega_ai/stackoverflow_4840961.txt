[site]: stackoverflow
[post_id]: 4840961
[parent_id]: 4840819
[tags]: 
I think this might work: #include template class Example { public: Example() { Construct (identity ()); } A foo() { return foo (identity ()); } private: template struct identity {}; template void Construct(identity id) { for (size_t i = 0; i void Construct(identity id) { value[0] = 0; value[1] = 0; std::cout A foo(identity id) { A r = 0; for (size_t i = 0; i A foo(identity id) { std::cout example; // change the 2 to see the difference int n = example.foo(); std::cin.get(); return 0; } Sorry, I just copy and pasted it from my test project. It's not really "specialization" in a way, it just calls overloads to specialized functions. I'm not sure if this is what you want and imo this isn't very elegant.
