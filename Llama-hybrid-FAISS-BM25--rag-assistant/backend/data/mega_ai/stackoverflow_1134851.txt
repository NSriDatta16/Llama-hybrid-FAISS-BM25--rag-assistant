[site]: stackoverflow
[post_id]: 1134851
[parent_id]: 1024640
[tags]: 
This can be done with Memory complexity O(Sqrt(N)) and CPU complexity O(N * Log(Log(N))) with an optimized windowed Sieve of Eratosthenes, as implemented in the code example below. As no language was specified and as I do not know Python, I have implemented it in VB.net, however I can convert it to C# if you need that. Imports System.Math Public Class TotientSerialCalculator 'Implements an extremely efficient Serial Totient(phi) calculator ' ' This implements an optimized windowed Sieve of Eratosthenes. The' ' window size is set at Sqrt(N) both to optimize collecting and ' ' applying all of the Primes below Sqrt(N), and to minimize ' ' window-turning overhead. ' ' ' ' CPU complexity is O( N * Log(Log(N)) ), which is virtually linear.' ' ' ' MEM Complexity is O( Sqrt(N) ). ' ' ' ' This is probalby the ideal combination, as any attempt to further ' 'reduce memory will almost certainly result in disproportionate increases' 'in CPU complexity, and vice-versa. ' Structure NumberFactors Dim UnFactored As Long 'the part of the number that still needs to be factored' Dim Phi As Long 'the totient value progressively calculated' ' (equals total numbers less than N that are CoPrime to N)' 'MEM = 8 bytes each' End Structure Private ReportInterval As Long Private PrevLast As Long 'the last value in the previous window' Private FirstValue As Long 'the first value in this windows range' Private WindowSize As Long Private LastValue As Long 'the last value in this windows range' Private NextFirst As Long 'the first value in the next window' 'Array that stores all of the NumberFactors in the current window.' ' this is the primary memory consumption for the class and it' ' is 16 * Sqrt(N) Bytes, which is O(Sqrt(N)).' Public Numbers() As NumberFactors ' For N=10^12 (1 trilion), this will be 16MB, which should be bearable anywhere.' '(note that the Primes() array is a secondary memory consumer' ' at O(pi(Sqrt(N)), which will be within 10x of O(Sqrt(N)))' Public Event EmitTotientPair(ByVal k As Long, ByVal Phi As Long) '===== The Routine To Call: ========================' Public Sub EmitTotientPairsToN(ByVal N As Long) 'Routine to Emit Totient pairs {k, Phi(k)} for k = 1 to N' ' 2009-07-14, RBarryYoung, Created.' Dim i As Long Dim k As Long 'the current number being factored' Dim p As Long 'the current prime factor' 'Establish the Window frame:' ' note: WindowSize is the critical value that controls both memory' ' usage and CPU consumption and must be SQRT(N) for it to work optimally.' WindowSize = Ceiling(Sqrt(CDbl(N))) ReDim Numbers(0 To WindowSize - 1) 'Initialize the first window:' MapWindow(1) Dim IsFirstWindow As Boolean = True 'adjust this to control how often results are show' ReportInterval = N / 100 'Allocate the primes array to hold the primes list:' ' Only primes = WindowSize Then Exit For If Numbers(i - FirstValue).UnFactored = i Then 'this is a prime less than SQRT(N), so add it to the list.' Primes(NextPrime) = i NextPrime += 1 End If Next End If PrimeIndex += 1 'move to the next prime' Loop 'Now Finish & Emit each one' For k = FirstValue To LastValue With Numbers(k - FirstValue) 'Primes larger than Sqrt(N) will not be finished: ' If .UnFactored > 1 Then 'Not done factoring, must be an large prime factor remaining: ' .Phi = .Phi * (.UnFactored - 1) .UnFactored = 1 End If 'Emit the value pair: (k, Phi(k)) ' EmitPhi(k, .Phi) End With Next 're-Map to the next window ' IsFirstWindow = False MapWindow(NextFirst) Loop While FirstValue Note that at O(N * Log(Log(N))), this routine is factoring each number at O(Log(Log(N))) on average which is much, much faster than the fastest single N factorization algorithms sited by some of the replies here. In fact, at N = 10^12 it is 2400 times faster! I have tested this routine on my 2Ghz Intel Core 2 laptop and it computes over 3,000,000 Phi() values per second. At this speed, it would take you about 4 days to compute 10^12 values. I have also tested it for correctness up to 100,000,000 without any errors. It is based in 64-bit integers, so anything up to 2^63 (10^19) should be accurate (though too slow for anyone). I also have a Visual Studio WinForm (also VB.net) for running/testing it, that I can provide if you want it. Let me know if you have any questions. As requested in the comments, I have added below a C# version of the code. However, because I am currently in the middle of some other projects, I do not have time to convert it myself, so I have used one of the online VB to C# conversion sites ( http://www.carlosag.net/tools/codetranslator/ ). So be aware that this was auto-converted and I have not had time to test or check it myself yet. using System.Math; public class TotientSerialCalculator { // Implements an extremely efficient Serial Totient(phi) calculator ' // This implements an optimized windowed Sieve of Eratosthenes. The' // window size is set at Sqrt(N) both to optimize collecting and ' // applying all of the Primes below Sqrt(N), and to minimize ' // window-turning overhead. ' // ' // CPU complexity is O( N * Log(Log(N)) ), which is virtually linear.' // ' // MEM Complexity is O( Sqrt(N) ). ' // ' // This is probalby the ideal combination, as any attempt to further ' // reduce memory will almost certainly result in disproportionate increases' // in CPU complexity, and vice-versa. ' struct NumberFactors { private long UnFactored; // the part of the number that still needs to be factored' private long Phi; } private long ReportInterval; private long PrevLast; // the last value in the previous window' private long FirstValue; // the first value in this windows range' private long WindowSize; private long LastValue; // the last value in this windows range' private long NextFirst; // the first value in the next window' // Array that stores all of the NumberFactors in the current window.' // this is the primary memory consumption for the class and it' // is 16 * Sqrt(N) Bytes, which is O(Sqrt(N)).' public NumberFactors[] Numbers; // For N=10^12 (1 trilion), this will be 16MB, which should be bearable anywhere.' // (note that the Primes() array is a secondary memory consumer' // at O(pi(Sqrt(N)), which will be within 10x of O(Sqrt(N)))' //NOTE: this part looks like it did not convert correctly public event EventHandler EmitTotientPair; private long k; private long Phi; // ===== The Routine To Call: ========================' public void EmitTotientPairsToN(long N) { // Routine to Emit Totient pairs {k, Phi(k)} for k = 1 to N' // 2009-07-14, RBarryYoung, Created.' long i; long k; // the current number being factored' long p; // the current prime factor' // Establish the Window frame:' // note: WindowSize is the critical value that controls both memory' // usage and CPU consumption and must be SQRT(N) for it to work optimally.' WindowSize = Ceiling(Sqrt(double.Parse(N))); object Numbers; this.MapWindow(1); bool IsFirstWindow = true; ReportInterval = (N / 100); // Allocate the primes array to hold the primes list:' // Only primes = WindowSize)) { break; } if ((Numbers[(i - FirstValue)].UnFactored == i)) { // this is a prime less than SQRT(N), so add it to the list.' Primes[NextPrime] = i; NextPrime++; } } } PrimeIndex++; // move to the next prime' } // Now Finish & Emit each one' for (k = FirstValue; (k 1)) { // Not done factoring, must be an large prime factor remaining: ' (Numbers[(k - FirstValue)].Phi * (Numbers[(k - FirstValue)].UnFactored - 1).UnFactored) = 1; Numbers[(k - FirstValue)].Phi = 1; } // Emit the value pair: (k, Phi(k)) ' this.EmitPhi(k, Numbers[(k - FirstValue)].Phi); } // re-Map to the next window ' IsFirstWindow = false; this.MapWindow(NextFirst); } } void EmitPhi(long k, long Phi) { // just a placeholder for now, that raises an event to the display form' // periodically for reporting purposes. Change this to do the actual' // emitting.' if (((k % ReportInterval) == 0)) { EmitTotientPair(k, Phi); } } public void MapWindow(long FirstVal) { // Efficiently reset the window so that we do not have to re-allocate it.' // init all of the boundary values' FirstValue = FirstVal; PrevLast = (FirstValue - 1); NextFirst = (FirstValue + WindowSize); LastValue = (NextFirst - 1); // Initialize the Numbers prime factor arrays' long i; for (i = 0; (i
