[site]: stackoverflow
[post_id]: 4710922
[parent_id]: 4705698
[tags]: 
It should work. Note that as others have already set, the CLR counters are per instance counters, thus you need to specify the instance name for the process you wish to query the counters for. So the statement you specified at the top of your post should work. However, you should also use the constructor overload that allows you to specify that you wish to access the instance in "read-only" mode: new PerformanceCounter(".NET CLR Memory", "# bytes in all heaps", Process.GetCurrentProcess().ProcessName, true); The second code fragment you posted does not work, as you didn't specify an instance name to the GetCounters() operation. Use the GetCounters(string instanceName) overload instead and it should work. Finally, note that the instance name is not necessarily the same as Process.ProcessName (or Process.GetCurrentProcess().ProcessName for that matter). If there are multiple instances of a process, i.e. executable, the process name is created by appending a # . To figure out the actual instance name of a process you should query the .NET CLR Memory\Process ID counter. Example: public static string GetInstanceNameForProcessId(int pid) { var cat = new PerformanceCounterCategory(".NET CLR Memory"); foreach (var instanceName in cat.GetInstanceNames()) { try { using (var pcPid = new PerformanceCounter(cat.CategoryName, "Process ID", instanceName)) { if ((int)pcPid.NextValue() == pid) { return instanceName; } } } catch (InvalidOperationException) { // This may happen, if the PC-instance no longer exists between the // time we called GetInstanceNames() and the time we come around actually // try and use the instance. // In this situation that is not an error, so ignore it. } } throw new ArgumentException( string.Format("No performance counter instance found for process id '{0}'", pid), "pid"); } The instance name you gather by this method is good for performance counters in other ".NET CLR" categories as well. Update : Added mitigation for potential race condition between the time we gather the potential instance names and the time we peruse them. A .NET process (for which we've seen an instance name) might no longer be there (and such the instance is also gone) when we try to use it.
