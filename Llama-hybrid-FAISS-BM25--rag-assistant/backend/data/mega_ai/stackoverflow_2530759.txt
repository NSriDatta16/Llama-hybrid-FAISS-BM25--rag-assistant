[site]: stackoverflow
[post_id]: 2530759
[parent_id]: 2528457
[tags]: 
I want to add to Southern Hospitality's answer Static variables in C and C++ the following remarks: The use of static to indicate "local to translation unit" is deprecated in C++ ( href="https://rads.stackoverflow.com/amzn/click/com/0201700735" rel="nofollow noreferrer" The C++ Programming Language: Special Edition, Appendix B.2.3, Deprecated Features). You should use unnamed namespaces instead: static int reply = 42; // deprecated namespace { int reply1 = 42; // The C++ way } As already said by Southern Hospitality, the order of initialization of global objects is undefined. In that situation, you should consider using the href="http://en.wikipedia.org/wiki/Singleton_pattern#C.2B.2B", Singleton pattern. UPDATE: GMan commented my answer: "The order is defined per-translation unit, ...": This really slipped my mind, so I looked it up in The C++ Programming Language. In Section 9.4.1, Initialization of Non-local Variables, Prof. Stroustrup suggests that "a function returning a reference is a good alternative to a global variable": int& use_count() { static int uc = 0; return uc; } "A call to use_count() now acts as a global variable that is initialized at its first use. For example:" void f() { std::cout In my understanding, this is very similar to the Singleton pattern. GMan commented further: "We need to limit our ability to create these objects to one, and provide global access to it." Does the limiting to one really relate to anything in the problem? We may need one globally, but who's to say we don't want it in other places?" Some quotes from Singleton(127) (Gamma et al, Design Patterns): "The Singleton pattern is an improvement over global variables. It avoids polluting the name space with global variables that store sole instances." "The pattern makes it easy to change your mind and allow more than one instance of the Singleton class." Singletons are initialized in the order they are first used. In Herb Sutter, Andrei Alexandrescu, C++ Coding Standards, Item 10 says: "Avoid shared data, especially global data." Therefore I use often Singletons to avoid global data. But of course, as everything is overusable, this could be a overuse of the Singleton pattern. (Johshua Kerievsky calls this "Singletonitis" in his book "Refactoring to Patterns".) UPDATE 2: (Sorry, but I cannot write comments, therefore this Update.) Jalf wrote in his comment: "The gang of four were smoking something illegal when they wrote about the singleton pattern." Obviously, other C++ developers smoked interesting substances, too. For example, Herb Sutter (he served for over a decade as secretary and chair of the ISO C++ standards committee during the development of the second C++ standard, C++0x, and as lead architect of C++/CLI at Microsoft. Herb is currently the designer of the Prism memory model for Microsoft platforms and the Concur extensions to Visual C++ for parallel programming), wrote in C++ Coding Standards, Item 21: "When you need such a (namespace level) variable that might depend upon another, consider the Singleton design pattern; used carefully, it might avoid implicit dependencies by ensuring that an object is initialized upon first access. Still, Singleton is a global variable in sheep's clothing, and is broken by mutual or cyclic dependencies." So, avoid global data, if you can. But if you have to use global data in separate translation units, Singleton should be an acceptable solution for enforcing a specific initialization sequence. Note that in the Java language global data does not even exist. Obviously, global data is substituted/emulated by the use of the Singleton design pattern. (For I am working in my dayjob with a Java team, I strive for a maximal similarity of my C++ programs with Java programs. E.g, every class is situated in its own source file/translation unit.)
