[site]: stackoverflow
[post_id]: 3751701
[parent_id]: 
[tags]: 
Socket's input byte stream wrapped in two different stream types?

I'm trying to implement such a protocol: Client side: 1) client sends command (String) 2) client sends object 3) client receives object or data [depends on command] Server side: 1) server reads command (String) 2) server receives object [type depends on command] 3) server sends object or data [depends on command] On client side, I'm doing something like this (program blocks on line, marked with "!!!"): /** Retrieves required wrapper streams */ private void getSocketStreams() { try { inputStream = new DataInputStream( connection.getInputStream()); /* !!! here is a problem: can I do next line's stuff? */ inputObjectStream = new ObjectInputStream( connection.getInputStream()); outputWriter = new BufferedWriter( new OutputStreamWriter( connection.getOutputStream())); outputObjectStream = new ObjectOutputStream( connection.getOutputStream()); } catch (IOException e) { e.printStackTrace(); } } /** "put" command processor */ private int processCmdPut(OrderInfo orderInfo) { /* Send command to peer */ try { outputWriter.write("put"); outputWriter.newLine(); outputWriter.flush(); } catch (IOException e) { e.printStackTrace(); } /* Send inserted object to peer */ sendObject(orderInfo); /* Get from peer inserted info id */ int id = -1; try { id = inputStream.readInt(); } catch (IOException e) { e.printStackTrace(); } return id; } /** * Sends object to peer. * @param obj object to send. */ public void sendObject(Object obj){ try { outputObjectStream.writeObject(obj); outputObjectStream.flush(); } catch (IOException e) { e.printStackTrace(); } } Server's side actions a mirrored client's. The question about line, marked with "!!!": is it possible to wrap socket's byte stream with two different high-lever streams and read/write into them by turns (one by one)? Am I wrong? There is my error or misunderstanding?
