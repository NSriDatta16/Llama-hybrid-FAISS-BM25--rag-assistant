[site]: stackoverflow
[post_id]: 5469147
[parent_id]: 5468921
[tags]: 
python sounds to be a good choice because it has a good threading API (the implementation is questionable though), matplotlib and pylab. I miss some more specs from your end but maybe this could be a good starting point for you: matplotlib: async plotting with threads . I would go for a single thread for handling bulk disk i/o reads and sync queueing to a pool of threads for data processing (if you have fixed record lengths things may get faster by precomputing reading offsets and passing just the offsets to the threadpool); with the diskio thread I would mmap the datasource files, read a predefined num bytes + one more read to eventually grab the last bytes to the end of the current datasource lineinput; the numbytes should be chosen somewhere near your average lineinput length; next is pool feeding via the queue and the data processing / plotting that takes place in the threadpool; I don't have a good picture here (of what are you plotting exactly) but I hope this helps. EDIT: there's file.readlines([sizehint]) to grab multiple lines at once; well it may not be so speedy cuz the docs are saying its using readline() internally EDIT: a quick skeleton code import threading from collections import deque import sys import mmap class processor(Thread): """ processor gets a batch of data at time from the diskio thread """ def __init__(self,q): Thread.__init__(self,name="plotter") self._queue = q def run(self): #get batched data while True: #we wait for a batch dataloop = self.feed(self._queue.get()) try: while True: self.plot(dataloop.next()) except StopIteration: pass #sanitizer exceptions following, maybe def parseline(self,line): """ return a data struct ready for plotting """ raise NotImplementedError def feed(self,databuf): #we yield one-at-time datastruct ready-to-go for plotting for line in databuf: yield self.parseline(line) def plot(self,data): """integrate https://www.esclab.tw/wiki/index.php/Matplotlib#Asynchronous_plotting_with_threads maybe """ class sharedq(object): """i dont recall where i got this implementation from you may write a better one""" def __init__(self,maxsize=8192): self.queue = deque() self.barrier = threading.RLock() self.read_c = threading.Condition(self.barrier) self.write_c = threading.Condition(self.barrier) self.msz = maxsize def put(self,item): self.barrier.acquire() while len(self.queue) >= self.msz: self.write_c.wait() self.queue.append(item) self.read_c.notify() self.barrier.release() def get(self): self.barrier.acquire() while not self.queue: self.read_c.wait() item = self.queue.popleft() self.write_c.notify() self.barrier.release() return item q = sharedq() #sizehint for readine lines numbytes=1024 for i in xrange(8): p = processor(q) p.start() for fn in sys.argv[1:] with open(fn, "r+b") as f: #you may want a better sizehint here map = mmap.mmap(f.fileno(), 0) #insert a loop here, i forgot q.put(map.readlines(numbytes)) #some cleanup code may be desirable
