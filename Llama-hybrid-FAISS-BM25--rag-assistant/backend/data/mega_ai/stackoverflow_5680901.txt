[site]: stackoverflow
[post_id]: 5680901
[parent_id]: 5680743
[tags]: 
To draw the line, implement touchesBegan: , touchedMove: , touchedEnded , touchesCancelled: in your view or view controller and build a path (CGPathRef) using the touch points. To make an an object move along the line, create a CAKeyframeAnimation, set the path and assign it to the object's layer. Edit: sample code When you have a CGPathRef path , creating the animation is as easy as: CAKeyframeAnimation* animation = [CAKeyframeAnimation animation]; animation.path = thePath; animation.duration = 2; animation.rotationMode = kCAAnimationRotateAuto; // object auto rotates to follow the path animation.removedOnCompletion = NO; animation.fillMode = kCAFillModeForwards; Finally, assign the animation to a layer: [layer1 addAnimation:animation forKey:@"position"]; Edit 2: sample application: I built an entire project called PathAnimation for you. Edit 3: this is the code I used in the PathAnimation project: // // CustomView.m // PathAnimation // // Created by Dominique d'Argent on 19.04.11. // Copyright 2011 Nicky Nubbel. All rights reserved. // #import "CustomView.h" @implementation CustomView - (id)initWithFrame:(CGRect)frame { self = [super initWithFrame:frame]; if (self) { object = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"arrow"]]; object.frame = CGRectMake(10.0, 30.0, 20.0, 20.0); [self addSubview:object]; [self createPath]; } return self; } - (void)dealloc { [object release]; [super dealloc]; } #pragma mark - Custom drawing // Only override drawRect: if you perform custom drawing. // An empty implementation adversely affects performance during animation. - (void)drawRect:(CGRect)rect { CGContextRef g = UIGraphicsGetCurrentContext(); CGFloat bgColor[4] = {1.0f, 1.0f, 1.0f, 1.0f}; CGContextSetFillColor(g, bgColor); CGContextFillRect(g, self.frame); CGFloat color[4] = {1.0f, 0.0f, 0.0f, 1.0f}; CGContextAddPath(g,path); CGContextSetStrokeColor(g, color); CGContextDrawPath(g, kCGPathStroke); CGPoint position = CGPathGetCurrentPoint(path); CGContextAddArc(g, position.x, position.y, 5.0f, 0.0f, 2 * M_PI, 0); CGContextSetFillColor(g, color); CGContextDrawPath(g, kCGPathFill); } #pragma mark - Path creation - (void)createPath { path = CGPathCreateMutable(); CGPathMoveToPoint(path, NULL, object.center.x, object.center.y); } #pragma mark - Touch handling - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { UITouch *touch = [touches anyObject]; CGPoint position = [touch locationInView:self]; if (CGRectContainsPoint(object.frame, position)) { // start animation [self go]; } else { CGPoint lastPosition = CGPathGetCurrentPoint(path); if (CGPointEqualToPoint(lastPosition, object.center)) { CGFloat angle = -atan2f(position.x - lastPosition.x, position.y - lastPosition.y); angle += M_PI_2; object.layer.transform = CATransform3DMakeRotation(angle, 0.0, 0.0, 1.0); } CGPathAddLineToPoint(path, NULL, position.x, position.y); [self setNeedsDisplay]; } } - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event { } - (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event { } - (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event { } #pragma mark - Animations - (void) go { NSLog(@"go"); object.layer.transform = CATransform3DIdentity; CAKeyframeAnimation* animation = [CAKeyframeAnimation animation]; animation.path = path; animation.duration = 5.0; animation.rotationMode = kCAAnimationRotateAuto; // object auto rotates to follow the path animation.removedOnCompletion = NO; animation.fillMode = kCAFillModeForwards; [object.layer addAnimation:animation forKey:@"position"]; object.center = CGPathGetCurrentPoint(path); [self createPath]; } @end
