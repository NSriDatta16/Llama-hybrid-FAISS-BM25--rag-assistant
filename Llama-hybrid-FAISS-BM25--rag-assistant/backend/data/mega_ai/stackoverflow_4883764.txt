[site]: stackoverflow
[post_id]: 4883764
[parent_id]: 4883655
[tags]: 
1) Access specifier are part of structure and do not affect the object created from "structure" Wrong actually, the order (in the layout) of data members within the same access specific ( public , protected or private ) is dictated by their order in the code, however no order is specified for data members with different specifiers. class Foo { public: int a; int b; protected: int c; int d; }; The only thing we know is that a must come before b and c must come before d . abcd , acbd , acdb , cabd , cadb and cdab are all possible. 2) All of the access specification information disappear before the program is run (during compilation).In a running program,object become the "region of storage" and nothing more.. thus we can break all the rules and access the memory directly as you can in c The information is only used during compilation, but then compilation is what generate the running code. Therefore compilation ensures that you won't access private members. However, since direct memory manipulation is permitted, you could effectively access private members or functions if you wish, it's just highly error-prone to try and do it manually. 3) C++ is designed to be pragmatic, not to aspire to abstract the real Pragmatic means that it's geared toward real use, with little consideration for purely theoretic arguments. Languages built from CS theory would include Haskell for example, which has an extremely sound mathematical background; on the other hand C++ has accumulated features that were deemed useful by its users. Also, C++ does not hide the low-level details from you (like memory management). Good C++ code generally leave it up to the compiler and use idioms to try and abstract it (somewhat), but if necessary you can always get closer to the metal (even including Assembly code directly)... and sometimes (like memory management) you do have to pay attention to what you're doing.
