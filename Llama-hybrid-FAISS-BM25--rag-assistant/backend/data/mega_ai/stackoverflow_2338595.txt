[site]: stackoverflow
[post_id]: 2338595
[parent_id]: 2338316
[tags]: 
As far as I know, there is no easy way to do this, but it is definitely a good way to practice functional programming skills. If you used some hierarchical representation of data (e.g. XML or JSON), the situation would be a lot easier, because you wouldn't have to transform the data structure from linear (e.g. list/array) to hierarchical (in this case, a list of lists). Anyway, a good way to approach the problem is to realize that you need to do some more general operation with the data - you need to group adjacent elements of the array, starting a new group when you find an line with a value in the first column. I'll start by adding a line number to the array and then convert it to list (which is usually easier to work with in F#): let data = lines |> Array.mapi (fun i l -> i, l.Split(';')) |> List.ofSeq Now, we can write a reusable function that groups adjacent elements of a list and starts a new group each time the specified predicate f returns true : let adjacentGroups f list = // Utility function that accumulates the elements of the current // group in 'current' and stores all groups in 'all'. The parameter // 'list' is the remainder of the list to be processed let rec adjacentGroupsUtil current all list = match list with // Finished processing - return all groups | [] -> List.rev (current::all) // Start a new group, add current to the list | x::xs when f(x) -> adjacentGroupsUtil [x] (current::all) xs // Add element to the current group | x::xs -> adjacentGroupsUtil (x::current) all xs // Call utility function, drop all empty groups and // reverse elements of each group (because they are // collected in a reversed order) adjacentGroupsUtil [] [] list |> List.filter (fun l -> l <> []) |> List.map List.rev Now, implementing your specific algorithm is relatively easy. We first need to group the elements, starting a new group each time the first column has some value: let groups = data |> adjacentGroups (fun (ln, cells) -> cells.[0] <> "") In the second step, we need to do some processing for each group. We take its first element (and pick the title of the group) and then find the minimal and maximal line number among the remaining elements: groups |> List.map (fun ((_, firstCols)::lines) -> let lineNums = lines |> List.map fst firstCols.[0], List.min lineNums, List.max lineNums ) Note that the pattern matching in the lambda function will give a warning, but we can safely ignore that because the group will always be non-empty. Summary: This answer shows that if you want to write elegant code, you can implement your reusable higher order function (such as adjacentGroups ), because not everything is available in the F# core libraries. If you use functional lists, you can implement it using recursion (for arrays, you'd use imperative programming as in the answer by gradbot ). Once you have a good set of reusable functions, most of the problems are easy :-).
