[site]: stackoverflow
[post_id]: 2300446
[parent_id]: 2299882
[tags]: 
There are a few times you benefit from working with raw machine code, not just assembly language. For example, consider sending a binary file via email, but with an email program that didn't know how to decode attachments. At one time, a few people wrote small programs that could decode the rest of an attachment, but everything in the program was a printable character. So, you decode your attachment, you'd save the body of the email as whatever.com , and then execute it. It would decode the attachment and write a binary file you could then execute. For another example, years ago on Fidonet there was a rather simple challenge: write a program that simply prints out a number that increments each time it's run -- but (the part that made it tricky) it's not allowed to use any external files or other storage to do the job. To keep this from getting too boring, it was also a code-golf kind of thing, though the measured size was executable bytes, not source code. Quite a few of the entries to this challenge used self-modifying code that depended heavily on exactly how instructions were encoded and such. Looking for a second, I see I still have the source code to one of my attempts: .model tiny,c .286 .code .startup main proc mov si,offset count inc byte ptr [si] mov al, [si] mov bx,4090h shr al, 4 call convert lodsb and al,0fh mov byte ptr end_convert, 08bh convert: add al,bl daa adc al,bh daa int 29h end_convert: ret db 0d6h ; mov dx, si mov ah,3ch xor cx, cx int 21h xchg bx, ax mov dx,offset main mov cx,offset the_end - offset main int 21h ret main endp count: db 0 name: db 'c.com', 0 the_end: end I'd better quit now, before I'm responsible for anybody have apoplectic fits (hoping I'm not too late...)
