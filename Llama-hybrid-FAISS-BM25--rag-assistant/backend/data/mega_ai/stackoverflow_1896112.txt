[site]: stackoverflow
[post_id]: 1896112
[parent_id]: 1895922
[tags]: 
I believe that the following expression definitely has undefined behaviour. i + ((i, i++, i) + 1) The reason is that the comma operator specifies sequence points between the subexpressions in parentheses but does not specify where in that sequence the evaluation of the left hand operand of + occurs. One possibility is between the sequence points surrounding i++ and this violates the 5/4 as i is written to between two sequence points but is also read twice between the same sequence points and not just to determine the value to be stored but also to determine the value of the first operand to the + operator. This also has undefined behaviour. i += (i, i++, i) + 1; Now, I am not so sure about this statement. i = (i, i++, i) + 1; Although the same principals apply, i must be "evaluated" as a modifiable lvalue and can be done so at any time, but I'm not convinced that its value is ever read as part of this. (Or is there another restriction that the expression violates to cause UB?) The sub-expression (i, i++, i) happens as part of determining the value to be stored and that sub-expression contains a sequence point after the storage of a value to i . I don't see any way that this wouldn't require the side effect of i++ to be complete before the determination of the value to be stored and hence the earliest possible point that the assignment side effect could occur. After this sequnce point i 's value is read at most once and only to determine the value that will be stored back to i , so this last part is fine.
