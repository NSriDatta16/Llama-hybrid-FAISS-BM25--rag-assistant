[site]: stackoverflow
[post_id]: 2908535
[parent_id]: 787212
[tags]: 
This seems to be the best resource for this question on the internet. Another close solution can be found here . I have solved this issue in a very satisfactory manner in a different way, essentially by supplanting my own gesture recognizer into the equation. I strongly recommend that anyone who is trying to achieve the effect requested by the original poster consider this alternative over aggressive subclassing of UIScrollView . The following process will provide: A UIScrollView containing your custom view Zoom and Pan with two fingers (via UIPinchGestureRecognizer ) Your view's event processing for all other touches First, let's assume you have a view controller and its view. In IB, make the view a subview of a scrollView and adjust the resize rules of your view so that it does not resize. In the attributes of the scrollview, turn on anything that says "bounce" and turn off " delaysContentTouches ". Also you must set the zoom min and max to other than the default of 1.0 for, as Apple's docs say, this is required for zooming to work. Create a custom subclass of UIScrollView , and make this scrollview that custom subclass. Add an outlet to your view controller for the scrollview and connect them up. You're now totally configured. You will need to add the following code to the UIScrollView subclass so that it transparently passes touch events (I suspect this could be done more elegantly, perhaps even bypassing the subclass altogether): #pragma mark - #pragma mark Event Passing - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { [self.nextResponder touchesBegan:touches withEvent:event]; } - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event { [self.nextResponder touchesMoved:touches withEvent:event]; } - (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event { [self.nextResponder touchesEnded:touches withEvent:event]; } - (BOOL)touchesShouldCancelInContentView:(UIView *)view { return NO; } Add this code to your view controller: - (void)setupGestures { UIPinchGestureRecognizer *pinchGesture = [[UIPinchGestureRecognizer alloc] initWithTarget:self action:@selector(handlePinchGesture:)]; [self.view addGestureRecognizer:pinchGesture]; [pinchGesture release]; } - (IBAction)handlePinchGesture:(UIPinchGestureRecognizer *)sender { if ( sender.state == UIGestureRecognizerStateBegan ) { //Hold values previousLocation = [sender locationInView:self.view]; previousOffset = self.scrollView.contentOffset; previousScale = self.scrollView.zoomScale; } else if ( sender.state == UIGestureRecognizerStateChanged ) { //Zoom [self.scrollView setZoomScale:previousScale*sender.scale animated:NO]; //Move location = [sender locationInView:self.view]; CGPoint offset = CGPointMake(previousOffset.x+(previousLocation.x-location.x), previousOffset.y+(previousLocation.y-location.y)); [self.scrollView setContentOffset:offset animated:NO]; } else { if ( previousScale*sender.scale .85 ) [self.scrollView setZoomScale:1.0 animated:YES]; } } Please note that in this method there are references to a number of properties you must define in your view controller's class files: CGFloat previousScale; CGPoint previousOffset; CGPoint previousLocation; CGPoint location; Ok that's it! Unfortunately I could not get the scrollView to show its scrollers during the gesture. I tried all of these strategies: //Scroll indicators self.scrollView.showsVerticalScrollIndicator = YES; self.scrollView.showsVerticalScrollIndicator = YES; [self.scrollView flashScrollIndicators]; [self.scrollView setNeedsDisplay]; One thing I really enjoyed is if you'll look at the last line you'll note that it grabs any final zooming that's around 100% and just rounds it to that. You can adjust your tolerance level; I had seen this in Pages' zoom behavior and thought it would be a nice touch.
