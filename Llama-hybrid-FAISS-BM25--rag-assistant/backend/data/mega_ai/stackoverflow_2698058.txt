[site]: stackoverflow
[post_id]: 2698058
[parent_id]: 2697843
[tags]: 
Hmm, why are you doing that? Why are you encoding a WideString to UTF-8 just to store it again back to WideString. You are obviously using a Unicode version of the Windows API. So there is no need to use a UTF-8-encoded string. Or am I missing something. Because Windows API functions are either Unicode (two bytes) or ANSI (one byte). UTF-8 would be wrong choice here, because mainly it contains one byte per character, but for characters above the ASCII base it uses two or more bytes. Otherwise the equivalent for your old code in unicode Delphi would be: var UnicodeStr: string; UTF8Str: string; begin UnicodeStr:='some unicode text'; UTF8Str:=UTF8Encode(UnicodeStr); Windows.SomeFunction(PWideChar(UTF8Str), ...) end; WideString and string (UnicodeString) are similar, but the new UnicodeString is faster because it is reference-counted and WideString is not. You code was not correct because the UTF-8 string has a variable number of bytes per character. "A" is stored as one byte. Just an ASCII byte code. "Ã¼" on the other hand would be stored as two bytes. And because you are then using PWideChar the function always expects two bytes per character. There is another difference. In older Delphi versions (ANSI) Utf8String was just an AnsiString. In Unicode versions of Delphi Utf8String is a string with a UTF-8 code page behind it. So it behaves differently. The old code would still work correctly: var UnicodeStr: WideString; UTF8Str: WideString; begin UnicodeStr:='some unicode text'; UTF8Str:=UTF8Encode(UnicodeStr); Windows.SomeFunction(PWideChar(UTF8Str), ...) end; It would act the same as it did in Delphi 2007. So maybe you have a problem elsewhere. Mick you are correct. The compiler does some extra work behind the scenes. So in order to avoid this you can do something like this: var UTF8Str: AnsiString; UnicodeStr: WideString; TempString: RawByteString; ResultString: WideString; begin UnicodeStr := 'some unicode text'; TempString := UTF8Encode(UnicodeStr); SetLength(UTF8Str, Length(TempString)); Move(TempString[1], UTF8Str[1], Length(UTF8Str)); ResultString := UTF8Str; end; I checked, and it works just the same. Because I move bytes directly in memory there is no codepage conversion done in the background. I am sure it can be done with greater eleganece, but the point is that I see this as the way for what you want to achieve.
