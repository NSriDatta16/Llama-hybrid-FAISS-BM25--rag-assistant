[site]: stackoverflow
[post_id]: 2475940
[parent_id]: 2475920
[tags]: 
My first question was, are the 2 third-party component classes sealed? They were not. At least we have that. So, since they are not sealed, the problem is solvable in the following way: Extract a common interface out of the coinciding members of the 2 third-party classes. I called it Icommon. public interface ICommon { string Name { get; } void DoThirdPartyStuff (); } Then create 2 new classes; DerivedClass1 and DerivedClass2 that inherit from ThirdPartyClass1 and ThirdPartyClass2 respectively. These 2 new classes both implement the ICommon interface, but are otherwise completely empty. public class DerivedClass1 : ThirdPartyClass1, ICommon { } public class DerivedClass2 : ThirdPartyClass2, ICommon { } Now, even though the derived classes are empty, the interface is satisfied by the base classes, which is where we extracted the interface from in the first place. The resulting class diagram looks like this. alt text http://www.freeimagehosting.net/uploads/988cadf318.png So now, instead of what we previously had: ThirdPartyClass1 c1 = new ThirdPartyClass1 (); c1. DoThirdPartyStuff (); We can now do: ICommon common = new DerivedClass1 (); common. DoThirdPartyStuff (); And the same can be done with DerivedClass2. The result is that all our existing code that referenced an instance of ThirdPartyClass1 can be left as is, by just swapping out the ThirdPartyClass1 reference for a ICommon reference. The ICommon reference could then be given an instance of DerivedClass1 or DerivedClass2, which of course in turn inherits from ThirdPartyClass1 and ThirdPartyClass2 respectively. And all just works. I do not know if there is a specific name for this, but to me it looks like a variant of the adaptor pattern. Perhaps we could have solve the problem with the dynamic types in C# 4.0, but that would have not had the benefit of compile-time checking. I would be very interested to know if anybody else has another elegant way of solving this problem.
