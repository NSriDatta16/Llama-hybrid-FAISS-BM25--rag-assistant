[site]: stackoverflow
[post_id]: 2856812
[parent_id]: 2833281
[tags]: 
The best solution for this is to use XPath. Let's say we have the following feed.xml file: FEED TITLE 1 id1 FEED TITLE 2 id2 id3 Here's a short but compile-and-runnable proof-of-concept (with feed.xml file in the same directory). import javax.xml.xpath.*; import javax.xml.parsers.*; import org.w3c.dom.*; import java.io.*; import java.util.*; public class XPathTest { static class Entry { final String title, id, origin, type; Entry(String title, String id, String origin, String type) { this.title = title; this.id = id; this.origin = origin; this.type = type; } @Override public String toString() { return String.format("%s:%s(%s)[%s]", id, title, origin, type); } } final static XPath xpath = XPathFactory.newInstance().newXPath(); static String evalString(Node context, String path) throws XPathExpressionException { return (String) xpath.evaluate(path, context, XPathConstants.STRING); } public static void main(String[] args) throws Exception { File file = new File("feed.xml"); Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(file); NodeList entriesNodeList = (NodeList) xpath.evaluate("//entry", document, XPathConstants.NODESET); List entries = new ArrayList (); for (int i = 0; i This produces the following output: id1:FEED TITLE 1(MadeIn1)[type1] id2:FEED TITLE 2(MadeIn2)[type2] id3:()[] Note how using XPath makes the value retrieval very simple, intuitive, readable, and straightforward, and "missing" values are also gracefully handled. API links package javax.xml.xpath http://www.w3.org/TR/xpath Wikipedia/XPath
