[site]: stackoverflow
[post_id]: 1149451
[parent_id]: 1149443
[tags]: 
You need to load the config file in the right way. Rather than using the static properties of ConfigurationManager use the methods to load. Also you need to ensure you are managing the difference between global, application, user roaming and user local configuration. Normally only the last two should be writeable. Some test code for writing changes to the use config file: Configuration config = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.PerUserRoamingAndLocal); TestConfigData data = (TestConfigData)config.GetSection("testConfigData"); ++data.Data; config.Save(ConfigurationSaveMode.Minimal); Where TestConfigDate is a custom configuration type: using System; using System.Configuration; using System.Text; namespace CustomConfiguration { public class TestConfigData : ConfigurationSection { [ConfigurationProperty("Name", IsRequired=true)] public string Name { get { return (string)this["Name"]; } set { this["Name"] = value; } } [ConfigurationProperty("Data", IsRequired=false), IntegerValidator(MinValue=0)] public int Data { get { return (int)this["Data"]; } set { this["Data"] = value; } } } } And the configuration file contains, noting the allowExeDefinition attribute on the section element to define that a user configuration file and override the app.exe.config :
