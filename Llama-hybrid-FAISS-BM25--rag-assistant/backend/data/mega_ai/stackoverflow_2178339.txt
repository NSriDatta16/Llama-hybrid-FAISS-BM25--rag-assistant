[site]: stackoverflow
[post_id]: 2178339
[parent_id]: 2178252
[tags]: 
If the client code can only see Foo (which is the purpose of pimpl idiom), then there's no use in define a specific size_type in the concrete implementation - it won't be visible/accessible to the client anyway. Standard containers can do that since they are built on so called "compile-time polymorphism", while you are specifically trying to use a [potentially] run-time implementation hiding method. In your situation the only choice would be to choose an integer type that "should be enough for all possible implementations" (like unsigned long , for example) and stick with it. Another possibility is to use the uintptr_t type, if it is available in your implementation (it is standardized in C99, but not in C++). This integer type is supposed to cover the entire storage address range available to the program, which means that it will always be sufficient for representing the size of any in-memory container. Note, that other posters often use the same logic, but incorrectly arrive at the conclusion that the appropriate type to use here is size_t . (This is usually a result of lack of experience with non-flat memory model implementatioons.) If your containers are always based on physical arrays, size_t will work. However, if your containers are not always array-based, size_t is not even remotely the correct type to use here, since its range is generally smaller than the maximum size of a non-continuous (non-array-based) container. But in any case, regardelss of what size you are end up using, it is a good idea to hide it behind a typedef-name, just like it is done in standard containers.
