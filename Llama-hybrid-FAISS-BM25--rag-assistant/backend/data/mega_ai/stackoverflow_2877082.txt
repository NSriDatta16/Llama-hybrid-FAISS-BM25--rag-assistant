[site]: stackoverflow
[post_id]: 2877082
[parent_id]: 2876733
[tags]: 
You're not alone at being confused and coding in c++ and c# I can understand why (not ment as critisism but as a comment since that's the world I live in too) in c++ when you use & on an argument to pass a reference you are basically saying this is an alias I will use inside the method for the argument being passed to the method. Anything you do to that argument will have the same effect as if you had used the variable it self. so in code you can do: void Foo(MyClass& arg) { arg = new MyClass(1); } int x = new MyClass(0); Foo(x); or int x = new MyClass(0); void Foo() { x = new MyClass(1); } in either case x now equals MyClass(1) (and you have a leak cuz there's no way you can get to the original but that's not my point). I guess from you question you knew that already but it will serve a purpose anyway :) If you pass a reference in the standard is that the reference is passed by value. It's no longer an alias everything you do to the object being references will effect the object but if you do anything to the variable referencing the object (e.g. assigning a new object) then that will only affect the copy of the reference. Let's have some more code c# MyClass x = MyClass(0); void Foo(MyClass arg) //reference being passed by val { arg = new MyClass(1); } Foo(x); x still equals MyClass(0) MyClass x = MyClass(0); void Foo(ref MyClass arg) //passing by ref { arg = new MyClass(1); } Foo(ref x); x equals MyClass(1) So the standard argument passing in C# differs from passing a reference in C++ but using the ref keyword (which is not encouraged) gives you close to the same mechanics as & in c++ & in C++ is usually encouraged due to optimization/lack of copying how ever since you only copy the reference in C# that's not a concern and ref should only be used when you really need an alias for the variable being passed to the method aka when you potentially have to assign a new object instance to the variable rather than using/changing the state of an object
