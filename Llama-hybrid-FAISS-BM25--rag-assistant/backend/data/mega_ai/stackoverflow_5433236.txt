[site]: stackoverflow
[post_id]: 5433236
[parent_id]: 5406981
[tags]: 
In case anybody else runs into this design challenge, I’ll post the IBAction I came up with. This scheme uses regular, unflipped views. That is, the origin is at the lower left-hand corner. When the docSize is changed, space is added or removed from the top. While for a single disclosure triangle, some controls need top struts and some need bottom struts, for this scheme, all controls must have both top and bottom struts. Otherwise they adjust themselves automatically, throwing everything off. As noted at the end, there’s a considerable challenge involved when fully scrolled to the bottom. But that’s another chapter… /** Action called upon clicking a disclosure triangle. Hides or discloses the box associated with the disclosure triangle. */ - (IBAction) discloseBox:(id)sender { // Determine which box is governed by this disclosure triangle. NSBox *boxTarget; switch ([sender tag]) { case kDT_Source: boxTarget = self.boxSourceInfo; break; case kDT_Tweak: boxTarget = self.boxTweak; break; case kDT_Series: boxTarget = self.boxSeries; break; case kDT_Abbrevs: boxTarget = self.boxAbbreviations; break; case kDT_Flag: boxTarget = self.boxFlaggingAndComments; break; default: break; } // Get size info on the content with and without the box. NSView *docView = [self.svEditorMain documentView]; NSSize docSize = [docView frame].size; CGFloat fHeightChange = [boxTarget frame].size.height; // Before actually changing the content size, record what point is currently at the top of the window. CGFloat dropFromTop_preChange = [self getCurrentDropFromTop]; // If the state is now on, make the box visible. // If the state is now off, hide the box and make the height change negative. switch ([sender state]) { case NSOnState: [boxTarget setHidden:NO]; break; case NSOffState: [boxTarget setHidden:YES]; fHeightChange *= -1; break; default: break; } // Use the height change to prepare the adjusted docSize, but don't apply it yet. NSSize adjustedDocSize = NSMakeSize(docSize.width, (docSize.height + fHeightChange)); // Make sure the adjustees array is populated. [self populateVerticalAdjusteesArray]; // If the height change is positive, expand the content size before adjusting the origins, so that the origins will have space to move up into. (Space will be added at top.) if (fHeightChange > 0) [docView setFrameSize:adjustedDocSize]; // Get the current, pre-change Y origin of the target box. CGFloat boxOriginY_preChange = [boxTarget frame].origin.y; // Loop through the adjustees, adjusting their height. NSControl *control; CGFloat originX; CGFloat originY; for (NSUInteger ui = 0; ui boxOriginY_preChange) { originX = [control frame].origin.x; // get originX just so you can assemble a new NSPoint originY += fHeightChange; [control setFrameOrigin:NSMakePoint(originX, originY)]; } // Since the array was assembled in order from top down, once a member is encountered whose origin is below the target's, we're done. else break; } // If the height change is negative, contract the content size only now, after the origins have all been safely adjusted downwards. (Space will be removed at top.) if (fHeightChange }
