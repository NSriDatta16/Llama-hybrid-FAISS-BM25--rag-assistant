[site]: stackoverflow
[post_id]: 4473083
[parent_id]: 
[tags]: 
SQL: Need to create two unique records for each single record

The simple question is how can you take a set of records with a PK and create exactly two records for each source with a slightly altered key for the duplicate? In other words, I take 4000 records and produce 8000 records where 4000 are identical and the other 4000 have a slightly altered key. I cannot do a union because this is essentially two selects (long story). The rest gets complicated, but maybe necessary to provide examples. This is my original set (it contains over 4000 records) dateGroup areaGroup itemID editionID 1 1 1 1 1 1 1 2 1 2 1 1 1 2 2 1 2 1 1 1 2 1 1 2 2 2 1 1 2 2 1 2 For each record I need to create a duplicate record ganging the areaGroups together under '0', then create a comma separated list of original areaGroups as a separate field. (The "why" is some dumb programmer (me) made a mistake about 15 years ago.) I can renumber the editionIDs as necessary, but the original and duplicate record must have the same editionID (thus why a union wouldn't work). The PK remains the same as above (all fields) dateGroup areaGroup itemID editionID aGroups 1 0 1 1 1 1 0 1 2 1 1 0 1 1 2 // Duplicate (EditionID) 1 0 2 1 2 2 0 1 1 1 2 0 1 2 1 2 0 1 1 2 // Duplicate (EditionID) 2 0 1 2 2 The end result would renumber the editionID as needed to make the record unique. dateGroup areaGroup itemID editionID aGroups (EditionID is what is altered) 1 0 1 1 1 1 0 1 2 1 1 0 1 2 2 1 changed to 2 (one more than row 1) 1 0 2 1 2 2 0 1 1 1 2 0 1 2 1 2 0 1 2 2 1 changed to 2 (one more than row 1) 2 0 1 2 2 1 1 1 1 1 1 1 2 1 2 1 2 1 changed to 2 (editionID) to match 1 2 2 1 2 1 1 1 2 1 1 2 2 2 1 2 1 changed to 2 to match above 2 2 1 2 I know you could calculate the editionID like a row rank like so: select row_number() over ( partition by dateGroup, itemID order by dateGroup, itemID) as editionID So all I need is to know how to duplicate the records from a single set
