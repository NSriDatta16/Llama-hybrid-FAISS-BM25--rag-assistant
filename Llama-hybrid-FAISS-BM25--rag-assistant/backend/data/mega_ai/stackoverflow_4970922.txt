[site]: stackoverflow
[post_id]: 4970922
[parent_id]: 
[tags]: 
Full setup of Transform Feedback(openGL)

GLSL 1.50, openGL 3.3. I've been lately trying to get my tranform feedback working but without success. I still receive error after glBeginTranformFeedback() and as I haven't found any full working code I have stacked up my knowledge with some code that I found and documentation, it should be working well by now but I am missing something. So if anybody got full code (initializing of buffers, setting up, updating, rendering, reading back) it would definitelly help and if you don't but know what's going on you could take look at my code. I excluded some benchmarking, handling of windows and it's creation: int main() { bool fullsize = false, paused = false; std::string caption = "Tester"; GLuint dataVAO,speedUpdateVBO,dataVBO; std::vector dataW; // Create the main rendering window init(); //just some camera commands UniShader shader; //my shader class keeps everything together shader.init(); shader.addShader("test.vert"); shader.addShader("test.frag"); shader.newAttributeVariable("speed"); shader.newFeedbackVarying("sp"); shader.linkShader(); shader.use(); //init some data dataW.push_back(vector3f(0,1,0)); //creating VAO glGenVertexArrays(1,&dataVAO); glBindVertexArray(dataVAO); //creating VBO glGenBuffers(1,&dataVBO); glBindBuffer(GL_ARRAY_BUFFER,dataVBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vector3f), 0, GL_DYNAMIC_DRAW); glVertexAttribPointer(shader.getAttributeIndex("speed"), 3, GL_FLOAT, GL_FALSE, 0, 0); glGenBuffers(1, &speedUpdateVBO); glBindBuffer(GL_TRANSFORM_FEEDBACK_BUFFER, speedUpdateVBO); glBufferData(GL_TRANSFORM_FEEDBACK_BUFFER, sizeof(vector3f), NULL, GL_DYNAMIC_COPY); glBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER, 0, speedUpdateVBO); glBindVertexArray(0); while (App.IsOpened()) { App.SetActive(); benchP = Clock.GetElapsedTime(); //update calls if(!paused) //update benchU = Clock.GetElapsedTime(); //render calls glClearColor(1.0f, 1.0f, 1.0f, 0.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glColor3f(0.6f,0.7f,0.7f); GLuint query; GLuint count = 0; glGenQueries(1, &query); glEnableVertexAttribArray(shader.getAttributeIndex("speed")); glBindVertexArray(dataVAO); glBindBuffer(GL_ARRAY_BUFFER,dataVBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vector3f)*dataW.size(), &dataW[0], GL_DYNAMIC_DRAW); glBindBuffer(GL_TRANSFORM_FEEDBACK_BUFFER, speedUpdateVBO); glBufferData(GL_TRANSFORM_FEEDBACK_BUFFER, sizeof(vector3f)*dataW.size(), NULL, GL_DYNAMIC_COPY); glBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER, 0, speedUpdateVBO); glEnable(GL_RASTERIZER_DISCARD); glBeginQuery(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, query); printOglError(); //Until this everything OK, I think glBeginTransformFeedback(GL_POINTS); printOglError(); //This one prints out Invalid Value glDrawArrays(GL_POINTS,0,dataW.size()); glEndTransformFeedback(); glEndQuery(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN); glDisable(GL_RASTERIZER_DISCARD); //retrieve updated data glGetQueryObjectuiv(query, GL_QUERY_RESULT, &count); //count is 0 -> nothing happend glBindVertexArray(0); glDisableVertexAttribArray(shader.getAttributeIndex("speed")); glDeleteQueries(1, &query); App.Display(); //some other benchmark stuff } shaders: vert #version 150 core in vec3 speed; varying vec3 sp; const float gravity_constant = 9.81f; void main(){ sp = speed; sp += vec3(0,-gravity_constant,0); } frag #version 150 core varying vec3 sp; void main (void) { vec3 c = sp; gl_FragColor = vec4(c,1.0); } Fragment shader is there just for GLSL optimalization. If sp wouldn't be used GLSL would clear it up. There may be some minor bugs as I extracted this from much larger code with multiple varyings that fails aswell.
