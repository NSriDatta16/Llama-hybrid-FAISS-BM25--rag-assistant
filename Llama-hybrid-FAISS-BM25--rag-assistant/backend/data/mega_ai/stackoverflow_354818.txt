[site]: stackoverflow
[post_id]: 354818
[parent_id]: 354442
[tags]: 
Some options you may want to look at: STLSoft by Matthew Wilson (author of Imperfect C++) has an auto_buffer template class that puts a default array on the stack but if it grows larger than the stack allocation will grab the memory from the heap. I like this class - if you know that your container sizes are generally going to be bounded by a rather low limit, then you get the speed of a local, stack allocated array. However, for the corner cases where you need more memory, it all still works properly. http://www.stlsoft.org/doc-1.9/classstlsoft_1_1auto__buffer.html Note that the implementation I use myself is not STLSoft's, but an implementation that borrows heavily from it. "The Lazy Programmer" did a post for an implementation of a container that uses alloca() for the storage. I'm not a fan of this technique, but I'll let you decide for yourself if it's what you want: http://tlzprgmr.wordpress.com/2008/04/02/c-how-to-create-variable-length-arrays-on-the-stack/ Then there's boost::array which has none of the dynamic sizing behavior of the first two, but gives you more of the vector interface than just using pointers as iterators that you get with built-in arrays (ie., you get begin() , end() , size() , etc.): http://www.boost.org/doc/libs/1_37_0/doc/html/boost/array.html
