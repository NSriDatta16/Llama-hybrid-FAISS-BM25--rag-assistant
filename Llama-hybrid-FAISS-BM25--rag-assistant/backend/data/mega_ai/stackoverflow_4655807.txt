[site]: stackoverflow
[post_id]: 4655807
[parent_id]: 4653140
[tags]: 
Too many years ago when assembly languages for 8-bit micros were how I spent my time, I would have written something like printf("%3.3s", ("NULSOHSTXETXEOTENQACKBELBS HT LF VT FF CR SO SI " "DLEDC1DC2DC3DC4NAKSYNETBCANEM SUBESCFS GS RS US ")[3*ch]); but not because its particularly better. And the multiply by three is annoying because 8-bit micros don't multiply so it would have required both a shift and an add, as well as a spare register. A much more C-like result would be to use a table with four bytes per control, with the NUL bytes included. That allows each entry to be referred to as a string constant, but saves the extra storage for 32 pointers. const char *charname(int ch) { if (ch >= 0 && ch I've tried to format the main table so its organization is clear. The function returns NULL for characters that name themselves, or are not 7-bit ASCII. Otherwise, it returns a pointer to a NUL-terminated ASCII string containing the conventional abbreviation of that control character, or "EOF" for the non-character EOF returned by C standard IO routines on end of file. Note the effort taken to pad each character name slot to exactly four bytes. This is a case where building this table with a scripting language or a separate program would be a good idea. In that case, the simple answer is to build a 129-entry table (or 257-entry) containing the names of all 7-bit ASCII (or 8-bit extended in your preferred code page) characters with an extra slot for EOF . See the sources to the functions declared in for a sample of handling the extra space for EOF .
