[site]: stackoverflow
[post_id]: 3295253
[parent_id]: 
[tags]: 
How to aggregate outputs from a dynamically generated set of projects into a single folder

I need to collect into a single folder all test assemblies, with their dependencies, and configuration files. The process should preserve the directory structure from the output of each test project. We have a solution that requires manually attaching test projects to a master project, but our solution has far too many projects for this to be maintainable. These should be located automatically based on naming convention (x.UnitTest.csproj, y.IntegrationTest.csproj). For background, we are working with a build system that passes artifacts (binaries, etc) between agents. We are compiling on one agent, and testing on other agents. The massive duplication of assemblies between test projects is slowing the build process down. What I have done: 1) I have a csproj that references most of the test projects. This gets binaries and dependencies into one folder. 2) I am able to identify all files to copy using this I've attempted most obvious things, such as MsBuild task: RebaseOutputs attribute, overriding the OutDir property. I can provide the msbuild task with a dynamically generated set of outputs, but can only build them in their default folder. Hooking into the TargetOutputs of msbuild task gives only the primary output assembly (without dependencies). I experimented with "Copy Always" for configuration files. This puts them in the output directory of the dependent project as "app.config" not "dllname.config", and not in the final project. Solutions that could make this better might include Provide an example of adding to the projectreference item array dynamically, before compilation. Use msbuild TargetOutputs to create a list of all files in the folder (instead of just the primary output) and copy to a destination folder. Today I'm using msbuild 3.5. Ideally the solution would work with msbuild 3.5. We are transitioning to .NET 4 / MsBuild 4 soon, so, if must be done in .Net 4, that is fine.
