[site]: stackoverflow
[post_id]: 3252068
[parent_id]: 3251069
[tags]: 
First some quick terminology, just in case: A classifier learns a map of inputs to outputs. You train a classifier by giving it input/output pairs, for example feature vectors like color information and labels like 'czech flag'. In practice, the labels are represented as scalar numbers. In your example, you have a multi-class problem, which simply means that there are more than two possible labels (obviously, since there are more than two country flags). Training a multi-class classifier can a little trickier than the vanilla binary classifier, so you may want to search for terms like "multi-class classifier" or "one-vs-many classifier" to investigate the best approach for you. On to the problem: I think your problem might be easily-solved using a simple classifier, like k-nearest neighbors, with color histograms as feature vectors. In particular, I would use HSV feature vectors as opposed to RGB feature vectors. Some great results have been reported in the literature using just this kind of simple classifier system, for example: SVMs for Histogram-Based Image Classification . In that paper, the authors use a particular classifier known as a Support Vector Machine (SVM) and HSV feature vectors. HSV feature vectors also sidestep the issue of image scale and rotation, for example a flag that is 1024x768 vs 640x480, or a flag that is rotated in an image by 45 degrees. The pseudocode for training the algorithm would look something like this: # training simple kNN -- just compute feature vectors, collect labels X = [] # tuple (input example, label) for training_image in data: x = get_hsv_vector(training_image) y = get_label(training_image) X.append((x,y)) # classification -- pick k closest feature vectors K = 3 # the 'k' in kNN -- how many similar featvecs to use d = [] # (distance, label) tuples for scoring x_test = get_hsv_vector(test_image) # feature vector to be classified for x_train in X: d.append((distance(x_test[0], x_train), x_test[1]) # sort distances, d, by closeness and pick top K labels for scoring d.sort() output = get_majority_vote([x[1] for x in d[:K]]) The kNN classifier is available in several python packages, with good documentation. It should be pretty easy to convert to HSV colorspace as well. If you don't achieve your desired results, you can try to improve your feature vectors or your classifier.
