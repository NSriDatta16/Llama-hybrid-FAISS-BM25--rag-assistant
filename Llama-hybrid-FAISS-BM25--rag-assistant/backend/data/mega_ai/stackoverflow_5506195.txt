[site]: stackoverflow
[post_id]: 5506195
[parent_id]: 
[tags]: 
Invalid argument type to unary expression

I have this program with a tableView as my first view. I have also implemented (or at least tried to) a search bar on top of the view. Have used several hours to search for a solution, but without positive results. #import "FirstViewController.h" #import "NSDictionary-MutableDeepCopy.h" @implementation FirstViewController @synthesize listData, table, search, allNames, names, keys; #pragma mark - #pragma mark Custom Methods - (void)resetSearch { NSMutableDictionary *allNamesCopy = [self.allNames mutableDeepCopy]; self.names = allNamesCopy; [allNamesCopy release]; NSMutableArray *keyArray = [[NSMutableArray alloc] init]; [keyArray addObjectsFromArray:[[self.allNames allKeys] sortedArrayUsingSelector:@selector(compare:)]]; self.keys = keyArray; [keyArray release]; } -(void)handleSearchForTerm:(NSString *)searchTerm { NSMutableArray *sectionsToRemove = [[NSMutableArray alloc] init]; [self resetSearch]; for (NSString *key in self.keys) { NSMutableArray *array = [names valueForKey:key]; NSMutableArray *toRemove = [[NSMutableArray alloc] init]; for (NSString *name in listData) { if ([name rangeOfString:searchTerm options:NSCaseInsensitiveSearch].location == NSNotFound) [toRemove addObject:name]; } if ([array count] == [toRemove count]) [sectionsToRemove addObject:key]; [array removeObjectsInArray:toRemove]; [toRemove release]; } [self.keys removeObjectsInArray:sectionsToRemove]; [sectionsToRemove release]; [table reloadData]; } - (void)viewDidLoad { NSString *path = [[NSBundle mainBundle] pathForResource:@"sortednames" ofType:@"plist"]; NSDictionary *dict = [[NSDictionary alloc] initWithContentsOfFile:path]; self.names = dict; self.allNames = dict; [dict release]; [self resetSearch]; [table reloadData]; [table setContentOffset:CGPointMake(0.0, 44.0)animated:NO]; self.parentViewController.view.backgroundColor = [UIColor colorWithPatternImage:[UIImage imageNamed:@"background.png"]]; NSArray *array = [[NSArray alloc] initWithObjects: // A larger amount of objects here. self.listData = array; [array release]; [super viewDidLoad]; } /* // The designated initializer. Override to perform setup that is required before the view is loaded. - (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil { if ((self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil])) { // Custom initialization } return self; } */ /* // Implement loadView to create a view hierarchy programmatically, without using a nib. - (void)loadView { } */ /* // Implement viewDidLoad to do additional setup after loading the view, typically from a nib. - (void)viewDidLoad { [super viewDidLoad]; } */ /* // Override to allow orientations other than the default portrait orientation. - (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation { // Return YES for supported orientations return (interfaceOrientation == UIInterfaceOrientationPortrait); } */ - (void)didReceiveMemoryWarning { // Releases the view if it doesn't have a superview. [super didReceiveMemoryWarning]; // Release any cached data, images, etc that aren't in use. } - (void)viewDidUnload { // Release any retained subviews of the main view. // e.g. self.myOutlet = nil; self.listData = nil; self.table = nil; self.search = nil; self.allNames = nil; self.names = nil; self.keys = nil; } - (void)dealloc { [listData release]; [search release]; [table release]; [allNames release]; [keys release]; [names release]; [super dealloc]; } #pragma mark - #pragma mark Table View Data Source Methods - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView { return ([keys count] > 0) ? [keys count] : 1; } - (NSInteger)tableView:(UITableView *)aTableView numberOfRowsInSection: (NSInteger)section { return [self.listData count]; if ([keys count] == 0) return 0; NSString *key = [keys objectAtIndex:section]; NSArray *nameSection = [names objectForKey:key]; return [nameSection count]; } - (UITableViewCell *) extracted_method: (UITableViewCell *) cell { return cell; } - (UITableViewCell *)tableView:(UITableView *)aTableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { NSUInteger section = [indexPath section]; NSUInteger row = [indexPath row]; NSString *key = [keys objectAtIndex:section]; NSArray *nameSection = [names objectForKey:key]; static NSString *sectionsTableIdentifier = @"sectionsTableIdentifier"; UITableViewCell *cell = [aTableView dequeueReusableCellWithIdentifier: sectionsTableIdentifier]; if (cell == nil) { cell = [[[UITableViewCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier: sectionsTableIdentifier] autorelease]; } cell.backgroundColor = [UIColor clearColor]; cell.textColor = [UIColor whiteColor]; cell.detailTextLabel.textColor = [UIColor whiteColor]; cell.text = [nameSection objectAtIndex:row]; [self extracted_method: cell].text = [listData objectAtIndex:row]; return cell; } - (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section { if ([keys count] == 0) return nil; NSString *key = [keys objectAtIndex:section]; return key; } -(NSArray *)sectionIndexTitlesForTableView:(UITableView *)tableView { return keys; } #pragma mark - #pragma mark Table View Delegate Methods - (NSIndexPath *)tableView:(UITableView *)tableView willSelectRowAtIndexPath:(NSIndexPath *)indexPath { [search resignFirstResponder]; return indexPath; } #pragma mark - #pragma mark Search Bar Delegate Methods - (void)searchBarSearchButtonClicked:(UISearchBar *)searchBar { NSString *searchTerm = [searchBar text]; [self handleSearchForTerm:searchTerm]; } - (void)searchBar:(UISearchBar *)searchBar textDidChange:(NSString *)searchTerm { if ([searchTerm length] == 0) { [self resetSearch]; [table reloadData]; return; } [self handleSearchForTerm:searchTerm]; } - (void)searchBarCancelButtonClicked:(UISearchBar *)searchBar { search.text = @""; [self resetSearch]; [table reloadData]; [searchBar resignFirstResponder]; } @end Ok guys. My problem is that this doesnt get the search function to work. In addition I receive siginal SIGABRT at this line: NSString *key = [keys objectAtIndex:section]; So I need help with two things: 1: I need to get that SIGABRT away. Error log message: * Terminating app due to uncaught exception 'NSRangeException', reason: '* -[NSMutableArray objectAtIndex:]: index 0 beyond bounds for empty array' That is I don't store any data in keys. how would I do that? and what would I store? 2: Want the search function to search in my listData array! Thanks in advance - hope u can help!
