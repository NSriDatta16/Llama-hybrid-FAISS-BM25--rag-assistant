[site]: stackoverflow
[post_id]: 2547791
[parent_id]: 2547604
[tags]: 
What you're looking for is a language feature called "return type covariance", which C# doesn't support. You have another option here: you can "shadow" the field instead of inheriting it. However, this is very dangerous and almost universally a bad idea, because anything assigned to an object as B.argument will not be available if it is upcast and referenced as A.argument. If you're on C# 4.0, you can get some aspects of what you're attempting by using a generic covariant interface: public class C { public int foo; } public class D : C { } public class A : ITest { public C foo { get; private set; } } public class B : ITest { public D foo { get; private set; } } public interface ITest where T : C { T foo { get; } } static class Program { public static void Covariance(ITest test) { } static void Main() { A myCVar = new A(); B myDVar = new B(); Covariance(myDVar); } } Note that the Covariance function will accept a B (which is an ITest , not an ITest ), because the ITest interface has marked the T parameter with the keyword out . This tells the compiler that this type parameter will only be used in output operations, so it is safe to substitute any derived class of T when using this interface.
