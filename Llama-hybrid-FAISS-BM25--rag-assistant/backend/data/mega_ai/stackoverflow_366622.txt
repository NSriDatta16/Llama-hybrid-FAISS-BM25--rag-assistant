[site]: stackoverflow
[post_id]: 366622
[parent_id]: 365946
[tags]: 
You could define an extension point and lookup/call your fragment classes via extensions. IExtensionRegistry registry = Platform.getExtensionRegistry(); IExtensionPoint extensionPoint = registry .getExtensionPoint("myplugin.myextension"); IConfigurationElement points[] = extensionPoint .getConfigurationElements(); for (IConfigurationElement point : points) { if ("myextensionFactory".equals(point.getName())) { Object impl = point.createExecutableExtension("class"); if (impl instanceof IMyExtension) { ((IMyExtension) impl).foo(); } } } } EDIT: To use this approach I have to convert my fragments projects to plug-in projects. â€“ bmatthews68 You shouldn't have to. For example, in my test code, I have the following files in the host plugin: META-INF/MANIFEST.MF : Manifest-Version: 1.0 Bundle-ManifestVersion: 2 Bundle-Name: Myplugin Plug-in Bundle-SymbolicName: myplugin;singleton:=true Bundle-Version: 1.0.0 Bundle-Activator: myplugin.Activator Require-Bundle: org.eclipse.core.runtime Eclipse-LazyStart: true Export-Package: myplugin plugin.xml : The fragment contains these files: META-INF/MANIFEST.MF : Manifest-Version: 1.0 Bundle-ManifestVersion: 2 Bundle-Name: Myfragment Fragment Bundle-SymbolicName: myfragment;singleton:=true Bundle-Version: 1.0.0 Fragment-Host: myplugin;bundle-version="1.0.0" fragment.xml : These projects were generated using Eclipse 3.3.1.1.
