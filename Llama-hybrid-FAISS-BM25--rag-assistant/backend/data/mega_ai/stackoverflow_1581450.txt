[site]: stackoverflow
[post_id]: 1581450
[parent_id]: 1581408
[tags]: 
To avoid the warning, you have to check whether or not $n is defined() : if(defined $n) { open my $eng,' while --$n; print scalar ; close $eng; } } else { print "No match found!\n"; } I also rewrote the part that reads English. Rather than reading the entire file in and only using one line of it, it reads in a $n - 1 lines and throws them away, and then prints the next line (for real this time) it reads. This should have the same effect, but with a lower memory impact on large files. (If it doesn't, it's probably an off-by-one error because I'm tired.) EDIT: It turns out this introduced a subtle bug. Your code to find the matching line does the same thing: slurps the file into an array, then finds the array index that matches. Let's convert this code to read line-by-line so that we don't get huge memory consumption issues: open my $fr,' ) { $n = $. if /$query/i; } } I think you understand most of that: while( ) reads line-by-line from $fr and sets each line to $_ for the loop iteration, /$query/i will implicitly match against $_ (which is what we want), but you're probably curious about this little bugger: $n = $. . From perldoc perlvar : HANDLE->input_line_number(EXPR) $INPUT_LINE_NUMBER $NR $. Current line number for the last filehandle accessed. Each filehandle in Perl counts the number of lines that have been read from it. (Depending on the value of $/ , Perl's idea of what constitutes a line may not match yours.) When a line is read from a filehandle (via readline() or <> ), or when tell() or seek() is called on it, $. becomes an alias to the line counter for that filehandle. You can adjust the counter by assigning to $. , but this will not actually move the seek pointer. Localizing $. will not localize the filehandle's line count. Instead, it will localize perl's notion of which filehandle $. is currently aliased to. $. is reset when the filehandle is closed, but not when an open filehandle is reopened without an intervening close(). For more details, see "I/O Operators" in perlop. Because <> never does an explicit close, line numbers increase across ARGV files (but see examples in eof). You can also use HANDLE->input_line_number(EXPR) to access the line counter for a given filehandle without having to worry about which handle you last accessed. (Mnemonic: many programs use "." to mean the current line number.) So if we found a match in your third paragraph, $. would be 3. As a general recommendation, read through the perlvar page every once in a while. There are some gems in there, and even if you don't understand what everything is for, you'll get it on a reread. However, the final thing I have to say is that mobrule's advice about explicitly storing paragraph information is probably the best way to go. I might shy away from a homemade format, but I understand if XML or something is a little to heavyweight for your purposes. (Just know that your purposes are likely to expand greatly if you're not careful).
