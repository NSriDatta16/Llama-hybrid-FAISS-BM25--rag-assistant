[site]: stackoverflow
[post_id]: 5721962
[parent_id]: 5721603
[tags]: 
First off, I note that the exception does not arise until you have exceeded the bounds of a long. How are you going to do that? Each int can be at most about two billion, and the top of a long is about eight billion billion, so that means that you'd have to be taking the average of more than four billion ints minimum in order to trigger the exception. Is that the sort of problem you regularly have to solve? Suppose for the sake of argument it is. Doing the math in doubles loses precision because double arithmetic is rounded off to about fifteen decimal places. Watch: using System; using System.Collections.Generic; static class Extensions { public static double DoubleAverage(this IEnumerable sequence) { double sum = 0.0; long count = 0; foreach(int item in sequence) { ++count; sum += item; } return sum / count; } public static IEnumerable Concat (this IEnumerable seq1, IEnumerable seq2) { foreach(T item in seq1) yield return item; foreach(T item in seq2) yield return item; } } class P { public static IEnumerable Repeat(int x, long count) { for (long i = 0; i Here we average with double arithmetic two series: one that is {a billion, a billion, a billion ... ten million times ... a billion, one, one one... ninety million times} and one that is the same sequence with the ones first and the billions last. If you run the code, you get different results. Not hugely different, but different, and the difference will become larger and larger the longer the sequences get. Long arithmetic is exact; double arithmetic potentially rounds off for every calculation and that means that massive error can accrue over time. It seems very unexpected to do an operation solely on ints that results in an accumulation of floating point rounding error. That's the sort of thing one expected when doing an operation on floats, but not when doing it on ints.
