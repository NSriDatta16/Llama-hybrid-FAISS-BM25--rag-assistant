[site]: stackoverflow
[post_id]: 773166
[parent_id]: 772381
[tags]: 
I'm not sure if this assists with your quest, but one thing I learned rather recently and took to heart is to have your data model's unique identifier implementation not propagate directly outside of the data layer, but to be wrapped in an abstraction. For instance, here is an interface which wraps a model's identifier: public interface IModelIdentifier where T : class { /// /// A string representation of the domain the model originated from. /// string Origin { get; } /// /// The model instance identifier for the model object that this /// refers to. Typically, this /// is a database key, file name, or some other unique identifier. /// The expected data type of the /// identifier. /// KeyDataType GetKey (); /// /// Performs an equality check on the two model identifiers and /// returns true if they are equal; otherwise false /// is returned. All implementations must also override the equal operator. /// /// The identifier to compare against. /// true if the identifiers are equal; otherwise /// false is returned. bool Equals(IModelIdentifier obj); } Your business logic layer, which may have in the past passed around int s as unique identifiers (for instance, from a identity column in your database table), is now passed as such: public IPerson RetrievePerson(IModelIdentifier personId) { /// Retrieval logic here... } Your data layer will then have a class which implements IModelIdentifier and populates its internal data type with the physical model's unique identifier. This insulates your business layer from any changes you may have at the data layer, such as replacing your int key identifiers with Guid s.
