[site]: stackoverflow
[post_id]: 3819707
[parent_id]: 3819564
[tags]: 
You do not specify how you measure the "memory consumption" of your application but perhaps you are using task manager? To get a better view of what is going on I suggest that you examine some performance counters for your application. Both .NET heap and general process memory performance counters are available. If you really want to understand the details of how your application uses memory you can use the Microsoft CLR profiler . What you see may be a result of the .NET heap expanding to accomodate a very large file. Big objects are placed on the Large Object Heap (LOH) and even if the .NET memory is garbage collected the free memory is never returned to the operating system. Also, objects on the LOH are never moved around during garbage collection and this may fragment the LOH exhausting the available address space even though there is plenty of free memory. Has anyone experienced this while using PackagePart? Or am I using it wrong? If you want to control the resources used by the package you are not using it in the best way. Packages are disposable and in general you should use it like this: using (var package = Package.Open(@"c:\test\1000pages.xps", FileMode.Open, FileAccess.ReadWrite, FileShare.None)) { // ... process the package } At the end of the using statement resources consumed by the package are either already released or can be garbage collected. If you really want to keep the _package member of your form you should at some point call Close() (or IDisposable.Dispose() ) to release the resources. Calling GC.Collect() is not recommended and will not necessarily be able to recycle the resources used by the package. Any managed memory (e.g. package buffers) that are reachable from _package will not be garbage collected no matter how often you try to force a garbage collection.
