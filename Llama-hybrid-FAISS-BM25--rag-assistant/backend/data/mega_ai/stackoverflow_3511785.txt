[site]: stackoverflow
[post_id]: 3511785
[parent_id]: 3510614
[tags]: 
If the origin is XML, I suggest to go for a completely different approach: XSL . Facelets is XHTML based. You can easily use XSL to go from XML to XHTML. This is doable with a bit decent Filter which kicks in before JSF is doing the works. Here's a kickoff example. persons.xml one 1 two 2 three 3 persons.xsl Persons JsfXmlFilter which is mapped on of the FacesServlet and assumes that the FacesServlet itself is mapped on an of *.jsf . public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletRequest r = (HttpServletRequest) request; String rootPath = r.getSession().getServletContext().getRealPath("/"); String uri = r.getRequestURI(); String xhtmlFileName = uri.substring(uri.lastIndexOf("/")).replaceAll("jsf$", "xhtml"); // Change this if FacesServlet is not mapped on `*.jsf`. File xhtmlFile = new File(rootPath, xhtmlFileName); if (!xhtmlFile.exists()) { // Do your caching job. String xmlFileName = xhtmlFileName.replaceAll("xhtml$", "xml"); String xslFileName = xhtmlFileName.replaceAll("xhtml$", "xsl"); File xmlFile = new File(rootPath, xmlFileName); File xslFile = new File(rootPath, xslFileName); Source xmlSource = new StreamSource(xmlFile); Source xslSource = new StreamSource(xslFile); Result xhtmlResult = new StreamResult(xhtmlFile); try { Transformer transformer = TransformerFactory.newInstance().newTransformer(xslSource); transformer.transform(xmlSource, xhtmlResult); } catch (TransformerException e) { throw new RuntimeException("Transforming failed.", e); } } chain.doFilter(request, response); } Run by http://example.com/context/persons.jsf and this filter will kick in and transform persons.xml to persons.xhtml using persons.xsl and finally put persons.xhtml there where JSF expect it is. True, XSL has a bit of learning curve, but it's IMO the right tool for the job since the source is XML and destination is XML based as wel. To do the mapping between the form and the managed bean, just use a Map . If you name the input fields like so ... The submitted values will be available by Map keys field1 , field2 , field3 , etc.
