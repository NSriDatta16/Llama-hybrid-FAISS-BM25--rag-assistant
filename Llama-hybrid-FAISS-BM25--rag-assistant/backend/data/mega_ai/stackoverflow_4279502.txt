[site]: stackoverflow
[post_id]: 4279502
[parent_id]: 4269139
[tags]: 
We can do this using a CONTEXT . This is a namespace in session memory which we can use to store values. Oracle comes with a default namespace, 'USERENV', but we can define our own. The context has to be created by a user with the CREATE ANY CONTEXT privilege; this is usually a DBA. The statement references a PACKAGE which sets and gets values in the namespace, but this package does not have to exist in order for the statement to succeed: SQL> create context user_ctx using apc.ctx_pkg 2 / Context created. SQL> Now let's create the package: SQL> create or replace package ctx_pkg 2 as 3 procedure set_user_id(p_userid in varchar2); 4 function get_user_id return varchar2; 5 procedure clear_user_id; 6 end ctx_pkg; 7 / Package created. SQL> There are three methods, to set, get and unset a value in the namespace. Note that we can use one namespace to hold different valiables. I am just using this package to set one variable (USER_ID) in the USER_CTX namespace. SQL> create or replace package body ctx_pkg 2 as 3 procedure set_user_id(p_userid in varchar2) 4 is 5 begin 6 DBMS_SESSION.SET_CONTEXT( 7 namespace => 'USER_CTX', 8 attribute => 'USER_ID', 9 value => p_userid); 10 end set_user_id; 11 12 function get_user_id return varchar2 13 is 14 begin 15 return sys_context('USER_CTX', 'USER_ID'); 16 end get_user_id; 17 18 procedure clear_user_id 19 is 20 begin 21 DBMS_SESSION.CLEAR_CONTEXT( 22 namespace => 'USER_CTX', 23 attribute => 'USER_ID'); 24 end clear_user_id; 25 26 end ctx_pkg; 27 / Package body created. SQL> So, how does this solve anything? Here is a table for the temporary storage of data. I'm going to add a column which will hold a token to identify the user. When we populate the table the value for this column will be provided by CTX_PKG.GET_USER_ID() : SQL> create table temp_23 as select * from big_table 2 where 1=0 3 / Table created. SQL> alter table temp_23 add (user_id varchar2(30)) 2 / Table altered. SQL> create unique index t23_pk on temp_23(user_id, id) 2 / Index created. SQL> ... and over that table I create a view:... create or replace view v_23 as select id , col1 , col2 , col3 , col4 from temp_23 where user_id = ctx_pkg.get_user_id / Now, when I want to store some data in the table I need to set the context with a value with uniquely identifies my user. SQL> exec ctx_pkg.set_user_id('APC') PL/SQL procedure successfully completed. SQL> This statement populates the temporary table with twenty random rows: SQL> insert into temp_23 2 select * from 3 ( select b.*, ctx_pkg.get_user_id 4 from big_table b 5 order by dbms_random.random ) 6 where rownum I can retrieve those rows by querying the view. But when I change my USER_ID and run the same query I cannot see them any more: SQL> select * from v_23 2 / ID COL1 COL2 COL3 COL4 ---------- ---------- ------------------------------ --------- ---------- 277834 1880 GV_$MAP_EXT_ELEMENT 15-OCT-07 4081 304540 36227 /375c3e3_TCPChannelReaper 15-OCT-07 36 1111897 17944 /8334094a_CGCast 15-OCT-07 17 1364675 42323 java/security/PublicKey 15-OCT-07 42 1555115 3379 ALL_TYPE_VERSIONS 15-OCT-07 3 2073178 3355 ALL_TYPE_METHODS 15-OCT-07 3 2286361 68816 NV 15-OCT-07 68 2513770 59414 /5c3965c8_DicomUidDoc 15-OCT-07 59 2560277 66973 MGMT_MNTR_CA 15-OCT-07 66 2700309 45890 /6cc68a64_TrustManagerSSLSocke 15-OCT-07 45 2749978 1852 V_$SQLSTATS 15-OCT-07 6395 2829080 24832 /6bcb6225_TypesTypePair 15-OCT-07 24 3205157 55063 SYS_NTsxSe84BlRX2HiXujasKy/w== 15-OCT-07 55 3236186 23830 /de0b4d45_BaseExecutableMember 15-OCT-07 23 3276764 31296 /a729f2c6_SunJCE_n 15-OCT-07 31 3447961 60129 HHGROUP 15-OCT-07 60 3517106 38204 java/awt/im/spi/InputMethod 15-OCT-07 38 3723931 30332 /32a30e8e_EventRequestManagerI 15-OCT-07 30 3877332 53700 EXF$XPVARCLST 15-OCT-07 53 4630976 21193 oracle/net/nl/NetStrings 15-OCT-07 21 20 rows selected. SQL> exec ctx_pkg.set_user_id('FOX_IN_SOCKS') PL/SQL procedure successfully completed. SQL> select * from v_23 2 / no rows selected SQL> So, the challenges are: to establish a token which you can use automatically to uniquely identify a user to find a hook in your connecting code which can set the context each time the user gets a session just as importantly, to find a hook in your dis-connecting code which can unset the context each time the user leaves a session Also, remember to clear out the table once the user has finished with it.
