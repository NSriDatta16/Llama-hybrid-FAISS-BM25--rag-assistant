[site]: stackoverflow
[post_id]: 1866687
[parent_id]: 1863884
[tags]: 
As it was already mentioned here, LINQ allows to extend any query by simply adding more criteria to it. var query = from x in xs where x==1 select x; if (mustAddCriteria1) query = from x in query where ... // criteria 1 select x; if (mustAddCriteria2) query = from x in query where ... // criteria 2 select x; And so on. This approach works just perfectly. But likely, you know that compilation of LINQ queries is pretty expensive: e.g. Entity Framework can compile just about 500 relatively simple queries per second (see e.g. ORMBattle.NET ). On the other hand, many ORM tools support compiled queries: You pass an IQueryable instance to some Compile method, and get a delegate allowing to execute it much faster later, because no recompilation would occur in this case. But if we'd try to use this approach here, we immediately notice that our query is actually dynamic: IQueryable we execute each time might differ from the previous one. Presence of query parts there is determined by values of external parameters. So can we execute such queries as compiled without e.g. explicit caching? DataObjects.Net 4 support so-called "boolean branching" feature. It implies any constant boolean expression is evaluated during query compilation and its actual value is injected into SQL query as true boolean constant (i.e. not as parameter value or as an expression utilizing parameters). This feature allows to generate different query plans dependently on values of such boolean expressions with ease. E.g. this code: int all = new Random().Next(2); var query = from c in Query .All where all!=0 || c.Id=="ALFKI" select c; will be executed using two different SQL queries, and thus - two different query plans: Query plan based on index seek (quite fast), if all==0 Query plan based on index scan (quite slow), if all!=0 Case when all==null, SQL query: SELECT [a].[CustomerId], 111 AS [TypeId] , [a].[CompanyName] FROM [dbo].[Customers] [a] WHERE(( CAST( 0 AS bit ) <> 0 ) OR( [a].[CustomerId] = 'ALFKI' ) ); Case when all==null, query plan: |--Compute Scalar(DEFINE:([Expr1002]=(111))) |--Clustered Index Seek(OBJECT:([DO40-Tests].[dbo].[Customers].[PK_Customer] AS [a]), SEEK:([a].[CustomerId]=N'ALFKI') ORDERED FORWARD) Second case (when all!=null), SQL query: SELECT [a].[CustomerId], 111 AS [TypeId] , [a].[CompanyName] FROM [dbo].[Customers] [a] WHERE(( CAST( 1 AS bit ) <> 0 ) OR( [a].[CustomerId] = 'ALFKI' ) ); -- Notice the ^ value is changed! Second case (when all!=null), query plan: |--Compute Scalar(DEFINE:([Expr1002]=(111))) |--Clustered Index Scan(OBJECT:([DO40-Tests].[dbo].[Customers].[PK_Customer] AS [a])) -- There is index scan instead of index seek! Note that almost any other ORM would compile this to a query utilizing integer parameter: SELECT [a].[CustomerId], 111 AS [TypeId] , [a].[CompanyName] FROM [dbo].[Customers] [a] WHERE(( @p <> 0 ) OR ( [a].[CustomerId] = 'ALFKI' ) ); -- ^^ parameter is used here Since SQL Server (as well as most of databases) generates a single version of query plan for a particular query, it has the only option in this case - generate a plan with index scan: |--Compute Scalar(DEFINE:([Expr1002]=(111))) |--Clustered Index Scan(OBJECT:([DO40-Tests].[dbo].[Customers].[PK_Customer] AS [a]), WHERE:(CONVERT(bit,[@p],0)<>(0) OR [DO40-Tests].[dbo].[Customers].[CustomerId] as [a].[CustomerId]=N'ALFKI')) Ok, that was a "quick" explanation of usefulness of this feature. Let's return back to your case now. Boolean branching allows to implement it in very simple fashion: var categoryId = 1; var userId = 1; var query = from product in Query .All let skipCategoryCriteria = !(categoryId > 0) let skipUserCriteria = !(userId > 0) where skipCategoryCriteria ? true : product.Category.Id==categoryId where skipUserCriteria ? true : ( from order in Query .All from detail in order.OrderDetails where detail.Product==product select true ).Any() select product; The example differs from yours, but it illustrates the idea. I used different model mainly to be able to test this (my example is based om Northwind model). This query is: Not a dynamic query, so you can safely pass it to Query.Execute(...) method to get it executed as compiled query. Nevertheless each its execution will lead to the same result as if this would be done with "appending" to IQueryable .
