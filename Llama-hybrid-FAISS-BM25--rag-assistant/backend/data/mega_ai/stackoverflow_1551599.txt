[site]: stackoverflow
[post_id]: 1551599
[parent_id]: 1229751
[tags]: 
The short answer is yes, it could affect. char and unsigned char are convertible types (3.9.1 in C++ Standard 0x n2800) so you can assign one to the other. You don't need the cast at all. [3.9.1] ... A char, a signed char, and an unsigned char occupy the same amount of storage and have the same alignment requirements; that is, they have the same object representation . [4.7] ... 2 If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source integer (modulo 2n where n is the number of bits used to represent the unsigned type). [ Note: In a two’s complement representation, this conversion is conceptual and there is no change in the bit pattern (if there is no truncation). —end note ] 3 If the destination type is signed, the value is unchanged if it can be represented in the destination type (and bit-field width); otherwise, the value is implementation-defined. Therefore even in the worst case you will get the best (less implementation-defined) conversion. Anyway in most implementations this will not change anything in the bit pattern, and you will not even have a conversion if look into the generated assembler. template char *copy_binary( unsigned char length, const ITER_T& begin) { char* stg = alloc_storage(length); std::copy(begin, begin + length, stg); return stg; } Using reinterpret_cast you depend on the compiler: [5.2.10.3] The mapping performed by reinterpret_cast is implementation-defined . [ Note: it might, or might not, produce a representation different from the original value. —end note ] Note: This is an interesting related post.
