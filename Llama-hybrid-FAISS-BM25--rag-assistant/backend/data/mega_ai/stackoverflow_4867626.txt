[site]: stackoverflow
[post_id]: 4867626
[parent_id]: 4867341
[tags]: 
Just based on simple experimentation with code like: _w= ['a', 'b', 'c', 'd', 'e'] d= {} w= [] for k in xrange(123): for word in _w: wk= word+ str(k) d[wk]= k w.append(wk) def m1(): for word in w: if word in d: pass def m2(n= 1): dk= d.keys() for word in w: if word in dk: pass and timings: In []: len(w) Out[]: 5 In []: %timeit m1() 1000000 loops, best of 3: 657 ns per loop In []: %timeit m2() 1000000 loops, best of 3: 1.55 us per loop In []: len(w) Out[]: 615 In []: %timeit m1() 10000 loops, best of 3: 49.2 us per loop In []: %timeit m2() 100 loops, best of 3: 5.62 ms per loop The conclusion will be that m1() is a clear winner (as expected ;-). OK, this is not really a proof (in a strict sense) of the superiority of m1() . There still exist a slight chance that someone will figure out a set of keys where m1() and m2() execution times are near each other (but I can't figure out any case where m1() would be actually much worse than m2() ). In practice m1() approach allways wins. It's allways engouraged to try out first hard facts of the alternative approaches, then if something contradicts your expectations you'll be more prepared to find why it happens.
