[site]: stackoverflow
[post_id]: 4009587
[parent_id]: 
[tags]: 
Problem in accepting connection from client (socket programming) in Visual C++

I have written a simple single threaded client server application in Visual C++ . When I run my server I wait for some time that it accepts some request from the client. When I connect the client to the server. The log message on the client reports 14 bytes are send and there is no message on the server. I have written a print statement to print whatever is accepted by the server on the console, but the server doesn't print anything. It seems to me like the client has connected to some other server. The client and server code is below. Server code #ifndef WIN32_LEAN_AND_MEAN #define WIN32_LEAN_AND_MEAN #endif #include #include #include #include #include #include #define DEFAULT_PORT "27015" #define DEFAULT_BUFLEN 512 #pragma comment(lib, "Ws2_32.lib") int main() { WSADATA wsdata; int result = WSAStartup(MAKEWORD(2,2),&wsdata); if (result != 0){ printf("%s","Unable to initilize windows socket\n"); getch(); return 1; } struct addrinfo *addrResult = NULL,hints; ZeroMemory(&hints, sizeof (hints)); hints.ai_family = AF_INET; hints.ai_socktype = SOCK_STREAM; hints.ai_protocol = IPPROTO_TCP; hints.ai_flags = AI_PASSIVE; result = getaddrinfo(NULL,DEFAULT_PORT,&hints,&addrResult); if (result != 0){ printf("%s","Error in getaddrInfo"); getch(); return 1; } SOCKET listenSocket = INVALID_SOCKET; listenSocket = socket(addrResult->ai_family,addrResult->ai_socktype,addrResult->ai_protocol); if (listenSocket == INVALID_SOCKET){ printf("%s","Error in creating socket object\n"); getch(); closesocket(listenSocket); WSACleanup(); return 1; } sockaddr_in service; service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr("127.0.0.1"); service.sin_port = htons(27015); if (bind(listenSocket,addrResult->ai_addr, (int)addrResult->ai_addrlen) == SOCKET_ERROR){ //if(bind(listenSocket,(SOCKADDR*) &service, // sizeof(service)) == SOCKET_ERROR){ printf("bind failed: %d\n", WSAGetLastError()); freeaddrinfo(addrResult); closesocket(listenSocket); WSACleanup(); getch(); return 1; } freeaddrinfo(addrResult); if (listen(listenSocket,SOMAXCONN) == SOCKET_ERROR){ printf("%s","Error in listening socket"); getch(); closesocket(listenSocket); WSACleanup(); } SOCKET clientSocket = INVALID_SOCKET; clientSocket = accept((listenSocket,NULL,NULL); if (clientSocket == INVALID_SOCKET){ closesocket(listenSocket); WSACleanup(); } char recvbuf[DEFAULT_BUFLEN]; int iRecvResult, iSendResult; int recvbuflen = DEFAULT_BUFLEN; do{ iRecvResult = 0; iSendResult = 0; iRecvResult = recv(clientSocket,recvbuf,recvbuflen,0); if (iRecvResult > 0){ printf("Bytes received: %d\n", iRecvResult); getch(); // Echo the buffer back to the sender iSendResult = send(clientSocket, recvbuf, iRecvResult, 0); if (iSendResult == SOCKET_ERROR) { printf("send failed: %d\n", WSAGetLastError()); closesocket(clientSocket); WSACleanup(); return 1; } printf("Bytes sent: %d\n", iSendResult); } else if (iRecvResult == 0){ printf("Connection closing...\n"); } else{ printf("recv failed: %d\n", WSAGetLastError()); closesocket(clientSocket); WSACleanup(); return 1; } }while(iRecvResult > 0); getch(); return 0; } Client code #ifndef WIN32_LEAN_AND_MEAN #define WIN32_LEAN_AND_MEAN #endif #include #include #include #include #include #include #define DEFAULT_PORT "27015" #define DEFAULT_BUFLEN 512 #pragma comment(lib, "Ws2_32.lib") int main(){ WSADATA wsdata; WSAStartup(MAKEWORD(2,2),&wsdata); struct addrinfo *addrResult = NULL,hints; ZeroMemory(&hints, sizeof (hints)); hints.ai_protocol = IPPROTO_TCP; hints.ai_socktype = SOCK_STREAM; hints.ai_family = AF_UNSPEC; int result = 0; if (getaddrinfo("127.0.0.1",DEFAULT_PORT, &hints,&addrResult)){ printf("%s","Error in getaddrInfo\n"); WSACleanup(); getch(); return 1; } SOCKET connectingSocket = INVALID_SOCKET; connectingSocket = socket(addrResult->ai_family,addrResult->ai_socktype, addrResult->ai_protocol); if (connectingSocket == INVALID_SOCKET){ printf("%s","Error in creating socket\n"); freeaddrinfo(addrResult); WSACleanup(); getch(); return 1; } if (connect(connectingSocket,addrResult->ai_addr, (int)addrResult->ai_addrlen) != 0){ closesocket(connectingSocket); connectingSocket = INVALID_SOCKET; WSACleanup(); } freeaddrinfo(addrResult); int recvbuflen = DEFAULT_BUFLEN; char *sendbuf = "this is a test"; char recvbuf[DEFAULT_BUFLEN]; int iResult; // Send an initial buffer iResult = send(connectingSocket, sendbuf, (int) strlen(sendbuf), 0); if (iResult == SOCKET_ERROR) { printf("send failed: %d\n", WSAGetLastError()); closesocket(connectingSocket); WSACleanup(); return 1; } printf("Bytes Sent: %ld\n", iResult); // shutdown the connection for sending since no more data will be sent // the client can still use the connectingSocket for receiving data iResult = shutdown(connectingSocket, SD_SEND); if (iResult == SOCKET_ERROR) { printf("shutdown failed: %d\n", WSAGetLastError()); closesocket(connectingSocket); WSACleanup(); return 1; } // Receive data until the server closes the connection do { iResult = recv(connectingSocket, recvbuf, recvbuflen, 0); if (iResult > 0) printf("Bytes received: %d\n", iResult); else if (iResult == 0) printf("Connection closed\n"); else printf("recv failed: %d\n", WSAGetLastError()); } while (iResult > 0); getch(); return 0; }
