[site]: crossvalidated
[post_id]: 500610
[parent_id]: 500498
[tags]: 
What is happening is that prophet is unable to detect the seasonality of the data automatically. This is not unexpected. Usually we define the seasonality manually or indirectly (e.g. when we see argument like yearly.seasonality=TRUE ). In both of the fitted models presented the algorithm assumes as linear evolution of the existing trend. Just in the case of 6000 samples prophet can detect the mean trend more effectively that in the case of having 1000 samples. In both cases, we fail to detect a relevant periodicity. In order to make our model fit our data more explicitly we need to define the periodicity terms ourselves. There are a number of ways to find the periodicity of signal. The most common way is through a signal's Fourier transform . We can examine the periodogram of our signal, find the frequency with the maximal spectral density and then inverse that frequency to get the corresponding period $T$ . A second simple way would be to calculate the average difference solution between successive local maxima assuming our signal is smooth enough. A third "funky" way, if we already know we have a single periodic component would be to try to fit an linear model with a periodic term of period $T$ and then pick the $T$ corresponding to the maximum likelihood. So code-wise: numDays = 6000 set.seed(10000) t = (1:numDays) y = sin( t/100 ) + rnorm(numDays)/4 # Using spectral decomposition / Fourier y_spec = stats::spectrum(y) T_F = 1/y_spec $freq[which.max(y_spec$ spec)] # 600 # Using a custom LM to test different periods T_LM = optim(par=c(30), # some starting value fn=function(x){-logLik( # Define an linear model with a periodic term of T=x[1] lm( y ~ sin(2*pi*t/x[1]) + cos(2*pi*t/x[1])) ) }, method="Brent", lower=2, upper=1000)$par # 628 print(paste0("Fourier Decomp. suggests seasonality of: ", T_F, " days and LM seasonality of: ", round(T_LM,1), " days.")) # "Fourier Decomp. suggests seasonality of: 600 days and LM seasonality of: 628.6 days." Based on the above can see that we have a periodicity of ~628 days. prophet allows us to define customer seasonality terms using the add_seasonlity function. As such we can redefine our modelling procedure f like: f = function(numDays){ set.seed(10000) startDate = as.Date('2000-01-01') endDate = startDate + numDays - 1 history In which case prophet is directly able to fit the periodicity in our data. Both for our 6000 samples: and our 1000 samples: As we see there was nothing wrong with our "randomly generated data" in any way. The data just did not fit the rather specific periodic cycles prophet accounts for automatically. In some cases, prophet is presented as a forecasting silver bullet; it is not. It is an excellent procedure and it has main automated goodies (e.g. weekly and monthly seasonality checks). We need though to be aware of what we try to predict/forecast and the underlying nature of our problem.
