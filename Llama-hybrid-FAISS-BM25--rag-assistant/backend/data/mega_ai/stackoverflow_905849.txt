[site]: stackoverflow
[post_id]: 905849
[parent_id]: 905818
[tags]: 
You can use a CLR user-defined aggregate to get such results. The user-defined aggregate can be invoked like the user-defined ones (e.g. SUM or MAX) and it doesn't use a cursor. using System; using System.Data; using Microsoft.SqlServer.Server; using System.Data.SqlTypes; using System.IO; using System.Text; [Serializable()] [SqlUserDefinedAggregate( Format.UserDefined, IsInvariantToNulls=true, IsInvariantToDuplicates=false, IsInvariantToOrder=false, MaxByteSize=8000)] public class Concat : IBinarySerialize { #region Private fields private string separator; private StringBuilder intermediateResult; #endregion #region IBinarySerialize members public void Read(BinaryReader r) { this.intermediateResult = new StringBuilder(r.ReadString()); } public void Write(BinaryWriter w) { w.Write(this.intermediateResult.ToString()); } #endregion #region Aggregation contract methods public void Init() { this.separator = ", "; this.intermediateResult = new StringBuilder(); } public void Accumulate(SqlString pValue) { if (pValue.IsNull) { return; } if (this.intermediateResult.Length > 0) { this.intermediateResult.Append(this.separator); } this.intermediateResult.Append(pValue.Value); } public void Merge(Concat pOtherAggregate) { this.intermediateResult.Append(pOtherAggregate.intermediateResult); } public SqlString Terminate() { return this.intermediateResult.ToString(); } #endregion } In this posts you'll find the code as well as my solution of debugging problems I encountered. I used this aggregate in production environment and it performed really well.
