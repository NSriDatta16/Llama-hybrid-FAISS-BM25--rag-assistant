[site]: stackoverflow
[post_id]: 4251594
[parent_id]: 4216139
[tags]: 
Ok, I think I have a possible solution for you. Keep in mind that I am a complete neophyte in this area so no warranties that his a) works b) is a decent solution c) won't make a "real" programmer toss their lunch. What I did was convert the entire ancestor tree of a particular item into a text list of row column pairs. (i.e. list the row and column of the dragged item, the row and column of its parent, the row and column of its parent's parent, etc... till we get to an invalid index - i.e. the root) This looks something like this (this example shows that the dragged item is four levels deep): 2;0,1;0,5;0,1,0 ^ ^ ^ ^ | | | | | | | great grandparent (and child of the root item) | | | | | grandparent | | | parent | item being dragged Later, in the dropMimeData function, I reverse the list (so that it reads from the root back down to the item being dragged) and build the indexes one at a time till I get back to the originally dragged item. Here are the snippets of code that make that all work. Again, I can't warrantee that this is a good idea, just that it appears to work and does not require that you serialize your python objects into a ByteArray. Hope this helps. #--------------------------------------------------------------------------- def mimeTypes(self): """ Only accept the internal custom drop type which is plain text """ types = QtCore.QStringList() types.append('text/plain') return types #--------------------------------------------------------------------------- def mimeData(self, index): """ Wrap the index up as a list of rows and columns of each parent/grandparent/etc """ rc = "" theIndex = index[0] #
