[site]: stackoverflow
[post_id]: 3860550
[parent_id]: 3860423
[tags]: 
For each operation you want to be able to undo (i.e. presumably insert, backspace and del, but not the cursor movements), we can list the "undo" procedure: insert -> position the cursor at that character and issue a del del -> position the cursor at the following character and issue an insert backspace -> position the cursor at the following character and issue an insert Unfortunately, your cursors use pointers, and when you undo a delete/backspace the newly allocated CNode may not be at the same address as previously, which could invalidate an earlier undo step trying to use that pointer address. Options include: some additional data structures to track which pointers have been invalidated in this way, and repopulate them with new values if the corresponding elements are recreated (painful) find a more deterministic way to find the correct index in the CNode list an absolute index into the document (but that may be difficult to calculate and slow to move to) save your cursor movement in your undo history mixing 10 substantive edits (del, backspace, insert) with an arbitrary number of interspersed cursor movements requires a dynamically sized container, and you'd be carrying quite a bit of "verbose baggage" you could hang a dynamic list of cursor movements off each element in a fixed-sized list of each substantive edit (not much better though) (As is, your Cnode list doesn't appear double-linked, so I don't see how you can move left without a very painful reiteration through the "document" from the header element...?) After sorting out this indexing/cursor-movement issue, you must decide between: after each operation, use a deque to save the undo information: struct History { an indicator of which operation to undo (e.g. enum Op { left, right, insert, del... }) only for insert operations: an object value } then have some on-undo processing function that reads these History records and coordinates the operations they describe, or when an operation is performed, push a function object onto your deque that encodes the undo and redo operations (in terms of calls to the Cursor object methods), so that actually doing an undo or redo operation just involves executing that object (i.e. the undo/redo operation is a "black box" parcelled up at edit time) / this is more elegant and flexible, but probably less familiar to beginning/intermediate programmers so may be harder to get right. The boost library has good supporting functions for this.
