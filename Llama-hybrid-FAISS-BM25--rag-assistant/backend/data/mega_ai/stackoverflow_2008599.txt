[site]: stackoverflow
[post_id]: 2008599
[parent_id]: 
[tags]: 
C++ vector push_back() overwrites on another vector of the same type?

I defined a class named nth_best_parse this way: class nth_best_parse { public: int traversal; int nth_best_active; int nth_best_passive; double viterbi_prob; nth_best_parse(); nth_best_parse(int t, int nbl, int nbr, double v) {traversal = t; nth_best_active = nbl; nth_best_passive = nbr; viterbi_prob = v;} }; Then I declared vectors of this nth_best_parse as members of two different classes: class Edge { // an edge associates an Earley style dotted-item with a span public: Span span; // Span of the edge bool isActive; vector leading_traversals; // The list of traversals which lead to parsing of this edge vector n_best_parses; union { DottedRule rule_state; // Accessed if isActive is true int symbol; // Accessed if isActive is false // A symbol corresponding to the category of a passive edge // Put inside this union to save space }; inline int span_length() {return span.end - span.start;} }; class BPCFGParser { public: // Some data structures used in intermediary computations for calculating the n-best parses // vector > nth_best_pairs; vector > n_best_pairs_for_traversals; void compute_n_best_parses(Edge *e, int n); } Then I run this program with gdb (by the way, I'm using Linux Ubuntu 9.04, g++ 4.3.3,GNU gdb 6.8-debian) and set a breakpoint at the end of the definition of compute_n_best_parses() with some conditions (to locate the exact call of this function I wanted, I was tracing back from a segmentation fault). When gdb hit the breakpoint, I issued a set of commands and the gdb output was like this: (gdb) print e->n_best_parses.size() $27 = 1 (gdb) print e->n_best_parses[0] $28 = (nth_best_parse &) @0x1e96240: {traversal = 0, nth_best_active = 0, nth_best_passive = 0, viterbi_prob = 0.16666666666666666} (gdb) print e->n_best_parses[0].traversal $29 = 0 (gdb) print &(e->n_best_parses[0].traversal) $30 = (int *) 0x1e96240 (gdb) awatch *$30 Hardware access (read/write) watchpoint 6: *$30 (gdb) print e->n_best_parses $31 = { >> = { _M_impl = { > = { > = { }, }, _M_start = 0x1e96240, _M_finish = 0x1e96258, _M_end_of_storage = 0x1e96288}}, } (gdb) continue Continuing. Hardware access (read/write) watchpoint 6: *$30 Old value = 0 New value = 1 0x0000000000408a4c in __gnu_cxx::new_allocator ::construct (this=0x1e96208, __p=0x1e96240, __args#0=@0x7fff8ad82260) at /usr/include/c++/4.3/ext/new_allocator.h:114 114 { ::new((void *)__p) _Tp(std::forward (__args)...); } (gdb) backtrace #0 0x0000000000408a4c in __gnu_cxx::new_allocator ::construct (this=0x1e96208, __p=0x1e96240, __args#0=@0x7fff8ad82260) at /usr/include/c++/4.3/ext/new_allocator.h:114 #1 0x000000000042169c in std::vector >::push_back (this=0x1e96208, __args#0=@0x7fff8ad82260) at /usr/include/c++/4.3/bits/stl_vector.h:703 #2 0x0000000000402bef in BPCFGParser::compute_n_best_parses (this=0x7fff8ad82770, e=0x7f5492858b78, n=3) at BPCFGParser.cpp:639 #3 0x00000000004027fd in BPCFGParser::compute_n_best_parses (this=0x7fff8ad82770, e=0x7f5492859d58, n=3) at BPCFGParser.cpp:606 #4 0x00000000004027fd in BPCFGParser::compute_n_best_parses (this=0x7fff8ad82770, e=0x7f549285a1d0, n=3) at BPCFGParser.cpp:606 #5 0x00000000004064d8 in main () at experiments.cpp:75 Line 639 of BPCFGParser.cpp was like this: PUSH_BEST_PAIR_FOR_TRAVERSAL(i,row,column,grammar->probs[temp_rule.symbol][temp_rule.expansion]); This was a macro defined at the beginning of the file as: #define PUSH_BEST_PAIR_FOR_TRAVERSAL(x,y,z,t) n_best_pairs_for_traversals[x].push_back(nth_best_parse(x, y, z, e->leading_traversals[x]->active_edge->n_best_parses[y].viterbi_prob * e->leading_traversals[x]->passive_edge->n_best_parses[z].viterbi_prob * t)) By the way, class Traversal is defined as: class Traversal { // Class for a traversal public: Edge *active_edge; Edge *passive_edge; Traversal(); Traversal(Edge *a, Edge *p) {active_edge = a; passive_edge = p;} }; So actually I'm pushing something to the vector n_best_pairs_for_traversals, which is a member of an instance of the class BPCFGParser and the push_back() code somehow overwrites on the vector n_best_parses, which is a member of an instance of the class Edge. How can this ever be possible?
