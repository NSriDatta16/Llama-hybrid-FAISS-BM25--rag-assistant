[site]: stackoverflow
[post_id]: 4696828
[parent_id]: 4695806
[tags]: 
First, standard formatting: (defun breadth (list y) (setf l y) (mapcar #'(lambda (element) (when (listp element) (when (> (breadth element (length element)) l) (setf l (breadth element (length element)))))) list) l) (defun max-breadth (list) (breadth list (length list))) Your problem is the (setf l y) , which should give you a warning about l being undefined. Setf should not be used on unbound variables. Use let to make a lexical scope: (defun breadth (list y) (let ((l y)) (mapcar #'(lambda (element) (when (listp element) (when (> (breadth element (length element)) l) (setf l (breadth element (length element)))))) list) l)) Then, instead of two nested when , use a single one and and : (when (and (listp element) (> (breadth element (length element)) 1)) (setf l (breadth element (length element)))) I find dolist more concise here: (dolist (element list) (when (and (listp element) (> (breadth element (length element)) l)) (setf l (breadth element (length element))))) The parameter y is always the length of the parameter list , so this call can be simplified. You also do not need to alias y : (defun breadth (list &aux (y (length list))) (dolist (element list) (when (and (listp element) (> (breadth element) y)) (setf y (breadth element)))) y) You could eliminate the double recursive call through a let , but we can use max here: (defun breadth (list &aux (y (length list))) (dolist (element list) (when (listp element) (setf y (max y (breadth element))))) y) You could also use reduce for this: (defun breadth (l) (if (listp l) (reduce #'max l :key #'breadth :initial-value (length l)) 0))
