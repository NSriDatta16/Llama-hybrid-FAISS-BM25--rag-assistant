[site]: stackoverflow
[post_id]: 4898618
[parent_id]: 
[tags]: 
how does printf know the address of a CString's character data?

Considering this code fragment: struct My { operator const char*()const{ return "my"; } } my; CStringA s( "aha" ); printf("%s %s", s, my ); // another variadic function to get rid of comments about printf :) void foo( int i, ... ) { va_list vars; va_start(vars, i); for( const char* p = va_arg(vars,const char*) ; p != NULL ; p=va_arg(vars,const char*) ) { std::cout This snippet results in the 'intuitive' output "aha". But I haven't got a clue how this can work: if the variadic-function call is translated into pushing the pointers of the arguments, printf will receive a CStringA* that is interpreted as a const char* if the variadic-function call is calling operator (const char*) on it, why wouldn't it do so for my own class? Can someone explain this? EDIT: added a dummy variadic function that treats it's arguments as const char* s. Behold - it even crashes when it reaches the my argument...
