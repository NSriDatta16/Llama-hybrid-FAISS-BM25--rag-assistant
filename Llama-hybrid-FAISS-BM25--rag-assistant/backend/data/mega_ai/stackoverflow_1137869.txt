[site]: stackoverflow
[post_id]: 1137869
[parent_id]: 
[tags]: 
How to handle type redundancy in external libraries?

I'm writing a computer graphics application that makes use of several different libraries that provide many of the required features. For example, in college I wrote quaternion, optimized 3 vector, and optimized 4x4 matrix classes that I like to use since they are efficient and I'm very familiar with them. I also wrote a K-D Tree implementation that only depends on the STL. Finally, I'm using ITK to compute the minimum eigenvalue (and associated eigenvector) of a given symmetric real matrix, among other things. With all of these libraries containing their own matrix and vector implementations, I find myself doing a lot of this sort of thing: FixedPointType closestPointCoords; KdTree::HyperPoint target(3); target[0] = transformedPoint[0]; target[1] = transformedPoint[1]; target[2] = transformedPoint[2]; KdTree::Neighbor result = FixedPointTree.FindNearestNeighbor(target); minimumDistance = result.GetDistance(); closestPointCoords[0] = result.GetPoint().Get(0); closestPointCoords[1] = result.GetPoint().Get(1); closestPointCoords[2] = result.GetPoint().Get(2); Obviously I could write a function that looks something like: FixedPointType ConvertHyperPointToFixedPointType(const KdTree::HyperPoint &p) { FixedPointType fixedPoint; fixedPoint[0] = p[0]; fixedPoint[1] = p[1]; fixedPoint[2] = p[2]; return fixedPoint; } I'd like to avoid adding inter-library dependancy by doing something like this: class HyperPoint { ... operator FixedPointType() { // Same content as ConvertHyperPointToFixedPointType above } ... }; But I'm wondering if anyone has come up with a more elegant solution to this problem. Perhaps I should take a page out of the .NET book and create a static Convert class? How have you handled type redundancy across libraries and the need to frequently convert between the various types? Is the Adapter pattern appropriate here? UPDATE After some more exploring I came across TypeConverter . So this problem looks like it's been addressed in C#. I'm still looking for a clean, efficient and simple way to do it in C++. So far I'm thinking the canonical types, or maybe just the bare ConvertHyperPointToFixedPointType kind of functions. UPDATE 2 After even more reading it sounds like the canonical type will actually act as the shim. See this paper for more info. Here's some sample code to illustrate my current inclination: class VectorConverter { public: VectorConverter(const VectorImp1 &v1) { _data[0] = v1[0]; _data[1] = v1[1]; _data[2] = v1[2]; } VectorConverter(const VectorImp2 &v2) { _data[0] = v2.Get(0); _data[1] = v2.Get(1); _data[2] = v2.Get(2); } operator VectorImp1() { return VectorImp1(_data[0], _data[1], _data[2]); } operator VectorImp2() { VectorImp2 v2; v2.Set(0, _data[0]); v2.Set(1, _data[1]); v2.Set(2, _data[2]); return v2; } // actual vector implementation goes here or a wrapper around an existing one }; // example usage VectorImp1 closestPointCoords, target; // for the sake of illustration I included the cast, but you could implicitly cast KdTree::Neighbor result = FixedPointTree.FindNearestNeighbor((VectorImp2)VectorConverter(target)); minimumDistance = result.GetDistance(); closestPointCoords = (VectorImp1)VectorConverter(result.GetPoint()); Thanks for all your help. Feel free to update this post if someone comes across something better.
