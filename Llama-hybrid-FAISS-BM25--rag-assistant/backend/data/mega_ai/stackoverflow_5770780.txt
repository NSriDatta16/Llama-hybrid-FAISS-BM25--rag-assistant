[site]: stackoverflow
[post_id]: 5770780
[parent_id]: 4191840
[tags]: 
Here's another solution; define a protocol (e.g. PopoverSensitiveController) that has only one method: #import "Foundation/Foundation.h" @protocol PopoverSensitiveController -(void) setIsInPopover:(BOOL) inPopover; @end A view controller that wants to know if it is in a popover then defines a property isInPopover; for example: #import #import "PopoverSensitiveController.h" #pragma mark - #pragma mark Interface @interface MyViewController : UIViewController { } #pragma mark - #pragma mark Properties @property (nonatomic) BOOL isInPopover; #pragma mark - #pragma mark Instance Methods ...other stuff... @end Finally, in the splitView delegate (the assumption is that your app uses a split view controller): #import "MySplitViewControllerDelegate.h" #import "SubstitutableDetailViewController.h" #import "PopoverSensitiveController.h" #pragma mark - #pragma mark Implementation @implementation MySplitViewControllerDelegate #pragma mark - #pragma mark UISplitViewControllerDelegate protocol methods -(void) splitViewController:(UISplitViewController *) splitViewController willHideViewController:(UIViewController *) aViewController withBarButtonItem:(UIBarButtonItem *) barButtonItem forPopoverController:(UIPopoverController *) pc { // Keep references to the popover controller and the popover button, and tell the detail view controller to show the button popoverController = [pc retain]; popoverButtonItem = [barButtonItem retain]; if ([[splitViewController.viewControllers objectAtIndex:1] respondsToSelector:@selector(showRootPopoverButtonItem:)]) { UIViewController *detailViewController = [splitViewController.viewControllers objectAtIndex:1]; [detailViewController showRootPopoverButtonItem:barButtonItem]; } if ([[splitViewController.viewControllers objectAtIndex:1] respondsToSelector:@selector(showRootPopoverButtonItem:)]) { UIViewController *detailViewController = [splitViewController.viewControllers objectAtIndex:1]; [detailViewController showRootPopoverButtonItem:barButtonItem]; } // If the view controller wants to know, tell it that it is a popover if ([aViewController respondsToSelector:@selector(setIsInPopover:)]) { [(id) aViewController setIsInPopover:YES]; } // Make sure the proper view controller is in the popover controller and the size is as requested popoverController.contentViewController = aViewController; popoverController.popoverContentSize = aViewController.contentSizeForViewInPopover; } -(void) splitViewController:(UISplitViewController *) splitViewController willShowViewController:(UIViewController *) aViewController invalidatingBarButtonItem:(UIBarButtonItem *) barButtonItem { // Tell the detail view controller to hide the button. if ([[splitViewController.viewControllers objectAtIndex:1] respondsToSelector:@selector(invalidateRootPopoverButtonItem:)]) { UIViewController *detailViewController = [splitViewController.viewControllers objectAtIndex:1]; [detailViewController invalidateRootPopoverButtonItem:barButtonItem]; } // If the view controller wants to know, tell it that it is not in a popover anymore if ([aViewController respondsToSelector:@selector(setIsInPopover:)]) { [(id) aViewController setIsInPopover:NO]; } // Now clear out everything [popoverController release]; popoverController = nil; [popoverButtonItem release]; popoverButtonItem = nil; } -(void) setPopoverButtonForSplitViewController:(UISplitViewController *) splitViewController { // Deal with the popover button UIViewController *detailViewController = [splitViewController.viewControllers objectAtIndex:1]; [detailViewController showRootPopoverButtonItem:popoverButtonItem]; // If the view controller wants to know, tell it that it is a popover (initialize the controller properly) if ([[splitViewController.viewControllers objectAtIndex:0] respondsToSelector:@selector(setIsInPopover:)]) { [(id) [splitViewController.viewControllers objectAtIndex:0] setIsInPopover:YES]; } } Then where ever in the view controller you want to know if you are in a popover, simply use the isInPopover property.
