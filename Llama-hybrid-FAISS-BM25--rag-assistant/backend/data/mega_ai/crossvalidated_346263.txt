[site]: crossvalidated
[post_id]: 346263
[parent_id]: 341430
[tags]: 
Answer my question Recall that $V^{\pi}$ satisfies the following linear equation: $$V^{\pi}(s) = \sum_{s'} P(s,\pi(s),s')[ R(s,\pi(s),s') + \gamma V^{\pi}(s')]$$ the code can be def compute_vpi(mdp, policy, gamma, num_iter=1000, min_difference=1e-5): """ Computes V^pi(s) FOR ALL STATES under given policy. :param policy: a dict of currently chosen actions {s : a} :returns: a dict {state : V^pi(state) for all states} """ # YOUR CODE HERE index_s = {i: s for i, s in enumerate(mdp.get_all_states())} s_index = {s: i for i, s in enumerate(mdp.get_all_states())} ns = len(mdp.get_all_states()) a, b = np.zeros((ns, ns)), np.zeros(ns) for i in range(ns): b_v = 0 state = index_s[i] a[i][i] = 1 - mdp.get_transition_prob(state, policy[state], state) * gamma for s_prime in mdp.get_next_states(state, policy[state]): if s_prime == state: continue a[i][s_index[s_prime]] = \ -mdp.get_transition_prob(state, policy[state], s_prime) * gamma b_v += mdp.get_transition_prob(state, policy[state], s_prime) *\ mdp.get_reward(state, policy[state], s_prime) b[i] = b_v solution = np.linalg.solve(a, b) return {index_s[i]: v for i, v in enumerate(solution)} The best practice to solve the equation is to build a matrix a and b and loop in each state and each entry of the matrix a, and b to update corresponding values.
