[site]: stackoverflow
[post_id]: 4261074
[parent_id]: 4260464
[tags]: 
Yes, removing a Foo* from a container destroys the Foo* , but it will not release the Foo . Destroying a raw pointer is always a no-op. It cannot be any other way! Let me give you several reasons why. Storage class Deleting a pointer only makes sense if the pointee was actually allocated dynamically, but how could the runtime possibly know whether that is the case when the pointer variable is destroyed? Pointers can also point to static and automatic variables, and deleting one of those yields undefined behavior . { Foo x; Foo* p = &x; Foo* q = new Foo; // Has *q been allocated dynamically? // (The answer is YES, but the runtime doesn't know that.) // Has *p been allocated dynamically? // (The answer is NO, but the runtime doesn't know that.) } Dangling pointers There is no way to figure out whether the pointee has already been released in the past. Deleting the same pointer twice yields undefined behavior . (It becomes a dangling pointer after the first delete.) { Foo* p = new Foo; Foo* q = p; // Has *q already been released? // (The answer is NO, but the runtime doesn't know that.) // (...suppose that pointees WOULD be automatically released...) // Has *p already been released? // (The answer WOULD now be YES, but the runtime doesn't know that.) } Uninitialized pointers It is also impossible to detect whether a pointer variable has been initialized at all. Guess what happens when you try to delete such a pointer? Once again, the answer is undefined behavior . { Foo* p; // Has p been properly initialized? // (The answer is NO, but the runtime doesn't know that.) } Dynamic arrays The type system does not distinguish between a pointer to a single object ( Foo* ) and a pointer to the first element of an array of objects (also Foo* ). When a pointer variable is destroyed, the runtime cannot possibly figure out whether to release the pointee via delete or via delete[] . Releasing via the wrong form invokes undefined behavior . { Foo* p = new Foo; Foo* q = new Foo[100]; // What should I do, delete q or delete[] q? // (The answer is delete[] q, but the runtime doesn't know that.) // What should I do, delete p or delete[] p? // (The answer is delete p, but the runtime doesn't know that.) } Summary Since the runtime cannot do anything sensible with the pointee, destroying a pointer variable is always a no-op. Doing nothing is definitely better than causing undefined behavior due to an uninformed guess :-) Advice Instead of raw pointers, consider using smart pointers as the value type of your container, because they take responsibility for releasing the pointee when it is no longer needed. Depending on your need, use std::shared_ptr or std::unique_ptr . If your compiler does not support C++0x yet, use boost::shared_ptr . Never , I repeat, NEVER EVER use std::auto_ptr as the value type of a container.
