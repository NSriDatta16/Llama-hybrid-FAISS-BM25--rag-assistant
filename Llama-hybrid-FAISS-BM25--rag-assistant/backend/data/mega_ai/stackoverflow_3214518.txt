[site]: stackoverflow
[post_id]: 3214518
[parent_id]: 
[tags]: 
Strongly-typed property reference to multiple classes with no common interface (C#)

The System.Windows.Documents namespace includes a number of classes with an Inlines property of type InlineCollection . For example, the Paragraph , Bold and Hyperlink classes all have this property. Each of these classes is decorated with ContentPropertyAttribute ... [ContentPropertyAttribute("Inlines")] public class Paragraph : Block ... which means that it is easy enough, using reflection, to detect that a given object exposes this property. However, I need to be able to access this property in a strongly-typed manner across a selection of the types that implement it. I am a little surprised that Microsoft didn't make all these classes implement an " IInlineContainer " interface, which would have made type checking and casting very easy. However, in the absence of such an interface, is there any way to fake this polymorphic functionality, ideally without littering my code with lots of conditions and type checking? Many thanks for your ideas, Tim Edit: Thanks for your suggestions. A number of people have suggested the idea of a wrapper class, but this is not possible in my situation, as the target objects are not created by my code, but by the other classes in the .NET framework, for example the Xaml parser or the RichTextBox control (in which the containing FlowDocument is being edited). Edit 2: There have been several great suggestions here and I thank everyone who shared their ideas. The solution I have chosen to implement employs extension methods, which was suggested by @qstarin, although I have refined the concept to suit my needs, as follows: public static InlineCollection GetInlines( this FrameworkContentElement element) { if (element == null) throw new ArgumentNullException("element"); if (element is Paragraph) { return ((Paragraph) element).Inlines; } else if (element is Span) // also catches Bold, Italic, Unerline, Hyperlink { return ((Span)element).Inlines; } else { return null; } } Although this approach requires conditional logic and type casting (which I said I wanted to avoid) the use of extension methods means that it only needs to be implemented in one place, leaving my various calling methods uncluttered.
