[site]: stackoverflow
[post_id]: 555680
[parent_id]: 555283
[tags]: 
I feel with you I remember when I first discovered MVC I tried to cram everything into it. I did indeed make a game that utilized MVC pattern. What I have found later though was that what I did was overkill. I tried to fit pretty much every single class I made into one category in MVC. What I suggest is to read "Design Patterns" by the gang of four. There are a lot of useful patterns besides MVC. Sometimes it doesn't make any sense to use MVC at all. Especially for games I am not sure if MVC is such a good idea. The reason being that you don't want to display a game object in many different ways (views), but you want to reuse a drawing code for many different types of game objects. For my own 2D game engine I used the strategy pattern quite actively. The game objects, like the player and the monsters I called a Sprite . I let the drawing of the sprite be handled by a strategy pattern . That is when I called sprite.draw() I would do something like this: class Sprite { void draw() { this.view.draw(this.currentPosition, this.currentOrientation); } Point currentPosition; // Current position of this sprite double currentOrientation; // Facing angle of sprite }; The benefit of this approach is that you can share a view object between several sprites. Because typically there will be a lot of e.g. monsters which will look the same but which will be a different positions and possibly behave different. So behavior I would also use a strategy pattern which would be a object which contains code describing behavior. That way I can apply the same behavior to several monsters at different location. So each frame I would call an update() function to update position orientation and what monster does. class Sprite { void setUpdateAction(Action action) { this.updateAction = action; } void update(double start_time, double delta_time) { this.prevPosition = position(); advance(delta_time); // Advance to next position based on current speed and orientation this.updateAction.execute(this, start_time, delta_time); } Action updateAction; }; There are loads of variations of this. In my current implementation I have even separated out currentPosition , speed , orientation and advance() into a separate object called MotionState . This is so I can build a search trees of possible positions and orientations when doing path searching algorithms. Then I don't want to carry with me information about how to behave each update or how sprite should be drawn.
