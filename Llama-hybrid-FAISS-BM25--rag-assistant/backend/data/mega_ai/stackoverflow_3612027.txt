[site]: stackoverflow
[post_id]: 3612027
[parent_id]: 
[tags]: 
MVVM with aggregated model classes - how to wrap in ViewModels?

I'm currently trying to create a small application using the MVVM pattern. However I don't really know how to correctly wrap up aggregated Model classes in my ViewModel. From what little I know about MVVM, you're not supposed to expose Models in your ViewModel as properties or else you could directly bind to the Model from your View. So it seems I have to wrap the nested Model in another ViewModel, but this imposes some problems while synching Model and ViewModel later on. So how do you do that efficiently? I'll give a short example. Let's suppose I have the following model classes: public class Bar { public string Name { get; set; } } public class Foo { public Bar NestedBar { get; set; } } Now I create two ViewModel classes accordingly, wrapping the Models, but run into problems with the FooViewModel: public class BarViewModel { private Bar _bar; public string Name { get { return _bar.Name; } set { _bar.Name = value; } } } public class FooViewModel { private Foo _foo; public BarViewModel Bar { get { return ???; } set { ??? = value; } } } Now what do I do with the Bar-property of FooViewModel? For "get" to work I need to return a BarViewModel instance. Do I create a new field of that type in FooViewModel and just wrap the _foo.NestedBar object in there? Changes to that field's properties should propagate down to the underlying Bar instance, right? What if I need to assign another BarViewModel instance to that property, like so: foo.Bar = new BarViewModel(); Now that won't propagate down to the model, which still holds the old instance of type Bar. I'd need to create a new Bar object based on the new BarViewModel and assing it to _foo, but how do you do that elegantly? It's pretty trivial in this sample, but if Bar is much more complex with lots of properties, that'll be a lot of typing... not to mention it'd be very prone to errors, if you forget to set one of the properties.
