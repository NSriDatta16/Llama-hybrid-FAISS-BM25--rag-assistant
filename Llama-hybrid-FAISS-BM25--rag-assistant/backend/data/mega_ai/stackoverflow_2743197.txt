[site]: stackoverflow
[post_id]: 2743197
[parent_id]: 2354769
[tags]: 
Your code has nothing to do with method resolution order. Method resolution comes in the case of multiple inheritance which is not the case of your example. Your code is simply wrong because you assume that self.__class__ is actually the same class of the one where the method is defined and this is wrong: >>> class A(object): ... def __init__(self): ... print self.__class__ ... >>> >>> class B(A): ... def __init__(self): ... A.__init__(self) ... >>> B() >>> A() >>> so when you should call: super(B, self).__init__(1, b, c) you are indeed calling: # super(self.__class__, self).__init__(1, b, c) super(C, self).__init__(1, b, c) EDIT : trying to better answer the question. class A(object): def __init__(self, a): for cls in self.__class__.mro(): if cls is not object: cls._init(self, a) def _init(self, a): print 'A._init' self.a = a class B(A): def _init(self, a): print 'B._init' class C(A): def _init(self, a): print 'C._init' class D(B, C): def _init(self, a): print 'D._init' d = D(3) print d.a prints: D._init B._init C._init A._init 3 (A modified version of template pattern ). Now parents' methods are really called implicitly, but i have to agree with python zen where explicit is better than implicit because the code is lesser readable and the gain is poor. But beware that all _init methods have the same parameters, you cannot completely forget about parents and I don't suggest to do so. For single inheritance, a better approach is explicitly calling parent's method, without invoking super . Doing so you don't have to name the current class , but still you must care about who is the parent's class. Good reads are: how-does-pythons-super-do-the-right-thing and the links suggested in that question and in particularity Python's Super is nifty, but you can't use it If hierarchy is likely to change is symptoms of bad design and has consequences in all the parts who are using that code and should not be encouraged. EDIT 2 Another example comes me in mind, but which uses metaclasses. Urwid library uses metaclass to store an attribute, __super , in class so that you need just to access to that attribute. Ex: >>> class MetaSuper(type): ... """adding .__super""" ... def __init__(cls, name, bases, d): ... super(MetaSuper, cls).__init__(name, bases, d) ... if hasattr(cls, "_%s__super" % name): ... raise AttributeError, "Class has same name as one of its super classes" ... setattr(cls, "_%s__super" % name, super(cls)) ... >>> class A: ... __metaclass__ = MetaSuper ... def __init__(self, a): ... self.a = a ... print 'A.__init__' ... >>> class B(A): ... def __init__(self, a): ... print 'B.__init__' ... self.__super.__init__(a) ... >>> b = B(42) B.__init__ A.__init__ >>> b.a 42 >>>
