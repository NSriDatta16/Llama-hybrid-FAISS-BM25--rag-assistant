[site]: stackoverflow
[post_id]: 1773705
[parent_id]: 1773541
[tags]: 
A word to the wise: It's probably a bad idea to try and implement your own ORM. Projects like hibernate have covered this task in great detail, so if you roll your own you are likely to reinvent the wheel and possibly attempt to solve problems that have already been solved. More on topic, ChssPly76 is correct in that you cannot accomplish this because of how static methods are handled in Java. When the VM loads the bytecode for the static method invocation, it will perform a lookup to find where the method actually is located. It won't find it on the Item class, so it will instead bind the call to DB.find . However! It may be possible to achieve what you are trying to do with some bytecode wrangling. Viewing the bytecode (using javap -c ) for the static method call in your example, we get the following: invokestatic Method Item.find:(I)Ljava/lang/Object Thus, once your call reaches DB.find , you could follow the stacktrace back to the callsite, and then inspect the bytecode at the callsite to retrive the actual target of the call. In theory, anyway, as I haven't seen this myself in practice. Also, beware of hacking bytecode like this, for here be dragons. Kudos for identifying the active record pattern , and wanting to use it in Java. I do agree it's a design pattern that makes more sense than most DB access patterns found in Java, and it's one of the strengths of Ruby and PHP.
