[site]: stackoverflow
[post_id]: 34186
[parent_id]: 32664
[tags]: 
More than a decade later, this feature finally exists in .NET 7 . The most generic interface is INumber (in the System.Numerics namespace), and it encompasses all numbers. To accept just integer types, consider using IBinaryInteger instead. Here’s an example IntegerFunction implementation: static bool IntegerFunction (T value) where T : IBinaryInteger { return value > T.Zero; } Console.WriteLine(IntegerFunction(5)); // True Console.WriteLine(IntegerFunction((sbyte)-5)); // False Console.WriteLine(IntegerFunction((ulong)5)); // True The (now obsolete) original answer below is left as a historical perspective. C# does not support this. Hejlsberg has described the reasons for not implementing the feature in an interview with Bruce Eckel : And it's not clear that the added complexity is worth the small yield that you get. If something you want to do is not directly supported in the constraint system, you can do it with a factory pattern. You could have a Matrix , for example, and in that Matrix you would like to define a dot product method. That of course that means you ultimately need to understand how to multiply two T s, but you can't say that as a constraint, at least not if T is int , double , or float . But what you could do is have your Matrix take as an argument a Calculator , and in Calculator , have a method called multiply . You go implement that and you pass it to the Matrix . However, this leads to fairly convoluted code, where the user has to supply their own Calculator implementation, for each T that they want to use. As long as it doesn’t have to be extensible, i.e. if you just want to support a fixed number of types, such as int and double , you can get away with a relatively simple interface: var mat = new Matrix (w, h); ( Minimal implementation in a GitHub Gist. ) However, as soon as you want the user to be able to supply their own, custom types, you need to open up this implementation so that the user can supply their own Calculator instances. For instance, to instantiate a matrix that uses a custom decimal floating point implementation, DFP , you’d have to write this code: var mat = new Matrix (DfpCalculator.Instance, w, h); … and implement all the members for DfpCalculator : ICalculator . An alternative, which unfortunately shares the same limitations, is to work with policy classes, as discussed in Sergey Shandar’s answer .
