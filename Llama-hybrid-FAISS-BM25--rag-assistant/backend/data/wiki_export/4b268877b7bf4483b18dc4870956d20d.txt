A carry-save adder is a type of digital adder, used to efficiently compute the sum of three or more binary numbers. It differs from other digital adders in that it outputs two (or more) numbers, and the answer of the original summation can be achieved by adding these outputs together. A carry save adder is typically used in a binary multiplier, since a binary multiplier involves addition of more than two binary numbers after multiplication. A big adder implemented using this technique will usually be much faster than conventional addition of those numbers.

Motivation

Consider the sum:
    12345678
 +  87654322
 = 100000000

Using basic arithmetic, we calculate right to left, "8 + 2 = 0, carry 1", "7 + 2 + 1 = 0, carry 1", "6 + 3 + 1 = 0, carry 1", and so on to the end of the sum. Although we know the last digit of the result at once, we cannot know the first digit until we have gone through every digit in the calculation, passing the carry from each digit to the one on its left. Thus adding two n-digit numbers has to take a time proportional to n, even if the machinery we are using would otherwise be capable of performing many calculations simultaneously.

In electronic terms, using bits (binary digits), this means that even if we have n one-bit adders at our disposal, we still have to allow a time proportional to n to allow a possible carry to propagate from one end of the number to the other. Until we have done this, 
 We do not know the result of the addition.
 We do not know whether the result of the addition is larger or smaller than a given number (for instance, we do not know whether it is positive or negative).

A carry look-ahead adder can reduce the delay. In principle the delay can be reduced so that it is proportional to log n, but for large numbers this is no longer the case, because even when carry look-ahead is implemented, the distances that signals have to travel on the chip increase in proportion to n, and propagation delays increase at the same rate. Once we get to the 512-bit to 2048-bit number sizes that are required in public-key cryptography, carry look-ahead is not of much help.

The basic concept
The idea of delaying carry resolution until the end, or saving carries, is due to John von Neumann.

The sum of two digits can never carry more than a 1, and the sum of two digits plus 1 can also never carry more than 1.  For example, in decimal, , which carries a 1; , which also carries a 1.  When adding three figures, we can add the first two and produce a sum and the carry digits; then add the sum and the carry digits to the third figure and produce a sum and the carry digits.  In binary, the only digits are zero and one, and so , , and  with a carried 1.  Adding the carry bit can give, at most,  with a carried 1, so a three-way addition is possible.  Because of this, it is also possible to add the first three figures and produce the sum and carry; for subsequent figures, the sum and carry are two terms, and the next single figure is added to these.

Here is an example of a binary sum of 3 long binary numbers:
   1011 1010 1010 1101 1111 0000 0000 1101 (a)
 + 1101 1110 1010 1101 1011 1110 1110 1111 (b)
 + 0001 0010 1011 0111 0101 0011 0101 0010 (c)

The straightforward way to do it would be to first compute (a+b), and then compute ((a+b)+c). Carry-save arithmetic works by abandoning any kind of carry propagation. It computes the sum digit by digit, as:
   1011 1010 1010 1101 1111 0000 0000 1101 (a)
 + 1101 1110 1010 1101 1011 1110 1110 1111 (b)
 + 0001 0010 1011 0111 0101 0011 0101 0010 (c)
 = 2113 2130 3031 2313 2223 1121 1211 2222

The notation is unconventional, but the result is still unambiguous: Σ2idi. If we assume the three numbers to be a, b and c. Then here, the result will be described as the sum of two binary numbers, where the first number, S, is simply the sum obtained by adding the digits (without any carry propagation), i.e. Si = ai ⊕ bi ⊕ ci  and the second number, C, is composed of carries from the previous individual sums, i.e. Ci+1 = (aibi) +  (bici) + (ciai) :
    0111 0110 1011 0111 0001 1101 1011 0000 and
  1 0011 0101 0101 1011 1110 0100 1001 1110

Now these 2 numbers can be sent to a carry-propagate adder which will output the result.

This was very advantageous from a delay (computation-time) perspective. If you were to add these 3 numbers using conventional methods, it would take you 2 carry-propagate adder delays to get to the answer. If you use the carry-save technique, you require only 1 carry-propagate adder delay and 1 full-adder delay (which is much lower than a carry-propagate delay). Thus, CSAs are typically very fast.

Carry-save accumulators

Supposing that we have two bits of storage per digit, we can use a redundant binary representation, storing the values 0, 1, 2, or 3 in each digit position. It is therefore obvious that one more binary number can be added to our carry-save result without overflowing our storage capacity: but then what?

The key to success is that at the moment of each partial addition we add three bits:
 0 or 1, from the number we are adding.
 0 if the digit in our store is 0 or 2, or 1 if it is 1 or 3.
 0 if the digit to its right is 0 or 1, or 1 if it is 2 or 3.
To put it another way, we are taking a carry digit from the position on our right, and passing a carry digit to the left, just as in conventional addition; but the carry digit we pass to the left is the result of the previous calculation and not the current one. In each clock cycle, carries only have to move one step along, and not n steps as in conventional addition.

Because signals don't have to move as far, the clock can tick much faster. ..

There is still a need to convert the result to binary at the end of a calculation, which effectively just means letting the carries travel all the way through the number just as in a conventional adder. But if we have done 512 additions in the process of performing a 512-bit multiplication, the cost of that final conversion is effectively split across those 512 additions, so each addition bears 1/512 of the cost of that final "conventional" addition.

Drawbacks

At each stage of a carry-save addition,
 We know the result of the addition at once.
 We still do not know whether the result of the addition is larger or smaller than a given number (for instance, we do not know whether it is positive or negative).

This latter point is a drawback when using carry-save adders to implement modular multiplication (multiplication followed by division, keeping the remainder only). If we cannot know whether the intermediate result is greater or less than the modulus, how can we know whether to subtract the modulus?

Montgomery multiplication, which depends on the rightmost digit of the result, is one solution; though rather like carry-save addition itself, it carries a fixed overhead, so that a sequence of Montgomery multiplications saves time but a single one does not. Fortunately exponentiation, which is effectively a sequence of multiplications, is the most common operation in public-key cryptography.

Careful error analysis allows a choice to be made about subtracting the modulus even though we don't know for certain whether the result of the addition is big enough to warrant the subtraction. For this to work, it is necessary for the circuit design to be able to add −2, −1, 0, +1 or +2 times the modulus. The advantage over Montgomery multiplication is that there is no fixed overhead attached to each sequence of multiplications.

Technical details

The carry-save unit consists of n full adders, each of which computes a single sum and carry bit based solely on the corresponding bits of the three input numbers.  Given the three n-bit numbers a, b, and c, it produces a partial sum ps and a shift-carry sc:

The entire sum can then be computed by:
 Shifting the carry sequence sc left by one place.
 Appending a 0 to the front (most significant bit) of the partial sum sequence ps.
 Using a ripple carry adder to add these two together and produce the resulting (n + 1)-bit value.

See also
 Wallace tree

Notes

References

Further reading
 

Binary arithmetic
Adders (electronics)