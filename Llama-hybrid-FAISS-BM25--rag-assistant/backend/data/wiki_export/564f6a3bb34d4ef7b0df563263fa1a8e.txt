sort is a generic function in the C++ Standard Library for doing comparison sorting. The function originated in the Standard Template Library (STL).

The specific sorting algorithm is not mandated by the language standard and may vary across implementations, but the worst-case asymptotic complexity of the function is specified: a call to  must perform no more than  comparisons when applied to a range of  elements.

Usage
The  function is included from the  header of the C++ Standard Library, and carries three arguments: . Here,  is a templated type that must be a random access iterator, and  and  must define a sequence of values, i.e.,  must be reachable from  by repeated application of the increment operator to . The third argument, also of a templated type, denotes a comparison predicate. This comparison predicate must define a strict weak ordering on the elements of the sequence to be sorted. The third argument is optional; if not given, the "less-than" () operator is used, which may be overloaded in C++.

This code sample sorts a given array of integers (in ascending order) and prints it out.

#include <algorithm>
#include <iostream>

int main() {
  int array[] = { 23, 5, -10, 0, 0, 321, 1, 2, 99, 30 };
  std::sort(std::begin(array), std::end(array));
  for (size_t i = 0; i < std::size(array); ++i) {
     std::cout << array[i] << ' ';
  }
  std::cout << '\n';
}

The same functionality using a  container, using its  and  methods to obtain iterators:

#include <algorithm>
#include <iostream>
#include <vector>

int main() {
  std::vector<int> vec = { 23, 5, -10, 0, 0, 321, 1, 2, 99, 30 };
  std::sort(vec.begin(), vec.end());
  for (size_t i = 0; i < vec.size(); ++i) {
     std::cout << vec[i] << ' ';
  }
  std::cout << '\n';
}

Genericity
 is specified generically, so that it can work on any random-access container and any way of determining that an element  of such a container should be placed before another element .

Although generically specified,  is not easily applied to all sorting problems. A particular problem that has been the subject of some study is the following:

 Let  and  be two arrays, where there exists some relation between the element  and the element  for all valid indices .
 Sort  while maintaining the relation with , i.e., apply the same permutation to  that sorts .
 Do the previous without copying the elements of  and  into a new array of pairs, sorting, and moving the elements back into the original arrays (which would require  temporary space).

A solution to this problem was suggested by A. Williams in 2002, who implemented a custom iterator type for pairs of arrays and analyzed some of the difficulties in correctly implementing such an iterator type. Williams's solution was studied and refined by K. Åhlander.

Complexity and implementations
The C++ standard requires that a call to  performs  comparisons when applied to a range of  elements.
In previous versions of C++, such as C++03, only average complexity was required to be . This was to allow the use of algorithms like (median-of-3) quicksort, which are fast in the average case, indeed significantly faster than other algorithms like heap sort with optimal worst-case complexity, and where the worst-case quadratic complexity rarely occurs. The introduction of hybrid algorithms such as introsort allowed both fast average performance and optimal worst-case performance, and thus the complexity requirements were tightened in later standards.

Different implementations use different algorithms. The GNU Standard C++ library, for example, uses a 3-part hybrid sorting algorithm: introsort is performed first (introsort itself being a hybrid of quicksort and heap sort), to a maximum depth given by 2×log2 n, where n is the number of elements, followed by an insertion sort on the result.

Other types of sorting
sort is not stable: equivalent elements that are ordered one way before sorting may be ordered differently after sorting. stable_sort ensures stability of result at expense of worse performance (in some cases), requiring only quasilinear time with exponent 2 – O(n log2 n) – if additional memory is not available, but linearithmic time O(n log n) if additional memory is available. This allows the use of in-place merge sort for in-place stable sorting and regular merge sort for stable sorting with additional memory.

Partial sorting is implemented by , which takes a range of  elements and an integer , and reorders the range so that the smallest  elements are in the first  positions in sorted order (leaving the remaining  in the remaining positions, in some unspecified order). Depending on design this may be considerably faster than complete sort. Historically, this was commonly implemented using a heap-based algorithm that takes  worst-case time. A better algorithm called quickselsort is used in the Copenhagen STL implementation, bringing the complexity down to .

Selection of the nth element is implemented by nth_element, which actually implements an in-place partial sort: it correctly sorts the nth element, and also ensures that this element partitions so elements before it are less than it, and elements after it are greater than it. There is the requirement that this takes linear time on average, but there is no worst-case requirement; these requirements are exactly met by quickselect, for any choice of pivot strategy.

Some containers, among them list, provide specialised version of sort as a member function. This is because linked lists don't have random access (and therefore can't use the regular sort function); and the specialised version also preserves the values list iterators point to.

Comparison to qsort
Aside from , the C++ standard library also includes the  function from the C standard library. Compared to , the templated  is more type-safe since it does not require access to data items through unsafe  pointers, as  does. Also,  accesses the comparison function using a function pointer, necessitating large numbers of repeated function calls, whereas in , comparison functions may be inlined into the custom object code generated for a template instantiation. In practice, C++ code using  is often considerably faster at sorting simple data like integers than equivalent C code using .

References

External links
 C++ reference for std::sort
 Another C++ reference for std::sort

C++ Standard Library
Sorting algorithms