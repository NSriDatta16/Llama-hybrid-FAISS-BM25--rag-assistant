In graph theory, a haven is a certain type of function on sets of vertices in an undirected graph. If a haven exists, it can be used by an evader to win a pursuit–evasion game on the graph, by consulting the function at each step of the game to determine a safe set of vertices to move into. Havens were first introduced by  as a tool for characterizing the treewidth of graphs. Their other applications include proving the existence of small separators on minor-closed families of graphs, and characterizing the ends and clique minors of infinite graphs.

Definition
If  is an undirected graph, and  is a set of vertices, then an -flap is a nonempty connected component of the subgraph of  formed by deleting . A haven of order  in  is a function  that assigns an -flap  to every set  of fewer than  vertices. This function must also satisfy additional constraints which are given differently by different authors.
The number  is called the order of the haven.

In the original definition of Seymour and Thomas, a haven is required to satisfy the property that every two flaps  and  must touch each other: either they share a common vertex or there exists an edge with one endpoint in each flap. In the definition used later by Alon, Seymour, and Thomas, havens are instead required to satisfy a weaker monotonicity property: if , and both  and   have fewer than  vertices, then  . The touching property implies the monotonicity property, but not necessarily vice versa. However, it follows from the results of Seymour and Thomas that, in finite graphs, if a haven with the monotonicity property exists, then one with the same order and the touching property also exists.

Havens with the touching definition are closely related to brambles, families of connected subgraphs of a given graph that all touch each other. The order of a bramble is the minimum number of vertices needed in a set of vertices that hits all of the subgraphs in the family. The set of flaps  for a haven of order  (with the touching definition) forms a bramble of order at least , because any set   of fewer than  vertices fails to hit the subgraph . Conversely, from any bramble of order , one may construct a haven of the same order, by defining  (for each choice of ) to be the -flap that includes all of the subgraphs in the bramble that are disjoint from . The requirement that the subgraphs in the bramble all touch each other can be used to show that this -flap exists, and that all of the flaps  chosen in this way touch each other. Thus, a graph has a bramble of order  if and only if it has a haven of order .

Example
As an example, let  be a nine-vertex grid graph. Define a haven of order 4 in , mapping each set  of three or fewer vertices to an -flap , as follows:
If there is a unique -flap that is larger than any of the other -flaps, let  be that unique large -flap.
Otherwise, choose  arbitrarily to be any -flap.
It is straightforward to verify by a case analysis that this function  satisfies the required monotonicity property of a haven. If  and  has fewer than two vertices, or  has two vertices that are not the two neighbors of a corner vertex of the grid, then there is only one -flap and it contains every -flap. In the remaining case,  consists of the two neighbors of a corner vertex and has two -flaps: one consisting of that corner vertex, and another (chosen as ) consisting of the six remaining vertices. No matter which vertex is added to  to form , there will be a -flap with at least four vertices, which must be the unique largest flap since it contains more than half of the vertices not in . This large -flap will be chosen as  and will be a subset of . Thus in each case monotonicity holds.

Pursuit–evasion
Havens model a certain class of strategies for an evader in a pursuit–evasion game in which fewer than  pursuers attempt to capture a single evader, the pursuers and evader are both restricted to the vertices of a given undirected graph, and the positions of the pursuers and evader are known to both players. At each move of the game, a new pursuer may be added to an arbitrary vertex of the graph (as long as fewer than  pursuers are placed on the graph at any time) or one of the already-added pursuers may be removed from the graph. However, before a new pursuer is added, the evader is first informed of its new location and may move along the edges of the graph to any unoccupied vertex. While moving, the evader may not pass through any vertex that is already occupied by any of the pursuers.

If a -haven (with the monotonicity property) exists, then the evader may avoid being captured indefinitely, and win the game, by always moving to a vertex of  where  is the set of vertices that will be occupied by pursuers at the end of the move. The monotonicity property of a haven guarantees that, when a new pursuer is added to a vertex of the graph, the vertices in  are always reachable from the current position of the evader.

For instance, an evader can win this game against three pursuers on a  grid by following this strategy with the haven of order 4 described in the example. However, on the same graph, four pursuers can always capture the evader, by first moving onto three vertices that split the grid onto two three-vertex paths, then moving into the center of the path containing the evader, forcing the evader into one of the corner vertices, and finally removing one of the pursuers that is not adjacent to this corner and placing it onto the evader. Therefore, the  grid can have no haven of order 5.

Havens with the touching property allow the evader to win the game against more powerful pursuers that may simultaneously jump from one set of occupied vertices to another.

Connections to treewidth, separators, and minors
Havens may be used to characterize the treewidth of graphs: a graph has a haven of order  if and only if it has treewidth at least . A tree decomposition may be used to describe a winning strategy for the pursuers in the same pursuit–evasion game, so it is also true that a graph has a haven of order  if and only if the evader wins with best play against fewer than  pursuers. In games won by the evader, there is always an optimal strategy in the form described by a haven, and in games won by the pursuer, there is always an optimal strategy in the form described by a tree decomposition. For instance, because the  grid has a haven of order 4, but does not have a haven of order 5, it must have treewidth exactly 3. The same min-max theorem can be generalized to infinite graphs of finite treewidth, with a definition of treewidth in which the underlying tree is required to be rayless (that is, having no ends).

Havens are also closely related to the existence of separators, small sets  of vertices in an -vertex graph such that every -flap has at most  vertices. If a graph  does not have a -vertex separator, then every set  of at most  vertices has a (unique) -flap with more than  vertices. In this case,  has a haven of order , in which  is defined to be this unique large -flap. That is, every graph has either a small separator or a haven of high order.

If a graph  has a haven of order , with  for some integer , then  must also have a complete graph  as a minor. In other words, the Hadwiger number of an -vertex graph with a haven of order  is at least . As a consequence, the -minor-free graphs have treewidth less than  and separators of size less than . More generally an  bound on treewidth and separator size holds for any nontrivial family of graphs that can be characterized by forbidden minors, because for any such family there is a constant  such that the family does not include .

In infinite graphs
If a graph  contains a ray, a semi-infinite simple path with a starting vertex but no ending vertex, then it has a haven of order : that is, a function  that maps each finite set  of vertices to an -flap, satisfying the consistency condition for havens. Namely, define  to be the unique -flap that contains infinitely many vertices of the ray. Thus, in the case of infinite graphs the connection between treewidth and havens breaks down: a single ray, despite itself being a tree, has havens of all finite orders and even more strongly a haven of order . Two rays of an infinite graph are considered to be equivalent if there is no finite set of vertices that separates infinitely many vertices of one ray from infinitely many vertices of the other ray; this is an equivalence relation, and its equivalence classes are called ends of the graph.

The ends of any graph are in one-to-one correspondence with its havens of order . For, every ray determines a haven, and every two equivalent rays determine the same haven. Conversely, every haven is determined by a ray in this way, as can be shown by the following case analysis:
If the haven has the property that the intersection  (where the intersection ranges over all finite sets ) is itself an infinite set , then every finite simple path that ends in a vertex of  can be extended to reach an additional vertex of , and repeating this extension process produces a ray passing through infinitely many vertices of . This ray determines the given haven.
On the other hand, if  is finite, then (by working in the subgraph )it can be assumed to be empty. In this case, for each finite set  of vertices there is a finite set  with the property that  is disjoint from . If a robber follows the evasion strategy determined by the haven, and the police follow a strategy given by this sequence of sets, then the path followed by the robber forms a ray that determines the haven.
Thus, every equivalence class of rays defines a unique haven, and every haven is defined by an equivalence class of rays.

For any cardinal number , an infinite graph  has a haven of order  if and only if it has a clique minor of order . That is, for uncountable cardinalities, the largest order of a haven in  is the Hadwiger number of .

References

Graph theory objects
Graph minor theory
Pursuit–evasion