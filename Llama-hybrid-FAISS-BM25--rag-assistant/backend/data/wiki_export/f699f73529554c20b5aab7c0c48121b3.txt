A binary moment diagram (BMD) is a generalization of the binary decision diagram (BDD) to linear functions over domains such as booleans (like BDDs), but also to integers or to real numbers.

They can deal with Boolean functions with complexity comparable to BDDs, but also some functions that are dealt with very inefficiently in a BDD are handled easily by BMD, most notably multiplication.

The most important properties of BMD is that, like with BDDs, each function has exactly one canonical representation, and many operations can be efficiently performed on these representations.

The main features that differentiate BMDs from BDDs are using linear instead of pointwise diagrams, and having weighted edges.

The rules that ensure the canonicity of the representation are:
 Decision over variables higher in the ordering may only point to decisions over variables lower in the ordering.
 No two nodes may be identical (in normalization such nodes all references to one of these nodes should be replaced be references to another)
 No node may have all decision parts equivalent to 0 (links to such nodes should be replaced by links to their always part)
 No edge may have weight zero (all such edges should be replaced by direct links to 0)
 Weights of the edges should be coprime. Without this rule or some equivalent of it, it would be possible for a function to have many representations, for example 2x + 2 could be represented as 2 · (1 + x) or 1 · (2 + 2x).

Pointwise and linear decomposition 

In pointwise decomposition, like in BDDs, on each branch point we store result of all branches separately.  An example of such decomposition for an integer function (2x + y) is:

In linear decomposition we provide instead a default value and a difference:

It can easily be seen that the latter (linear) representation is much more efficient in case of additive functions, as when we add many elements the latter representation will have only O(n) elements, while the former (pointwise), even with sharing, exponentially many.

Edge weights 

Another extension is using weights for edges. A value of function at given node is a sum of the true nodes below it (the node under always, and possibly the decided node) times the edges' weights.

For example,  can be represented as:
 Result node, always 1× value of node 2, if  add 4× value of node 4
 Always 1× value of node 3, if  add 2× value of node 4
 Always 0, if  add 1× value of node 4
 Always 1× value of node 5, if  add +4
 Always 1× value of node 6, if  add +2
 Always 0, if  add +1

Without weighted nodes a much more complex representation would be required:
 Result node, always value of node 2, if  value of node 4
 Always value of node 3, if  value of node 7
 Always 0, if  value of node 10
 Always value of node 5, if  add +16
 Always value of node 6, if  add +8
 Always 0, if  add +4
 Always value of node 8, if  add +8
 Always value of node 9, if  add +4
 Always 0, if  add +2
 Always value of node 11, if  add +4
 Always value of node 12, if  add +2
 Always 0, if  add +1

References

Graph data structures
Formal methods