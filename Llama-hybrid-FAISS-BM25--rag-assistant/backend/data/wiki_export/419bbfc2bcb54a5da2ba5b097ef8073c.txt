In queueing theory, a discipline within the mathematical theory of probability, Buzen's algorithm (or  convolution algorithm) is an algorithm for calculating the normalization constant G(N) in the Gordon–Newell theorem. This method was first proposed by Jeffrey P. Buzen in his 1971 PhD dissertation and subsequently published in a refereed journal in 1973. Computing G(N) is required to compute the stationary probability distribution of a closed queueing network.

Performing a naïve computation of the normalizing constant requires enumeration of all states. For a closed network with N circulating customers and M service facilities, G(N) is the sum of  individual terms, with each term consisting of M  factors raised to powers whose sum is N.  Buzen's algorithm computes G(N) using only NM multiplications and NM additions.  This dramatic improvement  opened the door to applying the Gordon-Newell theorem to models of real world computer systems as well as flexible manufacturing systems and other cases where bottlenecks and queues can form within networks of inter-connected service facilities. The values of G(1), G(2) ... G(N -1), which can be used to calculate other important quantities of interest, are computed as by-products of the algorithm.

Problem setup

Consider a closed queueing network with M service facilities and N circulating customers.  Assume that the service time for a customer at service facility i is given by an exponentially distributed random variable with parameter μi and that, after completing service at service facility i, a customer will proceed next to service facility j with probability pij.

Let  be the steady state probability that the number of customers at service facility i is equal to ni  for i = 1, 2, ... , M .   It follows from the Gordon–Newell theorem that 

 .... 

This result is usually written more compactly as

The values of Xi are determined by solving

G(N) is a normalizing constant chosen so that the sum of all  values of  is equal to 1.  Buzen's algorithm represents the first efficient procedure for computing G(N).

Algorithm description

The individual terms that must be added together to compute G(N) all have the following form:  

 .... .   Note that this set of terms can be partitioned into two groups.  The first group comprises all terms for which the exponent of  is greater than or equal to 1.  This implies that  raised to the power 1 can be factored out of each of these terms.  

After factoring out , a surprising result emerges: the modified terms in the first group are identical to the terms used to compute the normalizing constant for the same network with one customer removed.  Thus, the sum of the terms in the first group can be written as “XM  times G(N -1)”.  This insight provides the foundation for the development of the algorithm.   

Next consider the second group.  The exponent of XM  for every term in this group is zero.  As a result,  service facility M  effectively disappears from all terms in this group (since it reduces in every case to a factor of 1). This leaves the total number of customers at the remaining M -1 service facilities equal to N.  The second group includes all possible arrangements of these N customers. 

To express this concept precisely, assume that X1, X2, … XM  have been obtained for a given network with M service facilities. For any n ≤ N and m ≤ M, define g(n,m) as the normalizing constant for a network with n customers, m service facilities (1,2, … m), and values of  X1, X2, … Xm  that match the first m members of the original sequence X1, X2, … XM . 

Given this definition, the sum of the terms in the second group can now be written as g(N, M -1).

It also follows immediately that “XM  times G(N -1)”, the sum of the terms in the first group, can be re-written as “XM  times g(N -1,M )”.  

In addition, the normalizing constant G(N) in the Gordon-Newell theorem can now be re-written as g(N,M).  

Since G(N) is equal to the combined sum of the terms in the first and second groups,

G(N) = g(N, M ) = XM g(N -1,M ) + g(N,M -1)

This same recurrence relation clearly exists for any intermediate value of n from 1 to N, and for any intermediate value of m from 1 to M .  

This implies g(n,m) = Xm g(n -1,m) + g(n,m -1).  Buzen’s algorithm is simply the iterative application of this fundamental recurrence relation, along with the following boundary conditions.

g(0,m) = 1 for m = 1, 2, …M 

g(n,1)  =  (Xi)n for n = 0, 1, … N

Marginal distributions, expected number of customers

The Gordon-Newell theorem enables analysts to determine the stationary probability associated with each individual state of a closed queueing network.  These individual probabilities must then be added together to evaluate other important probabilities. For example P(ni ≥ k), the probability that the total number of customers at service center i is greater than or equal to k, must be summed over all values of ni ≥ k and, for each such value of ni, over all possible ways the remaining N – ni customers can be distributed across the other M -1 service centers in the network. 

Many of these marginal probabilities can be computed with minimal additional effort.  This is easy to see for the case of P(ni ≥ k).   Clearly, Xi must be raised to the power of k or higher in every state where the number of customers at service center i is greater than or equal to k. Thus Xi k can be factored out from each of these probabilities, leaving a set of modified probabilities whose sum is given by G(N-k)/G(N).   This observation yields the following simple and highly efficient result:

P(ni ≥ k) = (Xi)k G(N-k)/G(N)

This relationship can then be used to compute the marginal distributions and expected number of customers at each service facility.

The expected number of customers at service facility i is given by

These characterizations of quantities of interest in terms of the G(n) are also due to Buzen.

Implementation
It will be assumed that the Xm have been computed by solving the relevant equations and are available as an input to our routine.  Although g(n,m) is in principle a two dimensional matrix, it can be computed in a column by column fashion starting from the top of the leftmost column and running down each column to the bottom before proceeding to the next column on the right.  The routine uses a single column vector C to represent the current column of g. 

The first loop in the algorithm below initializes the column vector C[n] so that C[0] = 1 and C(n) = 0 for n≥1.   Note that C[0] remains equal to 1 throughout all subsequent iterations.   

In the second loop, each successive value of C(n) for n≥1 is set equal to the corresponding value of g(n,m) as the algorithm proceeds down column m.  This is achieved by setting each successive value of C(n) equal to:  

g(n,m-1) plus Xm  times g(n-1,m).   

Note that g(n,m-1) is the previous value of C(n), and g(n-1,m) is the current value of C(n-1) 

C[0] := 1
for n := 1 step 1 until N do
   C[n] := 0;

for m := 1 step 1 until M do
  for n := 1 step 1 until N do
     C[n] := C[n] + X[m]*C[n-1];

At completion, the final values of C[n] correspond to column M in the matrix g(n,m).  Thus they represent the desired values G(0), G(1), ... ,  G(N).

References

Jain: The Convolution Algorithm (class handout)
Menasce: Convolution Approach to Queueing Algorithms (presentation)

Queueing theory
Statistical algorithms