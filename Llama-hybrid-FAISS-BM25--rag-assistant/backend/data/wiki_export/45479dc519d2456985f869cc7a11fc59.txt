The kinetic Monte Carlo (KMC) method is a Monte Carlo method computer simulation intended to simulate the time evolution of some processes occurring in nature.  Typically these are processes that occur with known transition rates among states.  It is important to understand that these rates are inputs to the KMC algorithm, the method itself cannot predict them.

The KMC method is essentially the same as the dynamic Monte Carlo method and the Gillespie algorithm.

Algorithms 
One possible classification of KMC algorithms is as rejection-KMC (rKMC) and rejection-free-KMC (rfKMC).

Rejection-free KMC 

A rfKMC algorithm, often only called KMC, for simulating the time evolution of a system, where some processes can occur with known rates r, can be written for instance as follows:
 Set the time .
 Choose an initial state  k.
 Form the list of all  possible transition rates in the system , from state k into a generic state i. States that do not communicate with k will have .
 Calculate the cumulative function  for . The total rate is .
 Get a uniform random number .
 Find the event to carry out i by finding the i for which  (this can be achieved efficiently using binary search).
 Carry out event i (update the current state ).
 Get a new uniform random number .
 Update the time with , where .
 Return to step 3.

(Note: because the average value of  is equal to unity, the same average time scale can be obtained by instead using  in step 9. In this case, however, the delay associated with transition i will not be drawn from the Poisson distribution described by the rate , but will instead be the mean of that distribution.)

This algorithm is known in different sources variously as the residence-time algorithm or the n-fold way or the Bortz-Kalos-Lebowitz (BKL) algorithm. It is important to note that the timestep involved is a function of the probability that all events i, did not occur.

Rejection KMC
Rejection KMC has typically the advantage of an easier data handling, and faster computations for each attempted step, since the time consuming action of getting all  is not needed.
On the other hand, the time evolved at each step is smaller than for rfKMC. The relative weight of pros and cons varies with the case at hand, and with available resources.

An rKMC associated with the same transition rates as above can be written as follows:
 Set the time .
 Choose an initial state  k.
 Get the number  of all possible transition rates, from state k into a generic state i.
 Find the candidate event to carry out i by uniformly sampling from the  transitions above.
 Accept the event with probability , where  is a suitable upper bound for . It is often easy to find  without having to compute all   (e.g., for Metropolis transition rate probabilities).
 If accepted, carry out event i (update the current state ).
 Get a new uniform random number .
 Update the time with , where .
 Return to step 3.

(Note:  can change from one MC step to another.)
This algorithm is usually called a standard algorithm.

Theoretical and numerical comparisons between the algorithms were provided.

Time-dependent Algorithms
If the rates  are time dependent, step 9 in the rfKMC must be modified by:
 .
The reaction (step 6) has to be chosen after this by
 

Another very similar algorithm is called the First Reaction Method (FRM). It consists of choosing the first-occurring reaction, meaning to choose the smallest time , and the corresponding reaction number i, from the formula
 ,
where the  are N random numbers.

Comments on the algorithm
The key property of the KMC algorithm (and of the FRM one) is that if the rates are correct, if the processes associated with the rates are of the Poisson process type, and if different processes are independent (i.e. not correlated) then the KMC algorithm gives the correct time scale for the evolution of the simulated system. There was some debate about the correctness of the time scale for rKMC algorithms, but this was also rigorously shown to be correct.

If furthermore the transitions follow detailed balance, the KMC algorithm can be used to simulate thermodynamic equilibrium. However, KMC is widely used to simulate non-equilibrium processes, in which case detailed balance need not be obeyed.

The rfKMC algorithm is efficient in the sense that every iteration is guaranteed to produce a transition. However, in the form presented above it requires  operations for each transition, which is not too efficient. In many cases this can be much improved on by binning the same kinds of transitions into bins, and/or forming a tree data structure of the events. A constant-time scaling algorithm of this type has recently been developed and tested.

The major disadvantage with rfKMC is that all possible rates  and reactions have to be known in advance. The method itself can do nothing about predicting them. The rates and reactions must be obtained from other methods, such as diffusion (or other) experiments, molecular dynamics or density-functional theory simulations.

Examples of use
KMC has been used in simulations of the following physical systems:
 Surface diffusion
 Surface growth
 Vacancy diffusion in alloys (this was the original use)
 Coarsening of domain evolution
 Defect mobility and clustering in ion or neutron irradiated solids including, but not limited to, damage accumulation and amorphization/recrystallization models.
 Viscoelasticity of physically crosslinked networks

To give an idea what the "objects" and "events" may be in practice, here is one concrete simple example, corresponding to example 2 above.

Consider a system where individual atoms are deposited on a surface one at a time (typical of physical vapor deposition), but also may migrate on the surface with some known jump rate . In this case the "objects" of the KMC algorithm are simply the individual atoms.

If two atoms come right next to each other, they become immobile. Then the flux of incoming atoms determines a rate rdeposit, and the system can be simulated with KMC considering all deposited mobile atoms which have not (yet) met a counterpart and become immobile. This way there are the following events possible at each KMC step:
 A new atom comes in with rate 'rdeposit
 An already deposited atom jumps one step with rate w.

After an event has been selected and carried out with the KMC algorithm, one then needs to check whether the new or just jumped atom has become immediately adjacent to some other atom. If this has happened, the atom(s) which are now adjacent needs to be moved away from the list of mobile atoms, and correspondingly their jump events removed from the list of possible events.

Naturally in applying KMC to problems in physics and chemistry, one has to first consider whether the real system follows the assumptions underlying KMC well enough.
Real processes do not necessarily have well-defined rates, the
transition processes may be correlated, in case of atom or particle jumps
the jumps may not occur in random directions, and so on. When simulating
widely disparate time scales one also needs to consider whether
new processes may be present at longer time scales. If any of these
issues are valid, the time scale and system evolution predicted by KMC
may be skewed or even completely wrong.

History
The first publication which described the basic features of the KMC method (namely using a cumulative function to select an event and a time scale calculation of the form 1/R) was by Young and Elcock in 1966. The residence-time algorithm was also published at about the same time.

Apparently independent of the work of Young and Elcock, Bortz, Kalos and Lebowitz developed a KMC algorithm for simulating the Ising model, which they called the n-fold way''. The basics of their algorithm is the same as that of Young, but they do provide much greater detail on the method.

The following year Dan Gillespie published what is now known as the Gillespie algorithm to describe chemical reactions. The algorithm is similar and the time advancement scheme essentially the same as in KMC.

There is as of the writing of this (June 2006) no definitive treatise of the theory of KMC, but Fichthorn and Weinberg have discussed the theory for thermodynamic equilibrium KMC simulations in detail. A good introduction is given also by Art Voter, and by A.P.J. Jansen,, and a recent review is (Chatterjee 2007) or (Chotia 2008). The justification of KMC as a coarse-graining of the Langevin dynamics using the quasi-stationary distribution approach has been developed by T. Lelièvre and collaborators. 

In March 2006 the, probably, first commercial software using Kinetic Monte Carlo to simulate the diffusion and activation/deactivation of dopants in Silicon and Silicon like materials is released by Synopsys, reported by Martin-Bragado et al.

Varieties of KMC
The KMC method can be subdivided by how the objects are moving or reactions occurring. At least the following subdivisions are used:

 Lattice KMC (LKMC) signifies KMC carried out on an atomic lattice. Often this variety is also called atomistic KMC, (AKMC). A typical example is simulation of vacancy diffusion in alloys, where a vacancy is allowed to jump around the lattice with rates that depend on the local elemental composition.
 Object KMC (OKMC) means KMC carried out for defects or impurities, which are jumping either in random or lattice-specific directions. Only the positions of the jumping objects are included in the simulation, not those of the 'background' lattice atoms. The basic KMC step is one object jump.
 Event KMC (EKMC) or First-passage KMC (FPKMC) signifies an OKMC variety where the following reaction between objects (e.g. clustering of two impurities or vacancy-interstitial annihilation) is chosen with the KMC algorithm, taking the object positions into account, and this event is then immediately carried out.

References

External links
 3D lattice kinetic Monte Carlo simulation in 'bit language'
 KMC simulation of the Plateau-Rayleigh instability
 KMC simulation of f.c.c. vicinal (100)-surface diffusion
 Stochastic Kinetic Mean Field Model  (gives similar results as lattice kinetic Monte Carlo, however, far more cost-effective and easier to realise — open source program code is provided)

Monte Carlo methods
Statistical mechanics
Stochastic simulation