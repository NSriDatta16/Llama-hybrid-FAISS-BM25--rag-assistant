A source-to-source translator, source-to-source compiler (S2S compiler), transcompiler, or transpiler is a type of translator that takes the source code of a program written in a programming language as its input and produces an equivalent source code in the same or a different programming language. A source-to-source translator converts between programming languages that operate at approximately the same level of abstraction, while a traditional compiler translates from a higher level programming language to a lower level programming language. For example, a source-to-source translator may perform a translation of a program from Python to JavaScript, while a traditional compiler translates from a language like C to assembler or Java to bytecode. An automatic parallelizing compiler will frequently take in a high level language program as an input and then transform the code and annotate it with parallel code annotations (e.g., OpenMP) or language constructs (e.g. Fortran's forall statements).

Another purpose of source-to-source-compiling is translating legacy code to use the next version of the underlying programming language or an API that breaks backward compatibility. It will perform automatic code refactoring which is useful when the programs to refactor are outside the control of the original implementer (for example, converting programs from Python 2 to Python 3, or converting programs from an old API to the new API) or when the size of the program makes it impractical or time-consuming to refactor it by hand.

Transcompilers may either keep translated code structure as close to the source code as possible to ease development and debugging of the original source code or may change the structure of the original code so much that the translated code does not look like the source code. There are also debugging utilities that map the transcompiled source code back to the original code; for example, the JavaScript Source Map standard allows mapping of the JavaScript code executed by a web browser back to the original source when the JavaScript code was, for example, minified or produced by a transcompiled-to-JavaScript language.

Examples include Closure Compiler, CoffeeScript, Dart, Haxe, Opal, TypeScript and Emscripten.

Assembly language translators 
So called Assembly language translators are a class of source-to-source translators converting code from one assembly language into another, including (but not limited to) across different processor families and system platforms.

Intel CONV86 

Intel marketed their 16-bit processor 8086 to be source compatible to the 8080, an 8-bit processor. To support this, Intel had an ISIS-II-based translator from 8080 to 8086 source code named CONV86 (also referred to as CONV-86 and CONVERT 86) available to OEM customers since 1978, possibly the earliest program of this kind. It supported multiple levels of translation and ran at 2 MHz on an Intel Microprocessor Development System MDS-800 with 8-inch floppy drives. According to user reports, it did not work very reliably.

SCP TRANS86 
Seattle Computer Products' (SCP) offered TRANS86.COM, written by Tim Paterson in 1980 while developing 86-DOS. The utility could translate Intel 8080 and Zilog Z80 assembly source code (with Zilog/Mostek mnemonics) into  source code for the Intel 8086 (in a format only compatible with SCP's cross-assembler ASM86 for CP/M-80), but supported only a subset of opcodes, registers and modes, and often still required significant manual correction and rework afterwards. Also, performing only a mere transliteration, the brute-force single-pass translator did not carry out any register and jump optimizations. It took about 24 KB of RAM. The SCP version 1 of TRANS86.COM ran on Z80-based systems. Once 86-DOS was running, Paterson, in a self-hosting-inspired approach, utilized TRANS86 to convert itself into a program running under 86-DOS. Numbered version 2, this was named TRANS.COM instead. Later in 1982, the translator was apparently also available from Microsoft.

Sorcim TRANS86 
Also named TRANS86, Sorcim offered an 8080 to 8086 translator as well since December 1980. Like SCP's program it was designed to port CP/M-80 application code (in ASM, MAC, RMAC or ACT80 assembly format) to MS-DOS (in a format compatible with ACT86). In ACT80 format it also supported a few Z80 mnemonics. The translation occurred on an instruction-by-instruction basis with some optimization applied to conditional jumps. The program ran under CP/M-80, MP/M-80 and Cromemco DOS with a minimum of 24 KB of RAM, and had no restrictions on the source file size.

Digital Research XLT86 
Much more sophisticated and the first to introduce optimizing compiler technologies into the source translation process was Digital Research's XLT86 1.0 in September 1981. XLT86 1.1 was available by April 1982. The program was written by Gary Kildall and translated  source code for the Intel 8080 processor (in a format compatible with ASM, MAC or RMAC assemblers) into  source code for the 8086 (compatible with ASM86). Using global data flow analysis on 8080 register usage, the five-phase multi-pass translator would also optimize the output for code size and take care of calling conventions (CP/M-80 BDOS calls were mapped into BDOS calls for CP/M-86), so that CP/M-80 and MP/M-80 programs could be ported to the CP/M-86 and MP/M-86 platforms automatically. XLT86.COM itself was written in PL/I-80 for CP/M-80 platforms. The program occupied 30 KB of RAM for itself plus additional memory for the program graph. On a 64 KB memory system, the maximum source file size supported was about 6 KB, so that larger files had to be broken down accordingly before translation. Alternatively, XLT86 was also available for DEC VAX/VMS. Although XLT86's input and output worked on source-code level, the translator's in-memory representation of the program and the applied code optimizing technologies set the foundation to binary recompilation.

Others 
2500 AD Software offered an 8080 to 8086 source-code translator as part of their XASM suite for CP/M-80 machines with Z80 as well as for Zilog ZEUS and Olivetti PCOS systems.

Since 1979, Zilog offered a Z80 to Z8000 translator as part of their PDS 8000 development system. Advanced Micro Computers (AMC) and 2500 AD Software offered Z80 to Z8000 translators as well. The latter was named TRANS and was available for Z80 CP/M, CP/M-86, MS-DOS and PCOS.

The Z88DK development kit provides a Z80 to i486 source code translator targeting nasm named "to86.awk", written in 2008 by Stefano Bodrato. It is in turn based on an 8080 to Z80 converter written in 2003 by Douglas Beattie, Jr., named "toz80.awk".

In 2021, Brian Callahan wrote an 8080 CP/M 2.2 to MS-DOS source code translator targeting nasm named 8088ify.

Programming language implementations 

The first implementations of some programming languages started as transcompilers, and the default implementation for some of those languages are still transcompilers. In addition to the table below, a CoffeeScript maintainer provides a list of languages that compile to JavaScript.

Porting a codebase 
When developers want to switch to a different language while retaining most of an existing codebase, it might be better to use a transcompiler compared to rewriting the whole software by hand. Depending on the quality of the transcompiler, the code may or may not need manual intervention in order to work properly. This is different from "transcompiled languages" where the specifications demand that the output source code always works without modification. All transcompilers used to port a codebase will expect manual adjustment of the output source code if there is a need to achieve maximum code quality in terms of readability and platform convention.

Transcompiler pipelines 

A transcompiler pipeline is what results from recursive transcompiling.  By stringing together multiple layers of tech, with a transcompile step between each layer, technology can be repeatedly transformed, effectively creating a distributed language independent specification.

XSLT is a general-purpose transform tool that can be used between many different technologies, to create such a derivative code pipeline.

Recursive transcompiling 
Recursive transcompilation (or recursive transpiling) is the process of applying the notion of transcompiling recursively, to create a pipeline of transformations (often starting from a single source of truth) which repeatedly turn one technology into another.

By repeating this process, one can turn A → B → C → D → E → F and then back into .  Some information will be preserved through this pipeline, from A → , and that information (at an abstract level) demonstrates what each of the components A–F agree on.

In each of the different versions that the transcompiler pipeline produces, that information is preserved. It might take on many different shapes and sizes, but by the time it comes back to , having been transcompiled six times in the pipeline above, the information returns to its original state.

This information which survives the transform through each format, from , is (by definition) derivative content or derivative code.

Recursive transcompilation takes advantage of the fact that transcompilers may either keep translated code as close to the source code as possible to ease development and debugging of the original source code, or else they may change the structure of the original code so much, that the translated code does not look like the source code. There are also debugging utilities that map the transcompiled source code back to the original code; for example, JavaScript source maps allow mapping of the JavaScript code executed by a web browser back to the original source in a transcompiled-to-JavaScript language.

See also 

 
 
 
  a source-to-source compiler framework using explicit pattern-directed rewrite rules
  a source-to-source compiler from Fortran 77 to C
  (running IBM 1401 programs on Honeywell H200)
 
 
 
 
 
 
 
  a source-to-source compiler framework

Notes

References

Further reading 
 
 
  1984-11-11 version 1.05 (NB. The DOS executable XLT86.COM [12 KB] translates Intel 8080 assembly language source code to Intel 8086 assembly language source code. Despite its name this implementation in 8086 assembly is not related to Digital Research's earlier and much more sophisticated XLT86.)
   
  and , also available as  
  (9 pages) (NB. This software translator was developed by ST and translates Motorola 6805/HC05 assembly source code in 2500AD Software format into ST7 source code. The MIGR2ST7.EXE executable for Windows is available from "MCU ON CD".)

External links 
 
 
 

 
Utility software types