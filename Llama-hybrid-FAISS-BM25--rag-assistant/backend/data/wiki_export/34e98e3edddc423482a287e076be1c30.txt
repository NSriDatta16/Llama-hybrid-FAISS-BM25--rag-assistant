S-algol (St Andrews Algol) is a computer programming language derivative of ALGOL 60 developed at the University of St Andrews in 1979 by Ron Morrison and Tony Davie. The language is a modification of ALGOL to contain orthogonal data types that Morrison created for his PhD thesis.  Morrison would go on to become professor at the university and head of the department of computer science. The S-algol language was used for teaching at the university at an undergraduate level until 1999. It was also the language taught for several years in the 1980s at a local school in St. Andrews, Madras College. The computer science text Recursive Descent Compiling describes a recursive descent compiler for S-algol, implemented in S-algol.

PS-algol is a persistent derivative of S-algol.  It was developed around 1981 at the University of Edinburgh and of St Andrews.  It supports database ability by providing for longevity of data in the form of a persistent heap that survives termination of PS-algol programs.

History and implementations
Ron Morrison's 1979 PhD thesis, On the Development of Algol, describes the design and implementation of the S-algol language.  The technical report defining the language, The S-algol Reference Manual (1979, 1988), thanks several people for their help, including David Turner for discussions on language design around 1975.  The 1981 computer science text Recursive Descent Compiling describes the compiler implementation and bootstrapping process, and the 1982 book An Introduction to Programming with S-algol uses the language to teach computer programming.

The first S-algol implementation was on a PDP-11/40 computer running the Unix operating system. Due to the small 64 kilobyte address space available on the PDP-11, an interpreted bytecode implementation was chosen.  A single-pass, recursive descent compiler written in S-algol translated S-algol source into S-code, a bytecode for a stack-based abstract machine tailored for S-algol.  The S-code was then executed by an interpreter.  The S-algol implementation had many similarities with work on earlier Pascal compilers. The technique of using a recursive descent compiler to produce code for an abstract machine was well known, with the Pascal P compiler being a famous example from the early 1970s. The S-algol compiler was written using the stepwise refinement process described by Urs Amman for the development of a Pascal compiler and championed by the inventor of Pascal, Niklaus Wirth.

Reflecting the memory organization of the PDP-11 as 32K 16-bit words, the S-code instruction encoding was designed so that each bytecode consisted of one word. The initial bootstrap was performed by writing an S-algol compiler in Algol W on the IBM/360 that produced S-code, and using it to compile the compiler written in S-algol to S-code.  The resulting S-code file was copied to the PDP-11 and executed on an S-code interpreter written for the PDP-11, making it self-hosting.  The self-hosted S-algol compiler executed approximately 7.7 million S-code instructions to compile itself, generating an output file of about ten thousand S-code instructions (16-bit words).

An S-code interpreter was written for the VAX computer running VMS, making the VAX the first S-algol port.  S-algol was also ported to the Zilog Z80 microprocessor running CP/M, including raster graphics facilities that had been added to the language.  In 1983, S-algol was used as the basis for the PS-algol system, used for research in persistence.  The PS-algol S-code interpreter was implemented in C, and the S-code language was extended to include raster graphics.  The PS-algol implementation was the basis for S-algol ports to the Macintosh and Sun workstations, featuring a compiler rewritten in C and targeting the extended S-code.

S-algol was the basis for the PS-algol research in 1983, and a few years later PS-algol became the starting point for the Napier88 language and implementation.  While all S-algol compilers produced S-code to be interpreted, a later Napier88 implementation experimented with generating code in C and compiling it with the gcc compiler to provide a native code implementation.

Language overview
An S-algol program is a sequence of declarations and clauses.  Language elements that are declared include constants, variables, procedures and structures.  Constant and variable declarations must specify an initial value. The compiler infers the data type of the declared constant or variable from the type of the initial value, so the type is not stated explicitly.  Data types include integer, real, boolean, string, pointer (to a structure), and file, and vectors (arrays) of these types.  Procedure declarations do specify the data types of their arguments and return value (unless void).  Structures also specify the data types of their fields.  Clauses include expressions and control structures (if, case, for, while and repeat while).  The if and case control structures can have values and can be used freely in expressions as long as the type compatibility rules are met.

! Comments are introduced by an exclamation point and continue until end of line.

! The let keyword introduces declarations of constants and variables
! Identifiers start with an alphabetic character followed by alphanumeric characters or the full stop (.)
! An initial value must be given, and this determines the data type of declaration

let width := 10                   ! := sets the value of a variable, this is an int
let animal := "dog"               ! type string

let x := -7 ; let y := x + x      ! ; separates clauses, needed only if there are two or more clauses on a line

let n.a = 6.022e+23               ! = is used to set the value of a constant, this is a cfloat (constant float)

! if and case can have values and be used in expressions
let no.of.lives := if animal = "cat" then 9 else 1

! Sieve of Eratosthenes
write "Find primes up to n = ?"
let n = readi                     ! constant values can be set during the program run
let p = vector 2::n of true       ! vector of bool with bounds 2 to n
for i = 2 to truncate(sqrt(n)) do ! for indexes are constants so they use = rather than :=
    if p(i) do                    ! vector dereference uses parens like a procedure call
        for j = 2 * i to n by i do
            p(j) := false
for i = 2 to n do
    if p(i) do write i, "'n"      ! 'n in a literal string is a newline

! structure (record) type for a binary tree of cstrings
! the pntr data type can point to a structure of any type, type checking is done at runtime
structure tree.node(cstring name ; pntr left, right)

! inserts a new string into the binary tree head
procedure insert.tree(cpntr head ; cstring new -> pntr)
! the case clause ends with a mandatory default option, use default : {} if it is not needed
case true of
    head = nil       : tree.node(new, nil, nil)
    new < head(name) : { head(left) := insert.tree(head(left), new) ; head }
    new > head(name) : { head(right) := insert.tree(head(right), new) ; head }
    default          : head

procedure print.tree(cpntr head)
if head ~= nil do                 ! ~= is the not equals operator
begin
    print.tree(head(left))
    write head(name), "'n"
    print.tree(head(right))
end

let fruit := nil
fruit := insert.tree(fruit, "banana")
fruit := insert.tree(fruit, "kiwi")
fruit := insert.tree(fruit, "apple")
fruit := insert.tree(fruit, "peach")
print.tree(fruit)                 ! print in sorted order

! The end of the S-algol program is indicated by ?
?

Semantic principles
As its name suggests, S-algol is a member of the ALGOL family of programming languages.  Morrison identifies five traits of the ALGOL family:
 Scope rules and block structure – Names can be introduced to define local quantities that are undefined outside the local environment, but different environments may use the same name unambiguously to represent different objects.
 Abstraction facility – Provision of a powerful abstraction facility to shorten and clarify programs. In the ALGOL family this is offered by procedures with parameters.
 Compile-time type checking – Types can be checked by a static analysis of the program.
 Infinite store – The programmer is not responsible for storage allocation and can create as many data objects as needed.
 Selective store updating – The program may selectively alter the store.  In the ALGOL family this is effected by the assignment statement.

S-algol was designed to differ from prior members of the ALGOL family by being designed according to semantic principles to provide power through simplicity, and simplicity through greater generality. (See Orthogonal.)  Morrison describes three semantic principles that guided the design of S-algol:
 Principle of correspondence – The rules governing names should be uniform and apply everywhere.  This mostly applies to correspondence between declarations and procedure parameters, including consideration of all parameter passing modes.  This principle was examined by R. D. Tennent in conjunction with Pascal, and has its roots in work by Peter Landin and Christopher Strachey.
 Principle of abstraction – It should be possible to abstract over all meaningful semantic categories in the language.  Examples include the function, which is an abstraction over expressions, and the procedure, an abstraction over statements. Tennent and Morrison note that this is a difficult principle to apply because it is hard to identify the semantically meaningful constructs that should be abstracted.
 Principle of data type completeness – All data types should have the same rights in the language, and should be allowed in general operations such as assignment or being passed as a parameter. (See first-class citizen.)
Morrison also identifies one more basic design consideration:
 Conceptual store – The key design decisions concerning the store (memory management) include how the store is used, its relationship to data types, implementation of pointers, and protection (constant locations that can't be updated).

Design
Morrison's thesis explains how the design principles were applied in S-algol.

Data types
The basic or primitive data types in S-algol are integer, real, boolean, file, and string. (Later pixel and picture types were added to support raster graphics.)  Integer, real, and boolean are types common to most programming languages.  The file type is an input/output (I/O) stream that allows writing or reading data objects.  The string type in many languages at that time was considered a compound type, but including it as a native type makes the basic operations of concatenation, substring selection, length, and the comparisons (equals, less than, etc.) easier to use.  It is much more pleasant than the arrays of characters used in Pascal.

Vectors are provided with components of any type.  For any data type T, *T is the type of a vector with components of type T.  The bounds of the vector are not part of its type but are determined dynamically, and multi-dimension arrays are implemented as vectors of vectors.

The structure data type comprises any fixed number of fields each of a fixed type.  The class of a structure is not part of the type but can be determined dynamically.

The closure of basic types over vectors and structures provides an infinite number of data types.  The language definition allows any type to be used anywhere a type is acceptable.  This does not apply to infix operators, as they are syntactic sugar for common functions and are not part of the semantic model.

The store
Vectors and structures have full rights and can be assigned as passed as parameters, but copy on assignment and when passed can be inefficient for large objects.  Vectors and structures are treated as pointers to the objects, and the pointers are assigned and passed as parameters.  Pointers as general objects themselves as in ALGOL 68 and C are rejected for S-algol because of the concerns of C.A.R. Hoare about the null pointer and the problems with dangling pointers.

S-algol provides true constant values, objects which value cannot be updated.  This idea is due to Strachey, but constants in many languages such as Pascal are manifest constants, processed at compile time and not implemented as protected locations.  Also it must be possible to declare a constant of any data type, not just the scalar types.

Control structures
S-algol is an expression-oriented language, and statements are expressions of type void.  As a consequence, some control structures are expressions that yield values.

There are several conditional constructs.  The two-alternative version of the conditional is if <condition> then <clause> else <clause>, where the clauses can be statements or expressions.  If they are expressions, they must have the same type.  The one-armed conditional if <condition> do <statement> has type void. Use of do instead of else in the conditional statement avoids the dangling else syntactic ambiguity.

The case clause has a selector of any type which is matched using an equality test against expressions of the same type to find the selected clause.  The case clause can be a statement or an expression, so the result clauses must all be statements (type void) or expressions of the same type.  Matches are tested in order, so this resembles the guarded commands of Edsger Dijkstra without the non-determinism.

The loop statements are mostly conventional.  The for loop is similar to that of Hoare.  The control identifier is constant and cannot be modified inside the loop.  Also conventional are the while <condition> do <statement> and repeat <statement> while <condition> loops.  The repeat <statement> while <condition> do <statement> construct provides the early exit or "n-and-a-half" loop.

Abstractions
S-algol abstracts expressions as functions and statements (void expressions) as procedures.  Modules would provide the abstraction of declarations, but S-algol does not include modules because of the difficulties they pose with block-structured scope.  The final syntactic category is sequencer, or control structure.  Tennent used the term sequel for the abstraction over sequencers, these would be generalizations of goto and break.  The best known abstraction in this category is call-with-current-continuation, but it would not be well understood until some years later.  S-algol does not include goto or break, and does not include abstraction over sequencers.

Declarations and parameters
Every data object in S-algol must be given a value when it is declared.  This corresponds to call by value parameter passing and removes the possibility of using an uninitialised value. In fact call by value is the only parameter passing method in S-algol. Reference and result parameters are rejected, which is consistent with the S-algol ban on passing l-values.  Structures and vectors are passed as pointers to the objects, but this is still call by value as the behavior is the same as the value used on the right side of assignments.

Every declaration has a parametric equivalent.  All procedure parameter types must be specified.  Any procedure passed as a parameter has its full type specified (in contrast to Pascal) and the same is true for a structure class.

Input output model
S-algol provides the file data type for I/O streams, and several variations of read and write are defined to operate on the basic types.  It is expected that individual implementations will extend these simple facilities as needed.

Concrete syntax
ALGOL languages have been criticized as being verbose.  S-algol attempts to improve this by providing less restrictive syntax.  This is demonstrated mostly in the declaration syntax.  Since variable declarations must always include an initial value, the type does not need to be specified explicitly.

Although it would be possible to infer procedure parameter and return types by examining where the procedure is called, S-algol does require parameter and return types to be specified.  This is a practical decision, since it should be possible to understand a procedure without examining its calls.

Most ALGOLs require that all declarations come before the statements in a block.  In S-algol, declarations may be mixed with statements because everything must be declared before it is used and there is no goto that would permit jumping past a declaration.

See also
Napier88

References

External links
Algol 60 implementations and dialects, Computer History Museum Software Preservation Group
Persistent S-algol

ALGOL 60 dialect