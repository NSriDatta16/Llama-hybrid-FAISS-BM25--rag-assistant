The IBM Basic assembly language and successors is a series of assembly languages and assemblers made for the IBM System/360 mainframe system and its successors through the IBM Z.

The first of these, the Basic Assembly Language (BAL), is an extremely restricted assembly language, introduced in 1964 and used on 360 systems with only 8 KB of main memory, and only a card reader, a card punch, and a printer for input/output, as part of IBM Basic Programming Support (BPS/360). The Basic Assembler for BAL was also available as part of Basic Operating System/360 (BOS/360).

Subsequently, an assembly language appeared for the System/360 that had more powerful features and usability, such as support for macros. This language, and the line of assemblers that implemented it, continued to evolve for the System/370 and the architectures that followed, inheriting and extending its syntax. Some in the computer industry referred to these under the generic term "Basic Assembly Language" or "BAL". Many did not, however, and IBM itself usually referred to them as simply the "System/360 Assembler Language", as the "Assembler" for a given operating system or platform, or similar names. Specific assemblers were known by such names as Assembler E, Assembler F, Assembler H, and so forth.  Programmers utilizing this language, and this family of assemblers, also refer to them as ALC (for Assembly Language Coding), or simply "the assembler".

The latest derived language is known as the IBM High-Level Assembler (HLASM).

General characteristics
As it is an assembly language, BAL uses the native instruction set of the IBM mainframe architecture on which it runs, System/360. 

The successors to BAL use the native instruction sets of the IBM mainframe architectures on which they run, including System/360, System/370, System/370-XA, ESA/370, ESA/390, and z/Architecture.

The simplicity of machine instructions means that the source code of a program written in assembler will usually be much longer than an equivalent program in, say, COBOL or Fortran. In the past, the speed of hand-coded assembler programs was often felt to make up for this drawback, but with the advent of optimizing compilers, C for the mainframe, and other advances, assembler has lost much of its appeal. IBM continues to upgrade the assembler, however, and it is still used when the need for speed or very fine control is paramount. However, all of the IBM successors to BAL have included a sophisticated macro facility that allows writing much more compact source code.

Another reason to use assembler is that not all operating system functions can be accessed in high level languages. The application program interfaces of IBM's mainframe operating systems is defined as a set of assembly language "macro" instructions, that typically invoke Supervisor Call (SVC) [e.g., on z/OS] or Diagnose (DIAG) [on, e.g., z/VM] instructions to invoke operating system routines. It is possible to use operating system services from programs written in high-level languages by use of assembler subroutines.

Assembler statement format

The format of assembler language statements reflects the layout of an 80-column punched card, though successive versions have relaxed most of the restrictions.

 The optional statement label or name is a string alphanumeric characters beginning in column 1. The first character has to be alphabetic. Later versions added @, #, $, and _ to the legal characters used in labels, and increased the size from the initial six, to eight characters, then to almost unlimited lengths.
 The operation code or "mnemonic" can begin in any column to the right of column 1, separated from the statement label by a blank. The operation code would be only a machine instruction (macros were not available), making it usually 1, 2, 3, or rarely 4 letters. The operation code was enhanced to allow up to eight characters, then later to effectively unlimited lengths.
 The operand field can begin in any column to the right of the operation code, separated from the operation code by at least one blank. Blanks are invalid in operands except in character constants. The operand field, consisting of one or more operands, is optional depending on the operation code.
 Optional comments can appear to the right of the operand field, separated by at least one blank.
 Basic Assembly Language does not allow statement continuation. Later versions of the assembler indicate continuation by the appearance of any non-blank character in column 72 of the statement being continued. Basic Assembly Language requires that column 72 be blank.
 A "full-card comment" is indicated by an asterisk (*) in column 1.
 Card columns 73–80, called the identification-sequence field can be used by the programmer for any purpose, but usually contain sequence numbers for resorting a jumbled card deck.

Basic Assembly language also permits an alternate statement format with the statement starting in column 25, allowing the assembled instruction to be punched into the same card beginning in column 1. This option was not continued in later versions of the assembler.

Types of instructions
Three main types of instructions are found in the source code of a program written in assembler.

Assembler instructions
Assembler instructions, sometimes termed directives, pseudo operations or pseudoops on other systems, are requests to the assembler to perform various operations during the code generation process. For instance, CSECT means "start a section of code here"; DSECT provides data definitions for a structure, but generates no code; DC defines a constant to be placed in the object code.

One of the more important assembler instructions is USING, which supports the base-displacement addressing of the S/360 architecture. It guides the assembler in determining what base register and offset it should use for a relative address. In BAL, it was limited to the form

         USING base,reg-1,...,reg-n
Machine instruction addresses on S/360 specify a displacement (0–4095 bytes) from the value in a base register; while later versions of the architecture added relative-address formats, the older formats are still used by many instructions. USING allows the programmer to tell the assembler that the specified base registers are assumed to contain the address of "base", base+4096 (if multiple registers are specified), etc. This only provides a shortcut for the programmer, who otherwise would have to specify the base register in each instruction. Programmers are still responsible for actually loading the address of "base" into the register before writing code that depends on this value.

The related DROP assembler instruction nullifies a previous USING.

Machine instructions (mnemonic)
There is a one-to-one relationship with machine instructions. The full mnemonic instruction set is described in the Principles of Operation manual for each instruction set.
Examples:

 * This is a comment line
 * Load the fullword integer stored at the
 * location labeled 'ZIGGY' into general register 3:
       L     3,ZIGGY
       SLA   4,5             shift the value in general register 4 left by 5 bits
       MVC   TARGET,SOURCE   move characters from location 'SOURCE' to 'TARGET'
       AP    COUNT,=P'1'     add 1 to value in memory location 'COUNT' (packed decimal format)
       B     NEXT            unconditional branch to label 'NEXT'
 HERE  EQU   *               This is a label
       CLC   TARGET,=C'ADDRESS'  Compare memory location 'TARGET' to string 'ADDRESS'
       BE    THERE               branch if equal to program label 'THERE'

Generally accepted standards, although by no means mandatory, include the identification of general purpose registers with mnemonics. Unlike assemblers for some other systems, such as X86 assembly language, register mnemonics are not reserved symbols but are defined through EQU statements elsewhere in the program. This improves readability of assembler language programs and provides a cross-reference of register usage. Thus typically you may see the following in an assembler program:

 R3    EQU  3
       ...
       L    R3,ZIGGY

Some notable instruction mnemonics are BALR for a call storing the return address and condition code in a register, SVC, DIAG, and ZAP.

System/360 machine instructions are one, two, or three halfwords in length (two to 6 bytes). Originally there were four instruction formats, designated by the first two bits of the operation code field; z/Architecture added additional formats.

Macros and conditional assembly
The Basic Programming Support assembler did not support macros. Later assembler versions beginning with Assembler D allow the programmer to group instructions together into macros and add them to a library, which can then be invoked in other programs, usually with parameters, like the preprocessor facilities in C and related languages. Macros can include conditional assembler instructions, such as AIF (an ‘if’ construct), used to generate different code according to the chosen parameters. That makes the macro facility of this assembler very powerful. While multiline macros in C are an exception, macro definitions in assembler can easily be hundreds of lines.

Operating system macros
Most programs will require services from the operating system, and the OS provides standard macros for requesting those services. These are analogous to Unix system calls. For instance, in MVS (later z/OS), STORAGE (with the OBTAIN parameter) dynamically allocates a block of memory, and GET retrieves the next logical record from a file.

These macros are operating-system-dependent; unlike several higher-level languages, IBM mainframe assembly languages don't provide operating-system-independent statements or libraries to allocate memory, perform I/O operations, and so forth, and different IBM mainframe operating systems are not compatible at the system service level. For example, writing a sequential file would be coded differently in z/OS and in z/VSE.

Examples
The following fragment shows how the logic "If SEX = 'M', add 1 to MALES; else, add 1 to FEMALES" would be performed in assembler.

          CLI   SEX,C'M'       Male?
          BNE   IS_FEM         If not, branch around
          L     7,MALES        Load current value of MALES into register 7
          LA    7,1(7)        add 1 
          ST    7,MALES        store back the result
          B     GO_ON          Finished with this portion
 IS_FEM   EQU   *              A label
          L     7,FEMALES      Load current value in FEMALES into register 7 
          LA    7,1(7)         add 1 
          ST    7,FEMALES      store back the result
 GO_ON    EQU   *              - rest of program -
 *
 MALES    DC    F'0'           Counter for MALES (initially=0)
 FEMALES  DC    F'0'           Counter for FEMALES (initially=0)

The following is the ubiquitous Hello world program, and would, executing under an IBM operating system such as OS/VS1 or MVS, display the words 'Hello World' on the operator's console:

 HELLO    CSECT               The name of this program is 'HELLO'
 *                            Register 15 points here on entry from OPSYS or caller.
          STM   14,12,12(13)  Save registers 14,15, and 0 thru 12 in caller's Save area
          LR    12,15         Set up base register with program's entry point address
          USING HELLO,12      Tell assembler which register we are using for pgm. base
          LA    15,SAVE       Now Point at our own save area
          ST    15,8(13)      Set forward chain
          ST    13,4(15)      Set back chain
          LR    13,15         Set R13 to address of new save area
 *                            -end of housekeeping (similar for most programs) -
          WTO   'Hello World' Write To Operator (Operating System macro)
 *
          L     13,4(13)      restore address to caller-provided save area
          XC    8(4,13),8(13) Clear forward chain
          LM    14,12,12(13)  Restore registers as on entry
          DROP  12            The opposite of 'USING'
          SR    15,15         Set register 15 to 0 so that the return code (R15) is Zero
          BR    14            Return to caller
 *           
 SAVE     DS    18F           Define 18 fullwords to save calling program registers 
          END  HELLO          This is the end of the program

WTO is an assembler macro that generates an operating system call. Because of saving registers and later restoring and returning, this small program is usable as a batch program invoked directly by the operating system Job control language (JCL) like this:

// EXEC PGM=HELLO

or, alternatively, it can be CALLed as a subroutine from such a program:

 CALL 'HELLO'

Versions

With the exception of the assemblers for the IBM System/360 Model 20, the IBM assemblers were largely upward-compatible. The differences were mainly in the complexity of expressions allowed and in macro processing. OS/360 assemblers were originally designated according to their memory requirements.

Basic Programming Support assembler
The assembler for BPS is the true "basic assembler." It was intended to be loaded from cards and would run on an 8 KB System/360 (except Model 20). It has no support for macro instructions or extended mnemonics (such as BH in place of BC 2 to branch if condition code 2 indicates a high compare). It can assemble only a single control section and does not allow dummy sections (structure definitions). Parenthesized expressions are not allowed and expressions are limited to three terms with the only operators being '+', '-', and '*'.

Basic Operating System assembler
The Basic Operating System has two assembler versions. Both require 16 KB memory, one is tape resident and the other disk.

Assembler D
Assembler D was the DOS/360 assembler for machines with a memory size of 16 KB. It came in two versions: A 10 KB variant for machines with the minimum 16 KB memory, and a 14 KB variant for machines with 24 KB. An F-level assembler was also available for DOS machines with 64 KB or more. D assemblers offered nearly all the features of higher versions.

Assembler E and F
Assembler E was designed to run on an OS/360 system with a minimum of 32 KB of main storage, with the assembler itself requiring 15 KB. Assembler F can run under either DOS/360 or OS/360 on a system with a 64 KB memory, with the assembler requiring 44 KB. These assemblers are a standard part of OS/360; the version that was generated was specified at system generation (SYSGEN).

Assembler H
Assembler H runs on OS/360 and successors; it was faster and more powerful than Assembler F, but the macro language was not fully compatible.

Assembler H Version 2 was announced in 1981 and includes support for Extended Architecture (XA), including the AMODE and RMODE directives. It was withdrawn from marketing in 1994 and support ended in 1995. It was replaced by High Level Assembler.

Assembler XF
Assembler XF is a mostly compatible upgrade of Assembler F that includes the new System/370 architecture instructions. This version provides a common assembler for OS/VS, DOS/VS and VM systems. Other changes include relaxing restrictions on expressions and macro processing. Assembler XF requires a minimum partition/region size of 64 KB (virtual). Recommended size is 128 KB.

High Level Assembler
High Level Assembler or HLASM was released in June 1992 replacing IBM's Assembler H Version 2. It was the default translator for System/370 and System/390, and supported the MVS, VSE, and VM operating systems. As of 2023 it is IBM's current assembler programming language for its z/OS, z/VSE, z/VM and z/TPF operating systems on z/Architecture mainframe computers. Release 6 and later also run on Linux, and generate ELF or GOFF object files (this environment is sometimes referred to as Linux on IBM Z). While working at IBM, John Robert Ehrman created and was the lead developer for HLASM and is considered the "father of high level assembler".

Despite the name, HLASM on its own does not have many of the features normally associated with a high-level assembler. The name may come from the additional macro language capabilities, such as the ability to write user-defined functions. The assembler is mostly similar to Assembler H and Assembler(XF), incorporating the SLAC (Stanford Linear Accelerator) modifications. Among features added were an indication of CSECT/DSECT for location counter, dependent and labelled USING statements, a list of USING statements currently active, an indication of whether a variable is read or written in the cross-reference, and allowing mixed-case symbol names. The RSECT directive (Read-only Control Section) allows the assembler to check reentrancy on a per-section basis. RSECT was previously "undocumented and inconsistently implemented in Assembler H."

High Level Assembler Toolkit
The High Level Assembler Toolkit is a separately priced accompaniment to the High Level Assembler.  The toolkit contains:
 A set of structured programming macros —
IF/ELSE/ENDIF
DO/ENDDO
STRTSRCH/ORELSE/ENDLOOP/ENDSRCH
CASENTRY/CASE/ENDCASE
SELECT/WHEN/OTHRWISE/ENDSEL.
 A disassembler.
 A "Program Understanding Tool" (re-engineering aid).
 A Source XREF utility (cross-reference facility).
 Interactive Debug Facility.
 Enhanced SuperC (source comparison tool).

Specialized versions

7090/7094 Support Package assembler
The IBM 7090/7094 Support Package, known as SUPPAK, "consists of three programs designed to permit programs written for a System 360 to be assembled, tested, and executed on an IBM 709, 7090, 7094, or 7094 II."

This cross-assembler runs on a 7090 or 7094 system and was used while System/360 was in development. This assembler supports six-bit BCD character set as well as eight-bit EBCDIC.

IBM System/360 Model 20 assemblers
IBM supplied two assemblers for the Model 20: the Model 20 Basic Assembler, and the Model 20 DPS/TPS Assembler. Both supported only instructions available on the Model 20, including unique instructions CIO, TIO, XIOB, SPSW, BAS, BASR, and HPR. The Basic Assembler is a slightly more restricted version of System/360 Basic Assembler; notably, symbols are restricted to four characters in length. This version is capable of running on a system with 4 KB memory, and macro support is limited to IOCS macros. The card versions are two-pass assemblers that only support card input/output. The tape-resident versions are one-pass, using magnetic tape for intermediate storage. Programs assembled with the CPS Assembler can address a maximum of 16 KB.

The DPS/TPS assembler is a somewhat restricted version of System/360 BPS/BOS Assembler.

IBM System/360 Model 44 PS assembler
The IBM System/360 Model 44 Programming System Assembler processes a language that is a "selected subset" of OS/360 and DOS/360 assembler language. 

Most significantly the Model 44 assembler lacks support for macros and continuation statements. On the other hand it has a number of features not found in other System/360 assemblers—notably instructions to update a card image source dataset, named common, and implicit definition of SETA assembler variables.

It has no support for storage-to-storage (SS) instructions or the convert to binary (CVB), convert to decimal (CVD), read direct (RDD) and write direct (WRD) instructions. It does include four instructions unique to the Model 44: Change Priority Mask (CHPM), Load PSW Special (LPSX), Read Direct Word (RDDW), and Write Direct Word (WRDW). 

It also includes directives to update the source program, a function performed by utility programs in other systems (SKPTO, REWND, NUM, OMIT and ENDUP).

IBM System/360 TSS assembler
The assembler for the System/360 Model 67 Time Sharing System has a number of differences in directives to support unique TSS features. The PSECT directive generates a Prototype Control Section containing relocatable address constants and modifiable data used by the program.

Assembler G
"Assembler G" is a set of modifications made to Assembler F in the 1970s by the University of Waterloo (Assembler F was/is open source). Enhancements are mostly in better handling of input/output and improved buffering which speed up assemblies considerably. "Assembler G" was never an IBM product.

Non-IBM assemblers
There have been several IBM-compatible assemblers for special environments.

 The Univac 90/60, 90/70 and 90/80 series from Unisys was designed to accept IBM-format assembler, as the machine series was a workalike to the S/360 and S/370.
 The Fujitsu BS2000 series was also built as a 370 workalike from the same resource as Univac, and is still in use in some parts of Europe.
 Dignus LLC Systems/ASM is an HLASM-compatible assembler that can run natively on IBM systems or as a cross-assembler.
 Freeware PC/370, written by Don Higgins, was later purchased by Micro Focus.
 z390 is an assembler and System 390 emulator also written by Don Higgins and is programmed in Java. It is open source and available from http://www.z390.org/
 Penn State University authored a package called ASSIST, which includes a System 370 assembler and interpreter.
 Tachyon Software LLC markets the Tachyon Assembler Workbench which runs on Windows, Linux/x86, Linux for S/390 and zSeries, AIX and Solaris.
 GNU Assembler (gas) is part of the GNU Compiler Collection (gcc) for Linux on OS/390 and IBM Z. This assembler has a unique syntax that is incompatible with other assemblers for IBM architectures.

Importance
Originally all System/360 operating systems were written in assembler language, and all system interfaces were defined by macro definitions. Access from high-level languages (HLLs) was restricted to what that language supplied, and other system calls had to be coded as assembler subroutines called from HLL programs. Also, IBM allowed customization of OS features by an installation thru what were known as Exits—user-supplied routines that could extend or alter normal OS functions. These exits were required to be coded in assembler language. Later, IBM recoded OS/360 in a systems programming language, PL/S, but, except for a short trial, decided not to release the PL/S compiler to users. As a result of these factors, assembler language saw significant use on IBM systems for many years.

See also
 IBM System/360
 ASSIST assembler
 PC-based IBM-compatible mainframes – list of compatible machines or virtual machines
 Disassembler – reverse process of Assembly, reconstructing assembly-like source from machine code

Notes

References

External links

 IBM High Level Assembler manual
 A Programmer's Introduction to IBM System/360 Assembler Language (Student Text)
 High Level Assembler for z/OS & z/VM & z/VSE Language Reference
 The Punctilious Programmer: IBM Mainframe Assembler
 Basic IBM Mainframe Assembly Language Programming
 OS/390 Assembler Programming Introduction (archived)
 Web enabled IBM Assembler F compiler for small experiments
 ASSIST – Assembler System for Student Instruction & Systems Teaching

Basic assembly language
Assembly languages
Assembly language software
Assembly language Basic