In computer science, a type system is nominal (also called nominative or name-based) if compatibility and equivalence of data types is determined by explicit declarations and/or the name of the types. Nominal systems are used to determine if types are equivalent, as well as if a type is a subtype of another. Nominal type systems contrast with structural systems, where comparisons are based on the structure of the types in question and do not require explicit declarations.

Nominal typing 

Nominal typing means that two variables are type-compatible if and only if their declarations name the same type. For example, in C, two struct types with different names in the same translation unit are never considered compatible, even if they have identical field declarations.

However, C also allows a typedef declaration, which introduces an alias for an existing type. These are merely syntactical and do not differentiate the type from its alias for the purpose of type checking. This feature, present in many languages, can result in a loss of type safety when (for example) the same primitive integer type is used in two semantically distinct ways. Haskell provides the C-style syntactic alias in the form of the type declaration, as well as the newtype declaration that does introduce a new, distinct type, isomorphic to an existing type.

Nominal subtyping 

In a similar fashion, nominal subtyping means that one type is a subtype of another if and only if it is explicitly declared to be so in its definition. Nominally-typed languages typically enforce the requirement that declared subtypes be structurally compatible (though Eiffel allows non-compatible subtypes to be declared). However, subtypes which are structurally compatible "by accident", but not declared as subtypes, are not considered to be subtypes.

C++, C#, Java, Objective-C, Delphi, Swift, Julia and Rust all primarily use both nominal typing and nominal subtyping.

Some nominally-subtyped languages, such as Java and C#, allow classes to be declared final (or sealed in C# terminology), indicating that no further subtyping is permitted.

Comparison 

Nominal typing is useful at preventing accidental type equivalence, which allows better type-safety than structural typing. The cost is a reduced flexibility, as, for example, nominal typing does not allow new super-types to be created without modification of the existing subtypes.

See also 
 Structural type system
 Abstract type
 Type system

References

Sources

External links 
 c2.com: Nominative and structural typing

Type systems