In configuration management (CM), one has to control (among other things) changes made to software and documentation. This is called revision control, which manages multiple versions of the same unit of information. Although revision control is important to CM, it is not equal to it.

Synchronization Models, also known as Configuration Management Models (Feiler, 1991), describe methods to enable revision control through allowing simultaneous, concurrent changes to individual files.

Synchronization models 
Feiler (1991) reports on four different synchronization models, shortly described below.

Check-out/check-in 
In the check-out/check-in model, files are stored individually in a repository from which they are checked out whenever the files are accessed, and checked in when they have changed. This repository can store multiple versions of the files. Because these files can be documentation or source code, but can also be a collection of files, the term Configuration item (CI) will be used from now on. The basic mechanism used to prevent conflicts by simultaneous modifications is that of locking.

Composition 
The composition model is an extension on the check-out/check-in model. This model allows developers to think in configurations instead of individual files. Although the complete check-out/check-in model is represented in the composition model, it enables the use of different strategies for updating through the use of improved support for the management of configurations. A configuration is defined as being built up from a system model and version selection rules. The system model determines which files are used, while the version selection rules determine which version of the files (e.g. the latest versions or of a certain development state).

Long transactions 
The long transactions model takes a broader approach by assuming that a system is built up out of logical changes. Its focus is on the coordination and integration of these changes. Basically, it uses versions of configurations and versions of files. A configuration is created based on a change request which is stored separately. Files in this configuration can be synchronized using the check-out/check-in model. When the change is completed, the complete configuration is stored back into the repository and integrated with other changes.

Change set 

The change set model also works based on change requests and has a lot in common with the long transactions model. However, it starts with a certain configuration as the basis for changes. This is then changed according to the independent change requests that come in. New configurations of the product are then created by applying sets of the independently stored changes on the baseline version.

This entry covers the check-out/check-in synchronization model, including a meta-model (a process-data diagram). Because the check-out/check-in model is also included as a part of the other models discussed above, it is therefore further elaborated upon. Issues that are not discussed in detail are the three remaining synchronization models and the actual editing of CIs together with the methods related to this.

Vocabulary

Elaboration on check-out/check-in model 
This section contains an elaboration on the check-out/check-in synchronization model.

Process-data diagram 

The process-data diagram above describes the different concepts that are applicable in the check-out/check-in synchronization model and their relation to the activities that take place. Central to the meta-data model (right side of the figure) is the Configuration Item. This is stored in one or more repositories and can for example be a source code file or a collection of other CIs. The repository can contain multiple branches and revisions of files. These in turn consist of configuration items.

The meta-process model (left side of the figure) describes the process of the check-out and check-in activities. The activities are explained in the table of activities below.

Evaluation 
Feiler (1991) evaluated the check-out/check-in synchronization model. It has the clear advantage that it's easy to use and understand. However, this simplicity results in a lack of management of configurations, such as product version tracking and checking version history across multiple logically connected files.

The turn-taking mechanism of locking is a real problem as well when working with many developers, as these files cannot be edited by others once it has been locked.

Example 
To illustrate the check-out/check-in synchronization model, this section contains an example of how this process works. The figure below contains a state transition diagram of a CI.

When a CI is first created, it is modified and stored in the repository. When someone requests to open the CI, it is first copied to the local machine of the developer (note: there are systems where editing occurs directly in the repository. The copy step however is the classic check-out/check-in way). When that developer also wants to edit the CI, it requests a lock. This can be done directly at the request of opening a CI, but also after some time of reading it. When the CI is not locked yet, a lock is applied and it can be modified by the developer. After modifications have been done, it is stored back in the repository and unlocked.
Now, assume that the developer that was just discussed is in the process of editing a CI that is already in the repository. You want to open a CI from the repository and so it is copied to your local drive. You start reading it and find some things you wish to change, so you request to edit it. However, the CI is already locked and you will have to wait for it to be unlocked or close the file and proceed to another one.

See also 
Configuration management
Revision control
Change management process
Release management
Product structure modeling
Product family engineering
Product life-cycle management
List of revision control software

References 

Version control