The Verhoeff algorithm is a checksum for error detection first published by Dutch mathematician Jacobus Verhoeff in 1969.  It was the first decimal check digit algorithm which detects all single-digit errors, and all transposition errors involving two adjacent digits, which was at the time thought impossible with such a code.

The method was independently discovered by H. Peter Gumm in 1985, this time including a formal proof and an extension to any base.

Goals
Verhoeff had the goal of finding a decimal code—one where the check digit is a single decimal digit—which detected all single-digit errors and all transpositions of adjacent digits. At the time, supposed proofs of the nonexistence of these codes made base-11 codes popular, for example in the ISBN check digit.

His goals were also practical, and he based the evaluation of different codes on live data from the Dutch postal system, using a weighted points system for different kinds of error.  The analysis broke the errors down into a number of categories: first, by how many digits are in error; for those with two digits in error, there are transpositions (ab → ba), twins (aa → 'bb'), jump transpositions (abc → cba), phonetic (1a → a0), and jump twins (aba → cbc).  Additionally there are omitted and added digits.  Although the frequencies of some of these kinds of errors might be small, some codes might be immune to them in addition to the primary goals of detecting all singles and transpositions.

The phonetic errors in particular showed linguistic effects, because in Dutch, numbers are typically read in pairs; and also while 50 sounds similar to 15 in Dutch, 80 doesn't sound like 18.

Taking six-digit numbers as an example, Verhoeff reported the following classification of the errors:.

Description
The general idea of the algorithm is to represent each of the digits (0 through 9) as elements of the dihedral group . That is, map digits to , manipulate these, then map back into digits. Let this mapping be 

Let the nth digit be  and let the number of digits be .

For example given the code 248 then  is 3 and . 

Now define the permutation 

For example . Another example is  since 

Using multiplicative notation for the group operation of , the check digit is then simply a value  such that

 is explicitly given by inverse permutation

For example the check digit for 248 is 5. To verify this, use the mapping to  and insert into the LHS of the previous equation

To evaluate this permutation quickly use that

to get that

This is the same reflection being iteratively multiplied. Use that reflections are their own inverse.

In practice the algorithm is implemented using simple lookup tables without needing to understand how to generate those tables from the underlying group and permutation theory. This is more properly considered a family of algorithms, as other permutations work too. Verhoeff's notes that the particular permutation, given above, is special as it has the property of detecting 95.3% of the phonetic errors.

The strengths of the algorithm are that it detects all transliteration and transposition errors, and additionally most twin, twin jump, jump transposition and phonetic errors.

The main weakness of the Verhoeff algorithm is its complexity. The calculations required cannot easily be expressed as a formula in say . Lookup tables are required for easy calculation. A similar code is the Damm algorithm, which has similar qualities.

Table-based algorithm 
The Verhoeff algorithm can be implemented using three tables:
a multiplication table d, an inverse table inv, and a permutation table p.

The first table, d, is based on multiplication in the dihedral group D5. and is simply the Cayley table of the group.  Note that this group is not commutative, that is, for some values of j and k, d(j,k) ≠ d(k, j).

The inverse table inv represents the multiplicative inverse of a digit, that is, the value that satisfies d(j, inv(j)) = 0.

The permutation table p applies a permutation to each digit based on its position in the number. This is actually a single permutation  applied iteratively; i.e. p(i+j,n) = p(i, p(j,n)).

The Verhoeff checksum calculation is performed as follows:

 Create an array n out of the individual digits of the number, taken from right to left (rightmost digit is n0, etc.).
 Initialize the checksum c to zero.
 For each index i of the array n, starting at zero, replace c with .

The original number is valid if and only if .

To generate a check digit, append a , perform the calculation: the correct check digit is .

Examples 

Generate a check digit for 236:

c is 2, so the check digit is inv(2), which is 3.

Validate the check digit 2363:

c is zero, so the check is correct.

See also 
 Luhn algorithm, earlier (1960) check digit algorithm

References

External links

 Detailed description of the Verhoeff algorithm

Modular arithmetic
Checksum algorithms
Error detection and correction
1969 introductions