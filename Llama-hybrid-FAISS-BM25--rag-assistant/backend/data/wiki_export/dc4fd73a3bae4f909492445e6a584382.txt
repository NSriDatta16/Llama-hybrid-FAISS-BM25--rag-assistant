In computing, prebinding, also called prelinking, is a method for optimizing application load times by resolving library symbols prior to launch.

Background 
Most computer programs consist of code that requires external shared libraries to execute.  These libraries are normally integrated with the program at run time by a loader, in a process called dynamic linking.

While dynamic linking has advantages in code size and management, there are drawbacks as well.  Every time a program is run, the loader needs to resolve (find) the relevant libraries. Since libraries move around in memory, there is a performance penalty for resolution. This penalty increases for each additional library needing resolution.

Prelinking reduces this penalty by resolving libraries in advance. Afterward, resolution only occurs if the libraries have changed since being prelinked, such as following perhaps an upgrade.

Mac OS
Mac OS stores executables in the Mach-O file format.

Mac OS X
Mac OS X performs prebinding in the "Optimizing" stage of installing system software or certain applications.

Prebinding has changed a few times within the Mac OS X series. Before 10.2, prebinding only happened during the installation procedure (the aforementioned "Optimizing" stage). From 10.2 through 10.3 the OS checked for prebinding at launch time for applications, and the first time an application ran it would be prebound, making subsequent launches faster. This could also be manually run, which some OS-level installs did. In 10.4, only OS libraries were prebound. In 10.5 and later, Apple replaced prebinding with a dyld shared cache mechanism, which provided better OS performance.

Linux
On Linux, prelinking is accomplished via the prelink program, a free program written by Jakub Jelínek of Red Hat for ELF binaries.

Performance results have been mixed, but it seems to aid systems with a large number of libraries, such as KDE.

prelink randomization 
When run with the "-R" option, prelink will randomly select the address base where libraries are loaded.  This selection makes a return-to-libc attack harder to perform because the addresses are unique to that system.  The reason prelink does this is because kernel facilities supplying address space layout randomization (ASLR) for libraries cannot be used in conjunction with prelink without defeating the purpose of prelink and forcing the dynamic linker to perform relocations at program load time.

As stated, prelink and per-process library address randomization cannot be used in conjunction.  In order to avoid completely removing this security enhancement, prelink supplies its own randomization; however, this does not help a general information leak caused by prelink.  Attackers with the ability to read certain arbitrary files on the target system can discover where libraries are loaded in privileged daemons; often libc is enough as it is the most common library used in return-to-libc attacks.

By reading a shared library file such as libc, an attacker with local access can discover the load address of libc in every other application on the system.  Since most programs link to libc, the libc library file always has to be readable; any attacker with local access may gather information about the address space of higher privileged processes.  Local access may commonly be gained by shell accounts or Web server accounts that allow the use of CGI scripts, which may read and output any file on the system.  Directory traversal vulnerabilities can be used by attackers without accounts if CGI script vulnerabilities are available.

Because prelink is often run periodically, typically every two weeks, the address of any given library has a chance of changing over time.  prelink is often used in an incremental mode in which already prelinked libraries are not altered unless absolutely necessary, so a library may not change its base address when prelink is re-run.  This gives any address derived a half-life of the period in which prelink is run.  Also note that if a new version of the library is installed, the addresses change.

Jakub Jelínek points out that position independent executables (PIE) ignore prelinking on Red Hat Enterprise Linux and Fedora, and recommends that network and SUID programs be built PIE to facilitate a more secure environment.

Issues
Occasionally, prelinking can cause issues with application checkpoint and restart libraries like blcr, as well as other libraries (like OpenMPI) that use blcr internally.  Specifically when checkpointing a program on one host, and trying to restart on a different host, the restarted program may fail with a segfault due to differences in host-specific library memory address randomization.

See also 
 Dynamic binding
 Library (computing)
 Linker (computing)
 Loader (computing)
 Object file
 Rebasing
 Relocation
 Static library
 Prefetcher

References 

 A detailed explanation of prebinding

Further reading

External links 

Official releases by Jakub Jelínek
Yocto Project fork prelink-cross

Free system software
Preloading and prebinding
Memory management software
MacOS