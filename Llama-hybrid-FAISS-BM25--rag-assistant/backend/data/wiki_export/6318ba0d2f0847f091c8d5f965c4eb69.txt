In computational complexity theory, the complexity class TFNP is the class of total function problems which can be solved in nondeterministic polynomial time. That is, it is the class of function problems that are guaranteed to have an answer, and this answer can be checked in polynomial time, or equivalently it is the subset of FNP where a solution is guaranteed to exist. The abbreviation TFNP stands for "Total Function Nondeterministic Polynomial".

TFNP contains many natural problems that are of interest to computer scientists. These problems include integer factorization, finding a Nash Equilibrium of a game, and searching for local optima. TFNP is widely conjectured to contain problems that are computationally intractable, and several such problems have been shown to be hard under cryptographic assumptions.  However, there are no known unconditional intractability results or results showing NP-hardness of TFNP problems. TFNP is not believed to have any complete problems.

Formal Definition
The class TFNP is formally defined as follows.

A binary relation P(x,y) is in TFNP if and only if there is a deterministic polynomial time algorithm that can determine whether P(x,y) holds given both x and y, and for every x, there exists a y which is at most polynomially longer than x such that P(x,y) holds.

It was first defined by Megiddo and Papadimitriou in 1989, although TFNP problems and subclasses of TFNP had been defined and studied earlier.

Examples

Pigeonhole Principle Problem
 Input: A (polynomially computable) mapping f which maps a set of n+1 items to a set of n items.
 Question: Find two items a and b such that f(a)=f(b).
Let x be a mapping, and y a 2-tuple of items in its domain. The binary relation in question P(x,y) has the meaning "the images of both entries of y under x are equal", which, since the mapping is polynomially computable, is polynomially decidable. Moreover, such tuple y must exist for any mapping because of the Pigeonhole Principle.

Connections to Other Complexity Classes

F(NP ∩ coNP)
The complexity class  can be defined in two different ways, and those ways are not known to be equivalent.  One way applies F to the machine model for . It is known that with this definition,  coincides with TFNP. To see this, first notice that the inclusion  follows easily from the definitions of the classes. All "yes" answers to problems in TFNP can be easily verified by definition, and since problems in TFNP are total, there are no "no" answers, so it is vacuously true that "no" answers can be easily verified. For the reverse inclusion, let R be a binary relation in . Decompose R into  such that  precisely when  and y is a "yes" answer, and let R2 be  such   and y is a "no" answer. Then the binary relation  is in TFNP.

The other definition uses that  is known to be a well-behaved class of decision problems, and applies F to that class.  With this definition, if  then .

Connection to NP

NP is one of the most widely studied complexity classes. The conjecture that there are intractable problems in NP is widely accepted and often used as the most basic hardness assumption. Therefore, it is only natural to ask how TFNP is related to NP. It is not difficult to see that solutions to problems in NP can imply solutions to problems in TFNP. However, there are no TFNP problems which are known to be NP-hard. Intuition for this fact comes from the fact that problems in TFNP are total. For a problem to be NP-hard, there must exist a reduction from some NP-complete problem to the problem of interest. A typical reduction from problem A to problem B is performed by creating and analyzing a map that sends "yes" instances of A to "yes" instances of B and "no" instances of A to "no" instances of B. However, TFNP problems are total, so there are no "no" instances for this type of reduction, causing common techniques to be difficult to apply. Beyond this rough intuition, there are several concrete results that suggest that it might be difficult or even impossible to prove NP-hardness for TFNP problems. For example, if any TFNP problem is NP-complete, then NP = coNP, which is generally conjectured to be false, but is still a major open problem in complexity theory. This lack of connections with NP is a major motivation behind the study of TFNP as its own independent class.

Notable Subclasses
The structure of TFNP is often studied through the study of its subclasses. These subclasses are defined by the mathematical theorem by which solutions to the problems are guaranteed. One appeal of studying subclasses of TFNP is that although TFNP is believed not to have any complete problems, these subclasses are defined by a certain complete problem, making them easier to reason about.

PLS

PLS (standing for "Polynomial Local Search") is a class of problems designed to model the process of searching for a local optimum for a function. In particular, it is the class of total function problems that are polynomial-time reducible to the following problem
Given input circuits S and C each with n input and output bits, find x such that .
It contains the class CLS.

PPA

PPA (standing for "Polynomial time Parity Argument") is the class of problems whose solution is guaranteed by the handshaking lemma: any undirected graph with an odd degree vertex must have another odd degree vertex. It contains the subclass PPAD.

PPP

PPP (standing for "Polynomial time Pigeonhole Principle") is the class of problems whose solution is guaranteed by the Pigeonhole principle. More precisely, it is the class of problems that can be reduced in polynomial time to the Pigeon problem, defined as follows

Given circuit C with n input and output bits, find x such that  or x ≠ y such that .

PPP contains the classes PPAD and PWPP. Notable problems in this class include the short integer solution problem.

PPAD

PPAD (standing for "Polynomial time Parity Argument, Directed") is a restriction of PPA to problems whose solutions are guaranteed by a directed version of the handshake lemma. It is often defined as the set of problems that are polynomial-time reducible to End-of-a-Line:
Given circuits S and P with n input and output bits  and , find x such that  or  such that .
PPAD is in the intersection of PPA and PPP, and it contains CLS.

Here, the circuit S in the definition sends each point of the line to its successor, or to itself if the point is a sink. Likewise P sends each point of the line to its predecessor, or to itself if the point is a source. Points outside of all lines are identified by being fixed under both P and S (in other words, any isolated points are removed from the graph). Then the condition  defines the end of a line, which is either a sink or is such that S(x) = S(y) for some other point y; similarly the condition  defines the beginning of a line (since we assume that 0 is a source, we require the solution be nonzero in this case).

CLS
CLS (standing for "Continuous Local Search") is a class of search problems designed to model the process of finding a local optima of a continuous function over a continuous domain. It is defined as the class of problems that are polynomial-time reducible to the Continuous Localpoint problem:
Given two Lipschitz continuous functions S and C and parameters ε and λ, find an ε-approximate fixed point of S with respect to C or two points that violate the λ-continuity of C or S.
This class was first defined by Daskalakis and Papadimitriou in 2011. It is contained in the intersection of PPAD and PLS, and in 2020 it has been proven that . It was designed to be a class of relatively simple optimization problems that still contains many interesting problems that are believed to be hard.

Complete problems for CLS are for example finding an ε-KKT point, finding an ε-Banach fixed point and the Meta-Metric-Contraction problem.

EOPL and UEOPL

EOPL and UEOPL (which stands for "end of potential line" and "unique end of potential line") were introduced in 2020 by.

EOPL captures search problems that can be solved by local search, i.e. it is possible to jump from one candidate solution to the next one in polynomial time. A problem in EOPL can be interpreted as an exponentially large, directed, acyclic graph where each node is a candidate solution and has a cost (also called potential) which increases along the edges. The in- and out-degree of each node is at most one which means that the nodes form a collection of exponentially long lines. The end of each line is the node with highest cost on that line.
EOPL contains all problems that can be reduced in polynomial time to the search problem End-of-Potential-Line:
Given input circuits S, P each with n input and output bits, and C with n input and m output bits, , , and , find x such that
 x is the end of the line ,
 x is the start of a second line , or
 x violates the increasing cost ,  and 

Here, S sends each vertex of the graph to its successor, or to itself if the vertex is a sink. Likewise P sends each vertex of the graph to its predecessor, or to itself. Points outside the graph are identified by being fixed under both P and S. Then the first and second solution types are respectively the upper and lower ends of the line, and the third solution type is a violation of the condition that the potential increases along the edges. If this last condition is violated, the endpoint may not maximize the potential on the line. Therefore the problem is total: Either a solution is found or a short proof is found that the conditions are not satisfied.

UEOPL is defined very similarly, but it is promised that there is only one line. Hence finding the second type of solution above would violate the promise ensuring that the first type of solution is unique. A fourth solution type is added to provide another way of detecting the presence of a second line:
 two points x, y such that  and either  or .
A solution of this type either indicates that x and y are on different lines, or indicates a violation of the condition that values on the same line are strictly increasing. The advantage of including this condition is that it may be easier to find x and y as required than to find the start of their lines, or an explicit violation of the increasing cost condition. 

UEOPL contains, among others, the problem of solving the P-matrix-Linear complementarity problem, finding the sink of a Unique sink orientation in cubes, solving a simple stochastic game and the α-Ham Sandwich problem. 
Complete problems of UEOPL are Unique-End-of-Potential-Line, some variants of it with costs increasing exactly by 1 or an instance without the P circuit, and One-Permutation-Discrete-Contraction.

EOPL captures search problems like the ones in UEOPL with the relaxation that there are multiple lines allowed and it is searched for any end of a line. There are currently no problems known that are in EOPL but not in UEOPL.

EOPL is a subclass of CLS, it is unknown whether they are equal or not. UEOPL is trivially contained in EOPL.

FP

FP (complexity) (standing for "Function Polynomial") is the class of function problems that can be solved in deterministic polynomial time.  , and it is conjectured that this inclusion is strict. This class represents the class of function problems that are believed to be computationally tractable (without randomization). If TFNP = FP, then , which should be intuitive given the fact that . However, it is generally conjectured that , and so TFNP ≠ FP.

References 

Complexity classes