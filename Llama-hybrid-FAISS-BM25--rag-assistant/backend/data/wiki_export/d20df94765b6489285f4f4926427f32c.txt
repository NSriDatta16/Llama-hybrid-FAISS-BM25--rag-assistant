In computer processors, the overflow flag (sometimes called the V flag) is usually a single bit in a system status register used to indicate when an arithmetic overflow has occurred in an operation, indicating that the signed two's-complement result would not fit in the number of bits used for the result. Some architectures may be configured to automatically generate an exception on an operation resulting in overflow.

An example, suppose we add 127 and 127 using 8-bit registers. 127+127 is 254, but using 8-bit arithmetic the result would be 1111 1110 binary, which is the two's complement encoding of âˆ’2, a negative number. A negative sum of positive operands (or vice versa) is an overflow. The overflow flag would then be set so the program can be aware of the problem and mitigate this or signal an error. The overflow flag is thus set when the most significant bit (here considered the sign bit) is changed by adding two numbers with the same sign (or subtracting two numbers with opposite signs). Overflow cannot occur when the sign of two addition operands are different (or the sign of two subtraction operands are the same).

When binary values are interpreted as unsigned numbers, the overflow flag is meaningless and normally ignored.  One of the advantages of two's complement arithmetic is that the addition and subtraction operations do not need to distinguish between signed and unsigned operands.  For this reason, most computer instruction sets do not distinguish between signed and unsigned operands, generating both (signed) overflow and (unsigned) carry flags on every operation, and leaving it to following instructions to pay attention to whichever one is of interest.

Internally, the overflow flag is usually generated by an exclusive or of the internal carry into and out of the sign bit.

Bitwise operations (and, or, xor, not, rotate) do not have a notion of signed overflow, so the defined value varies on different processor architectures. Some processors clear the bit unconditionally (which is useful because bitwise operations set the sign flag, and the clear overflow flag then indicates that the sign flag is valid), others leave it unchanged, and some set it to an undefined value. Shifts and multiplies do permit a well-defined value, but it is not consistently implemented. For example, the x86 instruction set only defines the overflow flag for multiplies and 1-bit shifts; multi-bit shifts leave it undefined.

References

Computer arithmetic