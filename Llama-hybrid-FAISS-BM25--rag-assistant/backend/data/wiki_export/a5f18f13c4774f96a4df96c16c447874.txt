Within communication protocols, TLV (type-length-value or tag-length-value) is an encoding scheme used for informational elements. A TLV-encoded data stream contains code related to the record type, the record value's length, and finally the value itself.

Details 

The type and length are fixed in size (typically 1–4 bytes), and the value field is of variable size. These fields are used as follows:
 Type A binary code, often simply alphanumeric, which indicates the kind of field that this part of the message represents;
 Length The size of the value field (typically in bytes);
 Value Variable-sized series of bytes which contains data for this part of the message.

Some advantages of using a TLV representation data system solution are:
 TLV sequences are easily searched using generalized parsing functions; 
 New message elements which are received at an older node can be safely skipped and the rest of the message can be parsed. This is similar to the way that unknown XML tags can be safely skipped;
 TLV elements can be placed in any order inside the message body;
 TLV elements are typically used in a binary format and binary protocols which makes parsing faster and the data smaller than in comparable text based protocols.

Examples

Real-world examples

Transport protocols 
 TLS (and its predecessor SSL) use TLV-encoded messages.
 SSH
 COPS
 IS-IS
 RADIUS
 Link Layer Discovery Protocol allows for the sending of organizational-specific information as a TLV element within LLDP packets
 Media Redundancy Protocol allows organizational-specific information
 Dynamic Host Configuration Protocol (DHCP) uses TLV encoded options
RR protocol used in GSM cell phones (defined in 3GPP 04.18). In this protocol each message is defined as a sequence of information elements.

Data storage formats 

 IFF
 Matroska uses TLV for markup tags
 QTFF (the basis for MPEG-4 containers)

Other 

 ubus used for IPC in OpenWrt

Other examples 

Imagine a message to make a telephone call. In a first version of a system this might use two message elements: a "command" and a "phoneNumberToCall":
command_c/4/makeCall_c/phoneNumberToCall_c/8/"722-4246"

Here command_c, makeCall_c and phoneNumberToCall_c are integer constants and 4 and 8 are the lengths of the "value" fields, respectively.

Later (in version 2) a new field containing the calling number could be added:
command_c/4/makeCall_c/callingNumber_c/14/"1-613-715-9719"/phoneNumberToCall_c/8/"722-4246"

A version 1 system which received a message from a version 2 system would first read the command_c element and then read an element of type callingNumber_c. The version 1 system does not understand
callingNumber_c, so the length field is read (i.e. 14) and the system skips forward 14 bytes to read

phoneNumberToCall_c

which it understands, and message parsing carries on.

Other ways of representing data 

Core TCP/IP protocols (particularly IP, TCP, and UDP) use predefined, static fields.

Some application layer protocols, including HTTP/1.1 (and its non-standardized predecessors), FTP, SMTP, POP3, and SIP, use text-based "Field: Value" pairs formatted according to . (HTTP represents length of payload with a Content-Length header and separates headers from the payload with an empty line and headers from each other with a new line.)

ASN.1 specifies several TLV-based encoding rules (BER, DER), as well as non-TLV based ones (PER, XER).

CSN.1 describes encoding rules using non-TLV semantics.

More recently, XML has been used to implement messaging between different nodes in a network. These messages are typically prefixed with line-based text commands, such as with BEEP.

See also 

 Binary protocol
 KLV, specific type of type-length-value encoding

References

Data serialization formats
Data transmission
Internet Standards
Internet protocols