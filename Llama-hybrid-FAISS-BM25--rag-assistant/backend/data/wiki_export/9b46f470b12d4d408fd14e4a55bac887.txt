Trace scheduling is an optimization technique developed by Josh Fisher used in compilers for computer programs.

A compiler often can, by rearranging its generated machine instructions for faster execution, improve program performance. It increases ILP (Instruction Level Parallelism) along the important execution path by statically predicting frequent execution path. Trace scheduling is one of many known techniques for doing so.

A trace is a sequence of instructions, including branches but not including loops, that is executed for some input data. Trace scheduling uses a basic block scheduling method to schedule the instructions in each entire trace, beginning with the trace with the highest frequency. It then adds compensation code at the entry and exit of each trace to compensate for any effects that out-of-order execution may have had.

This can result in large increases in code sizes and poor or erratic performance if program's behavior varies significantly with the input.

Trace scheduling was originally developed for Very Long Instruction Word, or VLIW machines, and is a form of global code motion. It works by converting a loop to long straight-line code sequence using loop unrolling and static branch prediction. This process separates out "unlikely" code and adds handlers for exits from trace.  The goal is to have the most common case executed as a sequential set of instructions without branches.

See also
Instruction scheduling

References

 

Compiler optimizations
Compiler construction