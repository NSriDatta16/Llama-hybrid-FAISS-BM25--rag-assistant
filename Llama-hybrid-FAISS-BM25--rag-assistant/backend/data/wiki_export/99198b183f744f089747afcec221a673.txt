In software development, CMake is cross-platform free and open-source software for build automation, testing, packaging and installation of software by using a compiler-independent method. CMake is not a build system itself; it generates another system's build files. It supports directory hierarchies and applications that depend on multiple libraries. It is used in conjunction with native build environments such as Make, Qt Creator, Ninja, Android Studio, Apple's Xcode, and Microsoft Visual Studio. It has minimal dependencies, requiring only a C++ compiler on its own build system.

CMake is distributed as free and open-source software under a permissive BSD-3-Clause license.

History
CMake development began in 1999, in response to the need for a cross-platform build environment for the Insight Segmentation and Registration Toolkit (ITK). The project is funded by the United States National Library of Medicine as part of the Visible Human Project. It was partially inspired by , a predecessor to CMake, which was made by Ken Martin and other developers to support building of the Visualization Toolkit (VTK). pcmaker was a C program that converted Make files into MS Windows' NMake counterparts. At Kitware, Bill Hoffman blended components of pcmaker with his own ideas, striving to mimic the functionality of Unix configure scripts. CMake was first implemented in 2000 and further developed in 2001.

Historically CMake was conceived with the following major features in mind:

 depending only on system C++ compiler, meaning no third-party libraries
 to be able to generate VS Studio IDE input files
 capable of producing executable and linkable binary libraries (static and shared)
 to be able to run build-time code generators
 separate source/build file trees
 system checks and introspection (similar to Autotools): what system could and could not do
 automatically scan C/C++ deps
 cross-platform

Because of these constraints CMake didn't choose to use Tcl (popular at the time) scripting language as its default and instead, developers decided to create a simpler scripting language.

Continued development and improvements were fueled by the incorporation of CMake into developers’ own systems, including the VXL Project, the CABLE features added by Brad King, and GE Corporate R&D for support of DART. Additional features were created when VTK transitioned to CMake for its build environment and for supporting ParaView.

Version 3.0 was released in June 2014. It has been described as the beginning of "Modern CMake". Experts now advise to avoid variables in favor of targets and properties. The commands , , ,  that were at the core of CMake 2 should now be replaced by target-specific commands.

Features

Separate build tree 
One of its major features is the ability to place compiler outputs (such as object files) into a build tree which is located outside of the source tree. This enables multiple builds from the same source tree and cross-compilation. Separate source and build files ensure that removing a build directory will not affect source files and prevents clutter which might confuse version control systems.

Dependency management 
CMake keeps track and recompiles all the upstream dependencies of a given sub-module if its sources are changed.

Flexible project structure 
CMake can locate system-wide and user-specified executables, files, and libraries. These locations are stored in a cache, which can then be tailored before generating the target build files. The cache can be edited with a graphical editor, which is shipped with CMake.

Complicated directory hierarchies and applications that rely on several libraries are well supported by CMake. For instance, CMake is able to accommodate a project that has multiple toolkits, or libraries that each have multiple directories. In addition, CMake can work with projects that require executables to be created before generating code to be compiled for the final application. Its open-source, extensible design allows CMake to be adapted as necessary for specific projects.

IDE configuration support 
CMake can generate project files for several popular IDEs, such as Microsoft Visual Studio, Xcode, and Eclipse CDT. It can also produce build scripts for MSBuild or NMake on Windows; Unix Make on Unix-like platforms such as Linux, macOS, and Cygwin; and Ninja on both Windows and Unix-like platforms.

Compiler feature detection 
CMake allows specification of features that the compiler is required to support in order to get the target program or library compiled.

Compilers 
CMake supports an extensive list of compilers, including: Apple Clang, Clang, GNU GCC, MSVC, Oracle Developer Studio, and Intel C++ Compiler.

Packaging system 
Even though CMake is not a package manager, it provides basic modules (see CPack) functions for installing binaries and package information declared by the  script to be used by consumer CMake projects. The package may also be packed into an archive file for package manager or installer supported by a target platform. Third-party packages may also be imported via configured CMake files which are either provided by the same third-party or created manually.

GUI 
Cmake may be run by using a ncurses program like  that can be used to configure projects via command-line interface.

Build process
The build of a program or library with CMake is a two-stage process. First, build files (usually scripts) are created (generated) from configuration files (CMakeLists.txt scripts) written in CMake language. Then the platform's native build tools that can read these build files (native toolchain) are used for actual building of programs (build targets). The generator specified by the user on the commandline determines which build tool chain to use.

Generators 
The build files are configured depending on the used generator (e.g. Unix Makefiles for make) and associated toolchain files. Advanced users can also create and incorporate additional makefile generators to support their specific compiler and OS needs. Generated files are typically placed (by using 's flag) into a folder outside of the source's one (out of source build), e.g., .

Each build project in turn contains its own file and  directory in every project (sub-)directory of included by the  command, helping to avoid or speed up regeneration when it is run repeatedly.

The generation process and the output can be fine-tuned via target properties. Previously it was done via -prefixed global  variables that are also used to configure CMake itself and to set up initial defaults. The older approach is discouraged now.

Types of build targets 
Depending on CMakeLists.txt configuration the build files may be either executables, libraries (e.g. ,  etc.), object file libraries or pseudo-targets (including aliases). CMake can produce object files that can be linked against by executable binaries/libraries, avoiding dynamic (run-time) linking and using static (compile-time) linking instead. This enables flexibility in configuration of various optimizations.

Build dependencies may be determined automatically.

Precompiled headers 
It's possible to generate precompiled headers by using CMake since version 3.6.

Language

CMakeLists.txt 
CMake has a relatively simple interpreted, imperative scripting language. It supports variables, string manipulation methods, arrays, function/macro declarations, and module inclusion (importing). CMake Language commands (or directives) are read by  from a file named .  This file specifies the source files and build parameters, which CMake will place in the project's build specification (such as a Makefile). Additionally, -suffixed files can contain scripts used by CMake.

To generate a project's build files, one invokes  in terminal and specifies the directory that contains . This file contains one or more commands in the form of .

Command syntax 
The arguments of the commands are whitespace-separated and can include keywords to separate groups of arguments. Commands can take keywords. For instance, in the command  the keyword is . It serves as a delimiter between the list of source files and some other options.

Examples of commands that CMake offers to specify targets and their dependencies and which serve as the starting point of the CMakeLists.txt:

 — declares an executable binary target with sources (depend on language chosen) to be built
  — the same but for a library
  —  adds dependencies etc.

JSON strings 
CMake supports extracting values into variables from JSON-data strings (since version 3.19).

Internals
The CMake scripting language is implemented by using Yacc and Lex generators.

The executable programs CMake, CPack, and CTest are written in the C++ programming language.

Much of CMake's functionality is implemented in modules that are written in the CMake language.

Since release 3.0, CMake's documentation uses reStructuredText markup. HTML pages and man pages are generated by the Sphinx documentation generator.

Modules and tools 
CMake ships with numerous  modules and tools. These facilitate work such as finding dependencies (both built-in and external, e.g.  modules), testing the toolchain environment and executables, packaging releases ( module and  command), and managing dependencies on external projects ( module):
 ctest — is used for target testing commands specified by CMakeLists.txt
 ccmake and  cmake-gui — tweaks and updates configuration variables intended for the native build system
 cpack — helps to package software

CPack
CPack is a packaging system for software distributions. It is tightly integrated with CMake but can function without it.

It can be used to generate:
 Linux RPM, deb, and gzip packages (for both binaries and source code).
 NSIS files (for Microsoft Windows).
 macOS packages.

Adoption 
CMake has been very widely adopted among commercial, open source, and academic software projects. A few notable users include 
Android NDK, Netflix, Inria,  MySQL, Boost (C++ libraries), KeePassXC, KDE, KiCAD, FreeCAD, Webkit, Blender, Biicode, ReactOS, Apache Qpid, the ATLAS experiment, and Second Life.

Examples

Hello world
The following source code files demonstrate how to build a simple hello world program written in C++ by using CMake.

Example 1

// hello.cpp
#include <iostream>

int main()
{
    std::cout << "Hello, world!" << std::endl;
    return 0;
}

# CMakeLists.txt
cmake_minimum_required(VERSION 3.5)
project(HelloWorld CXX)
add_executable(hello hello.cpp)

Example 2

// hello.cpp
#include <iostream>
#include "hello_heading.h"

int main()
{
    for (int i = 0; i < Times; i++)
    {
        std::cout << "Hello, world!" << std::endl;
    }
    return 0;
}
// hello_heading.h
#ifndef HELLO_HEADING_H_
#define HELLO_HEADING_H_
const int Times = 10;
#endif
# CMakeLists.txt
cmake_minimum_required(VERSION 3.5)
project(HelloWorld CXX)
include_directories(${PROJECT_SOURCE_DIR})
add_executable(hello hello.cpp)

Shell commands to run CMake on a Linux system (to be entered in the directory that contains the two files above):
cmake -B build .          # Configure the build directory.
cmake --build build       # Build the program in the build directory.
./build/hello             # Run the program (outputs "Hello, world!")

See also

 
 configure script
Make
Monorepo
Qmake

Notes

References

External links
 

2000 software
Build automation
Compiling tools
Software that uses Qt
Software using the BSD license