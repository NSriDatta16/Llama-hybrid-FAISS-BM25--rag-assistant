s of the same region, assign pixel to their region. If multiple neighbors match and are members of different regions, assign pixel to one of the regions (it doesn't matter which one). Indicate that all of these regions are equivalent. Scan image again, assigning all equivalent regions the same region value. Others Some of the steps present in the two-pass algorithm can be merged for efficiency, allowing for a single sweep through the image. Multi-pass algorithms also exist, some of which run in linear time relative to the number of image pixels. In the early 1990s, there was considerable interest in parallelizing connected-component algorithms in image analysis applications, due to the bottleneck of sequentially processing each pixel. The interest to the algorithm arises again with an extensive use of CUDA. Pseudocode for the one-component-at-a-time algorithm Algorithm: Connected-component matrix is initialized to size of image matrix. A mark is initialized and incremented for every detected object in the image. A counter is initialized to count the number of objects. A row-major scan is started for the entire image. If an object pixel is detected, then following steps are repeated while (Index !=0) Set the corresponding pixel to 0 in Image. A vector (Index) is updated with all the neighboring pixels of the currently set pixels. Unique pixels are retained and repeated pixels are removed. Set the pixels indicated by Index to mark in the connected-component matrix. Increment the marker for another object in the image. One-Component-at-a-Time(image) [M, N] := size(image) connected := zeros(M, N) mark := value difference := increment offsets := [-1; M; 1; -M] index := [] no_of_objects := 0 for i: 1:M do for j: 1:N do if (image(i, j) == 1) then no_of_objects := no_of_objects + 1 index := [((j-1) × M + i)] connected(index) := mark while ~isempty(index) do image(index) := 0 neighbors := bsxfun(@plus, index, offsets) neighbors := unique(neighbors(:)) index := neighbors(find(image(neighbors))) connected(index) := mark end while mark := mark + difference end if end for end for The run time of the algorithm depends on the size of the image and the amount of foreground. The time complexity is comparable to the two pass algorithm if the foreground covers a significant part of the image. Otherwise the time complexity is lower. However, memory access is less structured than for the two-pass algorithm, which tends to increase the run time in practice. Performance evaluation In the last two decades many novel approaches to connected-component labeling have been proposed, but almost none of them have been subjected to a comparative performance assessment using the same data set. YACCLAB (acronym for Yet Another Connected Components Labeling Benchmark) is an example of C++ open source framework which collects, runs, and tests connected-component labeling algorithms. Hardware architectures The emergence of FPGAs with enough capacity to perform complex image processing tasks also led to high-performance architectures for connected-component labeling. Most of these architectures utilize the single pass variant of this algorithm, because of the limited memory resources available on an FPGA. These types of connected component labeling architectures can process several image pixels in parallel, thereby achieving high throughput and low processing latency. See also Feature extraction Flood fill References General Horn, Berthold K.P. (1986). Robot Vision. MIT Press. pp. 69–71. ISBN 978-0-262-08159-7. Al Bovik (2000). HandBook for Image and Video processing (PDF). Academic Press. pp. [37–70]. ISBN 0-12-119790-5. External links Implementation in C# about Extracting objects from image and Direct Connected Component Labeling Algorithm