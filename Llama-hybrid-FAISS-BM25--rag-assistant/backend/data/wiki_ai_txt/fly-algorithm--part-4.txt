metrics(preference, pestimated) 18. 19. // Compare the performances, i.e. compute the fly's local fitness 20. Lfitness(fkill) ← Gfitness(F-{fkill}) - Gfitness(F) 21. 22. If the local fitness is greater than 0, // Thresholded-selection of a bad fly that can be killed 23. then go to Step 26. // fkill is a good fly (the population's performance is better when fkill is included): we should not kill it 24. else go to Step 28. // fkill is a bad fly (the population's performance is worse when fkill is included): we can get rid of it 25. 26. Restore the fly's contribution, then go to Step 12. 27. 28. Select a genetic operator 29. 30. If the genetic operator is mutation, 31. then go to Step 34. 32. else go to Step 50. 33. 34. freproduce ← Select a random fly of F 35. 14. Remove freproduce's contribution from pestimated 37. 38. // Compute the population's performance without freproduce 39. Gfitness(F-{freproduce}) ← Errormetrics(preference, pestimated) 40. 41. // Compare the performances, i.e. compute the fly's local fitness 42. Lfitness(freproduce) ← Gfitness(F-{freproduce}) - Gfitness(F) 43. 44. Restore the fly's contribution 45. 46. If the local fitness is lower than or equal to 0, // Thresholded-selection of a good fly that can reproduce 47. else go to Step 34. // freproduce is a bad fly: we should not allow it to reproduce 48. then go to Step 53. // freproduce is a good fly: we can allow it to reproduce 49. 50. // New blood / Immigration 51. Replace fkill by a new fly with a random position, go to Step 57. 52. 53. // Mutation 54. Copy freproduce into fkill 55. Slightly and randomly alter fkill's position 56. 57. Add the new fly's contribution to the population 58. 59. If stop the reconstruction, 60. then go to Step 63. 61. else go to Step 10. 62. 63. // Extract solution 64. VF ← voxelisation of F 65. 66. return VF END Example: Digital arts In this example, an input image is to be approximated by a set of tiles (for example as in an ancient mosaic). A tile has an orientation (angle θ), a three colour components (R, G, B), a size (w, h) and a position (x, y, z). If there are N tiles, there are 9N unknown floating point numbers to guess. In other words for 5,000 tiles, there are 45,000 numbers to find. Using a classical evolutionary algorithm where the answer of the optimisation problem is the best individual, the genome of an individual would be made up of 45,000 genes. This approach would be extremely costly in term of complexity and computing time. The same applies for any classical optimisation algorithm. Using the Fly Algorithm, every individual mimics a tile and can be individually evaluated using its local fitness to assess its contribution to the population's performance (the global fitness). Here an individual has 9 genes instead of 9N, and there are N individuals. It can be solved as a reconstruction problem as follows: r e c o n s t r u c t i o n = a r g m i n ⁡ ∑ x = 0 x < W ∑ y = 0 y < H | i n p u t ( x , y ) − P [ F ] ( x , y ) | {\displaystyle reconstruction=\operatorname {arg\,min} {\overset {x<W}{\underset {x=0}{\sum }}}{\overset {y<H}{\underset {y=0}{\sum }}}|input(x,y)-P[F](x,y)|} where i n p u t {\displaystyle input} is the input image, x {\displaystyle x} and y {\displaystyle y} are the pixel coordinates along the horizontal and vertical axis respectively, W {\displaystyle W} and H {\displaystyle H} are the image width and height in number of pixels respectively, F {\displaystyle F} is the fly population, and P {\displaystyle P} is a projection operator that creates an image from flies. This projection operator P {\displaystyle P} can take many forms. In her work, Z. Ali Aboodd uses OpenGL to generate different effects (e.g. mosaics, or spray paint). For speeding up the evaluation of the fitness functions, OpenCL is used too. The algorithm starts with a population F {\displaystyle F} that is randomly generated (see Line 3 in the algorithm above). F {\displaystyle F} is then assessed using the global fitness to com