 T ( x , y ) = ( f x ( x , y ) , f y ( x , y ) ) {\displaystyle T(x,y)=\left(f_{x}(x,y),f_{y}(x,y)\right)} where each of the ƒx and ƒy have the form: f ( x , y ) = a 1 + a x x + a y y + ∑ i = 1 n ω i U ( ‖ ( x i , y i ) − ( x , y ) ‖ ) , {\displaystyle f(x,y)=a_{1}+a_{x}x+a_{y}y+\sum _{i=1}^{n}\omega _{i}U\left({\begin{Vmatrix}(x_{i},y_{i})-(x,y)\end{Vmatrix}}\right),} and the kernel function U ( r ) {\displaystyle U(r)\!} is defined by U ( r ) = r 2 log ⁡ r 2 {\displaystyle U(r)=r^{2}\log r^{2}\!} . The exact details of how to solve for the parameters can be found elsewhere but it essentially involves solving a linear system of equations. The bending energy (a measure of how much transformation is needed to align the points) will also be easily obtained. Regularized TPS The TPS formulation above has exact matching requirement for the pairs of points on the two shapes. For noisy data, it is best to relax this exact requirement. If we let v i {\displaystyle v_{i}} denote the target function values at corresponding locations p i = ( x i , y i ) {\displaystyle p_{i}=(x_{i},y_{i})} (Note that for f x {\displaystyle f_{x}} , v i {\displaystyle v_{i}} would x ′ {\displaystyle x'} the x-coordinate of the point corresponding to p i {\displaystyle p_{i}} and for f y {\displaystyle f_{y}} it would be the y-coordinate, y ′ {\displaystyle y'} ), relaxing the requirement amounts to minimizing H [ f ] = ∑ i = 1 n ( v i − f ( x i , y i ) ) 2 + λ I f {\displaystyle H[f]=\sum _{i=1}^{n}(v_{i}-f(x_{i},y_{i}))^{2}+\lambda I_{f}} where I f {\displaystyle I_{f}\!} is the bending energy and λ {\displaystyle \lambda \!} is called the regularization parameter. This ƒ that minimizes H[ƒ] can be found in a fairly straightforward way. If one uses normalize coordinates for ( x i , y i ) and ( x i ′ , y i ′ ) {\displaystyle (x_{i},y_{i}){\mbox{ and }}(x'_{i},y'_{i})} , then scale invariance is kept. However, if one uses the original non-normalized coordinates, then the regularization parameter needs to be normalized. Note that in many cases, regardless of the transformation used, the initial estimate of the correspondences contains some errors which could reduce the quality of the transformation. If we iterate the steps of finding correspondences and estimating transformations (i.e. repeating steps 2–5 with the newly transformed shape) we can overcome this problem. Typically, three iterations are all that is needed to obtain reasonable results. Step 6: Computing the shape distance Now, a shape distance between two shapes P {\displaystyle P\!} and Q {\displaystyle Q\!} . This distance is going to be a weighted sum of three potential terms: Shape context distance: this is the symmetric sum of shape context matching costs over best matching points: D s c ( P , Q ) = 1 n ∑ p ∈ P arg ⁡ min q ∈ Q C ( p , T ( q ) ) + 1 m ∑ q ∈ Q arg ⁡ min p ∈ P C ( p , T ( q ) ) {\displaystyle D_{sc}(P,Q)={\frac {1}{n}}\sum _{p\in P}\arg {\underset {q\in Q}{\min }}C(p,T(q))+{\frac {1}{m}}\sum _{q\in Q}\arg {\underset {p\in P}{\min }}C(p,T(q))} where T(·) is the estimated TPS transform that maps the points in Q to those in P. Appearance cost: After establishing image correspondences and properly warping one image to match the other, one can define an appearance cost as the sum of squared brightness differences in Gaussian windows around corresponding image points: D a c ( P , Q ) = 1 n ∑ i = 1 n ∑ Δ ∈ Z 2 G ( Δ ) [ I P ( p i + Δ ) − I Q ( T ( q π ( i ) ) + Δ ) ] 2 {\displaystyle D_{ac}(P,Q)={\frac {1}{n}}\sum _{i=1}^{n}\sum _{\Delta \in Z^{2}}G(\Delta )\left[I_{P}(p_{i}+\Delta )-I_{Q}(T(q_{\pi (i)})+\Delta )\right]^{2}} where I P {\displaystyle I_{P}\!} and I Q {\displaystyle I_{Q}\!} are the gray-level images ( I Q {\displaystyle I_{Q}\!} is the image after warping) and G {\displaystyle G\!} is a Gaussian windowing function. Transformation cost: The final cost D b e ( P , Q ) {\displaystyle D_{be}(P,Q)\!\,} measures how much transformation is necessary to bring the two images in