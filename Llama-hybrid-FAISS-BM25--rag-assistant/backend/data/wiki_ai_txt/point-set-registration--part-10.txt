 M] and j ∊ [1, N]: p i j := exp ⁡ ( − 1 2 σ 2 ‖ s j − T ( m i , θ ) ‖ 2 ) ∑ k = 1 M exp ⁡ ( − 1 2 σ 2 ‖ s j − T ( m k , θ ) ‖ 2 ) + ( 2 π σ 2 ) D 2 w 1 − w M N {\displaystyle p_{ij}:={\frac {\exp \left(-{\frac {1}{2\sigma ^{2}}}\lVert s_{j}-T(m_{i},\theta )\rVert ^{2}\right)}{\sum _{k=1}^{M}\exp \left(-{\frac {1}{2\sigma ^{2}}}\lVert s_{j}-T(m_{k},\theta )\rVert ^{2}\right)+(2\pi \sigma ^{2})^{\frac {D}{2}}{\frac {w}{1-w}}{\frac {M}{N}}}}} // M-step, solve for optimal transformation {θ, σ2} := solve(S, M, P) return θ where the vector 1 {\displaystyle \mathbf {1} } is a column vector of ones. The solve function differs by the type of registration performed. For example, in rigid registration, the output is a scale a, a rotation matrix R {\displaystyle \mathbf {R} } , and a translation vector t {\displaystyle \mathbf {t} } . The parameter θ {\displaystyle \theta } can be written as a tuple of these: θ = { a , R , t } {\displaystyle \theta =\lbrace a,\mathbf {R} ,\mathbf {t} \rbrace } which is initialized to one, the identity matrix, and a column vector of zeroes: θ 0 = { 1 , I , 0 } {\displaystyle \theta _{0}=\lbrace 1,\mathbf {I} ,\mathbf {0} \rbrace } The aligned point set is: T ( M ) = a M R T + 1 t T {\displaystyle T(\mathbf {M} )=a\mathbf {M} \mathbf {R} ^{T}+\mathbf {1} \mathbf {t} ^{T}} The solve_rigid function for rigid registration can then be written as follows, with derivation of the algebra explained in Myronenko's 2010 paper. solve_rigid(S, M, P) NP := 1TP1 μ s := 1 N P S T P T 1 {\displaystyle \mu _{s}:={\frac {1}{N_{\mathbf {P} }}}\mathbf {S} ^{T}\mathbf {P} ^{T}\mathbf {1} } μ m := 1 N P M T P 1 {\displaystyle \mu _{m}:={\frac {1}{N_{\mathbf {P} }}}\mathbf {M} ^{T}\mathbf {P} \mathbf {1} } S ^ := S − 1 μ s T {\displaystyle {\hat {\mathbf {S} }}:=\mathbf {S} -\mathbf {1} \mu _{s}^{T}} M ^ := M − 1 μ m T {\displaystyle {\hat {\mathbf {M} }}:=\mathbf {M} -\mathbf {1} \mu _{m}^{T}} A := S T ^ P T M ^ {\displaystyle \mathbf {A} :={\hat {\mathbf {S} ^{T}}}\mathbf {P} ^{T}{\hat {\mathbf {M} }}} U, V := svd(A) // the singular value decomposition of A = UΣVT C := diag(1, …, 1, det(UVT)) // diag(ξ)is the diagonal matrix formed from vector ξ R := UCVT a := tr ⁡ ( A T R ) tr ⁡ ( M ^ T diag ⁡ ( P 1 ) M ^ ) {\displaystyle a:={\frac {\operatorname {tr} (\mathbf {A} ^{T}\mathbf {R} )}{\operatorname {tr} (\mathbf {{\hat {\mathbf {M} }}^{T}\operatorname {diag} (\mathbf {P} \mathbf {1} ){\hat {\mathbf {M} }}} )}}} // tr is the trace of a matrix t := μs − aRμm σ 2 := 1 N P D ( tr ⁡ ( S ^ T diag ⁡ ( P T 1 ) S ^ ) − a tr ⁡ ( A T R ) ) {\displaystyle \sigma ^{2}:={\frac {1}{N_{\mathbf {P} }D}}(\operatorname {tr} (\mathbf {{\hat {\mathbf {S} }}^{T}\operatorname {diag} (\mathbf {P} ^{T}\mathbf {1} ){\hat {\mathbf {S} }}} )-a\operatorname {tr} (\mathbf {A} ^{T}\mathbf {R} ))} return {a, R, t}, σ2 For affine registration, where the goal is to find an affine transformation instead of a rigid one, the output is an affine transformation matrix B {\displaystyle \mathbf {B} } and a translation t {\displaystyle \mathbf {t} } such that the aligned point set is: T ( M ) = M B T + 1 t T {\displaystyle T(\mathbf {M} )=\mathbf {M} \mathbf {B} ^{T}+\mathbf {1} \mathbf {t} ^{T}} The solve_affine function for rigid registration can then be written as follows, with derivation of the algebra explained in Myronenko's 2010 paper. solve_affine(S, M, P) NP := 1TP1 μ s := 1 N P S T P T 1 {\displaystyle \mu _{s}:={\frac {1}{N_{\mathbf {P} }}}\mathbf {S} ^{T}\mathbf {P} ^{T}\mathbf {1} } μ m := 1 N P M T P 1 {\displaystyle \mu _{m}:={\frac {1}{N_{\mathbf {P} }}}\mathbf {M} ^{T}\mathbf {P} \mathbf {1} } S ^ := S − 1 μ s T {\displaystyle {\hat {\mathbf {S} }}:=\mathbf {S} -\mathbf {1} \mu _{s}^{T}} M ^ := M − 1 μ m T {\displaystyle {\hat {\mathbf {M} }}:=\mathbf {M} -\mathbf {1} \mu _{m}^{T}} B := ( S ^ T P T M ^ ) ( M ^ T diag ⁡ ( P 1 ) M ^ ) − 1 {\displaystyle \mathbf {B} :=({\hat {\mathbf {S} }}^{T}\mathbf {P} ^{T}{\hat {\mathbf {M} }})({\hat {\mathbf {M} }}^{