e any behavioural model. Both algorithms are search methods that start with a set of random solutions, which are iteratively corrected toward a global optimum. However, the solution of the optimisation problem in the Fly Algorithm is the population (or a subset of the population): The flies implicitly collaborate to build the solution. In PSO the solution is a single particle, the one with the best fitness. Another main difference between the Fly Algorithm and with PSO is that the Fly Algorithm is not based on any behavioural model but only builds a geometrical representation. Applications of the Fly algorithnm Computer stereo vision Obstacle avoidance Simultaneous localization and mapping (SLAM) Single-photon emission computed tomography (SPECT) reconstruction Positron emission tomography (PET) reconstruction Digital art Example: Tomography reconstruction Tomography reconstruction is an inverse problem that is often ill-posed due to missing data and/or noise. The answer to the inverse problem is not unique, and in case of extreme noise level it may not even exist. The input data of a reconstruction algorithm may be given as the Radon transform or sinogram ( Y ) {\displaystyle \left(Y\right)} of the data to reconstruct ( f ) {\displaystyle \left(f\right)} . f {\displaystyle f} is unknown; Y {\displaystyle Y} is known. The data acquisition in tomography can be modelled as: Y = P [ f ] + ϵ {\displaystyle Y=P[f]+\epsilon } where P {\displaystyle P} is the system matrix or projection operator and ϵ {\displaystyle \epsilon } corresponds to some Poisson noise. In this case the reconstruction corresponds to the inversion of the Radon transform: f = P − 1 [ Y ] {\displaystyle f=P^{-1}[Y]} Note that P − 1 {\displaystyle P^{-1}} can account for noise, acquisition geometry, etc. The Fly Algorithm is an example of iterative reconstruction. Iterative methods in tomographic reconstruction are relatively easy to model: f ^ = a r g m i n ⁡ | | Y − Y ^ | | 2 2 {\displaystyle {\hat {f}}=\operatorname {arg\,min} ||Y-{\hat {Y}}||_{2}^{2}} where f ^ {\displaystyle {\hat {f}}} is an estimate of f {\displaystyle f} , that minimises an error metrics (here ℓ2-norm, but other error metrics could be used) between Y {\displaystyle Y} and Y ^ {\displaystyle {\hat {Y}}} . Note that a regularisation term can be introduced to prevent overfitting and to smooth noise whilst preserving edges. Iterative methods can be implemented as follows: (i) The reconstruction starts using an initial estimate of the image (generally a constant image), (ii) Projection data is computed from this image, (iii) The estimated projections are compared with the measured projections, (iv) Corrections are made to correct the estimated image, and (v) The algorithm iterates until convergence of the estimated and measured projection sets. The pseudocode below is a step-by-step description of the Fly Algorithm for tomographic reconstruction. The algorithm follows the steady-state paradigm. For illustrative purposes, advanced genetic operators, such as mitosis, dual mutation, etc. are ignored. A JavaScript implementation can be found on Fly4PET. algorithm fly-algorithm is input: number of flies (N), input projection data (preference) output: the fly population (F), the projections estimated from F (pestimated) the 3-D volume corresponding to the voxelisation of F (VF) postcondition: the difference between pestimated and preference is minimal. START 1. // Initialisation 2. // Set the position of the N flies, i.e. create initial guess 3. for each fly i in fly population F do 4. F(i)x ← random(0, 1) 5. F(i)y ← random(0, 1) 6. F(i)z ← random(0, 1) 7. Add F(i)'s projection in pestimated 8. 9. // Compute the population's performance (i.e. the global fitness) 10. Gfitness(F) ← Errormetrics(preference, pestimated) 11. 12. fkill ← Select a random fly of F 13. 14. Remove fkill's contribution from pestimated 15. 16. // Compute the population's performance without fkill 17. Gfitness(F-{fkill}) ← Error