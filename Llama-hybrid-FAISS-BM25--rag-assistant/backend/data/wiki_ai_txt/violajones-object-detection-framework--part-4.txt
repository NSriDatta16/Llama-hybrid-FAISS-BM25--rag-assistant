 of a strong classifier. So all the features are grouped into several stages where each stage has certain number of features. The job of each stage is to determine whether a given sub-window is definitely not a face or may be a face. A given sub-window is immediately discarded as not a face if it fails in any of the stages. A simple framework for cascade training is given below: f = the maximum acceptable false positive rate per layer. d = the minimum acceptable detection rate per layer. Ftarget = target overall false positive rate. P = set of positive examples. N = set of negative examples. F(0) = 1.0; D(0) = 1.0; i = 0 while F(i) > Ftarget increase i n(i) = 0; F(i)= F(i-1) while F(i) > f × F(i-1) increase n(i) use P and N to train a classifier with n(i) features using AdaBoost Evaluate current cascaded classifier on validation set to determine F(i) and D(i) decrease threshold for the ith classifier (i.e. how many weak classifiers need to accept for strong classifier to accept) until the current cascaded classifier has a detection rate of at least d × D(i-1) (this also affects F(i)) N = ∅ if F(i) > Ftarget then evaluate the current cascaded detector on the set of non-face images and put any false detections into the set N. The cascade architecture has interesting implications for the performance of the individual classifiers. Because the activation of each classifier depends entirely on the behavior of its predecessor, the false positive rate for an entire cascade is: F = ∏ i = 1 K f i . {\displaystyle F=\prod _{i=1}^{K}f_{i}.} Similarly, the detection rate is: D = ∏ i = 1 K d i . {\displaystyle D=\prod _{i=1}^{K}d_{i}.} Thus, to match the false positive rates typically achieved by other detectors, each classifier can get away with having surprisingly poor performance. For example, for a 32-stage cascade to achieve a false positive rate of 10−6, each classifier need only achieve a false positive rate of about 65%. At the same time, however, each classifier needs to be exceptionally capable if it is to achieve adequate detection rates. For example, to achieve a detection rate of about 90%, each classifier in the aforementioned cascade needs to achieve a detection rate of approximately 99.7%. Using Viola–Jones for object tracking In videos of moving objects, one need not apply object detection to each frame. Instead, one can use tracking algorithms like the KLT algorithm to detect salient features within the detection bounding boxes and track their movement between frames. Not only does this improve tracking speed by removing the need to re-detect objects in each frame, but it improves the robustness as well, as the salient features are more resilient than the Viola-Jones detection framework to rotation and photometric changes. References External links Slides Presenting the Framework Information Regarding Haar Basis Functions "Extension of Viola–Jones framework using SURF feature". Archived from the original on 2020-10-18. "IMMI - Rapidminer Image Mining Extension". Archived from the original on 2022-07-03. - open-source tool for image mining "Robust Real-Time Face Detection" (PDF). Archived from the original (PDF) on 2019-02-02. An improved algorithm on Viola-Jones object detector Citations of the Viola–Jones algorithm in Google Scholar Video lecture on Viola–Jones algorithm on YouTube - Adaboost Explanation from ppt by Qing Chen, Discovery Labs, University of Ottawa and a video lecture by Ramsri Goutham. Implementations Jensen, Ole Helvig. "Implementing the Viola–Jones Face Detection Algorithm" (PDF). Archived from the original (PDF) on 2018-10-21. MATLAB: [1], [2] Archived 2017-09-07 at the Wayback Machine OpenCV: implemented as cvHaarDetectObjects(). Haar Cascade Detection in OpenCV Cascade Classifier Training in OpenCV