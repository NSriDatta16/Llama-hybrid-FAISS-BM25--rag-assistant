n. This can be achieved either by circumscription or by predicate completion. It is worth noticing that occlusion does not necessarily imply a change: for example, executing the action of opening the door when it was already open (in the formalization above) makes the predicate o c c l u d e o p e n {\displaystyle \mathrm {occludeopen} } true and makes o p e n {\displaystyle \mathrm {open} } true; however, o p e n {\displaystyle \mathrm {open} } has not changed value, as it was true already. Predicate completion solution This encoding is similar to the fluent occlusion solution, but the additional predicates denote change, not permission to change. For example, c h a n g e o p e n ( t ) {\displaystyle \mathrm {changeopen} (t)} represents the fact that the predicate o p e n {\displaystyle \mathrm {open} } will change from time t {\displaystyle t} to t + 1 {\displaystyle t+1} . As a result, a predicate changes if and only if the corresponding change predicate is true. An action results in a change if and only if it makes true a condition that was previously false or vice versa. ¬ o p e n ( 0 ) {\displaystyle \neg \mathrm {open} (0)} ¬ o n ( 0 ) {\displaystyle \neg \mathrm {on} (0)} ¬ o p e n ( 0 ) ⟹ c h a n g e o p e n ( 0 ) {\displaystyle \neg \mathrm {open} (0)\implies \mathrm {changeopen} (0)} ∀ t . c h a n g e o p e n ( t ) ⟺ ( ¬ o p e n ( t ) ⟺ o p e n ( t + 1 ) ) {\displaystyle \forall t.\mathrm {changeopen} (t)\iff (\neg \mathrm {open} (t)\iff \mathrm {open} (t+1))} ∀ t . c h a n g e o n ( t ) ⟺ ( ¬ o n ( t ) ⟺ o n ( t + 1 ) ) {\displaystyle \forall t.\mathrm {changeon} (t)\iff (\neg \mathrm {on} (t)\iff \mathrm {on} (t+1))} The third formula is a different way of saying that opening the door causes the door to be opened. Precisely, it states that opening the door changes the state of the door if it had been previously closed. The last two conditions state that a condition changes value at time t {\displaystyle t} if and only if the corresponding change predicate is true at time t {\displaystyle t} . To complete the solution, the time points in which the change predicates are true have to be as few as possible, and this can be done by applying predicate completion to the rules specifying the effects of actions. Successor state axioms solution The value of a condition after the execution of an action can be determined by the fact that the condition is true if and only if: the action makes the condition true; or the condition was previously true and the action does not make it false. A successor state axiom is a formalization in logic of these two facts. For example, if o p e n d o o r ( t ) {\displaystyle \mathrm {opendoor} (t)} and c l o s e d o o r ( t ) {\displaystyle \mathrm {closedoor} (t)} are two conditions used to denote that the action executed at time t {\displaystyle t} was to open or close the door, respectively, the running example is encoded as follows. ¬ o p e n ( 0 ) {\displaystyle \neg \mathrm {open} (0)} ¬ o n ( 0 ) {\displaystyle \neg \mathrm {on} (0)} o p e n d o o r ( 0 ) {\displaystyle \mathrm {opendoor} (0)} ∀ t . o p e n ( t + 1 ) ⟺ o p e n d o o r ( t ) ∨ ( o p e n ( t ) ∧ ¬ c l o s e d o o r ( t ) ) {\displaystyle \forall t.\mathrm {open} (t+1)\iff \mathrm {opendoor} (t)\vee (\mathrm {open} (t)\wedge \neg \mathrm {closedoor} (t))} This solution is centered around the value of conditions, rather than the effects of actions. In other words, there is an axiom for every condition, rather than a formula for every action. Preconditions to actions (which are not present in this example) are formalized by other formulae. The successor state axioms are used in the variant to the situation calculus proposed by Ray Reiter. Fluent calculus solution The fluent calculus is a variant of the situation calculus. It solves the frame problem by using first-order logic terms, rather than predicates, to represent the states. Converting predicates into terms in first-order logic is called reification; the fluent calcul