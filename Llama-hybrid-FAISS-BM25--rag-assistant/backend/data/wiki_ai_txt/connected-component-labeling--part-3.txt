rithm, however, is how this merging is done. This algorithm uses the union-find data structure which provides excellent performance for keeping track of equivalence relationships. Union-find essentially stores labels which correspond to the same blob in a disjoint-set data structure, making it easy to remember the equivalence of two labels by the use of an interface method E.g.: findSet(l). findSet(l) returns the minimum label value that is equivalent to the function argument 'l'. Once the initial labeling and equivalence recording is completed, the second pass merely replaces each pixel label with its equivalent disjoint-set representative element. A faster-scanning algorithm for connected-region extraction is presented below. On the first pass: Iterate through each element of the data by column, then by row (Raster Scanning) If the element is not the background Get the neighboring elements of the current element If there are no neighbors, uniquely label the current element and continue Otherwise, find the neighbor with the smallest label and assign it to the current element Store the equivalence between neighboring labels On the second pass: Iterate through each element of the data by column, then by row If the element is not the background Relabel the element with the lowest equivalent label Here, the background is a classification, specific to the data, used to distinguish salient elements from the foreground. If the background variable is omitted, then the two-pass algorithm will treat the background as another region. Graphical example of two-pass algorithm 1. The array from which connected regions are to be extracted is given below (8-connectivity based). We first assign different binary values to elements in the graph. The values "0~1" at the center of each of the elements in the following graph are the elements' values, whereas the "1,2,...,7" values in the next two graphs are the elements' labels. The two concepts should not be confused. 2. After the first pass, the following labels are generated: A total of 7 labels are generated in accordance with the conditions highlighted above. The label equivalence relationships generated are, 3. Array generated after the merging of labels is carried out. Here, the label value that was the smallest for a given region "floods" throughout the connected region and gives two distinct labels, and hence two distinct labels. 4. Final result in color to clearly see two different regions that have been found in the array. The pseudocode is: algorithm TwoPass(data) is linked = [] labels = structure with dimensions of data, initialized with the value of Background NextLabel = 0 First pass for row in data do for column in row do if data[row][column] is not Background then neighbors = connected elements with the current element's value if neighbors is empty then linked[NextLabel] = set containing NextLabel labels[row][column] = NextLabel NextLabel += 1 else Find the smallest label L = neighbors labels labels[row][column] = min(L) for label in L do linked[label] = union(linked[label], L) Second pass for row in data do for column in row do if data[row][column] is not Background then labels[row][column] = find(labels[row][column]) return labels The find and union algorithms are implemented as described in union find. Sequential algorithm Create a region counter Scan the image (in the following example, it is assumed that scanning is done from left to right and from top to bottom): For every pixel check the north and west pixel (when considering 4-connectivity) or the northeast, north, northwest, and west pixel for 8-connectivity for a given region criterion (i.e. intensity value of 1 in binary image, or similar intensity to connected pixels in gray-scale image). If none of the neighbors fit the criterion then assign to region value of the region counter. Increment region counter. If only one neighbor fits the criterion assign pixel to that region. If multiple neighbors match and are all member