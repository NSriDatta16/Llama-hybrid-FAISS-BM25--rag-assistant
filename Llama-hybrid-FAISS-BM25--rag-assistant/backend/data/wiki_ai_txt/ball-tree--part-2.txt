tructed ball tree. if a single point remains then create a leaf B containing the single point in D return B else let c be the dimension of greatest spread let p be the central point selected considering c let L, R be the sets of points lying to the left and right of the median along dimension c create B with two children: B.pivot := p B.child1 := construct_balltree(L), B.child2 := construct_balltree(R), let B.radius be maximum distance from p among children return B end if end function Nearest-neighbor search An important application of ball trees is expediting nearest neighbor search queries, in which the objective is to find the k points in the tree that are closest to a given test point by some distance metric (e.g. Euclidean distance). A simple search algorithm, sometimes called KNS1, exploits the distance property of the ball tree. In particular, if the algorithm is searching the data structure with a test point t, and has already seen some point p that is closest to t among the points encountered so far, then any subtree whose ball is further from t than p can be ignored for the rest of the search. Description The ball tree nearest-neighbor algorithm examines nodes in depth-first order, starting at the root. During the search, the algorithm maintains a max-first priority queue (often implemented with a heap), denoted Q here, of the k nearest points encountered so far. At each node B, it may perform one of three operations, before finally returning an updated version of the priority queue: If the distance from the test point t to the current node B is greater than the furthest point in Q, ignore B and return Q. If B is a leaf node, scan through every point enumerated in B and update the nearest-neighbor queue appropriately. Return the updated queue. If B is an internal node, call the algorithm recursively on B's two children, searching the child whose center is closer to t first. Return the queue after each of these calls has updated it in turn. Performing the recursive search in the order described in point 3 above increases likelihood that the further child will be pruned entirely during the search. Pseudocode function knn_search is input: t, the target point for the query k, the number of nearest neighbors of t to search for Q, max-first priority queue containing at most k points B, a node, or ball, in the tree output: Q, containing the k nearest neighbors from within B if distance(t, B.pivot) - B.radius â‰¥ distance(t, Q.first) then return Q unchanged else if B is a leaf node then for each point p in B do if distance(t, p) < distance(t, Q.first) then add p to Q if size(Q) > k then remove the furthest neighbor from Q end if end if repeat else let child1 be the child node closest to t let child2 be the child node furthest from t knn_search(t, k, Q, child1) knn_search(t, k, Q, child2) end if return Q end function Performance In comparison with several other data structures, ball trees have been shown to perform fairly well on the nearest-neighbor search problem, particularly as their number of dimensions grows. However, the best nearest-neighbor data structure for a given application will depend on the dimensionality, number of data points, and underlying structure of the data. == References ==