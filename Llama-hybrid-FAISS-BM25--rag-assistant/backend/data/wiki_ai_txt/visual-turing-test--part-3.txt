 of an object of type t with attributes A partially visible in region w that was not previously instantiated?' Uniqueness questions: A uniqueness question tries to uniquely identify an object to instantiate it. Quniq = 'Is there a unique instance of an object of type t with attributes A partially visible in region w that was not previously instantiated?' The uniqueness questions along with the existence questions form the instantiation questions. As mentioned earlier instantiating objects leads to other interesting questions and eventually a story line. Uniqueness questions follow the existence questions and a positive answer to it leads to instantiation of an object. Attribute questions: An attribute question tries to find more about the object once it has been instantiated. Such questions can query about a single attribute, conjunction of two attributes or disjunction of two attributes. Qatt(ot) = {'Does object ot have attribute a?' , 'Does object ot have attribute a1 or attribute a2?' , 'Does object ot have attribute a1 and attribute a2?'} Relationship questions: Once multiple objects have been instantiated, a relationship question explores the relationship between pairs of objects. Qrel(ot,ot') = 'Does object ot have relationship r with object ot'?' Implementation details As mentioned before the core of the Visual Turing Test is the query generator which generates a sequence of binary questions such that the answer to any question k is unpredictable given the correct answers to the previous k − 1 questions. This is a recursive process, given a history of questions and their correct answers, the query generator either stops because there are no more unpredictable questions, or randomly selects an unpredictable question and adds it to the history. The question space defined earlier implicitly imposes a constraint on the flow of the questions. To make it more clear this means that the attribute and relationship questions can not precede the instantiation questions. Only when the objects have been instantiated, can they be queried about their attributes and relations to other previously instantiated objects. Thus given a history we can restrict the possible questions that can follow it, and this set of questions are referred to as the candidate questions Q can {\displaystyle Q_{\text{can}}} . The task is to choose an unpredictable question from these candidate questions such that it conforms with the question flow that we will describe in the next section. For this, find the unpredictability of every question among the candidate questions. Let H {\displaystyle H} be a binary random variable, where H ( I ) = 1 {\displaystyle H(I)=1} , if the history H {\displaystyle H} is valid for the Image I {\displaystyle I} and 0 {\displaystyle 0} otherwise. Let q ∈ Q {\displaystyle q\in Q} can be the proposed question, and X q {\displaystyle X_{q}} be the answer to the question q {\displaystyle q} . Then, find the conditional probability of getting the answer Xq to the question q given the history H. P H ( X q = x ) = P { I : H ( I ) = 1 , X q ( I ) = x } P { I : H ( I ) = 1 } {\displaystyle P_{H}(X_{q}=x)={\frac {P\{I:H(I)=1,X_{q}(I)=x\}}{P\{I:H(I)=1\}}}} Given this probability the measure of the unpredictability is given by: ρ H ( q ) = | P H ( X Q = 1 ) − 0.5 | {\displaystyle \rho _{H}(q)=|P_{H}(X_{Q}=1)-0.5|} The closer ρ H ( q ) {\displaystyle \rho _{H}(q)} is to 0, the more unpredictable the question is. ρ H ( q ) {\displaystyle \rho _{H}(q)} for every question is calculated. The questions for which ρ H ( q ) < ϵ {\displaystyle \rho _{H}(q)<\epsilon } , are the set of almost unpredictable questions and the next question is randomly picked from these. Question flow As discussed in the previous section there is an implicit ordering in the question space, according to which the attribute questions come after the instantiation questions and the relationship questions come after the attribute questions, once multiple objects have been ins